syntax = "proto3";

option objc_class_prefix = "VAK";

import "intent.proto";
import "ssl.proto";
import "stub.proto";

package vaksana;

service Market {
    // Gets Config
    rpc GetConfig (Void) returns (Config) {}

    // ----- Encryption Related Functions -----
    // #TODO: Can be pulled out in a separate proto file and service
    // This file should contain only Market functionality

    // Server's Public Key
    rpc GetPublicKey (ContactDetails) returns (SKey) {}

    // Generate RSA key pair:
    //  - Returns the public key
    //  - Sends private key in email.
    rpc GenerateRSAKeyPair (ContactDetails) returns (SKey) {}

    // Returns Client's public key:
    //  - Returns the public key
    rpc GetClientPubkey(ContactDetails) returns (SKey) {}

    // Exchange Sym Key
    rpc GenerateAESKey (ContactDetails) returns (SKey) {}

    // Genereate SSL Key Pair (eg. to make secure Docker Connections)
    rpc GenerateSSLPair(CSSLInfo) returns (SSSLKeyPair) {}

    rpc KeepAlive(Token) return (Void) {}

    // ----- Basic Registration Functionality -----
    // Registers Domain and returns Token (ecrypted) - For subsequent queries
    rpc RegisterDomain (ClientInfo) returns (SToken) {}

    // Registers Intent
    rpc DefineIntent (CIntent) returns (ErrCode) {}

    // Registers a service after matching the contract of proto files
    rpc RegisterIntentHandler (CProducer) returns (ErrCode) {}

    // Registers Volume with the market, which will be used for all services
    rpc RegisterVolume(CVolume) returns (ErrCode) {}

    // Registers DockerHost with the market, which will be used for all services
    rpc RegisterHost(CDockerHost) returns (ErrCode) {}

    // Identifies the relevant intent and provisions the service
    rpc CreateStub(CStubDetails) returns (SUrl) {}

    // Destroys the service
    rpc DestroyStub(CUrl) returns (Void) {}
}

message Void {
}

message Config {
    string logurl = 1;
}

message ErrCode {
    // its 0 in case all the values are valid, else some error value
    int32 err = 1;
    // err message from the server
    string msg = 2;
}

message Token {
    string token = 1;
}

message Key {
    string key = 1;
    string signature = 2;
}

// detailsfor the communication
message ContactDetails {
    string email = 1;
    string phone = 2;
}

message ClientInfo {
    ContactDetails contact_details = 1;
    string domain = 2;
}




message SToken {
    string token = 1;
    ErrCode err = 2;
}

message SKey {
    Key key = 1;
    bool encrypted = 2;
    ErrCode err = 3;
}

message CIntent {
    Token token = 1;
    Intent intent = 2;
    bool encrypted = 3;
}

message CProducer {
    Token token = 1;
    Intent intent = 2;
    Infra infra = 3;
    Service service = 4;
    bool encrypted = 5;
}

message CStubDetails {
    Token token = 1;
    StubDetails stubdetails = 2;
    bool encrypted = 3;
}

message CDockerHost {
    Token token = 1;
    DockerHost dockerhost = 2;
    bool encrypted = 3;
}

message CVolume {
    Token token = 1;
    Volume volume = 2;
    bool encrypted = 3;
}

message SUrl {
    string url = 1;
    string service_id = 2;
    Token service_token = 3;
    string service_aes_key = 4;
    ErrCode err = 5;
}

message CUrl {
    Token token = 1;
    string url = 2;
    bool encrypted = 3;
}

message CSSLInfo {
    ContactDetails contact_details = 1;
    SSLInfo ssl_info = 2;
}

message SSSLKeyPair {
    SSLKeyPair keypair = 1;
    ErrCode err = 2;
}

message Server {
    string hostname = 1;
    int32 port = 2;
}

message Credentials {
    Token service_token = 1;
    string service_aes_key = 2;
    string service_id = 3;
    Server server = 4;
}

message ServiceCost {
    string token = 1;
    string server_id = 2;
    int32 cost_tokens = 3;
    int32 cost_per_token_musd = 4;
}
