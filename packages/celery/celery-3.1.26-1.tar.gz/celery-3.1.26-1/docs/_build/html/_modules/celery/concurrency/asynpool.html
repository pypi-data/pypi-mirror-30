
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>celery.concurrency.asynpool &#8212; Celery 4.2.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/celery.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Celery 4.2.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../concurrency.html" accesskey="U">celery.concurrency</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
<div class="deck">

    
        <p>
        This document describes the current stable version of Celery (4.2).
        For development docs,
        <a href="http://docs.celeryproject.org/en/master/_modules/celery/concurrency/asynpool.html">go here</a>.
        </p>
    

</div>
    <h1>Source code for celery.concurrency.asynpool</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Version of multiprocessing.Pool using Async I/O.</span>

<span class="sd">.. note::</span>

<span class="sd">    This module will be moved soon, so don&#39;t use it directly.</span>

<span class="sd">This is a non-blocking version of :class:`multiprocessing.Pool`.</span>

<span class="sd">This code deals with three major challenges:</span>

<span class="sd">#. Starting up child processes and keeping them running.</span>
<span class="sd">#. Sending jobs to the processes and receiving results back.</span>
<span class="sd">#. Safely shutting down this system.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">select</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">BytesIO</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Integral</span>
<span class="kn">from</span> <span class="nn">pickle</span> <span class="k">import</span> <span class="n">HIGHEST_PROTOCOL</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">sleep</span>
<span class="kn">from</span> <span class="nn">weakref</span> <span class="k">import</span> <span class="n">WeakValueDictionary</span><span class="p">,</span> <span class="n">ref</span>

<span class="kn">from</span> <span class="nn">billiard</span> <span class="k">import</span> <span class="n">pool</span> <span class="k">as</span> <span class="n">_pool</span>
<span class="kn">from</span> <span class="nn">billiard.compat</span> <span class="k">import</span> <span class="n">buf_t</span><span class="p">,</span> <span class="n">isblocking</span><span class="p">,</span> <span class="n">setblocking</span>
<span class="kn">from</span> <span class="nn">billiard.pool</span> <span class="k">import</span> <span class="n">ACK</span><span class="p">,</span> <span class="n">NACK</span><span class="p">,</span> <span class="n">RUN</span><span class="p">,</span> <span class="n">TERMINATE</span><span class="p">,</span> <span class="n">WorkersJoined</span>
<span class="kn">from</span> <span class="nn">billiard.queues</span> <span class="k">import</span> <span class="n">_SimpleQueue</span>
<span class="kn">from</span> <span class="nn">kombu.async</span> <span class="k">import</span> <span class="n">ERR</span><span class="p">,</span> <span class="n">WRITE</span>
<span class="kn">from</span> <span class="nn">kombu.serialization</span> <span class="k">import</span> <span class="n">pickle</span> <span class="k">as</span> <span class="n">_pickle</span>
<span class="kn">from</span> <span class="nn">kombu.utils.eventio</span> <span class="k">import</span> <span class="n">SELECT_BAD_FD</span>
<span class="kn">from</span> <span class="nn">kombu.utils.functional</span> <span class="k">import</span> <span class="n">fxrange</span>
<span class="kn">from</span> <span class="nn">vine</span> <span class="k">import</span> <span class="n">promise</span>

<span class="kn">from</span> <span class="nn">celery.five</span> <span class="k">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">values</span>
<span class="kn">from</span> <span class="nn">celery.utils.functional</span> <span class="k">import</span> <span class="n">noop</span>
<span class="kn">from</span> <span class="nn">celery.utils.log</span> <span class="k">import</span> <span class="n">get_logger</span>
<span class="kn">from</span> <span class="nn">celery.worker</span> <span class="k">import</span> <span class="n">state</span> <span class="k">as</span> <span class="n">worker_state</span>

<span class="c1"># pylint: disable=redefined-outer-name</span>
<span class="c1"># We cache globals and attribute lookups, so disable this warning.</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">_billiard</span> <span class="k">import</span> <span class="n">read</span> <span class="k">as</span> <span class="n">__read__</span>
    <span class="kn">from</span> <span class="nn">struct</span> <span class="k">import</span> <span class="n">unpack_from</span> <span class="k">as</span> <span class="n">_unpack_from</span>
    <span class="nb">memoryview</span> <span class="o">=</span> <span class="nb">memoryview</span>
    <span class="n">readcanbuf</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">unpack_from</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">_unpack_from</span><span class="o">=</span><span class="n">_unpack_from</span><span class="p">):</span>  <span class="c1"># noqa</span>
            <span class="k">return</span> <span class="n">_unpack_from</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">view</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>  <span class="c1"># &lt;- memoryview</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># unpack_from supports memoryview in 2.7.6 and 3.3+</span>
        <span class="n">unpack_from</span> <span class="o">=</span> <span class="n">_unpack_from</span>  <span class="c1"># noqa</span>

<span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">NameError</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">def</span> <span class="nf">__read__</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">read</span><span class="p">):</span>  <span class="c1"># noqa</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">buf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="n">readcanbuf</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># noqa</span>

    <span class="k">def</span> <span class="nf">unpack_from</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">iobuf</span><span class="p">,</span> <span class="n">unpack</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">):</span>  <span class="c1"># noqa</span>
        <span class="k">return</span> <span class="n">unpack</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">iobuf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>  <span class="c1"># &lt;-- BytesIO</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;AsynPool&#39;</span><span class="p">,)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">error</span><span class="p">,</span> <span class="n">debug</span> <span class="o">=</span> <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">logger</span><span class="o">.</span><span class="n">debug</span>

<span class="n">UNAVAIL</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">errno</span><span class="o">.</span><span class="n">EAGAIN</span><span class="p">,</span> <span class="n">errno</span><span class="o">.</span><span class="n">EINTR</span><span class="p">})</span>

<span class="c1">#: Constant sent by child process when started (ready to accept work)</span>
<span class="n">WORKER_UP</span> <span class="o">=</span> <span class="mi">15</span>

<span class="c1">#: A process must&#39;ve started before this timeout (in secs.) expires.</span>
<span class="n">PROC_ALIVE_TIMEOUT</span> <span class="o">=</span> <span class="mf">4.0</span>

<span class="n">SCHED_STRATEGY_FCFS</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">SCHED_STRATEGY_FAIR</span> <span class="o">=</span> <span class="mi">4</span>

<span class="n">SCHED_STRATEGIES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="kc">None</span><span class="p">:</span> <span class="n">SCHED_STRATEGY_FAIR</span><span class="p">,</span>
    <span class="s1">&#39;fast&#39;</span><span class="p">:</span> <span class="n">SCHED_STRATEGY_FCFS</span><span class="p">,</span>
    <span class="s1">&#39;fcfs&#39;</span><span class="p">:</span> <span class="n">SCHED_STRATEGY_FCFS</span><span class="p">,</span>
    <span class="s1">&#39;fair&#39;</span><span class="p">:</span> <span class="n">SCHED_STRATEGY_FAIR</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">SCHED_STRATEGY_TO_NAME</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">SCHED_STRATEGIES</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

<span class="n">Ack</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Ack&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;fd&#39;</span><span class="p">,</span> <span class="s1">&#39;payload&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">gen_not_started</span><span class="p">(</span><span class="n">gen</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if generator is not started.&quot;&quot;&quot;</span>
    <span class="c1"># gi_frame is None when generator stopped.</span>
    <span class="k">return</span> <span class="n">gen</span><span class="o">.</span><span class="n">gi_frame</span> <span class="ow">and</span> <span class="n">gen</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_lasti</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>


<span class="k">def</span> <span class="nf">_get_job_writer</span><span class="p">(</span><span class="n">job</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">_writer</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">writer</span><span class="p">()</span>  <span class="c1"># is a weakref</span>


<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">select</span><span class="p">,</span> <span class="s1">&#39;poll&#39;</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_select_imp</span><span class="p">(</span><span class="n">readers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">writers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">poll</span><span class="o">=</span><span class="n">select</span><span class="o">.</span><span class="n">poll</span><span class="p">,</span> <span class="n">POLLIN</span><span class="o">=</span><span class="n">select</span><span class="o">.</span><span class="n">POLLIN</span><span class="p">,</span>
                    <span class="n">POLLOUT</span><span class="o">=</span><span class="n">select</span><span class="o">.</span><span class="n">POLLOUT</span><span class="p">,</span> <span class="n">POLLERR</span><span class="o">=</span><span class="n">select</span><span class="o">.</span><span class="n">POLLERR</span><span class="p">):</span>
        <span class="n">poller</span> <span class="o">=</span> <span class="n">poll</span><span class="p">()</span>
        <span class="n">register</span> <span class="o">=</span> <span class="n">poller</span><span class="o">.</span><span class="n">register</span>

        <span class="k">if</span> <span class="n">readers</span><span class="p">:</span>
            <span class="p">[</span><span class="n">register</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">POLLIN</span><span class="p">)</span> <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">readers</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">writers</span><span class="p">:</span>
            <span class="p">[</span><span class="n">register</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">POLLOUT</span><span class="p">)</span> <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">writers</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">err</span><span class="p">:</span>
            <span class="p">[</span><span class="n">register</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">POLLERR</span><span class="p">)</span> <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">err</span><span class="p">]</span>

        <span class="n">R</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">timeout</span> <span class="ow">and</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">round</span><span class="p">(</span><span class="n">timeout</span> <span class="o">*</span> <span class="mf">1e3</span><span class="p">)</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">poller</span><span class="o">.</span><span class="n">poll</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fd</span><span class="p">,</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
                <span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">event</span> <span class="o">&amp;</span> <span class="n">POLLIN</span><span class="p">:</span>
                <span class="n">R</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">event</span> <span class="o">&amp;</span> <span class="n">POLLOUT</span><span class="p">:</span>
                <span class="n">W</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">event</span> <span class="o">&amp;</span> <span class="n">POLLERR</span><span class="p">:</span>
                <span class="n">R</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_select_imp</span><span class="p">(</span><span class="n">readers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">writers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">readers</span><span class="p">,</span> <span class="n">writers</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">_select</span><span class="p">(</span><span class="n">readers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">writers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">poll</span><span class="o">=</span><span class="n">_select_imp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simple wrapper to :class:`~select.select`, using :`~select.poll`.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        readers (Set[Fd]): Set of reader fds to test if readable.</span>
<span class="sd">        writers (Set[Fd]): Set of writer fds to test if writable.</span>
<span class="sd">        err (Set[Fd]): Set of fds to test for error condition.</span>

<span class="sd">    All fd sets passed must be mutable as this function</span>
<span class="sd">    will remove non-working fds from them, this also means</span>
<span class="sd">    the caller must make sure there are still fds in the sets</span>
<span class="sd">    before calling us again.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[Set, Set, Set]: of ``(readable, writable, again)``, where</span>
<span class="sd">        ``readable`` is a set of fds that have data available for read,</span>
<span class="sd">        ``writable`` is a set of fds that&#39;s ready to be written to</span>
<span class="sd">        and ``again`` is a flag that if set means the caller must</span>
<span class="sd">        throw away the result and call us again.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">readers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="n">readers</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">readers</span>
    <span class="n">writers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="n">writers</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">writers</span>
    <span class="n">err</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="n">err</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">err</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">poll</span><span class="p">(</span><span class="n">readers</span><span class="p">,</span> <span class="n">writers</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">select</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">)</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="c1"># Workaround for celery/celery#4513</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_errno</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">errno</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">_errno</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">_errno</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EINTR</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">(),</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">_errno</span> <span class="ow">in</span> <span class="n">SELECT_BAD_FD</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">readers</span> <span class="o">|</span> <span class="n">writers</span> <span class="o">|</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">fd</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="n">select</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">)</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">_errno</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">errno</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="n">_errno</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">_errno</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SELECT_BAD_FD</span><span class="p">:</span>
                        <span class="k">raise</span>
                    <span class="n">readers</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                    <span class="n">writers</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                    <span class="n">err</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">(),</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span>


<span class="k">class</span> <span class="nc">Worker</span><span class="p">(</span><span class="n">_pool</span><span class="o">.</span><span class="n">Worker</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pool worker process.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">on_loop_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pid</span><span class="p">):</span>
        <span class="c1"># our version sends a WORKER_UP message when the process is ready</span>
        <span class="c1"># to accept work, this will tell the parent that the inqueue fd</span>
        <span class="c1"># is writable.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outq</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">WORKER_UP</span><span class="p">,</span> <span class="p">(</span><span class="n">pid</span><span class="p">,)))</span>


<span class="k">class</span> <span class="nc">ResultHandler</span><span class="p">(</span><span class="n">_pool</span><span class="o">.</span><span class="n">ResultHandler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Handles messages from the pool processes.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fileno_to_outq</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fileno_to_outq&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_process_alive</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;on_process_alive&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ResultHandler</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># add our custom message handler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_handlers</span><span class="p">[</span><span class="n">WORKER_UP</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_process_alive</span>

    <span class="k">def</span> <span class="nf">_recv_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">add_reader</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span>
                      <span class="n">__read__</span><span class="o">=</span><span class="n">__read__</span><span class="p">,</span> <span class="n">readcanbuf</span><span class="o">=</span><span class="n">readcanbuf</span><span class="p">,</span>
                      <span class="n">BytesIO</span><span class="o">=</span><span class="n">BytesIO</span><span class="p">,</span> <span class="n">unpack_from</span><span class="o">=</span><span class="n">unpack_from</span><span class="p">,</span>
                      <span class="n">load</span><span class="o">=</span><span class="n">_pickle</span><span class="o">.</span><span class="n">load</span><span class="p">):</span>
        <span class="n">Hr</span> <span class="o">=</span> <span class="n">Br</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">readcanbuf</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">bufv</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">bufv</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
        <span class="c1"># header</span>

        <span class="k">while</span> <span class="n">Hr</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">__read__</span><span class="p">(</span>
                    <span class="n">fd</span><span class="p">,</span> <span class="n">bufv</span><span class="p">[</span><span class="n">Hr</span><span class="p">:]</span> <span class="k">if</span> <span class="n">readcanbuf</span> <span class="k">else</span> <span class="n">bufv</span><span class="p">,</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">Hr</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">exc</span><span class="o">.</span><span class="n">errno</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">UNAVAIL</span><span class="p">:</span>
                    <span class="k">raise</span>
                <span class="k">yield</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;End of file during message&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">Hr</span>
                           <span class="k">else</span> <span class="ne">EOFError</span><span class="p">())</span>
                <span class="n">Hr</span> <span class="o">+=</span> <span class="n">n</span>

        <span class="n">body_size</span><span class="p">,</span> <span class="o">=</span> <span class="n">unpack_from</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;&gt;i&#39;</span><span class="p">,</span> <span class="n">bufv</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">readcanbuf</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">body_size</span><span class="p">)</span>
            <span class="n">bufv</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">bufv</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>

        <span class="k">while</span> <span class="n">Br</span> <span class="o">&lt;</span> <span class="n">body_size</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">__read__</span><span class="p">(</span>
                    <span class="n">fd</span><span class="p">,</span> <span class="n">bufv</span><span class="p">[</span><span class="n">Br</span><span class="p">:]</span> <span class="k">if</span> <span class="n">readcanbuf</span> <span class="k">else</span> <span class="n">bufv</span><span class="p">,</span> <span class="n">body_size</span> <span class="o">-</span> <span class="n">Br</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">exc</span><span class="o">.</span><span class="n">errno</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">UNAVAIL</span><span class="p">:</span>
                    <span class="k">raise</span>
                <span class="k">yield</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;End of file during message&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">Br</span>
                           <span class="k">else</span> <span class="ne">EOFError</span><span class="p">())</span>
                <span class="n">Br</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="n">add_reader</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_event</span><span class="p">,</span> <span class="n">fd</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">readcanbuf</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">bufv</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bufv</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">bufv</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">message</span><span class="p">:</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_process_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coroutine reading messages from the pool processes.&quot;&quot;&quot;</span>
        <span class="n">fileno_to_outq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileno_to_outq</span>
        <span class="n">on_state_change</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_state_change</span>
        <span class="n">add_reader</span> <span class="o">=</span> <span class="n">hub</span><span class="o">.</span><span class="n">add_reader</span>
        <span class="n">remove_reader</span> <span class="o">=</span> <span class="n">hub</span><span class="o">.</span><span class="n">remove_reader</span>
        <span class="n">recv_message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recv_message</span>

        <span class="k">def</span> <span class="nf">on_result_readable</span><span class="p">(</span><span class="n">fileno</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fileno_to_outq</span><span class="p">[</span><span class="n">fileno</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>  <span class="c1"># process gone</span>
                <span class="k">return</span> <span class="n">remove_reader</span><span class="p">(</span><span class="n">fileno</span><span class="p">)</span>
            <span class="n">it</span> <span class="o">=</span> <span class="n">recv_message</span><span class="p">(</span><span class="n">add_reader</span><span class="p">,</span> <span class="n">fileno</span><span class="p">,</span> <span class="n">on_state_change</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">,</span> <span class="ne">EOFError</span><span class="p">):</span>
                <span class="n">remove_reader</span><span class="p">(</span><span class="n">fileno</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">add_reader</span><span class="p">(</span><span class="n">fileno</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">on_result_readable</span>

    <span class="k">def</span> <span class="nf">register_with_event_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hub</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handle_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_process_result</span><span class="p">(</span><span class="n">hub</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c1"># pylint: disable=method-hidden</span>
        <span class="c1">#   register_with_event_loop overrides this</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not registered with event loop&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_stop_not_started</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># This is always used, since we do not start any threads.</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="n">check_timeouts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_timeouts</span>
        <span class="n">fileno_to_outq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileno_to_outq</span>
        <span class="n">on_state_change</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_state_change</span>
        <span class="n">join_exited_workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_exited_workers</span>

        <span class="c1"># flush the processes outqueues until they&#39;ve all terminated.</span>
        <span class="n">outqueues</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fileno_to_outq</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">cache</span> <span class="ow">and</span> <span class="n">outqueues</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">TERMINATE</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">check_timeouts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># make sure tasks with a time limit will time out.</span>
                <span class="n">check_timeouts</span><span class="p">()</span>
            <span class="c1"># cannot iterate and remove at the same time</span>
            <span class="n">pending_remove_fd</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">outqueues</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_flush_outqueue</span><span class="p">(</span>
                    <span class="n">fd</span><span class="p">,</span> <span class="n">pending_remove_fd</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">fileno_to_outq</span><span class="p">,</span>
                    <span class="n">on_state_change</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">join_exited_workers</span><span class="p">(</span><span class="n">shutdown</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">WorkersJoined</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">debug</span><span class="p">(</span><span class="s1">&#39;result handler: all workers terminated&#39;</span><span class="p">)</span>
            <span class="n">outqueues</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">pending_remove_fd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_flush_outqueue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">remove</span><span class="p">,</span> <span class="n">process_index</span><span class="p">,</span> <span class="n">on_state_change</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># process already found terminated</span>
            <span class="c1"># this means its outqueue has already been processed</span>
            <span class="c1"># by the worker lost handler.</span>
            <span class="k">return</span> <span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>

        <span class="n">reader</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">outq</span><span class="o">.</span><span class="n">_reader</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">setblocking</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reader</span><span class="o">.</span><span class="n">poll</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">task</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">EOFError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">task</span><span class="p">:</span>
                <span class="n">on_state_change</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">setblocking</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AsynPool</span><span class="p">(</span><span class="n">_pool</span><span class="o">.</span><span class="n">Pool</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;AsyncIO Pool (no threads).&quot;&quot;&quot;</span>

    <span class="n">ResultHandler</span> <span class="o">=</span> <span class="n">ResultHandler</span>
    <span class="n">Worker</span> <span class="o">=</span> <span class="n">Worker</span>

    <span class="k">def</span> <span class="nf">WorkerProcess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">):</span>
        <span class="n">worker</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">AsynPool</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">WorkerProcess</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
        <span class="n">worker</span><span class="o">.</span><span class="n">dead</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">worker</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">processes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">synack</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">sched_strategy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sched_strategy</span> <span class="o">=</span> <span class="n">SCHED_STRATEGIES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sched_strategy</span><span class="p">,</span>
                                                   <span class="n">sched_strategy</span><span class="p">)</span>
        <span class="n">processes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="k">if</span> <span class="n">processes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">processes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synack</span> <span class="o">=</span> <span class="n">synack</span>
        <span class="c1"># create queue-pairs for all our processes in advance.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span> <span class="o">=</span> <span class="p">{</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_process_queues</span><span class="p">():</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">processes</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1"># inqueue fileno -&gt; process mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_inq</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># outqueue fileno -&gt; process mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_outq</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># synqueue fileno -&gt; process mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_synq</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># We keep track of processes that haven&#39;t yet</span>
        <span class="c1"># sent a WORKER_UP message.  If a process fails to send</span>
        <span class="c1"># this message within proc_up_timeout we terminate it</span>
        <span class="c1"># and hope the next process will recover.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proc_alive_timeout</span> <span class="o">=</span> <span class="n">PROC_ALIVE_TIMEOUT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waiting_to_start</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># denormalized set of all inqueues.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_inqueues</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Set of fds being written to (busy)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active_writes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Set of active co-routines currently writing jobs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Set of fds that are busy (executing task)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_busy_workers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mark_worker_as_available</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_busy_workers</span><span class="o">.</span><span class="n">discard</span>

        <span class="c1"># Holds jobs waiting to be written to child processes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outbound_buffer</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write_stats</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">AsynPool</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">processes</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">proc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="p">:</span>
            <span class="c1"># create initial mappings, these will be updated</span>
            <span class="c1"># as processes are recycled, or found lost elsewhere.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_outq</span><span class="p">[</span><span class="n">proc</span><span class="o">.</span><span class="n">outqR_fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">proc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_synq</span><span class="p">[</span><span class="n">proc</span><span class="o">.</span><span class="n">synqW_fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">proc</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">on_soft_timeout</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_timeout_handler</span><span class="p">,</span> <span class="s1">&#39;on_soft_timeout&#39;</span><span class="p">,</span> <span class="n">noop</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_hard_timeout</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_timeout_handler</span><span class="p">,</span> <span class="s1">&#39;on_hard_timeout&#39;</span><span class="p">,</span> <span class="n">noop</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_worker_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>  <span class="c1"># Issue #2927</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AsynPool</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_create_worker_process</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_event_process_exit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hub</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
        <span class="c1"># This method is called whenever the process sentinel is readable.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_untrack_child_process</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">hub</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maintain_pool</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_track_child_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">hub</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fd</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">_sentinel_poll</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># we need to duplicate the fd here to carefully</span>
            <span class="c1"># control when the fd is removed from the process table,</span>
            <span class="c1"># as once the original fd is closed we cannot unregister</span>
            <span class="c1"># the fd from epoll(7) anymore, causing a 100% CPU poll loop.</span>
            <span class="n">fd</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">_sentinel_poll</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">dup</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">_popen</span><span class="o">.</span><span class="n">sentinel</span><span class="p">)</span>
        <span class="n">hub</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_process_exit</span><span class="p">,</span> <span class="n">hub</span><span class="p">,</span> <span class="n">proc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_untrack_child_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">hub</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">_sentinel_poll</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fd</span><span class="p">,</span> <span class="n">proc</span><span class="o">.</span><span class="n">_sentinel_poll</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">_sentinel_poll</span><span class="p">,</span> <span class="kc">None</span>
            <span class="n">hub</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_with_event_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register the async pool with the current event loop.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_result_handler</span><span class="o">.</span><span class="n">register_with_event_loop</span><span class="p">(</span><span class="n">hub</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handle_result_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result_handler</span><span class="o">.</span><span class="n">handle_event</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_timelimit_handlers</span><span class="p">(</span><span class="n">hub</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_process_handlers</span><span class="p">(</span><span class="n">hub</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_write_handlers</span><span class="p">(</span><span class="n">hub</span><span class="p">)</span>

        <span class="c1"># Add handler for when a process exits (calls maintain_pool)</span>
        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_child_process</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">hub</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="p">]</span>
        <span class="c1"># Handle_result_event is called whenever one of the</span>
        <span class="c1"># result queues are readable.</span>
        <span class="p">[</span><span class="n">hub</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_result_event</span><span class="p">,</span> <span class="n">fd</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_outq</span><span class="p">]</span>

        <span class="c1"># Timers include calling maintain_pool at a regular interval</span>
        <span class="c1"># to be certain processes are restarted.</span>
        <span class="k">for</span> <span class="n">handler</span><span class="p">,</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">items</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timers</span><span class="p">):</span>
            <span class="n">hub</span><span class="o">.</span><span class="n">call_repeatedly</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>

        <span class="n">hub</span><span class="o">.</span><span class="n">on_tick</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_poll_start</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_timelimit_handlers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create handlers used to implement time limits.&quot;&quot;&quot;</span>
        <span class="n">call_later</span> <span class="o">=</span> <span class="n">hub</span><span class="o">.</span><span class="n">call_later</span>
        <span class="n">trefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tref_for_id</span> <span class="o">=</span> <span class="n">WeakValueDictionary</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">on_timeout_set</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">soft</span><span class="p">,</span> <span class="n">hard</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">soft</span><span class="p">:</span>
                <span class="n">trefs</span><span class="p">[</span><span class="n">R</span><span class="o">.</span><span class="n">_job</span><span class="p">]</span> <span class="o">=</span> <span class="n">call_later</span><span class="p">(</span>
                    <span class="n">soft</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_soft_timeout</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">_job</span><span class="p">,</span> <span class="n">soft</span><span class="p">,</span> <span class="n">hard</span><span class="p">,</span> <span class="n">hub</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">hard</span><span class="p">:</span>
                <span class="n">trefs</span><span class="p">[</span><span class="n">R</span><span class="o">.</span><span class="n">_job</span><span class="p">]</span> <span class="o">=</span> <span class="n">call_later</span><span class="p">(</span>
                    <span class="n">hard</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_hard_timeout</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">_job</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_timeout_set</span> <span class="o">=</span> <span class="n">on_timeout_set</span>

        <span class="k">def</span> <span class="nf">_discard_tref</span><span class="p">(</span><span class="n">job</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tref</span> <span class="o">=</span> <span class="n">trefs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
                <span class="n">tref</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
                <span class="k">del</span> <span class="n">tref</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="k">pass</span>  <span class="c1"># out of scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_discard_tref</span> <span class="o">=</span> <span class="n">_discard_tref</span>

        <span class="k">def</span> <span class="nf">on_timeout_cancel</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
            <span class="n">_discard_tref</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">_job</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_timeout_cancel</span> <span class="o">=</span> <span class="n">on_timeout_cancel</span>

    <span class="k">def</span> <span class="nf">_on_soft_timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">soft</span><span class="p">,</span> <span class="n">hard</span><span class="p">,</span> <span class="n">hub</span><span class="p">):</span>
        <span class="c1"># only used by async pool.</span>
        <span class="k">if</span> <span class="n">hard</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tref_for_id</span><span class="p">[</span><span class="n">job</span><span class="p">]</span> <span class="o">=</span> <span class="n">hub</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span>
                <span class="n">hard</span> <span class="o">-</span> <span class="n">soft</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_hard_timeout</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">job</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># job ready</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_soft_timeout</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hard</span><span class="p">:</span>
                <span class="c1"># remove tref</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_discard_tref</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_on_hard_timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job</span><span class="p">):</span>
        <span class="c1"># only used by async pool.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">job</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># job ready</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_hard_timeout</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># remove tref</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_discard_tref</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_job_ready</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">inqW_fd</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mark_worker_as_available</span><span class="p">(</span><span class="n">inqW_fd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_process_handlers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create handlers called on process up/down, etc.&quot;&quot;&quot;</span>
        <span class="n">add_reader</span><span class="p">,</span> <span class="n">remove_reader</span><span class="p">,</span> <span class="n">remove_writer</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">hub</span><span class="o">.</span><span class="n">add_reader</span><span class="p">,</span> <span class="n">hub</span><span class="o">.</span><span class="n">remove_reader</span><span class="p">,</span> <span class="n">hub</span><span class="o">.</span><span class="n">remove_writer</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span>
        <span class="n">all_inqueues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_inqueues</span>
        <span class="n">fileno_to_inq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_inq</span>
        <span class="n">fileno_to_outq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_outq</span>
        <span class="n">fileno_to_synq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_synq</span>
        <span class="n">busy_workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_busy_workers</span>
        <span class="n">handle_result_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_result_event</span>
        <span class="n">process_flush_queues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_flush_queues</span>
        <span class="n">waiting_to_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waiting_to_start</span>

        <span class="k">def</span> <span class="nf">verify_process_alive</span><span class="p">(</span><span class="n">proc</span><span class="p">):</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">proc</span><span class="p">()</span>  <span class="c1"># is a weakref</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">proc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">proc</span><span class="o">.</span><span class="n">_is_alive</span><span class="p">()</span> <span class="ow">and</span>
                    <span class="n">proc</span> <span class="ow">in</span> <span class="n">waiting_to_start</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">proc</span><span class="o">.</span><span class="n">outqR_fd</span> <span class="ow">in</span> <span class="n">fileno_to_outq</span>
                <span class="k">assert</span> <span class="n">fileno_to_outq</span><span class="p">[</span><span class="n">proc</span><span class="o">.</span><span class="n">outqR_fd</span><span class="p">]</span> <span class="ow">is</span> <span class="n">proc</span>
                <span class="k">assert</span> <span class="n">proc</span><span class="o">.</span><span class="n">outqR_fd</span> <span class="ow">in</span> <span class="n">hub</span><span class="o">.</span><span class="n">readers</span>
                <span class="n">error</span><span class="p">(</span><span class="s1">&#39;Timed out waiting for UP message from </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">proc</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">on_process_up</span><span class="p">(</span><span class="n">proc</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Called when a process has started.&quot;&quot;&quot;</span>
            <span class="c1"># If we got the same fd as a previous process then we&#39;ll also</span>
            <span class="c1"># receive jobs in the old buffer, so we need to reset the</span>
            <span class="c1"># job._write_to and job._scheduled_for attributes used to recover</span>
            <span class="c1"># message boundaries when processes exit.</span>
            <span class="n">infd</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">inqW_fd</span>
            <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">values</span><span class="p">(</span><span class="n">cache</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span> <span class="ow">and</span> <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span><span class="o">.</span><span class="n">inqW_fd</span> <span class="o">==</span> <span class="n">infd</span><span class="p">:</span>
                    <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span> <span class="o">=</span> <span class="n">proc</span>
                <span class="k">if</span> <span class="n">job</span><span class="o">.</span><span class="n">_scheduled_for</span> <span class="ow">and</span> <span class="n">job</span><span class="o">.</span><span class="n">_scheduled_for</span><span class="o">.</span><span class="n">inqW_fd</span> <span class="o">==</span> <span class="n">infd</span><span class="p">:</span>
                    <span class="n">job</span><span class="o">.</span><span class="n">_scheduled_for</span> <span class="o">=</span> <span class="n">proc</span>
            <span class="n">fileno_to_outq</span><span class="p">[</span><span class="n">proc</span><span class="o">.</span><span class="n">outqR_fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">proc</span>

            <span class="c1"># maintain_pool is called whenever a process exits.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_track_child_process</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">hub</span><span class="p">)</span>

            <span class="k">assert</span> <span class="ow">not</span> <span class="n">isblocking</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">outq</span><span class="o">.</span><span class="n">_reader</span><span class="p">)</span>

            <span class="c1"># handle_result_event is called when the processes outqueue is</span>
            <span class="c1"># readable.</span>
            <span class="n">add_reader</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">outqR_fd</span><span class="p">,</span> <span class="n">handle_result_event</span><span class="p">,</span> <span class="n">proc</span><span class="o">.</span><span class="n">outqR_fd</span><span class="p">)</span>

            <span class="n">waiting_to_start</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
            <span class="n">hub</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_proc_alive_timeout</span><span class="p">,</span> <span class="n">verify_process_alive</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">proc</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">on_process_up</span> <span class="o">=</span> <span class="n">on_process_up</span>

        <span class="k">def</span> <span class="nf">_remove_from_index</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">remove_fun</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="c1"># this remove the file descriptors for a process from</span>
            <span class="c1"># the indices.  we have to make sure we don&#39;t overwrite</span>
            <span class="c1"># another processes fds, as the fds may be reused.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fd</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">):</span>
                <span class="k">return</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="ow">is</span> <span class="n">proc</span><span class="p">:</span>
                    <span class="c1"># fd hasn&#39;t been reused so we can remove it from index.</span>
                    <span class="n">index</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">remove_fun</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">callback</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fd</span>

        <span class="k">def</span> <span class="nf">on_process_down</span><span class="p">(</span><span class="n">proc</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Called when a worker process exits.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="s1">&#39;dead&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="n">process_flush_queues</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
            <span class="n">_remove_from_index</span><span class="p">(</span>
                <span class="n">proc</span><span class="o">.</span><span class="n">outq</span><span class="o">.</span><span class="n">_reader</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">fileno_to_outq</span><span class="p">,</span> <span class="n">remove_reader</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">synq</span><span class="p">:</span>
                <span class="n">_remove_from_index</span><span class="p">(</span>
                    <span class="n">proc</span><span class="o">.</span><span class="n">synq</span><span class="o">.</span><span class="n">_writer</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">fileno_to_synq</span><span class="p">,</span> <span class="n">remove_writer</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">inq</span> <span class="o">=</span> <span class="n">_remove_from_index</span><span class="p">(</span>
                <span class="n">proc</span><span class="o">.</span><span class="n">inq</span><span class="o">.</span><span class="n">_writer</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">fileno_to_inq</span><span class="p">,</span> <span class="n">remove_writer</span><span class="p">,</span>
                <span class="n">callback</span><span class="o">=</span><span class="n">all_inqueues</span><span class="o">.</span><span class="n">discard</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">inq</span><span class="p">:</span>
                <span class="n">busy_workers</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">inq</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_untrack_child_process</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">hub</span><span class="p">)</span>
            <span class="n">waiting_to_start</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active_writes</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">inqW_fd</span><span class="p">)</span>
            <span class="n">remove_writer</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">inq</span><span class="o">.</span><span class="n">_writer</span><span class="p">)</span>
            <span class="n">remove_reader</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">outq</span><span class="o">.</span><span class="n">_reader</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">synqR_fd</span><span class="p">:</span>
                <span class="n">remove_reader</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">synq</span><span class="o">.</span><span class="n">_reader</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">synqW_fd</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_active_writes</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">synqW_fd</span><span class="p">)</span>
                <span class="n">remove_reader</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">synq</span><span class="o">.</span><span class="n">_writer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_process_down</span> <span class="o">=</span> <span class="n">on_process_down</span>

    <span class="k">def</span> <span class="nf">_create_write_handlers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hub</span><span class="p">,</span>
                               <span class="n">pack</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">,</span> <span class="n">dumps</span><span class="o">=</span><span class="n">_pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">,</span>
                               <span class="n">protocol</span><span class="o">=</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create handlers used to write data to child processes.&quot;&quot;&quot;</span>
        <span class="n">fileno_to_inq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_inq</span>
        <span class="n">fileno_to_synq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_synq</span>
        <span class="n">outbound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outbound_buffer</span>
        <span class="n">pop_message</span> <span class="o">=</span> <span class="n">outbound</span><span class="o">.</span><span class="n">popleft</span>
        <span class="n">put_message</span> <span class="o">=</span> <span class="n">outbound</span><span class="o">.</span><span class="n">append</span>
        <span class="n">all_inqueues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_inqueues</span>
        <span class="n">active_writes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_writes</span>
        <span class="n">active_writers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span>
        <span class="n">busy_workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_busy_workers</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">all_inqueues</span><span class="o">.</span><span class="n">difference</span>
        <span class="n">add_writer</span> <span class="o">=</span> <span class="n">hub</span><span class="o">.</span><span class="n">add_writer</span>
        <span class="n">hub_add</span><span class="p">,</span> <span class="n">hub_remove</span> <span class="o">=</span> <span class="n">hub</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">hub</span><span class="o">.</span><span class="n">remove</span>
        <span class="n">mark_write_fd_as_active</span> <span class="o">=</span> <span class="n">active_writes</span><span class="o">.</span><span class="n">add</span>
        <span class="n">mark_write_gen_as_active</span> <span class="o">=</span> <span class="n">active_writers</span><span class="o">.</span><span class="n">add</span>
        <span class="n">mark_worker_as_busy</span> <span class="o">=</span> <span class="n">busy_workers</span><span class="o">.</span><span class="n">add</span>
        <span class="n">write_generator_done</span> <span class="o">=</span> <span class="n">active_writers</span><span class="o">.</span><span class="n">discard</span>
        <span class="n">get_job</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="fm">__getitem__</span>
        <span class="n">write_stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_stats</span>
        <span class="n">is_fair_strategy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sched_strategy</span> <span class="o">==</span> <span class="n">SCHED_STRATEGY_FAIR</span>
        <span class="n">revoked_tasks</span> <span class="o">=</span> <span class="n">worker_state</span><span class="o">.</span><span class="n">revoked</span>
        <span class="n">getpid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span>

        <span class="n">precalc</span> <span class="o">=</span> <span class="p">{</span><span class="n">ACK</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_payload</span><span class="p">(</span><span class="n">ACK</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)),</span>
                   <span class="n">NACK</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_payload</span><span class="p">(</span><span class="n">NACK</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))}</span>

        <span class="k">def</span> <span class="nf">_put_back</span><span class="p">(</span><span class="n">job</span><span class="p">,</span> <span class="n">_time</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">):</span>
            <span class="c1"># puts back at the end of the queue</span>
            <span class="k">if</span> <span class="n">job</span><span class="o">.</span><span class="n">_terminated</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> \
                    <span class="n">job</span><span class="o">.</span><span class="n">correlation_id</span> <span class="ow">in</span> <span class="n">revoked_tasks</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">job</span><span class="o">.</span><span class="n">_accepted</span><span class="p">:</span>
                    <span class="n">job</span><span class="o">.</span><span class="n">_ack</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_time</span><span class="p">(),</span> <span class="n">getpid</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">job</span><span class="o">.</span><span class="n">_set_terminated</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">_terminated</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># XXX linear lookup, should find a better way,</span>
                <span class="c1"># but this happens rarely and is here to protect against races.</span>
                <span class="k">if</span> <span class="n">job</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">outbound</span><span class="p">:</span>
                    <span class="n">outbound</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_put_back</span> <span class="o">=</span> <span class="n">_put_back</span>

        <span class="c1"># called for every event loop iteration, and if there</span>
        <span class="c1"># are messages pending this will schedule writing one message</span>
        <span class="c1"># by registering the &#39;schedule_writes&#39; function for all currently</span>
        <span class="c1"># inactive inqueues (not already being written to)</span>

        <span class="c1"># consolidate means the event loop will merge them</span>
        <span class="c1"># and call the callback once with the list writable fds as</span>
        <span class="c1"># argument.  Using this means we minimize the risk of having</span>
        <span class="c1"># the same fd receive every task if the pipe read buffer is not</span>
        <span class="c1"># full.</span>
        <span class="k">if</span> <span class="n">is_fair_strategy</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">on_poll_start</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">outbound</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">busy_workers</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_inqueues</span><span class="p">):</span>
                    <span class="c1">#  print(&#39;ALL: %r ACTIVE: %r&#39; % (len(all_inqueues),</span>
                    <span class="c1">#                                len(active_writes)))</span>
                    <span class="n">inactive</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">active_writes</span><span class="p">)</span>
                    <span class="p">[</span><span class="n">hub_add</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">WRITE</span> <span class="o">|</span> <span class="n">ERR</span><span class="p">,</span> <span class="n">consolidate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">inactive</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="p">[</span><span class="n">hub_remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">diff</span><span class="p">(</span><span class="n">active_writes</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">on_poll_start</span><span class="p">():</span>  <span class="c1"># noqa</span>
                <span class="k">if</span> <span class="n">outbound</span><span class="p">:</span>
                    <span class="p">[</span><span class="n">hub_add</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">WRITE</span> <span class="o">|</span> <span class="n">ERR</span><span class="p">,</span> <span class="n">consolidate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">diff</span><span class="p">(</span><span class="n">active_writes</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="p">[</span><span class="n">hub_remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">diff</span><span class="p">(</span><span class="n">active_writes</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_poll_start</span> <span class="o">=</span> <span class="n">on_poll_start</span>

        <span class="k">def</span> <span class="nf">on_inqueue_close</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
            <span class="c1"># Makes sure the fd is removed from tracking when</span>
            <span class="c1"># the connection is closed, this is essential as fds may be reused.</span>
            <span class="n">busy_workers</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fileno_to_inq</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="ow">is</span> <span class="n">proc</span><span class="p">:</span>
                    <span class="n">fileno_to_inq</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="n">active_writes</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                    <span class="n">all_inqueues</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                    <span class="n">hub_remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_inqueue_close</span> <span class="o">=</span> <span class="n">on_inqueue_close</span>

        <span class="k">def</span> <span class="nf">schedule_writes</span><span class="p">(</span><span class="n">ready_fds</span><span class="p">,</span> <span class="n">total_write_count</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># Schedule write operation to ready file descriptor.</span>
            <span class="c1"># The file descriptor is writable, but that does not</span>
            <span class="c1"># mean the process is currently reading from the socket.</span>
            <span class="c1"># The socket is buffered so writable simply means that</span>
            <span class="c1"># the buffer can accept at least 1 byte of data.</span>

            <span class="c1"># This means we have to cycle between the ready fds.</span>
            <span class="c1"># the first version used shuffle, but this version</span>
            <span class="c1"># using `total_writes % ready_fds` is about 30% faster</span>
            <span class="c1"># with many processes, and also leans more towards fairness</span>
            <span class="c1"># in write stats when used with many processes</span>
            <span class="c1"># [XXX On macOS, this may vary depending</span>
            <span class="c1"># on event loop implementation (i.e, select/poll vs epoll), so</span>
            <span class="c1"># have to test further]</span>
            <span class="n">num_ready</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ready_fds</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ready</span><span class="p">):</span>
                <span class="n">ready_fd</span> <span class="o">=</span> <span class="n">ready_fds</span><span class="p">[</span><span class="n">total_write_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">num_ready</span><span class="p">]</span>
                <span class="n">total_write_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">ready_fd</span> <span class="ow">in</span> <span class="n">active_writes</span><span class="p">:</span>
                    <span class="c1"># already writing to this fd</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">is_fair_strategy</span> <span class="ow">and</span> <span class="n">ready_fd</span> <span class="ow">in</span> <span class="n">busy_workers</span><span class="p">:</span>
                    <span class="c1"># worker is already busy with another task</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">ready_fd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_inqueues</span><span class="p">:</span>
                    <span class="n">hub_remove</span><span class="p">(</span><span class="n">ready_fd</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">job</span> <span class="o">=</span> <span class="n">pop_message</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="c1"># no more messages, remove all inactive fds from the hub.</span>
                    <span class="c1"># this is important since the fds are always writable</span>
                    <span class="c1"># as long as there&#39;s 1 byte left in the buffer, and so</span>
                    <span class="c1"># this may create a spinloop where the event loop</span>
                    <span class="c1"># always wakes up.</span>
                    <span class="k">for</span> <span class="n">inqfd</span> <span class="ow">in</span> <span class="n">diff</span><span class="p">(</span><span class="n">active_writes</span><span class="p">):</span>
                        <span class="n">hub_remove</span><span class="p">(</span><span class="n">inqfd</span><span class="p">)</span>
                    <span class="k">break</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">job</span><span class="o">.</span><span class="n">_accepted</span><span class="p">:</span>  <span class="c1"># job not accepted by another worker</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="c1"># keep track of what process the write operation</span>
                            <span class="c1"># was scheduled for.</span>
                            <span class="n">proc</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">_scheduled_for</span> <span class="o">=</span> <span class="n">fileno_to_inq</span><span class="p">[</span><span class="n">ready_fd</span><span class="p">]</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="c1"># write was scheduled for this fd but the process</span>
                            <span class="c1"># has since exited and the message must be sent to</span>
                            <span class="c1"># another process.</span>
                            <span class="n">put_message</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
                            <span class="k">continue</span>
                        <span class="n">cor</span> <span class="o">=</span> <span class="n">_write_job</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">ready_fd</span><span class="p">,</span> <span class="n">job</span><span class="p">)</span>
                        <span class="n">job</span><span class="o">.</span><span class="n">_writer</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="n">cor</span><span class="p">)</span>
                        <span class="n">mark_write_gen_as_active</span><span class="p">(</span><span class="n">cor</span><span class="p">)</span>
                        <span class="n">mark_write_fd_as_active</span><span class="p">(</span><span class="n">ready_fd</span><span class="p">)</span>
                        <span class="n">mark_worker_as_busy</span><span class="p">(</span><span class="n">ready_fd</span><span class="p">)</span>

                        <span class="c1"># Try to write immediately, in case there&#39;s an error.</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="nb">next</span><span class="p">(</span><span class="n">cor</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">exc</span><span class="o">.</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">errno</span><span class="o">.</span><span class="n">EBADF</span><span class="p">:</span>
                                <span class="k">raise</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">add_writer</span><span class="p">(</span><span class="n">ready_fd</span><span class="p">,</span> <span class="n">cor</span><span class="p">)</span>
        <span class="n">hub</span><span class="o">.</span><span class="n">consolidate_callback</span> <span class="o">=</span> <span class="n">schedule_writes</span>

        <span class="k">def</span> <span class="nf">send_job</span><span class="p">(</span><span class="n">tup</span><span class="p">):</span>
            <span class="c1"># Schedule writing job request for when one of the process</span>
            <span class="c1"># inqueues are writable.</span>
            <span class="n">body</span> <span class="o">=</span> <span class="n">dumps</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">protocol</span><span class="p">)</span>
            <span class="n">body_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">pack</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;&gt;I&#39;</span><span class="p">,</span> <span class="n">body_size</span><span class="p">)</span>
            <span class="c1"># index 1,0 is the job ID.</span>
            <span class="n">job</span> <span class="o">=</span> <span class="n">get_job</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">job</span><span class="o">.</span><span class="n">_payload</span> <span class="o">=</span> <span class="n">buf_t</span><span class="p">(</span><span class="n">header</span><span class="p">),</span> <span class="n">buf_t</span><span class="p">(</span><span class="n">body</span><span class="p">),</span> <span class="n">body_size</span>
            <span class="n">put_message</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quick_put</span> <span class="o">=</span> <span class="n">send_job</span>

        <span class="k">def</span> <span class="nf">on_not_recovering</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span>
                <span class="s1">&#39;Process inqueue damaged: </span><span class="si">%r</span><span class="s1"> </span><span class="si">%r</span><span class="s1">: </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">proc</span><span class="o">.</span><span class="n">exitcode</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">_is_alive</span><span class="p">():</span>
                <span class="n">proc</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="n">hub</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_put_back</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_write_job</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">job</span><span class="p">):</span>
            <span class="c1"># writes job to the worker process.</span>
            <span class="c1"># Operation must complete if more than one byte of data</span>
            <span class="c1"># was written.  If the broker connection is lost</span>
            <span class="c1"># and no data was written the operation shall be canceled.</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">body_size</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">_payload</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># job result keeps track of what process the job is sent to.</span>
                <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span> <span class="o">=</span> <span class="n">proc</span>
                <span class="n">send</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">send_job_offset</span>

                <span class="n">Hw</span> <span class="o">=</span> <span class="n">Bw</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># write header</span>
                <span class="k">while</span> <span class="n">Hw</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">Hw</span> <span class="o">+=</span> <span class="n">send</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">Hw</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>  <span class="c1"># pylint: disable=broad-except</span>
                        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="s1">&#39;errno&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">UNAVAIL</span><span class="p">:</span>
                            <span class="k">raise</span>
                        <span class="c1"># suspend until more data</span>
                        <span class="n">errors</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">errors</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                            <span class="n">on_not_recovering</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
                        <span class="k">yield</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># write body</span>
                <span class="k">while</span> <span class="n">Bw</span> <span class="o">&lt;</span> <span class="n">body_size</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">Bw</span> <span class="o">+=</span> <span class="n">send</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">Bw</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>  <span class="c1"># pylint: disable=broad-except</span>
                        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="s1">&#39;errno&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">UNAVAIL</span><span class="p">:</span>
                            <span class="k">raise</span>
                        <span class="c1"># suspend until more data</span>
                        <span class="n">errors</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">errors</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                            <span class="n">on_not_recovering</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
                        <span class="k">yield</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">hub_remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                <span class="n">write_stats</span><span class="p">[</span><span class="n">proc</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># message written, so this fd is now available</span>
                <span class="n">active_writes</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                <span class="n">write_generator_done</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">_writer</span><span class="p">())</span>  <span class="c1"># is a weakref</span>

        <span class="k">def</span> <span class="nf">send_ack</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">fd</span><span class="p">):</span>
            <span class="c1"># Only used when synack is enabled.</span>
            <span class="c1"># Schedule writing ack response for when the fd is writable.</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">Ack</span><span class="p">(</span><span class="n">job</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">precalc</span><span class="p">[</span><span class="n">response</span><span class="p">])</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">promise</span><span class="p">(</span><span class="n">write_generator_done</span><span class="p">)</span>
            <span class="n">cor</span> <span class="o">=</span> <span class="n">_write_ack</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">)</span>
            <span class="n">mark_write_gen_as_active</span><span class="p">(</span><span class="n">cor</span><span class="p">)</span>
            <span class="n">mark_write_fd_as_active</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="n">callback</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">cor</span><span class="p">,)</span>
            <span class="n">add_writer</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">cor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_ack</span> <span class="o">=</span> <span class="n">send_ack</span>

        <span class="k">def</span> <span class="nf">_write_ack</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="c1"># writes ack back to the worker if synack enabled.</span>
            <span class="c1"># this operation *MUST* complete, otherwise</span>
            <span class="c1"># the worker process will hang waiting for the ack.</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">body_size</span> <span class="o">=</span> <span class="n">ack</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">proc</span> <span class="o">=</span> <span class="n">fileno_to_synq</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># process died, we can safely discard the ack at this</span>
                    <span class="c1"># point.</span>
                    <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
                <span class="n">send</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">send_syn_offset</span>

                <span class="n">Hw</span> <span class="o">=</span> <span class="n">Bw</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># write header</span>
                <span class="k">while</span> <span class="n">Hw</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">Hw</span> <span class="o">+=</span> <span class="n">send</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">Hw</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>  <span class="c1"># pylint: disable=broad-except</span>
                        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="s1">&#39;errno&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">UNAVAIL</span><span class="p">:</span>
                            <span class="k">raise</span>
                        <span class="k">yield</span>

                <span class="c1"># write body</span>
                <span class="k">while</span> <span class="n">Bw</span> <span class="o">&lt;</span> <span class="n">body_size</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">Bw</span> <span class="o">+=</span> <span class="n">send</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">Bw</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>  <span class="c1"># pylint: disable=broad-except</span>
                        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="s1">&#39;errno&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">UNAVAIL</span><span class="p">:</span>
                            <span class="k">raise</span>
                        <span class="c1"># suspend until more data</span>
                        <span class="k">yield</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">callback</span><span class="p">:</span>
                    <span class="n">callback</span><span class="p">()</span>
                <span class="c1"># message written, so this fd is now available</span>
                <span class="n">active_writes</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="n">TERMINATE</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># cancel all tasks that haven&#39;t been accepted so that NACK is sent.</span>
        <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">job</span><span class="o">.</span><span class="n">_accepted</span><span class="p">:</span>
                <span class="n">job</span><span class="o">.</span><span class="n">_cancel</span><span class="p">()</span>

        <span class="c1"># clear the outgoing buffer as the tasks will be redelivered by</span>
        <span class="c1"># the broker anyway.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">outbound_buffer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outbound_buffer</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maintain_pool</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># ...but we must continue writing the payloads we already started</span>
            <span class="c1"># to keep message boundaries.</span>
            <span class="c1"># The messages may be NACK&#39;ed later if synack is enabled.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="n">RUN</span><span class="p">:</span>
                <span class="c1"># flush outgoing buffers</span>
                <span class="n">intervals</span> <span class="o">=</span> <span class="n">fxrange</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="n">repeatlast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">owned_by</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">):</span>
                    <span class="n">writer</span> <span class="o">=</span> <span class="n">_get_job_writer</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">writer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">owned_by</span><span class="p">[</span><span class="n">writer</span><span class="p">]</span> <span class="o">=</span> <span class="n">job</span>

                <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span><span class="p">:</span>
                    <span class="n">writers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">writers</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;_write_job&#39;</span> <span class="ow">and</span>
                                <span class="n">gen_not_started</span><span class="p">(</span><span class="n">gen</span><span class="p">)):</span>
                            <span class="c1"># hasn&#39;t started writing the job so can</span>
                            <span class="c1"># discard the task, but we must also remove</span>
                            <span class="c1"># it from the Pool._cache.</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">job</span> <span class="o">=</span> <span class="n">owned_by</span><span class="p">[</span><span class="n">gen</span><span class="p">]</span>
                            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                                <span class="k">pass</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># removes from Pool._cache</span>
                                <span class="n">job</span><span class="o">.</span><span class="n">discard</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">job</span> <span class="o">=</span> <span class="n">owned_by</span><span class="p">[</span><span class="n">gen</span><span class="p">]</span>
                            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                                <span class="k">pass</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">job_proc</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span>
                                <span class="k">if</span> <span class="n">job_proc</span><span class="o">.</span><span class="n">_is_alive</span><span class="p">():</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_flush_writer</span><span class="p">(</span><span class="n">job_proc</span><span class="p">,</span> <span class="n">gen</span><span class="p">)</span>
                    <span class="c1"># workers may have exited in the meantime.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">maintain_pool</span><span class="p">()</span>
                    <span class="n">sleep</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">intervals</span><span class="p">))</span>  <span class="c1"># don&#39;t busyloop</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outbound_buffer</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active_writes</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_busy_workers</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_flush_writer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
        <span class="n">fds</span> <span class="o">=</span> <span class="p">{</span><span class="n">proc</span><span class="o">.</span><span class="n">inq</span><span class="o">.</span><span class="n">_writer</span><span class="p">}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">fds</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">proc</span><span class="o">.</span><span class="n">_is_alive</span><span class="p">():</span>
                    <span class="k">break</span>  <span class="c1"># process exited</span>
                <span class="n">readable</span><span class="p">,</span> <span class="n">writable</span><span class="p">,</span> <span class="n">again</span> <span class="o">=</span> <span class="n">_select</span><span class="p">(</span>
                    <span class="n">writers</span><span class="o">=</span><span class="n">fds</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="n">fds</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">again</span> <span class="ow">and</span> <span class="p">(</span><span class="n">writable</span> <span class="ow">or</span> <span class="n">readable</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="nb">next</span><span class="p">(</span><span class="n">writer</span><span class="p">)</span>
                    <span class="k">except</span> <span class="p">(</span><span class="ne">StopIteration</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">,</span> <span class="ne">EOFError</span><span class="p">):</span>
                        <span class="k">break</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">writer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_process_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get queues for a new process.</span>

<span class="sd">        Here we&#39;ll find an unused slot, as there should always</span>
<span class="sd">        be one available when we start a new process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">q</span> <span class="k">for</span> <span class="n">q</span><span class="p">,</span> <span class="n">owner</span> <span class="ow">in</span> <span class="n">items</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">owner</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_grow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Grow the pool by ``n`` proceses.&quot;&quot;&quot;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_processes</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diff</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_process_queues</span><span class="p">():</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
            <span class="p">})</span>

    <span class="k">def</span> <span class="nf">on_shrink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shrink the pool by ``n`` processes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">create_process_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new in, out, etc. queues, returned as a tuple.&quot;&quot;&quot;</span>
        <span class="c1"># NOTE: Pipes must be set O_NONBLOCK at creation time (the original</span>
        <span class="c1"># fd), otherwise it won&#39;t be possible to change the flags until</span>
        <span class="c1"># there&#39;s an actual reader/writer on the other side.</span>
        <span class="n">inq</span> <span class="o">=</span> <span class="n">_SimpleQueue</span><span class="p">(</span><span class="n">wnonblock</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">outq</span> <span class="o">=</span> <span class="n">_SimpleQueue</span><span class="p">(</span><span class="n">rnonblock</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">synq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">isblocking</span><span class="p">(</span><span class="n">inq</span><span class="o">.</span><span class="n">_reader</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">isblocking</span><span class="p">(</span><span class="n">inq</span><span class="o">.</span><span class="n">_writer</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">isblocking</span><span class="p">(</span><span class="n">outq</span><span class="o">.</span><span class="n">_reader</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">isblocking</span><span class="p">(</span><span class="n">outq</span><span class="o">.</span><span class="n">_writer</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">synack</span><span class="p">:</span>
            <span class="n">synq</span> <span class="o">=</span> <span class="n">_SimpleQueue</span><span class="p">(</span><span class="n">wnonblock</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">isblocking</span><span class="p">(</span><span class="n">synq</span><span class="o">.</span><span class="n">_reader</span><span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">isblocking</span><span class="p">(</span><span class="n">synq</span><span class="o">.</span><span class="n">_writer</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inq</span><span class="p">,</span> <span class="n">outq</span><span class="p">,</span> <span class="n">synq</span>

    <span class="k">def</span> <span class="nf">on_process_alive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called when reciving the :const:`WORKER_UP` message.</span>

<span class="sd">        Marks the process as ready to receive work.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span> <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">pid</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;process with pid=</span><span class="si">%s</span><span class="s1"> already exited&#39;</span><span class="p">,</span> <span class="n">pid</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">proc</span><span class="o">.</span><span class="n">inqW_fd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_inq</span>
        <span class="k">assert</span> <span class="n">proc</span><span class="o">.</span><span class="n">inqW_fd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_inqueues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waiting_to_start</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_inq</span><span class="p">[</span><span class="n">proc</span><span class="o">.</span><span class="n">inqW_fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">proc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_synq</span><span class="p">[</span><span class="n">proc</span><span class="o">.</span><span class="n">synqW_fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">proc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_inqueues</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">inqW_fd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_job_process_down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">pid_gone</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called for each job when the process assigned to it exits.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span><span class="o">.</span><span class="n">_is_alive</span><span class="p">():</span>
            <span class="c1"># job was partially written</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_partial_read</span><span class="p">(</span><span class="n">job</span><span class="p">,</span> <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">job</span><span class="o">.</span><span class="n">_scheduled_for</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">job</span><span class="o">.</span><span class="n">_scheduled_for</span><span class="o">.</span><span class="n">_is_alive</span><span class="p">():</span>
            <span class="c1"># job was only scheduled to be written to this process,</span>
            <span class="c1"># but no data was sent so put it back on the outbound_buffer.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_put_back</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_job_process_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">exitcode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called when the process executing job&#39; exits.</span>

<span class="sd">        This happens when the process job&#39;</span>
<span class="sd">        was assigned to exited by mysterious means (error exitcodes and</span>
<span class="sd">        signals).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mark_as_worker_lost</span><span class="p">(</span><span class="n">job</span><span class="p">,</span> <span class="n">exitcode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">human_write_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_stats</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;N/A&#39;</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">write_stats</span><span class="p">))</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">per</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">total</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{0:.2%}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="n">total</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;total&#39;</span><span class="p">:</span> <span class="n">total</span><span class="p">,</span>
            <span class="s1">&#39;avg&#39;</span><span class="p">:</span> <span class="n">per</span><span class="p">(</span><span class="n">total</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">write_stats</span><span class="p">)</span> <span class="k">if</span> <span class="n">total</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total</span><span class="p">),</span>
            <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">per</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">total</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">),</span>
            <span class="s1">&#39;raw&#39;</span><span class="p">:</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">vals</span><span class="p">)),</span>
            <span class="s1">&#39;strategy&#39;</span><span class="p">:</span> <span class="n">SCHED_STRATEGY_TO_NAME</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sched_strategy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sched_strategy</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="s1">&#39;inqueues&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;total&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_all_inqueues</span><span class="p">),</span>
                <span class="s1">&#39;active&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active_writes</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_process_cleanup_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called to clean up queues after process exit.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">proc</span><span class="o">.</span><span class="n">dead</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_worker_queues</span><span class="p">(</span><span class="n">proc</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_stop_task_handler</span><span class="p">(</span><span class="n">task_handler</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called at shutdown to tell processes that we&#39;re shutting down.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">proc</span> <span class="ow">in</span> <span class="n">task_handler</span><span class="o">.</span><span class="n">pool</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">setblocking</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">inq</span><span class="o">.</span><span class="n">_writer</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">proc</span><span class="o">.</span><span class="n">inq</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">exc</span><span class="o">.</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">errno</span><span class="o">.</span><span class="n">EBADF</span><span class="p">:</span>
                        <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">create_result_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AsynPool</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">create_result_handler</span><span class="p">(</span>
            <span class="n">fileno_to_outq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_outq</span><span class="p">,</span>
            <span class="n">on_process_alive</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">on_process_alive</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_register_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">queues</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mark new ownership for ``queues`` to update fileno indices.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">queues</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">[</span><span class="n">queues</span><span class="p">]</span> <span class="o">=</span> <span class="n">proc</span>
        <span class="k">assert</span> <span class="n">b</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_worker_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the queues owned by ``proc``.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">q</span> <span class="k">for</span> <span class="n">q</span><span class="p">,</span> <span class="n">owner</span> <span class="ow">in</span> <span class="n">items</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">owner</span> <span class="o">==</span> <span class="n">proc</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># this is only used by the original pool that used a shared</span>
        <span class="c1"># queue for all processes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quick_put</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># these attributes are unused by this class, but we&#39;ll still</span>
        <span class="c1"># have to initialize them for compatibility.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inqueue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outqueue</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_quick_get</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poll_result</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">process_flush_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush all queues.</span>

<span class="sd">        Including the outbound buffer, so that</span>
<span class="sd">        all tasks that haven&#39;t been started will be discarded.</span>

<span class="sd">        In Celery this is called whenever the transport connection is lost</span>
<span class="sd">        (consumer restart), and when a process is terminated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resq</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">outq</span><span class="o">.</span><span class="n">_reader</span>
        <span class="n">on_state_change</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result_handler</span><span class="o">.</span><span class="n">on_state_change</span>
        <span class="n">fds</span> <span class="o">=</span> <span class="p">{</span><span class="n">resq</span><span class="p">}</span>
        <span class="k">while</span> <span class="n">fds</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">resq</span><span class="o">.</span><span class="n">closed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">TERMINATE</span><span class="p">:</span>
            <span class="n">readable</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_select</span><span class="p">(</span><span class="n">fds</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fds</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">readable</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">task</span> <span class="o">=</span> <span class="n">resq</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">,</span> <span class="ne">EOFError</span><span class="p">)</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="n">_errno</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="s1">&#39;errno&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">_errno</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EINTR</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">_errno</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EAGAIN</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="k">elif</span> <span class="n">_errno</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">UNAVAIL</span><span class="p">:</span>
                        <span class="n">debug</span><span class="p">(</span><span class="s1">&#39;got </span><span class="si">%r</span><span class="s1"> while flushing process </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span>
                              <span class="n">exc</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">task</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">debug</span><span class="p">(</span><span class="s1">&#39;got sentinel while flushing process </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">proc</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">on_state_change</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">def</span> <span class="nf">on_partial_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called when a job was partially written to exited child.&quot;&quot;&quot;</span>
        <span class="c1"># worker terminated by signal:</span>
        <span class="c1"># we cannot reuse the sockets again, because we don&#39;t know if</span>
        <span class="c1"># the process wrote/read anything frmo them, and if so we cannot</span>
        <span class="c1"># restore the message boundaries.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">job</span><span class="o">.</span><span class="n">_accepted</span><span class="p">:</span>
            <span class="c1"># job was not acked, so find another worker to send it to.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_put_back</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">_get_job_writer</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">writer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">writer</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">writer</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">proc</span><span class="o">.</span><span class="n">dead</span><span class="p">:</span>
            <span class="n">proc</span><span class="o">.</span><span class="n">dead</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># Replace queues to avoid reuse</span>
            <span class="n">before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">queues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_worker_queues</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">destroy_queues</span><span class="p">(</span><span class="n">queues</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">create_process_queues</span><span class="p">()]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">)</span> <span class="o">==</span> <span class="n">before</span>

    <span class="k">def</span> <span class="nf">destroy_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queues</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Destroy queues that can no longer be used.</span>

<span class="sd">        This way they can be replaced by new usable sockets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">proc</span><span class="o">.</span><span class="n">_is_alive</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waiting_to_start</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
        <span class="n">removed</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">queues</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">removed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_inqueue_close</span><span class="p">(</span><span class="n">queues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_writer</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">proc</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">for</span> <span class="n">queue</span> <span class="ow">in</span> <span class="n">queues</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">queue</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sock</span> <span class="ow">in</span> <span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">_reader</span><span class="p">,</span> <span class="n">queue</span><span class="o">.</span><span class="n">_writer</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">sock</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                        <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">):</span>
                            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">removed</span>

    <span class="k">def</span> <span class="nf">_create_payload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span>
                        <span class="n">dumps</span><span class="o">=</span><span class="n">_pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">,</span> <span class="n">pack</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">,</span>
                        <span class="n">protocol</span><span class="o">=</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">):</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">dumps</span><span class="p">((</span><span class="n">type_</span><span class="p">,</span> <span class="n">args</span><span class="p">),</span> <span class="n">protocol</span><span class="o">=</span><span class="n">protocol</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">pack</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;&gt;I&#39;</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">header</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">size</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_set_result_sentinel</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_outqueue</span><span class="p">,</span> <span class="n">_pool</span><span class="p">):</span>
        <span class="c1"># unused</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_help_stuff_finish_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Pool._help_stuff_finished is a classmethod so we have to use this</span>
        <span class="c1"># trick to modify the arguments passed to it.</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="p">,)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_help_stuff_finish</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">pool</span><span class="p">):</span>
        <span class="c1"># pylint: disable=arguments-differ</span>
        <span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;removing tasks from inqueue until task handler finished&#39;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">fileno_to_proc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">inqR</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">pool</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fd</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">inq</span><span class="o">.</span><span class="n">_reader</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>
                <span class="n">inqR</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                <span class="n">fileno_to_proc</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">while</span> <span class="n">inqR</span><span class="p">:</span>
            <span class="n">readable</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">again</span> <span class="o">=</span> <span class="n">_select</span><span class="p">(</span><span class="n">inqR</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">again</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">readable</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">readable</span><span class="p">:</span>
                <span class="n">fileno_to_proc</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span><span class="o">.</span><span class="n">inq</span><span class="o">.</span><span class="n">_reader</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">timers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">maintain_pool</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">}</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/celery_512.png" alt="Logo"/>
            </a></p><iframe src="https://ghbtns.com/github-btn.html?user=celery&repo=celery&type=watch&count=true&size=large"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>
<div id="donate">
    <b>Please help support this community project with a donation:</b>
    <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
    <input type="hidden" name="cmd" value="_s-xclick">
    <input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----MIIHTwYJKoZIhvcNAQcEoIIHQDCCBzwCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYA2+c723xlntHKQYQR9yn9BEtUhDoUUlnOqhniqvNMWB4k2R0JpVkrNSu5JCbdjNOqDXKHoRfIWe3HXJJMPZBJKFMD5Izprb6xEZlTGaWnlrGXFfkdBaILQQgWYqV0DnuNmtDXCvfYmyu0p1K04wLjAJ1ufnBSP1UaS6BTcoIOOuTELMAkGBSsOAwIaBQAwgcwGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQIFg/2qPwa7UCAgah20QLIllcp0VHazYo2C9h8c6gn8MTcTnpW0WFXhz9ylc/i5dCXabkrrLBBfg8NygAuvYRr4k1zdC0AJIgsV/6rSAhehabRvjRDH2EZ8OieqHfIPfkAcTm+JqbS6Z27lXkebYPnJzhkZxW7+ZC6hU/H40JFXChTag8lhqJfZELiOZLWxxilj2mkwlkdMx1YL6lcPAA7ajpAwjsnJYd/9VxLA6MDmcOu+TKgggOHMIIDgzCCAuygAwIBAgIBADANBgkqhkiG9w0BAQUFADCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wHhcNMDQwMjEzMTAxMzE1WhcNMzUwMjEzMTAxMzE1WjCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMFHTt38RMxLXJyO2SmS+Ndl72T7oKJ4u4uw+6awntALWh03PewmIJuzbALScsTS4sZoS1fKciBGoh11gIfHzylvkdNe/hJl66/RGqrj5rFb08sAABNTzDTiqqNpJeBsYs/c2aiGozptX2RlnBktH+SUNpAajW724Nv2Wvhif6sFAgMBAAGjge4wgeswHQYDVR0OBBYEFJaffLvGbxe9WT9S1wob7BDWZJRrMIG7BgNVHSMEgbMwgbCAFJaffLvGbxe9WT9S1wob7BDWZJRroYGUpIGRMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbYIBADAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4GBAIFfOlaagFrl71+jq6OKidbWFSE+Q4FqROvdgIONth+8kSK//Y/4ihuE4Ymvzn5ceE3S/iBSQQMjyvb+s2TWbQYDwcp129OPIbD9epdr4tJOUNiSojw7BHwYRiPh58S1xGlFgHFXwrEBb3dgNbMUa+u4qectsMAXpVHnD9wIyfmHMYIBmjCCAZYCAQEwgZQwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tAgEAMAkGBSsOAwIaBQCgXTAYBgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMBwGCSqGSIb3DQEJBTEPFw0xNTEyMTAxOTEzMzBaMCMGCSqGSIb3DQEJBDEWBBTUno4gI/mmaVaGVpgB/CWwQd3DeDANBgkqhkiG9w0BAQEFAASBgFmZ1j1Ss/FNl/JRIOakhBJEdm2KGLH0d2ewwTYIgIkEKSdc5Rg2/2xFS/dglcs5Te3R2GzaqjGlNSKldsk/MgZP/BudpHAASQ09hrfDy5TaBlRRl1Yu0WzGBKcVm/WRh0v2TVV8vBHVGiJD+aY5epgRXXI/XUKD0bp8tVV1T7LS-----END PKCS7-----
    ">
    <input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
    <img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
    </form>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Celery 4.2.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../concurrency.html" >celery.concurrency</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; <a href="../../../copyright.html">Copyright</a> 2009-2017, Ask Solem &amp; contributors.
    </div>
  </body>
</html>