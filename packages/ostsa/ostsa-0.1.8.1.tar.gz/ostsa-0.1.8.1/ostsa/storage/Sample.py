from .SampleDao import create_dirs
from ..parsing import clear_memoized_values
from inspect import getmembers

import os
import pickle
import uuid

###############################################################################

def feature(feature_name):
    """Mark the specified method as a feature method. A feature method is a
    method that takes no arguments and returns either a single feature or a
    list of features. The feature_name should be a string specifying the
    desired name of the feature.
    
    This decorator only works with classes that inherit from the Sample class.
    """
    
    def mark_feature_method(method):
        
        # Give the method a special attribute that indicates the name of the
        # feature. This will be used to identify feature methods.
        method._feature_name = feature_name
        
        return method
        
    # Use the mark_feature_method function to mark functions.
    return mark_feature_method
    
###############################################################################
    
def load_sample(sample_file):
    """Loads the sample object from the specified file."""
    with open(sample_file, 'rb') as file:
        return pickle.load(file)
    
###############################################################################

class Sample(object):
    """The Sample class is the base for a class that represents a specific
    type of sample. The Sample class provides utilities for marking methods
    as feature methods, which the SampleDao class can use to automatically
    generate, save, and load databases that hold the Sample's features.
    
    To mark a method as a feature method, import the "feature" decorator
    and use it on the requested method:
        
        class MySample(Sample):
            
            # ...
            
            @feature('Random')
            def random_feature(self):
                return random()
                
    The string passed in the decorator will be used for the column name used
    to hold the feature when a database is generated by the SampleDao class.
    """
    
    @classmethod
    def feature_methods(cls):
        """Retrieve a list of all of the class's feature methods.
        
        The returned list will contain tuples that contain the name of the
        feature (the string in the method's decorator) in the first slot and
        the actual method in the second slot.
        
        The list will be sorted alphabetically by the name of the feature
        supplied in the feature decorator in order to provide consistent
        and reliable ordering.
        """
        
        # Retrieve all of the functions from the class and its base classes.
        #
        # Note: By iterating backwards through the list of classes, we are
        #       ensuring that feature functions defined in derived classes have
        #       priority over base classes.
        feature_functions = {}
        classes = cls.__mro__
        for c in reversed(classes):
                        
            # Get a list of all of the feature functions in the class.
            #
            # A feature method can be identified by the _feature_name 
            # attribute.
            #
            # Note: The decorator will turn these methods into functions 
            #       instead of methods. Hence, the predicate must be 
            #       isfunction and not ismethod.
            class_feature_functions = {function[1]._feature_name: function[1] 
                                       for function in getmembers(c)
                                       if hasattr(function[1], 
                                                  '_feature_name')}
            
            
            # Add the class's feature functions to the overall list.
            feature_functions.update(class_feature_functions)
            
        # Sort the feature methods by the feature names.
        final_list = [(key, feature_functions[key]) for key 
                      in sorted(feature_functions.keys())]
        
        return final_list
        
    def __init__(self):
        """Initialize a new Sample object."""
        
        # Generate a random id.
        # Note: The odds of a collision with this kind of random ID is 
        #       mathematically negligible.
        self._id = uuid.uuid4()
        
    def __enter__(self):
        return self        
        
    def __exit__(self, type, value, traceback):
        """Calls the cleanup method."""
        self.cleanup()
        
    def cleanup(self):
        """Perform any cleanup optimizations that can be done once the sample
        is assumed to be done with extraction.
        
        In most cases, this will result in clearing any cached/memoized values
        related to this class. This is useful for preventing excessive RAM
        usage in large batch operations.
        
        This method is called if the sample is used in a with statement.
        """
        
        clear_memoized_values(self)
        
        
    def features(self):
        """Get a full list of all features available in the class.
        
        This property appends the results of all of the feature methods
        into one list and returns the list. Before calling these methods, the
        optimize method will be called first to perform any optimizations the 
        implementing subclass may contain.
        """
        
        # Perform any optimizations that are available.
        self.optimize()
        
        # Retrieve the results of every feature method into one list.
        feature_list = []

        feature_methods = [f[1] for f in self.__class__.feature_methods()]
        for feature_method in feature_methods:
            
            # Evaluate the result of the method.
            feature = feature_method(self)
            
            # If the method only returned a single value, simply append it to
            # the list. If the method returned a full a list of features, add
            # all of the values individually.
            if (isinstance(feature, (list, tuple))):
                feature_list.extend(feature)
            
            else:
                feature_list.append(feature)
                
        return feature_list
        
    @property
    def identifier(self):
        """Get the identifier used to uniquely identify this sample.
        
        If this is not overridden, an incremented value will be used."""
        return str(self._id)
    
    @property
    def label(self):
        """Get the label for the sample."""
        return None
            
    def optimize(self):
        """Performs any optimization that may improve performance when
        attempting to load all features from the sample at once.
        """
        pass
    
    def save(self, directory='', name=None):
        """Save the sample to a file.
        
        The directory should point to a directory where the file should be
        saved. If no directory is specified, the file will be saved in the
        current directory. If the specified directory does not exist, it will
        be created.
        
        The name should be the name of the file. If no name is specified, the
        ID of the sample is used as the file name. No file extension is used.
        """
        
        # Use id for default file name.
        name = name or self.identifier
        
        # Ensure the directory exists.
        file_path = os.path.join(directory, name)
        create_dirs(file_path)
        
        # Save the sample.
        with open(file_path, 'wb') as file:
            pickle.dump(self, file, protocol=2)