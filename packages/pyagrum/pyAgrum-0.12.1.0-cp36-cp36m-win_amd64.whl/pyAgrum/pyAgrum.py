# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
pyAgrum is a Python wrapper for the C++ aGrUM library. It provides a high-level
interface to the part of agrum allowing to create, handle and make computations
into Bayesian Networks. The module is mainly generated by the SWIG
interface generator.
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_pyAgrum')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_pyAgrum')
    _pyAgrum = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyAgrum', [dirname(__file__)])
        except ImportError:
            import _pyAgrum
            return _pyAgrum
        try:
            _mod = imp.load_module('_pyAgrum', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _pyAgrum = swig_import_helper()
    del swig_import_helper
else:
    import _pyAgrum
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        """value(self) -> PyObject *"""
        return _pyAgrum.SwigPyIterator_value(self)


    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        """
        incr(self, n=1) -> SwigPyIterator
        incr(self) -> SwigPyIterator
        """
        return _pyAgrum.SwigPyIterator_incr(self, n)


    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        """
        decr(self, n=1) -> SwigPyIterator
        decr(self) -> SwigPyIterator
        """
        return _pyAgrum.SwigPyIterator_decr(self, n)


    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        """distance(self, x) -> ptrdiff_t"""
        return _pyAgrum.SwigPyIterator_distance(self, x)


    def equal(self, x: 'SwigPyIterator') -> "bool":
        """equal(self, x) -> bool"""
        return _pyAgrum.SwigPyIterator_equal(self, x)


    def copy(self) -> "swig::SwigPyIterator *":
        """copy(self) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator_copy(self)


    def next(self) -> "PyObject *":
        """next(self) -> PyObject *"""
        return _pyAgrum.SwigPyIterator_next(self)


    def __next__(self) -> "PyObject *":
        """__next__(self) -> PyObject *"""
        return _pyAgrum.SwigPyIterator___next__(self)


    def previous(self) -> "PyObject *":
        """previous(self) -> PyObject *"""
        return _pyAgrum.SwigPyIterator_previous(self)


    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        """advance(self, n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator_advance(self, n)


    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        """__eq__(self, x) -> bool"""
        return _pyAgrum.SwigPyIterator___eq__(self, x)


    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        """__ne__(self, x) -> bool"""
        return _pyAgrum.SwigPyIterator___ne__(self, x)


    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        """__iadd__(self, n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator___iadd__(self, n)


    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        """__isub__(self, n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator___isub__(self, n)


    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        """__add__(self, n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator___add__(self, n)


    def __sub__(self, *args) -> "ptrdiff_t":
        """
        __sub__(self, n) -> SwigPyIterator
        __sub__(self, x) -> ptrdiff_t
        """
        return _pyAgrum.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _pyAgrum.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


import numpy

class JTGenerator(_object):
    """Proxy of C++ JTGenerator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, JTGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, JTGenerator, name)
    __repr__ = _swig_repr

    def junctionTree(self, *args) -> "gum::JunctionTree":
        """
        junctionTree(self, g) -> CliqueGraph
        junctionTree(self, bn) -> CliqueGraph
        """
        return _pyAgrum.JTGenerator_junctionTree(self, *args)


    def binaryJoinTree(self, *args) -> "gum::JunctionTree":
        """
        binaryJoinTree(self, g) -> CliqueGraph
        binaryJoinTree(self, bn) -> CliqueGraph
        """
        return _pyAgrum.JTGenerator_binaryJoinTree(self, *args)


    def __init__(self):
        """__init__(self) -> JTGenerator"""
        this = _pyAgrum.new_JTGenerator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_JTGenerator
    __del__ = lambda self: None
JTGenerator_swigregister = _pyAgrum.JTGenerator_swigregister
JTGenerator_swigregister(JTGenerator)

class PythonBNListener(_object):
    """Proxy of C++ PythonBNListener class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonBNListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonBNListener, name)
    __repr__ = _swig_repr

    def __init__(self, g: 'DiGraph', vnm: 'VariableNodeMap'):
        """__init__(self, g, vnm) -> PythonBNListener"""
        this = _pyAgrum.new_PythonBNListener(g, vnm)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_PythonBNListener
    __del__ = lambda self: None

    def whenNodeAdded(self, source: 'void const *', id: 'gum::NodeId') -> "void":
        """whenNodeAdded(self, source, id)"""
        return _pyAgrum.PythonBNListener_whenNodeAdded(self, source, id)


    def whenNodeDeleted(self, arg2: 'void const *', id: 'gum::NodeId') -> "void":
        """whenNodeDeleted(self, arg2, id)"""
        return _pyAgrum.PythonBNListener_whenNodeDeleted(self, arg2, id)


    def whenArcAdded(self, arg2: 'void const *', src: 'gum::NodeId', dst: 'gum::NodeId') -> "void":
        """whenArcAdded(self, arg2, src, dst)"""
        return _pyAgrum.PythonBNListener_whenArcAdded(self, arg2, src, dst)


    def whenArcDeleted(self, arg2: 'void const *', src: 'gum::NodeId', dst: 'gum::NodeId') -> "void":
        """whenArcDeleted(self, arg2, src, dst)"""
        return _pyAgrum.PythonBNListener_whenArcDeleted(self, arg2, src, dst)


    def setWhenArcAdded(self, pyfunc: 'PyObject *') -> "void":
        """setWhenArcAdded(self, pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenArcAdded(self, pyfunc)


    def setWhenArcDeleted(self, pyfunc: 'PyObject *') -> "void":
        """setWhenArcDeleted(self, pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenArcDeleted(self, pyfunc)


    def setWhenNodeAdded(self, pyfunc: 'PyObject *') -> "void":
        """setWhenNodeAdded(self, pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenNodeAdded(self, pyfunc)


    def setWhenNodeDeleted(self, pyfunc: 'PyObject *') -> "void":
        """setWhenNodeDeleted(self, pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenNodeDeleted(self, pyfunc)

PythonBNListener_swigregister = _pyAgrum.PythonBNListener_swigregister
PythonBNListener_swigregister(PythonBNListener)

class PythonLoadListener(_object):
    """Proxy of C++ PythonLoadListener class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonLoadListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonLoadListener, name)
    __repr__ = _swig_repr

    def whenLoading(self, buffer: 'void const *', percent: 'int') -> "void":
        """whenLoading(self, buffer, percent)"""
        return _pyAgrum.PythonLoadListener_whenLoading(self, buffer, percent)


    def setPythonListener(self, l: 'PyObject *') -> "bool":
        """setPythonListener(self, l) -> bool"""
        return _pyAgrum.PythonLoadListener_setPythonListener(self, l)


    def __init__(self):
        """__init__(self) -> PythonLoadListener"""
        this = _pyAgrum.new_PythonLoadListener()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_PythonLoadListener
    __del__ = lambda self: None
PythonLoadListener_swigregister = _pyAgrum.PythonLoadListener_swigregister
PythonLoadListener_swigregister(PythonLoadListener)


def __fillLoadListeners(py_listener: 'std::vector< PythonLoadListener,std::allocator< PythonLoadListener > > &', l: 'PyObject *') -> "int":
    """__fillLoadListeners(py_listener, l) -> int"""
    return _pyAgrum.__fillLoadListeners(py_listener, l)
class PythonApproximationListener(_object):
    """Proxy of C++ PythonApproximationListener class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonApproximationListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonApproximationListener, name)
    __repr__ = _swig_repr

    def __init__(self, algo: 'IApproximationSchemeConfiguration'):
        """__init__(self, algo) -> PythonApproximationListener"""
        this = _pyAgrum.new_PythonApproximationListener(algo)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_PythonApproximationListener
    __del__ = lambda self: None

    def whenProgress(self, src: 'void const *', step: 'gum::Size const', error: 'double const', duration: 'double const') -> "void":
        """whenProgress(self, src, step, error, duration)"""
        return _pyAgrum.PythonApproximationListener_whenProgress(self, src, step, error, duration)


    def whenStop(self, src: 'void const *', message: 'std::string const') -> "void":
        """whenStop(self, src, message)"""
        return _pyAgrum.PythonApproximationListener_whenStop(self, src, message)


    def setWhenProgress(self, pyfunc: 'PyObject *') -> "void":
        """setWhenProgress(self, pyfunc)"""
        return _pyAgrum.PythonApproximationListener_setWhenProgress(self, pyfunc)


    def setWhenStop(self, pyfunc: 'PyObject *') -> "void":
        """setWhenStop(self, pyfunc)"""
        return _pyAgrum.PythonApproximationListener_setWhenStop(self, pyfunc)

PythonApproximationListener_swigregister = _pyAgrum.PythonApproximationListener_swigregister
PythonApproximationListener_swigregister(PythonApproximationListener)

class BNGenerator(_object):
    """Proxy of C++ BNGenerator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BNGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BNGenerator, name)
    __repr__ = _swig_repr

    def generate(self, n_nodes: 'gum::Size'=10, n_arcs: 'gum::Size'=15, n_modmax: 'gum::Size'=4) -> "gum::BayesNet< double >":
        """
        generate(self, n_nodes=10, n_arcs=15, n_modmax=4) -> BayesNet_double
        generate(self, n_nodes=10, n_arcs=15) -> BayesNet_double
        generate(self, n_nodes=10) -> BayesNet_double
        generate(self) -> BayesNet_double
        """
        return _pyAgrum.BNGenerator_generate(self, n_nodes, n_arcs, n_modmax)


    def __init__(self):
        """__init__(self) -> BNGenerator"""
        this = _pyAgrum.new_BNGenerator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_BNGenerator
    __del__ = lambda self: None
BNGenerator_swigregister = _pyAgrum.BNGenerator_swigregister
BNGenerator_swigregister(BNGenerator)

class IDGenerator(_object):
    """Proxy of C++ IDGenerator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IDGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IDGenerator, name)
    __repr__ = _swig_repr

    def generate(self, nbrNodes: 'gum::Size'=10, arcDensity: 'double'=0.2, chanceNodeDensity: 'double'=0.8, utilityNodeDensity: 'double'=0.1, max_modality: 'int'=2) -> "gum::InfluenceDiagram< double >":
        """
        generate(self, nbrNodes=10, arcDensity=0.2, chanceNodeDensity=0.8, utilityNodeDensity=0.1, max_modality=2) -> InfluenceDiagram_double
        generate(self, nbrNodes=10, arcDensity=0.2, chanceNodeDensity=0.8, utilityNodeDensity=0.1) -> InfluenceDiagram_double
        generate(self, nbrNodes=10, arcDensity=0.2, chanceNodeDensity=0.8) -> InfluenceDiagram_double
        generate(self, nbrNodes=10, arcDensity=0.2) -> InfluenceDiagram_double
        generate(self, nbrNodes=10) -> InfluenceDiagram_double
        generate(self) -> InfluenceDiagram_double
        """
        return _pyAgrum.IDGenerator_generate(self, nbrNodes, arcDensity, chanceNodeDensity, utilityNodeDensity, max_modality)


    def __init__(self):
        """__init__(self) -> IDGenerator"""
        this = _pyAgrum.new_IDGenerator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_IDGenerator
    __del__ = lambda self: None
IDGenerator_swigregister = _pyAgrum.IDGenerator_swigregister
IDGenerator_swigregister(IDGenerator)

class PRMexplorer(_object):
    """Proxy of C++ PRMexplorer class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PRMexplorer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PRMexplorer, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(self) -> PRMexplorer"""
        this = _pyAgrum.new_PRMexplorer()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_PRMexplorer
    __del__ = lambda self: None

    def load(self, *args) -> "void":
        """
        load(self, filename, classpath, verbose=False)
        load(self, filename, classpath)
        load(self, filename)
        """
        return _pyAgrum.PRMexplorer_load(self, *args)


    def isType(self, name: 'std::string') -> "PyObject *":
        """isType(self, name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_isType(self, name)


    def isClass(self, name: 'std::string') -> "PyObject *":
        """isClass(self, name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_isClass(self, name)


    def isInterface(self, name: 'std::string') -> "PyObject *":
        """isInterface(self, name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_isInterface(self, name)


    def classes(self) -> "PyObject *":
        """classes(self) -> PyObject *"""
        return _pyAgrum.PRMexplorer_classes(self)


    def classAttributes(self, class_name: 'std::string') -> "PyObject *":
        """classAttributes(self, class_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_classAttributes(self, class_name)


    def isAttribute(self, class_name: 'std::string', att_name: 'std::string') -> "PyObject *":
        """isAttribute(self, class_name, att_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_isAttribute(self, class_name, att_name)


    def classReferences(self, class_name: 'std::string') -> "PyObject *":
        """classReferences(self, class_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_classReferences(self, class_name)


    def classParameters(self, class_name: 'std::string') -> "PyObject *":
        """classParameters(self, class_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_classParameters(self, class_name)


    def classImplements(self, class_name: 'std::string') -> "PyObject *":
        """classImplements(self, class_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_classImplements(self, class_name)

    __swig_setmethods__["aggType"] = _pyAgrum.PRMexplorer_aggType_set
    __swig_getmethods__["aggType"] = _pyAgrum.PRMexplorer_aggType_get
    if _newclass:
        aggType = _swig_property(_pyAgrum.PRMexplorer_aggType_get, _pyAgrum.PRMexplorer_aggType_set)

    def classAggregates(self, class_name: 'std::string') -> "PyObject *":
        """classAggregates(self, class_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_classAggregates(self, class_name)


    def classSlotChains(self, class_name: 'std::string') -> "PyObject *":
        """classSlotChains(self, class_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_classSlotChains(self, class_name)


    def classDag(self, class_name: 'std::string') -> "PyObject *":
        """classDag(self, class_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_classDag(self, class_name)


    def getalltheSystems(self) -> "PyObject *":
        """getalltheSystems(self) -> PyObject *"""
        return _pyAgrum.PRMexplorer_getalltheSystems(self)


    def getSuperClass(self, class_name: 'std::string') -> "PyObject *":
        """getSuperClass(self, class_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_getSuperClass(self, class_name)


    def getDirectSubClass(self, class_name: 'std::string') -> "PyObject *":
        """getDirectSubClass(self, class_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_getDirectSubClass(self, class_name)


    def cpf(self, class_name: 'std::string', attribute: 'std::string') -> "gum::Potential< double > const &":
        """cpf(self, class_name, attribute) -> Potential_double"""
        return _pyAgrum.PRMexplorer_cpf(self, class_name, attribute)


    def types(self) -> "PyObject *":
        """types(self) -> PyObject *"""
        return _pyAgrum.PRMexplorer_types(self)


    def getSuperType(self, type_name: 'std::string') -> "PyObject *":
        """getSuperType(self, type_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_getSuperType(self, type_name)


    def getDirectSubTypes(self, type_name: 'std::string') -> "PyObject *":
        """getDirectSubTypes(self, type_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_getDirectSubTypes(self, type_name)


    def getLabels(self, type_name: 'std::string') -> "PyObject *":
        """getLabels(self, type_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_getLabels(self, type_name)


    def getLabelMap(self, type_name: 'std::string') -> "PyObject *":
        """getLabelMap(self, type_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_getLabelMap(self, type_name)


    def interfaces(self) -> "PyObject *":
        """interfaces(self) -> PyObject *"""
        return _pyAgrum.PRMexplorer_interfaces(self)


    def interAttributes(self, interface_name: 'std::string', allAttributes: 'bool'=False) -> "PyObject *":
        """
        interAttributes(self, interface_name, allAttributes=False) -> PyObject
        interAttributes(self, interface_name) -> PyObject *
        """
        return _pyAgrum.PRMexplorer_interAttributes(self, interface_name, allAttributes)


    def interReferences(self, interface_name: 'std::string') -> "PyObject *":
        """interReferences(self, interface_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_interReferences(self, interface_name)


    def getSuperInterface(self, interface_name: 'std::string') -> "PyObject *":
        """getSuperInterface(self, interface_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_getSuperInterface(self, interface_name)


    def getDirectSubInterfaces(self, interface_name: 'std::string') -> "PyObject *":
        """getDirectSubInterfaces(self, interface_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_getDirectSubInterfaces(self, interface_name)


    def getImplementations(self, interface_name: 'std::string') -> "PyObject *":
        """getImplementations(self, interface_name) -> PyObject *"""
        return _pyAgrum.PRMexplorer_getImplementations(self, interface_name)

PRMexplorer_swigregister = _pyAgrum.PRMexplorer_swigregister
PRMexplorer_swigregister(PRMexplorer)

class Vector_double(_object):
    """Proxy of C++ std::vector<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector_double, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(self) -> SwigPyIterator"""
        return _pyAgrum.Vector_double_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(self) -> bool"""
        return _pyAgrum.Vector_double___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(self) -> bool"""
        return _pyAgrum.Vector_double___bool__(self)


    def __len__(self) -> "std::vector< double >::size_type":
        """__len__(self) -> std::vector< double >::size_type"""
        return _pyAgrum.Vector_double___len__(self)


    def __getslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "std::vector< double,std::allocator< double > > *":
        """__getslice__(self, i, j) -> Vector_double"""
        return _pyAgrum.Vector_double___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _pyAgrum.Vector_double___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "void":
        """__delslice__(self, i, j)"""
        return _pyAgrum.Vector_double___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _pyAgrum.Vector_double___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        """
        __getitem__(self, slice) -> Vector_double
        __getitem__(self, i) -> std::vector< double >::value_type const &
        """
        return _pyAgrum.Vector_double___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _pyAgrum.Vector_double___setitem__(self, *args)


    def pop(self) -> "std::vector< double >::value_type":
        """pop(self) -> std::vector< double >::value_type"""
        return _pyAgrum.Vector_double_pop(self)


    def append(self, x: 'std::vector< double >::value_type const &') -> "void":
        """append(self, x)"""
        return _pyAgrum.Vector_double_append(self, x)


    def empty(self) -> "bool":
        """empty(self) -> bool"""
        return _pyAgrum.Vector_double_empty(self)


    def size(self) -> "std::vector< double >::size_type":
        """size(self) -> std::vector< double >::size_type"""
        return _pyAgrum.Vector_double_size(self)


    def swap(self, v: 'Vector_double') -> "void":
        """swap(self, v)"""
        return _pyAgrum.Vector_double_swap(self, v)


    def begin(self) -> "std::vector< double >::iterator":
        """begin(self) -> std::vector< double >::iterator"""
        return _pyAgrum.Vector_double_begin(self)


    def end(self) -> "std::vector< double >::iterator":
        """end(self) -> std::vector< double >::iterator"""
        return _pyAgrum.Vector_double_end(self)


    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        """rbegin(self) -> std::vector< double >::reverse_iterator"""
        return _pyAgrum.Vector_double_rbegin(self)


    def rend(self) -> "std::vector< double >::reverse_iterator":
        """rend(self) -> std::vector< double >::reverse_iterator"""
        return _pyAgrum.Vector_double_rend(self)


    def clear(self) -> "void":
        """clear(self)"""
        return _pyAgrum.Vector_double_clear(self)


    def get_allocator(self) -> "std::vector< double >::allocator_type":
        """get_allocator(self) -> std::vector< double >::allocator_type"""
        return _pyAgrum.Vector_double_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(self)"""
        return _pyAgrum.Vector_double_pop_back(self)


    def erase(self, *args) -> "std::vector< double >::iterator":
        """
        erase(self, pos) -> std::vector< double >::iterator
        erase(self, first, last) -> std::vector< double >::iterator
        """
        return _pyAgrum.Vector_double_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(self) -> Vector_double
        __init__(self, arg2) -> Vector_double
        __init__(self, size) -> Vector_double
        __init__(self, size, value) -> Vector_double
        """
        this = _pyAgrum.new_Vector_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< double >::value_type const &') -> "void":
        """push_back(self, x)"""
        return _pyAgrum.Vector_double_push_back(self, x)


    def front(self) -> "std::vector< double >::value_type const &":
        """front(self) -> std::vector< double >::value_type const &"""
        return _pyAgrum.Vector_double_front(self)


    def back(self) -> "std::vector< double >::value_type const &":
        """back(self) -> std::vector< double >::value_type const &"""
        return _pyAgrum.Vector_double_back(self)


    def assign(self, n: 'std::vector< double >::size_type', x: 'std::vector< double >::value_type const &') -> "void":
        """assign(self, n, x)"""
        return _pyAgrum.Vector_double_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _pyAgrum.Vector_double_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(self, pos, x) -> std::vector< double >::iterator
        insert(self, pos, n, x)
        """
        return _pyAgrum.Vector_double_insert(self, *args)


    def reserve(self, n: 'std::vector< double >::size_type') -> "void":
        """reserve(self, n)"""
        return _pyAgrum.Vector_double_reserve(self, n)


    def capacity(self) -> "std::vector< double >::size_type":
        """capacity(self) -> std::vector< double >::size_type"""
        return _pyAgrum.Vector_double_capacity(self)

    __swig_destroy__ = _pyAgrum.delete_Vector_double
    __del__ = lambda self: None
Vector_double_swigregister = _pyAgrum.Vector_double_swigregister
Vector_double_swigregister(Vector_double)

class Vector_int(_object):
    """Proxy of C++ std::vector<(unsigned int)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector_int, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector_int, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(self) -> SwigPyIterator"""
        return _pyAgrum.Vector_int_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(self) -> bool"""
        return _pyAgrum.Vector_int___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(self) -> bool"""
        return _pyAgrum.Vector_int___bool__(self)


    def __len__(self) -> "std::vector< unsigned int >::size_type":
        """__len__(self) -> std::vector< unsigned int >::size_type"""
        return _pyAgrum.Vector_int___len__(self)


    def __getslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        """__getslice__(self, i, j) -> Vector_int"""
        return _pyAgrum.Vector_int___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _pyAgrum.Vector_int___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "void":
        """__delslice__(self, i, j)"""
        return _pyAgrum.Vector_int___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _pyAgrum.Vector_int___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        """
        __getitem__(self, slice) -> Vector_int
        __getitem__(self, i) -> std::vector< unsigned int >::value_type const &
        """
        return _pyAgrum.Vector_int___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _pyAgrum.Vector_int___setitem__(self, *args)


    def pop(self) -> "std::vector< unsigned int >::value_type":
        """pop(self) -> std::vector< unsigned int >::value_type"""
        return _pyAgrum.Vector_int_pop(self)


    def append(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        """append(self, x)"""
        return _pyAgrum.Vector_int_append(self, x)


    def empty(self) -> "bool":
        """empty(self) -> bool"""
        return _pyAgrum.Vector_int_empty(self)


    def size(self) -> "std::vector< unsigned int >::size_type":
        """size(self) -> std::vector< unsigned int >::size_type"""
        return _pyAgrum.Vector_int_size(self)


    def swap(self, v: 'Vector_int') -> "void":
        """swap(self, v)"""
        return _pyAgrum.Vector_int_swap(self, v)


    def begin(self) -> "std::vector< unsigned int >::iterator":
        """begin(self) -> std::vector< unsigned int >::iterator"""
        return _pyAgrum.Vector_int_begin(self)


    def end(self) -> "std::vector< unsigned int >::iterator":
        """end(self) -> std::vector< unsigned int >::iterator"""
        return _pyAgrum.Vector_int_end(self)


    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        """rbegin(self) -> std::vector< unsigned int >::reverse_iterator"""
        return _pyAgrum.Vector_int_rbegin(self)


    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        """rend(self) -> std::vector< unsigned int >::reverse_iterator"""
        return _pyAgrum.Vector_int_rend(self)


    def clear(self) -> "void":
        """clear(self)"""
        return _pyAgrum.Vector_int_clear(self)


    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        """get_allocator(self) -> std::vector< unsigned int >::allocator_type"""
        return _pyAgrum.Vector_int_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(self)"""
        return _pyAgrum.Vector_int_pop_back(self)


    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        """
        erase(self, pos) -> std::vector< unsigned int >::iterator
        erase(self, first, last) -> std::vector< unsigned int >::iterator
        """
        return _pyAgrum.Vector_int_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(self) -> Vector_int
        __init__(self, arg2) -> Vector_int
        __init__(self, size) -> Vector_int
        __init__(self, size, value) -> Vector_int
        """
        this = _pyAgrum.new_Vector_int(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        """push_back(self, x)"""
        return _pyAgrum.Vector_int_push_back(self, x)


    def front(self) -> "std::vector< unsigned int >::value_type const &":
        """front(self) -> std::vector< unsigned int >::value_type const &"""
        return _pyAgrum.Vector_int_front(self)


    def back(self) -> "std::vector< unsigned int >::value_type const &":
        """back(self) -> std::vector< unsigned int >::value_type const &"""
        return _pyAgrum.Vector_int_back(self)


    def assign(self, n: 'std::vector< unsigned int >::size_type', x: 'std::vector< unsigned int >::value_type const &') -> "void":
        """assign(self, n, x)"""
        return _pyAgrum.Vector_int_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _pyAgrum.Vector_int_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(self, pos, x) -> std::vector< unsigned int >::iterator
        insert(self, pos, n, x)
        """
        return _pyAgrum.Vector_int_insert(self, *args)


    def reserve(self, n: 'std::vector< unsigned int >::size_type') -> "void":
        """reserve(self, n)"""
        return _pyAgrum.Vector_int_reserve(self, n)


    def capacity(self) -> "std::vector< unsigned int >::size_type":
        """capacity(self) -> std::vector< unsigned int >::size_type"""
        return _pyAgrum.Vector_int_capacity(self)

    __swig_destroy__ = _pyAgrum.delete_Vector_int
    __del__ = lambda self: None
Vector_int_swigregister = _pyAgrum.Vector_int_swigregister
Vector_int_swigregister(Vector_int)

class Vector_string(_object):
    """Proxy of C++ std::vector<(std::string)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector_string, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector_string, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(self) -> SwigPyIterator"""
        return _pyAgrum.Vector_string_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(self) -> bool"""
        return _pyAgrum.Vector_string___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(self) -> bool"""
        return _pyAgrum.Vector_string___bool__(self)


    def __len__(self) -> "std::vector< std::string >::size_type":
        """__len__(self) -> std::vector< std::string >::size_type"""
        return _pyAgrum.Vector_string___len__(self)


    def __getslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "std::vector< std::string,std::allocator< std::string > > *":
        """__getslice__(self, i, j) -> Vector_string"""
        return _pyAgrum.Vector_string___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _pyAgrum.Vector_string___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "void":
        """__delslice__(self, i, j)"""
        return _pyAgrum.Vector_string___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _pyAgrum.Vector_string___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        """
        __getitem__(self, slice) -> Vector_string
        __getitem__(self, i) -> std::vector< std::string >::value_type const &
        """
        return _pyAgrum.Vector_string___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _pyAgrum.Vector_string___setitem__(self, *args)


    def pop(self) -> "std::vector< std::string >::value_type":
        """pop(self) -> std::vector< std::string >::value_type"""
        return _pyAgrum.Vector_string_pop(self)


    def append(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        """append(self, x)"""
        return _pyAgrum.Vector_string_append(self, x)


    def empty(self) -> "bool":
        """empty(self) -> bool"""
        return _pyAgrum.Vector_string_empty(self)


    def size(self) -> "std::vector< std::string >::size_type":
        """size(self) -> std::vector< std::string >::size_type"""
        return _pyAgrum.Vector_string_size(self)


    def swap(self, v: 'Vector_string') -> "void":
        """swap(self, v)"""
        return _pyAgrum.Vector_string_swap(self, v)


    def begin(self) -> "std::vector< std::string >::iterator":
        """begin(self) -> std::vector< std::string >::iterator"""
        return _pyAgrum.Vector_string_begin(self)


    def end(self) -> "std::vector< std::string >::iterator":
        """end(self) -> std::vector< std::string >::iterator"""
        return _pyAgrum.Vector_string_end(self)


    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        """rbegin(self) -> std::vector< std::string >::reverse_iterator"""
        return _pyAgrum.Vector_string_rbegin(self)


    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        """rend(self) -> std::vector< std::string >::reverse_iterator"""
        return _pyAgrum.Vector_string_rend(self)


    def clear(self) -> "void":
        """clear(self)"""
        return _pyAgrum.Vector_string_clear(self)


    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        """get_allocator(self) -> std::vector< std::string >::allocator_type"""
        return _pyAgrum.Vector_string_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(self)"""
        return _pyAgrum.Vector_string_pop_back(self)


    def erase(self, *args) -> "std::vector< std::string >::iterator":
        """
        erase(self, pos) -> std::vector< std::string >::iterator
        erase(self, first, last) -> std::vector< std::string >::iterator
        """
        return _pyAgrum.Vector_string_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(self) -> Vector_string
        __init__(self, arg2) -> Vector_string
        __init__(self, size) -> Vector_string
        __init__(self, size, value) -> Vector_string
        """
        this = _pyAgrum.new_Vector_string(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        """push_back(self, x)"""
        return _pyAgrum.Vector_string_push_back(self, x)


    def front(self) -> "std::vector< std::string >::value_type const &":
        """front(self) -> std::vector< std::string >::value_type const &"""
        return _pyAgrum.Vector_string_front(self)


    def back(self) -> "std::vector< std::string >::value_type const &":
        """back(self) -> std::vector< std::string >::value_type const &"""
        return _pyAgrum.Vector_string_back(self)


    def assign(self, n: 'std::vector< std::string >::size_type', x: 'std::vector< std::string >::value_type const &') -> "void":
        """assign(self, n, x)"""
        return _pyAgrum.Vector_string_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _pyAgrum.Vector_string_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(self, pos, x) -> std::vector< std::string >::iterator
        insert(self, pos, n, x)
        """
        return _pyAgrum.Vector_string_insert(self, *args)


    def reserve(self, n: 'std::vector< std::string >::size_type') -> "void":
        """reserve(self, n)"""
        return _pyAgrum.Vector_string_reserve(self, n)


    def capacity(self) -> "std::vector< std::string >::size_type":
        """capacity(self) -> std::vector< std::string >::size_type"""
        return _pyAgrum.Vector_string_capacity(self)

    __swig_destroy__ = _pyAgrum.delete_Vector_string
    __del__ = lambda self: None
Vector_string_swigregister = _pyAgrum.Vector_string_swigregister
Vector_string_swigregister(Vector_string)

class SetIteratorStaticEnd(_object):
    """Proxy of C++ gum::SetIteratorStaticEnd class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SetIteratorStaticEnd, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SetIteratorStaticEnd, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(self) -> SetIteratorStaticEnd"""
        this = _pyAgrum.new_SetIteratorStaticEnd()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_SetIteratorStaticEnd
    __del__ = lambda self: None
SetIteratorStaticEnd_swigregister = _pyAgrum.SetIteratorStaticEnd_swigregister
SetIteratorStaticEnd_swigregister(SetIteratorStaticEnd)

class GumException(Exception):
    """Proxy of C++ gum::Exception class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GumException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GumException, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> GumException
        __init__(self, aMsg) -> GumException
        __init__(self) -> GumException
        __init__(self, e) -> GumException
        """
        this = _pyAgrum.new_GumException(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_GumException
    __del__ = lambda self: None

    def __str__(self) -> "std::string const":
        """__str__(self) -> std::string const"""
        return _pyAgrum.GumException___str__(self)


    def errorContent(self) -> "std::string const":
        """errorContent(self) -> std::string const"""
        return _pyAgrum.GumException_errorContent(self)


    def errorType(self) -> "std::string const":
        """errorType(self) -> std::string const"""
        return _pyAgrum.GumException_errorType(self)


    def errorCallStack(self) -> "std::string const":
        """errorCallStack(self) -> std::string const"""
        return _pyAgrum.GumException_errorCallStack(self)

GumException_swigregister = _pyAgrum.GumException_swigregister
GumException_swigregister(GumException)


def __createMsg(filename: 'std::string const &', function: 'std::string const &', line: 'int const', msg: 'std::string const &') -> "std::string const":
    """__createMsg(filename, function, line, msg) -> std::string const"""
    return _pyAgrum.__createMsg(filename, function, line, msg)
class IdError(GumException):
    """Proxy of C++ gum::IdError class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IdError, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IdError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> IdError
        __init__(self, aMsg) -> IdError
        """
        this = _pyAgrum.new_IdError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_IdError
    __del__ = lambda self: None
IdError_swigregister = _pyAgrum.IdError_swigregister
IdError_swigregister(IdError)

class FatalError(GumException):
    """Proxy of C++ gum::FatalError class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FatalError, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FatalError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> FatalError
        __init__(self, aMsg) -> FatalError
        """
        this = _pyAgrum.new_FatalError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_FatalError
    __del__ = lambda self: None
FatalError_swigregister = _pyAgrum.FatalError_swigregister
FatalError_swigregister(FatalError)

class UndefinedIteratorValue(GumException):
    """Proxy of C++ gum::UndefinedIteratorValue class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UndefinedIteratorValue, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UndefinedIteratorValue, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> UndefinedIteratorValue
        __init__(self, aMsg) -> UndefinedIteratorValue
        """
        this = _pyAgrum.new_UndefinedIteratorValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_UndefinedIteratorValue
    __del__ = lambda self: None
UndefinedIteratorValue_swigregister = _pyAgrum.UndefinedIteratorValue_swigregister
UndefinedIteratorValue_swigregister(UndefinedIteratorValue)

class UndefinedIteratorKey(GumException):
    """Proxy of C++ gum::UndefinedIteratorKey class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UndefinedIteratorKey, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UndefinedIteratorKey, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> UndefinedIteratorKey
        __init__(self, aMsg) -> UndefinedIteratorKey
        """
        this = _pyAgrum.new_UndefinedIteratorKey(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_UndefinedIteratorKey
    __del__ = lambda self: None
UndefinedIteratorKey_swigregister = _pyAgrum.UndefinedIteratorKey_swigregister
UndefinedIteratorKey_swigregister(UndefinedIteratorKey)

class NullElement(GumException):
    """Proxy of C++ gum::NullElement class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NullElement, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NullElement, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> NullElement
        __init__(self, aMsg) -> NullElement
        """
        this = _pyAgrum.new_NullElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_NullElement
    __del__ = lambda self: None
NullElement_swigregister = _pyAgrum.NullElement_swigregister
NullElement_swigregister(NullElement)

class UndefinedElement(GumException):
    """Proxy of C++ gum::UndefinedElement class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UndefinedElement, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UndefinedElement, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> UndefinedElement
        __init__(self, aMsg) -> UndefinedElement
        """
        this = _pyAgrum.new_UndefinedElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_UndefinedElement
    __del__ = lambda self: None
UndefinedElement_swigregister = _pyAgrum.UndefinedElement_swigregister
UndefinedElement_swigregister(UndefinedElement)

class SizeError(GumException):
    """Proxy of C++ gum::SizeError class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SizeError, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SizeError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> SizeError
        __init__(self, aMsg) -> SizeError
        """
        this = _pyAgrum.new_SizeError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_SizeError
    __del__ = lambda self: None
SizeError_swigregister = _pyAgrum.SizeError_swigregister
SizeError_swigregister(SizeError)

class EmptySet(GumException):
    """Proxy of C++ gum::EmptySet class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EmptySet, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EmptySet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> EmptySet
        __init__(self, aMsg) -> EmptySet
        """
        this = _pyAgrum.new_EmptySet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_EmptySet
    __del__ = lambda self: None
EmptySet_swigregister = _pyAgrum.EmptySet_swigregister
EmptySet_swigregister(EmptySet)

class InvalidArgumentsNumber(GumException):
    """Proxy of C++ gum::InvalidArgumentsNumber class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidArgumentsNumber, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidArgumentsNumber, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> InvalidArgumentsNumber
        __init__(self, aMsg) -> InvalidArgumentsNumber
        """
        this = _pyAgrum.new_InvalidArgumentsNumber(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidArgumentsNumber
    __del__ = lambda self: None
InvalidArgumentsNumber_swigregister = _pyAgrum.InvalidArgumentsNumber_swigregister
InvalidArgumentsNumber_swigregister(InvalidArgumentsNumber)

class InvalidArgument(GumException):
    """Proxy of C++ gum::InvalidArgument class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidArgument, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidArgument, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> InvalidArgument
        __init__(self, aMsg) -> InvalidArgument
        """
        this = _pyAgrum.new_InvalidArgument(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidArgument
    __del__ = lambda self: None
InvalidArgument_swigregister = _pyAgrum.InvalidArgument_swigregister
InvalidArgument_swigregister(InvalidArgument)

class IOError(GumException):
    """Proxy of C++ gum::IOError class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IOError, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IOError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> IOError
        __init__(self, aMsg) -> IOError
        """
        this = _pyAgrum.new_IOError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_IOError
    __del__ = lambda self: None
IOError_swigregister = _pyAgrum.IOError_swigregister
IOError_swigregister(IOError)

class FormatNotFound(IOError):
    """Proxy of C++ gum::FormatNotFound class."""

    __swig_setmethods__ = {}
    for _s in [IOError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormatNotFound, name, value)
    __swig_getmethods__ = {}
    for _s in [IOError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormatNotFound, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> FormatNotFound
        __init__(self, aMsg) -> FormatNotFound
        """
        this = _pyAgrum.new_FormatNotFound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_FormatNotFound
    __del__ = lambda self: None
FormatNotFound_swigregister = _pyAgrum.FormatNotFound_swigregister
FormatNotFound_swigregister(FormatNotFound)

class OperationNotAllowed(GumException):
    """Proxy of C++ gum::OperationNotAllowed class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OperationNotAllowed, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OperationNotAllowed, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> OperationNotAllowed
        __init__(self, aMsg) -> OperationNotAllowed
        """
        this = _pyAgrum.new_OperationNotAllowed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_OperationNotAllowed
    __del__ = lambda self: None
OperationNotAllowed_swigregister = _pyAgrum.OperationNotAllowed_swigregister
OperationNotAllowed_swigregister(OperationNotAllowed)

class NotFound(GumException):
    """Proxy of C++ gum::NotFound class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotFound, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotFound, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> NotFound
        __init__(self, aMsg) -> NotFound
        """
        this = _pyAgrum.new_NotFound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_NotFound
    __del__ = lambda self: None
NotFound_swigregister = _pyAgrum.NotFound_swigregister
NotFound_swigregister(NotFound)

class ReferenceError(GumException):
    """Proxy of C++ gum::ReferenceError class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ReferenceError, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ReferenceError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> ReferenceError
        __init__(self, aMsg) -> ReferenceError
        """
        this = _pyAgrum.new_ReferenceError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_ReferenceError
    __del__ = lambda self: None
ReferenceError_swigregister = _pyAgrum.ReferenceError_swigregister
ReferenceError_swigregister(ReferenceError)

class OutOfBounds(ReferenceError):
    """Proxy of C++ gum::OutOfBounds class."""

    __swig_setmethods__ = {}
    for _s in [ReferenceError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfBounds, name, value)
    __swig_getmethods__ = {}
    for _s in [ReferenceError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfBounds, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> OutOfBounds
        __init__(self, aMsg) -> OutOfBounds
        """
        this = _pyAgrum.new_OutOfBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_OutOfBounds
    __del__ = lambda self: None
OutOfBounds_swigregister = _pyAgrum.OutOfBounds_swigregister
OutOfBounds_swigregister(OutOfBounds)

class OutOfLowerBound(OutOfBounds):
    """Proxy of C++ gum::OutOfLowerBound class."""

    __swig_setmethods__ = {}
    for _s in [OutOfBounds]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfLowerBound, name, value)
    __swig_getmethods__ = {}
    for _s in [OutOfBounds]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfLowerBound, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> OutOfLowerBound
        __init__(self, aMsg) -> OutOfLowerBound
        """
        this = _pyAgrum.new_OutOfLowerBound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_OutOfLowerBound
    __del__ = lambda self: None
OutOfLowerBound_swigregister = _pyAgrum.OutOfLowerBound_swigregister
OutOfLowerBound_swigregister(OutOfLowerBound)

class OutOfUpperBound(OutOfBounds):
    """Proxy of C++ gum::OutOfUpperBound class."""

    __swig_setmethods__ = {}
    for _s in [OutOfBounds]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfUpperBound, name, value)
    __swig_getmethods__ = {}
    for _s in [OutOfBounds]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfUpperBound, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> OutOfUpperBound
        __init__(self, aMsg) -> OutOfUpperBound
        """
        this = _pyAgrum.new_OutOfUpperBound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_OutOfUpperBound
    __del__ = lambda self: None
OutOfUpperBound_swigregister = _pyAgrum.OutOfUpperBound_swigregister
OutOfUpperBound_swigregister(OutOfUpperBound)

class DuplicateElement(ReferenceError):
    """Proxy of C++ gum::DuplicateElement class."""

    __swig_setmethods__ = {}
    for _s in [ReferenceError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DuplicateElement, name, value)
    __swig_getmethods__ = {}
    for _s in [ReferenceError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DuplicateElement, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> DuplicateElement
        __init__(self, aMsg) -> DuplicateElement
        """
        this = _pyAgrum.new_DuplicateElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_DuplicateElement
    __del__ = lambda self: None
DuplicateElement_swigregister = _pyAgrum.DuplicateElement_swigregister
DuplicateElement_swigregister(DuplicateElement)

class DuplicateLabel(ReferenceError):
    """Proxy of C++ gum::DuplicateLabel class."""

    __swig_setmethods__ = {}
    for _s in [ReferenceError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DuplicateLabel, name, value)
    __swig_getmethods__ = {}
    for _s in [ReferenceError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DuplicateLabel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> DuplicateLabel
        __init__(self, aMsg) -> DuplicateLabel
        """
        this = _pyAgrum.new_DuplicateLabel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_DuplicateLabel
    __del__ = lambda self: None
DuplicateLabel_swigregister = _pyAgrum.DuplicateLabel_swigregister
DuplicateLabel_swigregister(DuplicateLabel)

class GraphError(GumException):
    """Proxy of C++ gum::GraphError class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GraphError, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GraphError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> GraphError
        __init__(self, aMsg) -> GraphError
        """
        this = _pyAgrum.new_GraphError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_GraphError
    __del__ = lambda self: None
GraphError_swigregister = _pyAgrum.GraphError_swigregister
GraphError_swigregister(GraphError)

class NoNeighbour(GraphError):
    """Proxy of C++ gum::NoNeighbour class."""

    __swig_setmethods__ = {}
    for _s in [GraphError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoNeighbour, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NoNeighbour, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> NoNeighbour
        __init__(self, aMsg) -> NoNeighbour
        """
        this = _pyAgrum.new_NoNeighbour(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_NoNeighbour
    __del__ = lambda self: None
NoNeighbour_swigregister = _pyAgrum.NoNeighbour_swigregister
NoNeighbour_swigregister(NoNeighbour)

class NoParent(GraphError):
    """Proxy of C++ gum::NoParent class."""

    __swig_setmethods__ = {}
    for _s in [GraphError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoParent, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NoParent, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> NoParent
        __init__(self, aMsg) -> NoParent
        """
        this = _pyAgrum.new_NoParent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_NoParent
    __del__ = lambda self: None
NoParent_swigregister = _pyAgrum.NoParent_swigregister
NoParent_swigregister(NoParent)

class NoChild(GraphError):
    """Proxy of C++ gum::NoChild class."""

    __swig_setmethods__ = {}
    for _s in [GraphError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoChild, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NoChild, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> NoChild
        __init__(self, aMsg) -> NoChild
        """
        this = _pyAgrum.new_NoChild(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_NoChild
    __del__ = lambda self: None
NoChild_swigregister = _pyAgrum.NoChild_swigregister
NoChild_swigregister(NoChild)

class InvalidEdge(GraphError):
    """Proxy of C++ gum::InvalidEdge class."""

    __swig_setmethods__ = {}
    for _s in [GraphError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidEdge, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidEdge, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> InvalidEdge
        __init__(self, aMsg) -> InvalidEdge
        """
        this = _pyAgrum.new_InvalidEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidEdge
    __del__ = lambda self: None
InvalidEdge_swigregister = _pyAgrum.InvalidEdge_swigregister
InvalidEdge_swigregister(InvalidEdge)

class InvalidArc(GraphError):
    """Proxy of C++ gum::InvalidArc class."""

    __swig_setmethods__ = {}
    for _s in [GraphError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidArc, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidArc, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> InvalidArc
        __init__(self, aMsg) -> InvalidArc
        """
        this = _pyAgrum.new_InvalidArc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidArc
    __del__ = lambda self: None
InvalidArc_swigregister = _pyAgrum.InvalidArc_swigregister
InvalidArc_swigregister(InvalidArc)

class InvalidNode(GraphError):
    """Proxy of C++ gum::InvalidNode class."""

    __swig_setmethods__ = {}
    for _s in [GraphError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidNode, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidNode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> InvalidNode
        __init__(self, aMsg) -> InvalidNode
        """
        this = _pyAgrum.new_InvalidNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidNode
    __del__ = lambda self: None
InvalidNode_swigregister = _pyAgrum.InvalidNode_swigregister
InvalidNode_swigregister(InvalidNode)

class EmptyBSTree(GraphError):
    """Proxy of C++ gum::EmptyBSTree class."""

    __swig_setmethods__ = {}
    for _s in [GraphError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EmptyBSTree, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EmptyBSTree, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> EmptyBSTree
        __init__(self, aMsg) -> EmptyBSTree
        """
        this = _pyAgrum.new_EmptyBSTree(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_EmptyBSTree
    __del__ = lambda self: None
EmptyBSTree_swigregister = _pyAgrum.EmptyBSTree_swigregister
EmptyBSTree_swigregister(EmptyBSTree)

class DefaultInLabel(GraphError):
    """Proxy of C++ gum::DefaultInLabel class."""

    __swig_setmethods__ = {}
    for _s in [GraphError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DefaultInLabel, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DefaultInLabel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> DefaultInLabel
        __init__(self, aMsg) -> DefaultInLabel
        """
        this = _pyAgrum.new_DefaultInLabel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_DefaultInLabel
    __del__ = lambda self: None
DefaultInLabel_swigregister = _pyAgrum.DefaultInLabel_swigregister
DefaultInLabel_swigregister(DefaultInLabel)

class InvalidDirectedCycle(GraphError):
    """Proxy of C++ gum::InvalidDirectedCycle class."""

    __swig_setmethods__ = {}
    for _s in [GraphError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidDirectedCycle, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidDirectedCycle, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> InvalidDirectedCycle
        __init__(self, aMsg) -> InvalidDirectedCycle
        """
        this = _pyAgrum.new_InvalidDirectedCycle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidDirectedCycle
    __del__ = lambda self: None
InvalidDirectedCycle_swigregister = _pyAgrum.InvalidDirectedCycle_swigregister
InvalidDirectedCycle_swigregister(InvalidDirectedCycle)

class CPTError(GumException):
    """Proxy of C++ gum::CPTError class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPTError, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CPTError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> CPTError
        __init__(self, aMsg) -> CPTError
        """
        this = _pyAgrum.new_CPTError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_CPTError
    __del__ = lambda self: None
CPTError_swigregister = _pyAgrum.CPTError_swigregister
CPTError_swigregister(CPTError)

class CPTNoSumTo1(CPTError):
    """Proxy of C++ gum::CPTNoSumTo1 class."""

    __swig_setmethods__ = {}
    for _s in [CPTError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPTNoSumTo1, name, value)
    __swig_getmethods__ = {}
    for _s in [CPTError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CPTNoSumTo1, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> CPTNoSumTo1
        __init__(self, aMsg) -> CPTNoSumTo1
        """
        this = _pyAgrum.new_CPTNoSumTo1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_CPTNoSumTo1
    __del__ = lambda self: None
CPTNoSumTo1_swigregister = _pyAgrum.CPTNoSumTo1_swigregister
CPTNoSumTo1_swigregister(CPTNoSumTo1)

class IncompatibleEvidence(GumException):
    """Proxy of C++ gum::IncompatibleEvidence class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IncompatibleEvidence, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IncompatibleEvidence, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> IncompatibleEvidence
        __init__(self, aMsg) -> IncompatibleEvidence
        """
        this = _pyAgrum.new_IncompatibleEvidence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_IncompatibleEvidence
    __del__ = lambda self: None
IncompatibleEvidence_swigregister = _pyAgrum.IncompatibleEvidence_swigregister
IncompatibleEvidence_swigregister(IncompatibleEvidence)

class FactoryError(GumException):
    """Proxy of C++ gum::FactoryError class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FactoryError, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FactoryError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> FactoryError
        __init__(self, aMsg) -> FactoryError
        """
        this = _pyAgrum.new_FactoryError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_FactoryError
    __del__ = lambda self: None
FactoryError_swigregister = _pyAgrum.FactoryError_swigregister
FactoryError_swigregister(FactoryError)

class FactoryInvalidState(FactoryError):
    """Proxy of C++ gum::FactoryInvalidState class."""

    __swig_setmethods__ = {}
    for _s in [FactoryError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FactoryInvalidState, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FactoryInvalidState, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> FactoryInvalidState
        __init__(self, aMsg) -> FactoryInvalidState
        """
        this = _pyAgrum.new_FactoryInvalidState(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_FactoryInvalidState
    __del__ = lambda self: None
FactoryInvalidState_swigregister = _pyAgrum.FactoryInvalidState_swigregister
FactoryInvalidState_swigregister(FactoryInvalidState)

class WrongType(FactoryError):
    """Proxy of C++ gum::WrongType class."""

    __swig_setmethods__ = {}
    for _s in [FactoryError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WrongType, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WrongType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> WrongType
        __init__(self, aMsg) -> WrongType
        """
        this = _pyAgrum.new_WrongType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_WrongType
    __del__ = lambda self: None
WrongType_swigregister = _pyAgrum.WrongType_swigregister
WrongType_swigregister(WrongType)

class WrongClassElement(FactoryError):
    """Proxy of C++ gum::WrongClassElement class."""

    __swig_setmethods__ = {}
    for _s in [FactoryError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WrongClassElement, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WrongClassElement, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> WrongClassElement
        __init__(self, aMsg) -> WrongClassElement
        """
        this = _pyAgrum.new_WrongClassElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_WrongClassElement
    __del__ = lambda self: None
WrongClassElement_swigregister = _pyAgrum.WrongClassElement_swigregister
WrongClassElement_swigregister(WrongClassElement)

class TypeError(FactoryError):
    """Proxy of C++ gum::TypeError class."""

    __swig_setmethods__ = {}
    for _s in [FactoryError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypeError, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TypeError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> TypeError
        __init__(self, aMsg) -> TypeError
        """
        this = _pyAgrum.new_TypeError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_TypeError
    __del__ = lambda self: None
TypeError_swigregister = _pyAgrum.TypeError_swigregister
TypeError_swigregister(TypeError)

class LearningError(GumException):
    """Proxy of C++ gum::LearningError class."""

    __swig_setmethods__ = {}
    for _s in [GumException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LearningError, name, value)
    __swig_getmethods__ = {}
    for _s in [GumException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LearningError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> LearningError
        __init__(self, aMsg) -> LearningError
        """
        this = _pyAgrum.new_LearningError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_LearningError
    __del__ = lambda self: None
LearningError_swigregister = _pyAgrum.LearningError_swigregister
LearningError_swigregister(LearningError)

class IncompatibleScoreApriori(LearningError):
    """Proxy of C++ gum::IncompatibleScoreApriori class."""

    __swig_setmethods__ = {}
    for _s in [LearningError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IncompatibleScoreApriori, name, value)
    __swig_getmethods__ = {}
    for _s in [LearningError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IncompatibleScoreApriori, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> IncompatibleScoreApriori
        __init__(self, aMsg) -> IncompatibleScoreApriori
        """
        this = _pyAgrum.new_IncompatibleScoreApriori(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_IncompatibleScoreApriori
    __del__ = lambda self: None
IncompatibleScoreApriori_swigregister = _pyAgrum.IncompatibleScoreApriori_swigregister
IncompatibleScoreApriori_swigregister(IncompatibleScoreApriori)

class PossiblyIncompatibleScoreApriori(LearningError):
    """Proxy of C++ gum::PossiblyIncompatibleScoreApriori class."""

    __swig_setmethods__ = {}
    for _s in [LearningError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PossiblyIncompatibleScoreApriori, name, value)
    __swig_getmethods__ = {}
    for _s in [LearningError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PossiblyIncompatibleScoreApriori, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> PossiblyIncompatibleScoreApriori
        __init__(self, aMsg) -> PossiblyIncompatibleScoreApriori
        """
        this = _pyAgrum.new_PossiblyIncompatibleScoreApriori(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_PossiblyIncompatibleScoreApriori
    __del__ = lambda self: None
PossiblyIncompatibleScoreApriori_swigregister = _pyAgrum.PossiblyIncompatibleScoreApriori_swigregister
PossiblyIncompatibleScoreApriori_swigregister(PossiblyIncompatibleScoreApriori)

class DatabaseError(LearningError):
    """Proxy of C++ gum::DatabaseError class."""

    __swig_setmethods__ = {}
    for _s in [LearningError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DatabaseError, name, value)
    __swig_getmethods__ = {}
    for _s in [LearningError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DatabaseError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> DatabaseError
        __init__(self, aMsg) -> DatabaseError
        """
        this = _pyAgrum.new_DatabaseError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_DatabaseError
    __del__ = lambda self: None
DatabaseError_swigregister = _pyAgrum.DatabaseError_swigregister
DatabaseError_swigregister(DatabaseError)

class MissingVariableInDatabase(LearningError):
    """Proxy of C++ gum::MissingVariableInDatabase class."""

    __swig_setmethods__ = {}
    for _s in [LearningError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MissingVariableInDatabase, name, value)
    __swig_getmethods__ = {}
    for _s in [LearningError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MissingVariableInDatabase, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> MissingVariableInDatabase
        __init__(self, aMsg) -> MissingVariableInDatabase
        """
        this = _pyAgrum.new_MissingVariableInDatabase(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_MissingVariableInDatabase
    __del__ = lambda self: None
MissingVariableInDatabase_swigregister = _pyAgrum.MissingVariableInDatabase_swigregister
MissingVariableInDatabase_swigregister(MissingVariableInDatabase)

class UnknownLabelInDatabase(LearningError):
    """Proxy of C++ gum::UnknownLabelInDatabase class."""

    __swig_setmethods__ = {}
    for _s in [LearningError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnknownLabelInDatabase, name, value)
    __swig_getmethods__ = {}
    for _s in [LearningError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UnknownLabelInDatabase, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, aType) -> UnknownLabelInDatabase
        __init__(self, aMsg) -> UnknownLabelInDatabase
        """
        this = _pyAgrum.new_UnknownLabelInDatabase(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_UnknownLabelInDatabase
    __del__ = lambda self: None
UnknownLabelInDatabase_swigregister = _pyAgrum.UnknownLabelInDatabase_swigregister
UnknownLabelInDatabase_swigregister(UnknownLabelInDatabase)

class SyntaxError(IOError):
    """Proxy of C++ gum::SyntaxError class."""

    __swig_setmethods__ = {}
    for _s in [IOError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SyntaxError, name, value)
    __swig_getmethods__ = {}
    for _s in [IOError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SyntaxError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aMsg, nol, noc, aType) -> SyntaxError
        __init__(self, aMsg, nol, noc) -> SyntaxError
        """
        this = _pyAgrum.new_SyntaxError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def col(self) -> "gum::Size":
        """col(self) -> gum::Size"""
        return _pyAgrum.SyntaxError_col(self)


    def line(self) -> "gum::Size":
        """line(self) -> gum::Size"""
        return _pyAgrum.SyntaxError_line(self)

    __swig_destroy__ = _pyAgrum.delete_SyntaxError
    __del__ = lambda self: None
SyntaxError_swigregister = _pyAgrum.SyntaxError_swigregister
SyntaxError_swigregister(SyntaxError)


def randomProba() -> "double":
    """randomProba() -> double"""
    return _pyAgrum.randomProba()

def randomGeneratorSeed() -> "unsigned int":
    """randomGeneratorSeed() -> unsigned int"""
    return _pyAgrum.randomGeneratorSeed()

def initRandom(seed: 'unsigned int'=0) -> "void":
    """
    initRandom(seed=0)
    initRandom()
    """
    return _pyAgrum.initRandom(seed)

def getRandomGenerator(seed: 'unsigned int'=0) -> "std::default_random_engine":
    """
    getRandomGenerator(seed=0) -> std::default_random_engine
    getRandomGenerator() -> std::default_random_engine
    """
    return _pyAgrum.getRandomGenerator(seed)

def isOMP() -> "bool":
    """isOMP() -> bool"""
    return _pyAgrum.isOMP()

def setNumberOfThreads(number: 'unsigned int') -> "void":
    """setNumberOfThreads(number)"""
    return _pyAgrum.setNumberOfThreads(number)

def getMaxNumberOfThreads() -> "unsigned int":
    """getMaxNumberOfThreads() -> unsigned int"""
    return _pyAgrum.getMaxNumberOfThreads()

def getThreadNumber() -> "unsigned int":
    """getThreadNumber() -> unsigned int"""
    return _pyAgrum.getThreadNumber()

def getNumberOfRunningThreads() -> "unsigned int":
    """getNumberOfRunningThreads() -> unsigned int"""
    return _pyAgrum.getNumberOfRunningThreads()

def getNumberOfLogicalProcessors() -> "unsigned int":
    """getNumberOfLogicalProcessors() -> unsigned int"""
    return _pyAgrum.getNumberOfLogicalProcessors()

def setNestedParallelism(value: 'bool') -> "void":
    """setNestedParallelism(value)"""
    return _pyAgrum.setNestedParallelism(value)

def getNestedParallelism() -> "bool":
    """getNestedParallelism() -> bool"""
    return _pyAgrum.getNestedParallelism()

def setDynamicThreadsNumber(value: 'bool') -> "void":
    """setDynamicThreadsNumber(value)"""
    return _pyAgrum.setDynamicThreadsNumber(value)

def getDynamicThreadsNumber() -> "bool":
    """getDynamicThreadsNumber() -> bool"""
    return _pyAgrum.getDynamicThreadsNumber()
class Variable(_object):
    """Proxy of C++ gum::Variable class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Variable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Variable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_Variable
    __del__ = lambda self: None

    def clone(self) -> "gum::Variable *":
        """clone(self) -> Variable"""
        return _pyAgrum.Variable_clone(self)


    def __eq__(self, aRV: 'Variable') -> "bool":
        """__eq__(self, aRV) -> bool"""
        return _pyAgrum.Variable___eq__(self, aRV)


    def __ne__(self, aRV: 'Variable') -> "bool":
        """__ne__(self, aRV) -> bool"""
        return _pyAgrum.Variable___ne__(self, aRV)


    def setName(self, theValue: 'std::string const &') -> "void":
        """setName(self, theValue)"""
        return _pyAgrum.Variable_setName(self, theValue)


    def name(self) -> "std::string const &":
        """name(self) -> std::string const &"""
        return _pyAgrum.Variable_name(self)


    def setDescription(self, theValue: 'std::string const &') -> "void":
        """setDescription(self, theValue)"""
        return _pyAgrum.Variable_setDescription(self, theValue)


    def description(self) -> "std::string const &":
        """description(self) -> std::string const &"""
        return _pyAgrum.Variable_description(self)

Variable_swigregister = _pyAgrum.Variable_swigregister
Variable_swigregister(Variable)

class DiscreteVariable(Variable):
    """Proxy of C++ gum::DiscreteVariable class."""

    __swig_setmethods__ = {}
    for _s in [Variable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiscreteVariable, name, value)
    __swig_getmethods__ = {}
    for _s in [Variable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DiscreteVariable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    VarType_Discretized = _pyAgrum.DiscreteVariable_VarType_Discretized
    VarType_Labelized = _pyAgrum.DiscreteVariable_VarType_Labelized
    VarType_Range = _pyAgrum.DiscreteVariable_VarType_Range
    __swig_destroy__ = _pyAgrum.delete_DiscreteVariable
    __del__ = lambda self: None

    def clone(self) -> "gum::DiscreteVariable *":
        """clone(self) -> DiscreteVariable"""
        return _pyAgrum.DiscreteVariable_clone(self)


    def empty(self) -> "bool":
        """empty(self) -> bool"""
        return _pyAgrum.DiscreteVariable_empty(self)


    def domainSize(self) -> "gum::Size":
        """domainSize(self) -> gum::Size"""
        return _pyAgrum.DiscreteVariable_domainSize(self)


    def labels(self) -> "std::vector< std::string,std::allocator< std::string > >":
        """labels(self) -> Vector_string"""
        return _pyAgrum.DiscreteVariable_labels(self)


    def numerical(self, indice: 'gum::Idx') -> "double":
        """numerical(self, indice) -> double"""
        return _pyAgrum.DiscreteVariable_numerical(self, indice)


    def varType(self) -> "gum::DiscreteVariable::VarType":
        """varType(self) -> gum::DiscreteVariable::VarType"""
        return _pyAgrum.DiscreteVariable_varType(self)


    def __eq__(self, aRV: 'DiscreteVariable') -> "bool":
        """__eq__(self, aRV) -> bool"""
        return _pyAgrum.DiscreteVariable___eq__(self, aRV)


    def __ne__(self, aRV: 'DiscreteVariable') -> "bool":
        """__ne__(self, aRV) -> bool"""
        return _pyAgrum.DiscreteVariable___ne__(self, aRV)


    def index(self, label: 'std::string const &') -> "gum::Idx":
        """index(self, label) -> gum::Idx"""
        return _pyAgrum.DiscreteVariable_index(self, label)


    def label(self, i: 'gum::Idx') -> "std::string":
        """label(self, i) -> std::string"""
        return _pyAgrum.DiscreteVariable_label(self, i)


    def __str__(self) -> "std::string const":
        """__str__(self) -> std::string const"""
        return _pyAgrum.DiscreteVariable___str__(self)


    def toStringWithDescription(self) -> "std::string const":
        """toStringWithDescription(self) -> std::string const"""
        return _pyAgrum.DiscreteVariable_toStringWithDescription(self)


    def domain(self) -> "std::string const":
        """domain(self) -> std::string const"""
        return _pyAgrum.DiscreteVariable_domain(self)


    def __getitem__(self,label):   # adding the y() function here
        return self.index(label)


    def toLabelizedVar(self) -> "gum::LabelizedVariable &":
        """toLabelizedVar(self) -> LabelizedVariable"""
        return _pyAgrum.DiscreteVariable_toLabelizedVar(self)


    def toRangeVar(self) -> "gum::RangeVariable &":
        """toRangeVar(self) -> RangeVariable"""
        return _pyAgrum.DiscreteVariable_toRangeVar(self)


    def toDiscretizedVar(self) -> "gum::DiscretizedVariable< double > &":
        """toDiscretizedVar(self) -> DiscretizedVariable_double"""
        return _pyAgrum.DiscreteVariable_toDiscretizedVar(self)

DiscreteVariable_swigregister = _pyAgrum.DiscreteVariable_swigregister
DiscreteVariable_swigregister(DiscreteVariable)

class LabelizedVariable(DiscreteVariable):
    """

    LabelizedVariable is a discrete random variable with a customizable sequence of labels.

    Available constructors:

        ``LabelizedVariable(aName, aDesc='', nbrLabel=2) -> LabelizedVariable``

        ``LabelizedVariable(aLDRV) -> LabelizedVariable``

    Parameters
    ----------
    aName: str
      The name of the variable
    aDesc: str
      The (optional) description of the variable
    nbrLabel: int
      The number of labels to create. By default , the value start from '0' to 'nbrLabel-1'
    aLDRV: pyAgrum.LabelizedVariable
      Another `LabelizedVariable` that will be copied

    Examples
    --------
    >>> import pyAgrum as gum
    >>> v=gum.LabelizedVariable('v')
    >>> print(v)
    v<0,1>
    >>> w=gum.LabelizedVariable('w','',4)
    >>> print(w)
    w<0,1,2,3>

    """

    __swig_setmethods__ = {}
    for _s in [DiscreteVariable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelizedVariable, name, value)
    __swig_getmethods__ = {}
    for _s in [DiscreteVariable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelizedVariable, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aName, aDesc, nbrLabel=2) -> LabelizedVariable
        __init__(self, aName, aDesc) -> LabelizedVariable
        __init__(self, aName) -> LabelizedVariable
        __init__(self, aLDRV) -> LabelizedVariable
        """
        this = _pyAgrum.new_LabelizedVariable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_LabelizedVariable
    __del__ = lambda self: None

    def clone(self) -> "gum::DiscreteVariable *":
        """clone(self) -> DiscreteVariable"""
        return _pyAgrum.LabelizedVariable_clone(self)


    def index(self, label: 'std::string const &') -> "gum::Idx":
        """index(self, label) -> gum::Idx"""
        return _pyAgrum.LabelizedVariable_index(self, label)


    def isLabel(self, aLabel: 'std::string const &') -> "bool":
        """isLabel(self, aLabel) -> bool"""
        return _pyAgrum.LabelizedVariable_isLabel(self, aLabel)


    def addLabel(self,*args):
      _pyAgrum.LabelizedVariable_addLabel(self,*args)
      return self



    def changeLabel(self, pos: 'gum::Idx', aLabel: 'std::string const') -> "void":
        """changeLabel(self, pos, aLabel)"""
        return _pyAgrum.LabelizedVariable_changeLabel(self, pos, aLabel)


    def eraseLabels(self) -> "void":
        """eraseLabels(self)"""
        return _pyAgrum.LabelizedVariable_eraseLabels(self)


    def label(self, i: 'gum::Idx') -> "std::string":
        """label(self, i) -> std::string"""
        return _pyAgrum.LabelizedVariable_label(self, i)


    def numerical(self, indice: 'gum::Idx') -> "double":
        """numerical(self, indice) -> double"""
        return _pyAgrum.LabelizedVariable_numerical(self, indice)


    def domainSize(self) -> "gum::Size":
        """domainSize(self) -> gum::Size"""
        return _pyAgrum.LabelizedVariable_domainSize(self)


    def varType(self) -> "gum::DiscreteVariable::VarType":
        """varType(self) -> gum::DiscreteVariable::VarType"""
        return _pyAgrum.LabelizedVariable_varType(self)


    def domain(self) -> "std::string const":
        """
        domain(self) -> std::string const


        Returns
        -------
        str
            the domain of the variable as a string

        """
        return _pyAgrum.LabelizedVariable_domain(self)

LabelizedVariable_swigregister = _pyAgrum.LabelizedVariable_swigregister
LabelizedVariable_swigregister(LabelizedVariable)

class RangeVariable(DiscreteVariable):
    """Proxy of C++ gum::RangeVariable class."""

    __swig_setmethods__ = {}
    for _s in [DiscreteVariable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RangeVariable, name, value)
    __swig_getmethods__ = {}
    for _s in [DiscreteVariable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RangeVariable, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aName, aDesc, minVal=0, maxVal=1) -> RangeVariable
        __init__(self, aName, aDesc, minVal=0) -> RangeVariable
        __init__(self, aName, aDesc) -> RangeVariable
        __init__(self, aDRV) -> RangeVariable
        """
        this = _pyAgrum.new_RangeVariable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_RangeVariable
    __del__ = lambda self: None

    def clone(self) -> "gum::DiscreteVariable *":
        """clone(self) -> DiscreteVariable"""
        return _pyAgrum.RangeVariable_clone(self)


    def domainSize(self) -> "gum::Size":
        """domainSize(self) -> gum::Size"""
        return _pyAgrum.RangeVariable_domainSize(self)


    def varType(self) -> "gum::DiscreteVariable::VarType":
        """varType(self) -> gum::DiscreteVariable::VarType"""
        return _pyAgrum.RangeVariable_varType(self)


    def label(self, indice: 'gum::Idx') -> "std::string":
        """label(self, indice) -> std::string"""
        return _pyAgrum.RangeVariable_label(self, indice)


    def numerical(self, indice: 'gum::Idx') -> "double":
        """numerical(self, indice) -> double"""
        return _pyAgrum.RangeVariable_numerical(self, indice)


    def minVal(self) -> "long":
        """minVal(self) -> long"""
        return _pyAgrum.RangeVariable_minVal(self)


    def setMinVal(self, minVal: 'long') -> "void":
        """setMinVal(self, minVal)"""
        return _pyAgrum.RangeVariable_setMinVal(self, minVal)


    def maxVal(self) -> "long":
        """maxVal(self) -> long"""
        return _pyAgrum.RangeVariable_maxVal(self)


    def setMaxVal(self, maxVal: 'long') -> "void":
        """setMaxVal(self, maxVal)"""
        return _pyAgrum.RangeVariable_setMaxVal(self, maxVal)


    def belongs(self, val: 'long') -> "bool":
        """belongs(self, val) -> bool"""
        return _pyAgrum.RangeVariable_belongs(self, val)


    def index(self, arg2: 'std::string const &') -> "gum::Idx":
        """index(self, arg2) -> gum::Idx"""
        return _pyAgrum.RangeVariable_index(self, arg2)


    def domain(self) -> "std::string const":
        """domain(self) -> std::string const"""
        return _pyAgrum.RangeVariable_domain(self)

RangeVariable_swigregister = _pyAgrum.RangeVariable_swigregister
RangeVariable_swigregister(RangeVariable)

INC_MARKS_ARRAY = _pyAgrum.INC_MARKS_ARRAY
class Edge(_object):
    """

    pyAgrum.Edge is the representation of an arc between two nodes represented by `int`s : the first and the second.

    Available constructors :
        ``Edge(aN1,aN2) -> Edge``

        ``Edge(src) -> Edge``

    Parameters
    ----------
    aN1 : int
      the nodeId of the first node
    aN2 : int
      the nodeId of the secondnode
    src: Edge
      the Edge to copy

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Edge, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Edge, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aN1, aN2) -> Edge
        __init__(self, src) -> Edge
        """
        this = _pyAgrum.new_Edge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_Edge
    __del__ = lambda self: None

    def other(self, id: 'gum::NodeId') -> "gum::NodeId":
        """
        other(self, id) -> gum::NodeId


        Parameters
        ----------
        id : int
          the nodeId of one of the nodes of the Edge


        Returns
        ------
        int
          the nodeId of the other node

        """
        return _pyAgrum.Edge_other(self, id)


    def first(self) -> "gum::NodeId":
        """
        first(self) -> gum::NodeId


        Returns
        ------
        int
          the nodeId of the first node of the arc (the tail)

        """
        return _pyAgrum.Edge_first(self)


    def second(self) -> "gum::NodeId":
        """
        second(self) -> gum::NodeId


        Returns
        ------
        int
          the nodeId of the second node of the arc (the head)

        """
        return _pyAgrum.Edge_second(self)


    def __eq__(self, src: 'Edge') -> "bool":
        """__eq__(self, src) -> bool"""
        return _pyAgrum.Edge___eq__(self, src)


    def __ne__(self, src: 'Edge') -> "bool":
        """__ne__(self, src) -> bool"""
        return _pyAgrum.Edge___ne__(self, src)

Edge_swigregister = _pyAgrum.Edge_swigregister
Edge_swigregister(Edge)

class Arc(_object):
    """

    pyAgrum.Arc is the representation of an arc between two nodes represented by `int`s : the head and the tail.

    Available constructors:
        ``Arc(tail, head) -> Arc``

        ``Arc(src) -> Arc``

    Parameters
    ----------
    tail : int
      the tail
    head : int
      the head
    src : :class: Arc
      the Arc to copy


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Arc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Arc, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, tail, head) -> Arc
        __init__(self, src) -> Arc
        """
        this = _pyAgrum.new_Arc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_Arc
    __del__ = lambda self: None

    def tail(self) -> "gum::NodeId":
        """
        tail(self) -> gum::NodeId


        Returns
        -------
        int
          the id of the tail node

        """
        return _pyAgrum.Arc_tail(self)


    def head(self) -> "gum::NodeId":
        """
        head(self) -> gum::NodeId


        Returns
        ------
        int
          the id of the head node

        """
        return _pyAgrum.Arc_head(self)


    def other(self, id: 'gum::NodeId') -> "gum::NodeId":
        """
        other(self, id) -> gum::NodeId


        Parameters
        ----------
        id : int
          the nodeId of the head or the tail


        Returns
        ------
        int
          the nodeId of the other node

        """
        return _pyAgrum.Arc_other(self, id)


    def first(self) -> "gum::NodeId":
        """
        first(self) -> gum::NodeId


        Returns
        ------
        int
          the nodeId of the first node of the arc (the tail)

        """
        return _pyAgrum.Arc_first(self)


    def second(self) -> "gum::NodeId":
        """
        second(self) -> gum::NodeId


        Returns
        ------
        int
          the nodeId of the second node of the arc (the head)

        """
        return _pyAgrum.Arc_second(self)


    def __eq__(self, src: 'Arc') -> "bool":
        """__eq__(self, src) -> bool"""
        return _pyAgrum.Arc___eq__(self, src)


    def __ne__(self, src: 'Arc') -> "bool":
        """__ne__(self, src) -> bool"""
        return _pyAgrum.Arc___ne__(self, src)

Arc_swigregister = _pyAgrum.Arc_swigregister
Arc_swigregister(Arc)

class DiGraph(_object):
    """

    DiGraph represents a Directed Graph.

    Available constructors:
        ``DiGraph() -> DiGraph``

        ``DiGraph(src) -> DiGraph``

    Parameters
    ----------
    src : :class: DiGraph
      the digraph to copy


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiGraph, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DiGraph, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, nodes_size, nodes_resize_policy=True, arcs_size, arcs_resize_policy=True) -> DiGraph
        __init__(self, nodes_size, nodes_resize_policy=True, arcs_size) -> DiGraph
        __init__(self, nodes_size, nodes_resize_policy=True) -> DiGraph
        __init__(self, nodes_size) -> DiGraph
        __init__(self) -> DiGraph
        __init__(self, g) -> DiGraph
        """
        this = _pyAgrum.new_DiGraph(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_DiGraph
    __del__ = lambda self: None

    def __eq__(self, g: 'DiGraph') -> "bool":
        """__eq__(self, g) -> bool"""
        return _pyAgrum.DiGraph___eq__(self, g)


    def __ne__(self, g: 'DiGraph') -> "bool":
        """__ne__(self, g) -> bool"""
        return _pyAgrum.DiGraph___ne__(self, g)


    def eraseNode(self, id: 'gum::NodeId const') -> "void":
        """eraseNode(self, id)"""
        return _pyAgrum.DiGraph_eraseNode(self, id)


    def clear(self) -> "void":
        """clear(self)"""
        return _pyAgrum.DiGraph_clear(self)


    def __str__(self) -> "std::string const":
        """__str__(self) -> std::string const"""
        return _pyAgrum.DiGraph___str__(self)


    def toDot(self) -> "std::string const":
        """toDot(self) -> std::string const"""
        return _pyAgrum.DiGraph_toDot(self)


    def topologicalOrder(self, clear: 'bool'=True) -> "gum::Sequence< gum::NodeId > const &":
        """
        topologicalOrder(self, clear=True) -> gum::Sequence< gum::NodeId > const
        topologicalOrder(self) -> gum::Sequence< gum::NodeId > const &
        """
        return _pyAgrum.DiGraph_topologicalOrder(self, clear)


    def ids(self) -> "PyObject *":
        """
        ids(self) -> PyObject *


        Returns
        -------
        List
            the list of ids

        """
        return _pyAgrum.DiGraph_ids(self)


    def arcs(self) -> "PyObject *":
        """arcs(self) -> PyObject *"""
        return _pyAgrum.DiGraph_arcs(self)


    def parents(self, id: 'gum::NodeId') -> "PyObject *":
        """parents(self, id) -> PyObject *"""
        return _pyAgrum.DiGraph_parents(self, id)


    def children(self, id: 'gum::NodeId') -> "PyObject *":
        """children(self, id) -> PyObject *"""
        return _pyAgrum.DiGraph_children(self, id)


    def addNode(self) -> "gum::NodeId":
        """
        addNode(self) -> gum::NodeId


        Add a node by choosing a new NodeId

        Returns
        -------
        int
          the new NodeId

        """
        return _pyAgrum.DiGraph_addNode(self)


    def addNodeWithId(self, id: 'gum::NodeId const') -> "void":
        """addNodeWithId(self, id)"""
        return _pyAgrum.DiGraph_addNodeWithId(self, id)


    def existsNode(self, id: 'gum::NodeId const') -> "bool":
        """
        existsNode(self, id) -> bool


        Check if a node with a certain id exists in the graph.

        Parameters
        ----------
        id : int
            the checked id

        Returns
        -------
        bool
            True if the node exists

        """
        return _pyAgrum.DiGraph_existsNode(self, id)


    def size(self) -> "gum::Size":
        """size(self) -> gum::Size"""
        return _pyAgrum.DiGraph_size(self)


    def empty(self) -> "bool":
        """empty(self) -> bool"""
        return _pyAgrum.DiGraph_empty(self)


    def addArc(self, *args) -> "void":
        """
        addArc(self, tail, head)
        addArc(self, n1, n2)
        """
        return _pyAgrum.DiGraph_addArc(self, *args)


    def eraseArc(self, n1: 'gum::NodeId const', n2: 'gum::NodeId const') -> "void":
        """eraseArc(self, n1, n2)"""
        return _pyAgrum.DiGraph_eraseArc(self, n1, n2)


    def existsArc(self, n1: 'gum::NodeId const', n2: 'gum::NodeId const') -> "bool":
        """existsArc(self, n1, n2) -> bool"""
        return _pyAgrum.DiGraph_existsArc(self, n1, n2)


    def eraseParents(self, n: 'gum::NodeId const') -> "void":
        """eraseParents(self, n)"""
        return _pyAgrum.DiGraph_eraseParents(self, n)


    def eraseChildren(self, n: 'gum::NodeId const') -> "void":
        """eraseChildren(self, n)"""
        return _pyAgrum.DiGraph_eraseChildren(self, n)


    def sizeArcs(self) -> "gum::Size":
        """sizeArcs(self) -> gum::Size"""
        return _pyAgrum.DiGraph_sizeArcs(self)


    def emptyArcs(self) -> "bool":
        """emptyArcs(self) -> bool"""
        return _pyAgrum.DiGraph_emptyArcs(self)

DiGraph_swigregister = _pyAgrum.DiGraph_swigregister
DiGraph_swigregister(DiGraph)

class DAG(DiGraph):
    """Proxy of C++ gum::DAG class."""

    __swig_setmethods__ = {}
    for _s in [DiGraph]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DAG, name, value)
    __swig_getmethods__ = {}
    for _s in [DiGraph]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DAG, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, nodes_size, nodes_resize_policy=True, arcs_size, arcs_resize_policy=True) -> DAG
        __init__(self, nodes_size, nodes_resize_policy=True, arcs_size) -> DAG
        __init__(self, nodes_size, nodes_resize_policy=True) -> DAG
        __init__(self, nodes_size) -> DAG
        __init__(self) -> DAG
        __init__(self, g) -> DAG
        """
        this = _pyAgrum.new_DAG(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_DAG
    __del__ = lambda self: None

    def addArc(self, *args) -> "void":
        """
        addArc(self, tail, head)
        addArc(self, n1, n2)
        """
        return _pyAgrum.DAG_addArc(self, *args)


    def eraseArc(self, n1: 'gum::NodeId const', n2: 'gum::NodeId const') -> "void":
        """eraseArc(self, n1, n2)"""
        return _pyAgrum.DAG_eraseArc(self, n1, n2)


    def existsArc(self, n1: 'gum::NodeId const', n2: 'gum::NodeId const') -> "bool":
        """existsArc(self, n1, n2) -> bool"""
        return _pyAgrum.DAG_existsArc(self, n1, n2)


    def eraseParents(self, n: 'gum::NodeId const') -> "void":
        """eraseParents(self, n)"""
        return _pyAgrum.DAG_eraseParents(self, n)


    def eraseChildren(self, n: 'gum::NodeId const') -> "void":
        """eraseChildren(self, n)"""
        return _pyAgrum.DAG_eraseChildren(self, n)


    def sizeArcs(self) -> "gum::Size":
        """sizeArcs(self) -> gum::Size"""
        return _pyAgrum.DAG_sizeArcs(self)


    def emptyArcs(self) -> "bool":
        """emptyArcs(self) -> bool"""
        return _pyAgrum.DAG_emptyArcs(self)

DAG_swigregister = _pyAgrum.DAG_swigregister
DAG_swigregister(DAG)

class UndiGraph(_object):
    """Proxy of C++ gum::UndiGraph class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UndiGraph, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UndiGraph, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, nodes_size, nodes_resize_policy=True, edges_size, edges_resize_policy=True) -> UndiGraph
        __init__(self, nodes_size, nodes_resize_policy=True, edges_size) -> UndiGraph
        __init__(self, nodes_size, nodes_resize_policy=True) -> UndiGraph
        __init__(self, nodes_size) -> UndiGraph
        __init__(self) -> UndiGraph
        __init__(self, g) -> UndiGraph
        """
        this = _pyAgrum.new_UndiGraph(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_UndiGraph
    __del__ = lambda self: None

    def __eq__(self, g: 'UndiGraph') -> "bool":
        """__eq__(self, g) -> bool"""
        return _pyAgrum.UndiGraph___eq__(self, g)


    def __ne__(self, g: 'UndiGraph') -> "bool":
        """__ne__(self, g) -> bool"""
        return _pyAgrum.UndiGraph___ne__(self, g)


    def eraseNode(self, id: 'gum::NodeId const') -> "void":
        """eraseNode(self, id)"""
        return _pyAgrum.UndiGraph_eraseNode(self, id)


    def clear(self) -> "void":
        """clear(self)"""
        return _pyAgrum.UndiGraph_clear(self)


    def __str__(self) -> "std::string const":
        """__str__(self) -> std::string const"""
        return _pyAgrum.UndiGraph___str__(self)


    def toDot(self) -> "std::string const":
        """toDot(self) -> std::string const"""
        return _pyAgrum.UndiGraph_toDot(self)


    def hasUndirectedCycle(self) -> "bool":
        """hasUndirectedCycle(self) -> bool"""
        return _pyAgrum.UndiGraph_hasUndirectedCycle(self)


    def partialUndiGraph(self, nodesSet: 'gum::NodeSet') -> "gum::UndiGraph":
        """partialUndiGraph(self, nodesSet) -> UndiGraph"""
        return _pyAgrum.UndiGraph_partialUndiGraph(self, nodesSet)


    def ids(self) -> "PyObject *":
        """ids(self) -> PyObject *"""
        return _pyAgrum.UndiGraph_ids(self)


    def edges(self) -> "PyObject *":
        """edges(self) -> PyObject *"""
        return _pyAgrum.UndiGraph_edges(self)


    def neighbours(self, id: 'gum::NodeId') -> "PyObject *":
        """neighbours(self, id) -> PyObject *"""
        return _pyAgrum.UndiGraph_neighbours(self, id)


    def addNode(self) -> "gum::NodeId":
        """addNode(self) -> gum::NodeId"""
        return _pyAgrum.UndiGraph_addNode(self)


    def addNodeWithId(self, id: 'gum::NodeId const') -> "void":
        """addNodeWithId(self, id)"""
        return _pyAgrum.UndiGraph_addNodeWithId(self, id)


    def existsNode(self, id: 'gum::NodeId const') -> "bool":
        """existsNode(self, id) -> bool"""
        return _pyAgrum.UndiGraph_existsNode(self, id)


    def size(self) -> "gum::Size":
        """size(self) -> gum::Size"""
        return _pyAgrum.UndiGraph_size(self)


    def empty(self) -> "bool":
        """empty(self) -> bool"""
        return _pyAgrum.UndiGraph_empty(self)


    def addEdge(self, n1: 'gum::NodeId const', n2: 'gum::NodeId const') -> "void":
        """addEdge(self, n1, n2)"""
        return _pyAgrum.UndiGraph_addEdge(self, n1, n2)


    def eraseEdge(self, n1: 'gum::NodeId const', n2: 'gum::NodeId const') -> "void":
        """eraseEdge(self, n1, n2)"""
        return _pyAgrum.UndiGraph_eraseEdge(self, n1, n2)


    def existsEdge(self, n1: 'gum::NodeId const', n2: 'gum::NodeId const') -> "bool":
        """existsEdge(self, n1, n2) -> bool"""
        return _pyAgrum.UndiGraph_existsEdge(self, n1, n2)


    def sizeEdges(self) -> "gum::Size":
        """sizeEdges(self) -> gum::Size"""
        return _pyAgrum.UndiGraph_sizeEdges(self)


    def emptyEdges(self) -> "bool":
        """emptyEdges(self) -> bool"""
        return _pyAgrum.UndiGraph_emptyEdges(self)


    def eraseNeighbours(self, n: 'gum::NodeId const') -> "void":
        """eraseNeighbours(self, n)"""
        return _pyAgrum.UndiGraph_eraseNeighbours(self, n)

UndiGraph_swigregister = _pyAgrum.UndiGraph_swigregister
UndiGraph_swigregister(UndiGraph)

class MixedGraph(UndiGraph, DiGraph):
    """Proxy of C++ gum::MixedGraph class."""

    __swig_setmethods__ = {}
    for _s in [UndiGraph, DiGraph]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MixedGraph, name, value)
    __swig_getmethods__ = {}
    for _s in [UndiGraph, DiGraph]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MixedGraph, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, nodes_size, nodes_resize_policy=True, arcs_size, arcs_resize_policy=True, edges_size, edges_resize_policy=True) -> MixedGraph
        __init__(self, nodes_size, nodes_resize_policy=True, arcs_size, arcs_resize_policy=True, edges_size) -> MixedGraph
        __init__(self, nodes_size, nodes_resize_policy=True, arcs_size, arcs_resize_policy=True) -> MixedGraph
        __init__(self, nodes_size, nodes_resize_policy=True, arcs_size) -> MixedGraph
        __init__(self, nodes_size, nodes_resize_policy=True) -> MixedGraph
        __init__(self, nodes_size) -> MixedGraph
        __init__(self) -> MixedGraph
        __init__(self, g) -> MixedGraph
        """
        this = _pyAgrum.new_MixedGraph(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_MixedGraph
    __del__ = lambda self: None

    def __eq__(self, g: 'MixedGraph') -> "bool":
        """__eq__(self, g) -> bool"""
        return _pyAgrum.MixedGraph___eq__(self, g)


    def __ne__(self, g: 'MixedGraph') -> "bool":
        """__ne__(self, g) -> bool"""
        return _pyAgrum.MixedGraph___ne__(self, g)


    def eraseNode(self, id: 'gum::NodeId const') -> "void":
        """eraseNode(self, id)"""
        return _pyAgrum.MixedGraph_eraseNode(self, id)


    def clear(self) -> "void":
        """clear(self)"""
        return _pyAgrum.MixedGraph_clear(self)


    def mixedOrientedPath(self, node1: 'gum::NodeId const', node2: 'gum::NodeId const') -> "std::vector< gum::NodeId,std::allocator< gum::NodeId > > const":
        """mixedOrientedPath(self, node1, node2) -> Vector_int"""
        return _pyAgrum.MixedGraph_mixedOrientedPath(self, node1, node2)


    def mixedUnorientedPath(self, node1: 'gum::NodeId const', node2: 'gum::NodeId const') -> "std::vector< gum::NodeId,std::allocator< gum::NodeId > > const":
        """mixedUnorientedPath(self, node1, node2) -> Vector_int"""
        return _pyAgrum.MixedGraph_mixedUnorientedPath(self, node1, node2)


    def toDot(self) -> "std::string const":
        """toDot(self) -> std::string const"""
        return _pyAgrum.MixedGraph_toDot(self)


    def __str__(self) -> "std::string const":
        """__str__(self) -> std::string const"""
        return _pyAgrum.MixedGraph___str__(self)


    def addNode(self) -> "gum::NodeId":
        """addNode(self) -> gum::NodeId"""
        return _pyAgrum.MixedGraph_addNode(self)


    def addNodeWithId(self, id: 'gum::NodeId const') -> "void":
        """addNodeWithId(self, id)"""
        return _pyAgrum.MixedGraph_addNodeWithId(self, id)


    def existsNode(self, id: 'gum::NodeId const') -> "bool":
        """existsNode(self, id) -> bool"""
        return _pyAgrum.MixedGraph_existsNode(self, id)


    def size(self) -> "gum::Size":
        """size(self) -> gum::Size"""
        return _pyAgrum.MixedGraph_size(self)


    def empty(self) -> "bool":
        """empty(self) -> bool"""
        return _pyAgrum.MixedGraph_empty(self)


    def addEdge(self, n1: 'gum::NodeId const', n2: 'gum::NodeId const') -> "void":
        """addEdge(self, n1, n2)"""
        return _pyAgrum.MixedGraph_addEdge(self, n1, n2)


    def eraseEdge(self, n1: 'gum::NodeId const', n2: 'gum::NodeId const') -> "void":
        """eraseEdge(self, n1, n2)"""
        return _pyAgrum.MixedGraph_eraseEdge(self, n1, n2)


    def existsEdge(self, n1: 'gum::NodeId const', n2: 'gum::NodeId const') -> "bool":
        """existsEdge(self, n1, n2) -> bool"""
        return _pyAgrum.MixedGraph_existsEdge(self, n1, n2)


    def sizeEdges(self) -> "gum::Size":
        """sizeEdges(self) -> gum::Size"""
        return _pyAgrum.MixedGraph_sizeEdges(self)


    def emptyEdges(self) -> "bool":
        """emptyEdges(self) -> bool"""
        return _pyAgrum.MixedGraph_emptyEdges(self)


    def eraseNeighbours(self, n: 'gum::NodeId const') -> "void":
        """eraseNeighbours(self, n)"""
        return _pyAgrum.MixedGraph_eraseNeighbours(self, n)


    def addArc(self, n1: 'gum::NodeId const', n2: 'gum::NodeId const') -> "void":
        """addArc(self, n1, n2)"""
        return _pyAgrum.MixedGraph_addArc(self, n1, n2)


    def eraseArc(self, n1: 'gum::NodeId const', n2: 'gum::NodeId const') -> "void":
        """eraseArc(self, n1, n2)"""
        return _pyAgrum.MixedGraph_eraseArc(self, n1, n2)


    def existsArc(self, n1: 'gum::NodeId const', n2: 'gum::NodeId const') -> "bool":
        """existsArc(self, n1, n2) -> bool"""
        return _pyAgrum.MixedGraph_existsArc(self, n1, n2)


    def eraseParents(self, n: 'gum::NodeId const') -> "void":
        """eraseParents(self, n)"""
        return _pyAgrum.MixedGraph_eraseParents(self, n)


    def eraseChildren(self, n: 'gum::NodeId const') -> "void":
        """eraseChildren(self, n)"""
        return _pyAgrum.MixedGraph_eraseChildren(self, n)


    def sizeArcs(self) -> "gum::Size":
        """sizeArcs(self) -> gum::Size"""
        return _pyAgrum.MixedGraph_sizeArcs(self)


    def emptyArcs(self) -> "bool":
        """emptyArcs(self) -> bool"""
        return _pyAgrum.MixedGraph_emptyArcs(self)

MixedGraph_swigregister = _pyAgrum.MixedGraph_swigregister
MixedGraph_swigregister(MixedGraph)

class CliqueGraph(UndiGraph):
    """Proxy of C++ gum::CliqueGraph class."""

    __swig_setmethods__ = {}
    for _s in [UndiGraph]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CliqueGraph, name, value)
    __swig_getmethods__ = {}
    for _s in [UndiGraph]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CliqueGraph, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, nodes_size, nodes_resize_policy=True, edges_size, edges_resize_policy=True) -> CliqueGraph
        __init__(self, nodes_size, nodes_resize_policy=True, edges_size) -> CliqueGraph
        __init__(self, nodes_size, nodes_resize_policy=True) -> CliqueGraph
        __init__(self, nodes_size) -> CliqueGraph
        __init__(self) -> CliqueGraph
        __init__(self, arg2) -> CliqueGraph
        """
        this = _pyAgrum.new_CliqueGraph(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_CliqueGraph
    __del__ = lambda self: None

    def addEdge(self, first: 'gum::NodeId const', second: 'gum::NodeId const') -> "void":
        """addEdge(self, first, second)"""
        return _pyAgrum.CliqueGraph_addEdge(self, first, second)


    def eraseEdge(self, edge: 'Edge') -> "void":
        """eraseEdge(self, edge)"""
        return _pyAgrum.CliqueGraph_eraseEdge(self, edge)


    def clearEdges(self) -> "void":
        """clearEdges(self)"""
        return _pyAgrum.CliqueGraph_clearEdges(self)


    def eraseNode(self, node: 'gum::NodeId const') -> "void":
        """eraseNode(self, node)"""
        return _pyAgrum.CliqueGraph_eraseNode(self, node)


    def clear(self) -> "void":
        """clear(self)"""
        return _pyAgrum.CliqueGraph_clear(self)


    def container(self, idNode: 'gum::NodeId const') -> "gum::NodeId":
        """container(self, idNode) -> gum::NodeId"""
        return _pyAgrum.CliqueGraph_container(self, idNode)


    def setClique(self, idClique: 'gum::NodeId const', new_clique: 'gum::NodeSet const &') -> "void":
        """setClique(self, idClique, new_clique)"""
        return _pyAgrum.CliqueGraph_setClique(self, idClique, new_clique)


    def addToClique(self, clique_id: 'gum::NodeId const', node_id: 'gum::NodeId const') -> "void":
        """addToClique(self, clique_id, node_id)"""
        return _pyAgrum.CliqueGraph_addToClique(self, clique_id, node_id)


    def eraseFromClique(self, clique_id: 'gum::NodeId const', node_id: 'gum::NodeId const') -> "void":
        """eraseFromClique(self, clique_id, node_id)"""
        return _pyAgrum.CliqueGraph_eraseFromClique(self, clique_id, node_id)


    def separator(self, *args) -> "gum::NodeSet const &":
        """
        separator(self, edge) -> gum::NodeSet const
        separator(self, clique1, clique) -> gum::NodeSet const &
        """
        return _pyAgrum.CliqueGraph_separator(self, *args)


    def containerPath(self, node1: 'gum::NodeId const', node2: 'gum::NodeId const') -> "std::vector< gum::NodeId,std::allocator< gum::NodeId > >":
        """containerPath(self, node1, node2) -> Vector_int"""
        return _pyAgrum.CliqueGraph_containerPath(self, node1, node2)


    def hasRunningIntersection(self) -> "bool":
        """hasRunningIntersection(self) -> bool"""
        return _pyAgrum.CliqueGraph_hasRunningIntersection(self)


    def isJoinTree(self) -> "bool":
        """isJoinTree(self) -> bool"""
        return _pyAgrum.CliqueGraph_isJoinTree(self)


    def __str__(self) -> "std::string const":
        """__str__(self) -> std::string const"""
        return _pyAgrum.CliqueGraph___str__(self)


    def toDot(self) -> "std::string const":
        """toDot(self) -> std::string const"""
        return _pyAgrum.CliqueGraph_toDot(self)


    def __ne__(self, arg2: 'CliqueGraph') -> "bool":
        """__ne__(self, arg2) -> bool"""
        return _pyAgrum.CliqueGraph___ne__(self, arg2)


    def __eq__(self, arg2: 'CliqueGraph') -> "bool":
        """__eq__(self, arg2) -> bool"""
        return _pyAgrum.CliqueGraph___eq__(self, arg2)


    def clique(self, clique: 'gum::NodeId const') -> "PyObject *":
        """clique(self, clique) -> PyObject *"""
        return _pyAgrum.CliqueGraph_clique(self, clique)


    def toDotWithNames(self,bn):
      def nameFromId(m):
        return " ".join([bn.variable(int(n)).name()
                         for n in m.group().split("-")])
      import re
      m = re.compile('(?<=label=\")\d+[\-\d+]*')
      return m.sub(nameFromId,self.toDot())

CliqueGraph_swigregister = _pyAgrum.CliqueGraph_swigregister
CliqueGraph_swigregister(CliqueGraph)

class Instantiation(_object):
    """Proxy of C++ gum::Instantiation class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Instantiation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Instantiation, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self) -> Instantiation
        __init__(self, aI, notifyMaster=True) -> Instantiation
        __init__(self, aI) -> Instantiation
        __init__(self, aMD) -> Instantiation
        __init__(self, aMD) -> Instantiation
        __init__(self, aMD) -> Instantiation
        __init__(self, aMD) -> Instantiation
        """
        this = _pyAgrum.new_Instantiation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_Instantiation
    __del__ = lambda self: None

    def nbrDim(self) -> "gum::Idx":
        """nbrDim(self) -> gum::Idx"""
        return _pyAgrum.Instantiation_nbrDim(self)


    def add(self, v: 'DiscreteVariable') -> "void":
        """add(self, v)"""
        return _pyAgrum.Instantiation_add(self, v)


    def erase(self, v: 'DiscreteVariable') -> "void":
        """erase(self, v)"""
        return _pyAgrum.Instantiation_erase(self, v)


    def clear(self) -> "void":
        """clear(self)"""
        return _pyAgrum.Instantiation_clear(self)


    def domainSize(self) -> "gum::Size":
        """domainSize(self) -> gum::Size"""
        return _pyAgrum.Instantiation_domainSize(self)


    def pos(self, v: 'DiscreteVariable') -> "gum::Idx":
        """pos(self, v) -> gum::Idx"""
        return _pyAgrum.Instantiation_pos(self, v)


    def val(self, *args) -> "gum::Idx":
        """
        val(self, i) -> gum::Idx
        val(self, var) -> gum::Idx
        """
        return _pyAgrum.Instantiation_val(self, *args)


    def valFromPtr(self, pvar: 'DiscreteVariable') -> "gum::Idx":
        """valFromPtr(self, pvar) -> gum::Idx"""
        return _pyAgrum.Instantiation_valFromPtr(self, pvar)


    def variable(self, i: 'gum::Idx') -> "gum::DiscreteVariable const &":
        """variable(self, i) -> DiscreteVariable"""
        return _pyAgrum.Instantiation_variable(self, i)


    def chgVal(self, *args) -> "gum::Instantiation &":
        """
        chgVal(self, v, newval) -> Instantiation
        chgVal(self, v, newval) -> Instantiation
        chgVal(self, varPos, newval) -> Instantiation
        """
        return _pyAgrum.Instantiation_chgVal(self, *args)


    def setVals(self, i: 'Instantiation') -> "gum::Instantiation &":
        """setVals(self, i) -> Instantiation"""
        return _pyAgrum.Instantiation_setVals(self, i)


    def contains(self, *args) -> "bool":
        """
        contains(self, v) -> bool
        contains(self, v) -> bool
        """
        return _pyAgrum.Instantiation_contains(self, *args)


    def variablesSequence(self) -> "gum::Sequence< gum::DiscreteVariable const * > const &":
        """variablesSequence(self) -> gum::Sequence< gum::DiscreteVariable const * > const &"""
        return _pyAgrum.Instantiation_variablesSequence(self)


    def empty(self) -> "bool":
        """empty(self) -> bool"""
        return _pyAgrum.Instantiation_empty(self)


    def inOverflow(self) -> "bool":
        """inOverflow(self) -> bool"""
        return _pyAgrum.Instantiation_inOverflow(self)


    def unsetOverflow(self) -> "void":
        """unsetOverflow(self)"""
        return _pyAgrum.Instantiation_unsetOverflow(self)


    def unsetEnd(self) -> "void":
        """unsetEnd(self)"""
        return _pyAgrum.Instantiation_unsetEnd(self)


    def end(self) -> "bool":
        """end(self) -> bool"""
        return _pyAgrum.Instantiation_end(self)


    def rend(self) -> "bool":
        """rend(self) -> bool"""
        return _pyAgrum.Instantiation_rend(self)


    def inc(self) -> "void":
        """inc(self)"""
        return _pyAgrum.Instantiation_inc(self)


    def dec(self) -> "void":
        """dec(self)"""
        return _pyAgrum.Instantiation_dec(self)


    def incIn(self, i: 'Instantiation') -> "void":
        """incIn(self, i)"""
        return _pyAgrum.Instantiation_incIn(self, i)


    def decIn(self, i: 'Instantiation') -> "void":
        """decIn(self, i)"""
        return _pyAgrum.Instantiation_decIn(self, i)


    def incOut(self, i: 'Instantiation') -> "void":
        """incOut(self, i)"""
        return _pyAgrum.Instantiation_incOut(self, i)


    def decOut(self, i: 'Instantiation') -> "void":
        """decOut(self, i)"""
        return _pyAgrum.Instantiation_decOut(self, i)


    def incNotVar(self, v: 'DiscreteVariable') -> "void":
        """incNotVar(self, v)"""
        return _pyAgrum.Instantiation_incNotVar(self, v)


    def decNotVar(self, v: 'DiscreteVariable') -> "void":
        """decNotVar(self, v)"""
        return _pyAgrum.Instantiation_decNotVar(self, v)


    def incVar(self, v: 'DiscreteVariable') -> "void":
        """incVar(self, v)"""
        return _pyAgrum.Instantiation_incVar(self, v)


    def decVar(self, v: 'DiscreteVariable') -> "void":
        """decVar(self, v)"""
        return _pyAgrum.Instantiation_decVar(self, v)


    def setFirst(self) -> "void":
        """setFirst(self)"""
        return _pyAgrum.Instantiation_setFirst(self)


    def setLast(self) -> "void":
        """setLast(self)"""
        return _pyAgrum.Instantiation_setLast(self)


    def setFirstIn(self, i: 'Instantiation') -> "void":
        """setFirstIn(self, i)"""
        return _pyAgrum.Instantiation_setFirstIn(self, i)


    def setLastIn(self, i: 'Instantiation') -> "void":
        """setLastIn(self, i)"""
        return _pyAgrum.Instantiation_setLastIn(self, i)


    def setFirstOut(self, i: 'Instantiation') -> "void":
        """setFirstOut(self, i)"""
        return _pyAgrum.Instantiation_setFirstOut(self, i)


    def setLastOut(self, i: 'Instantiation') -> "void":
        """setLastOut(self, i)"""
        return _pyAgrum.Instantiation_setLastOut(self, i)


    def setFirstNotVar(self, v: 'DiscreteVariable') -> "void":
        """setFirstNotVar(self, v)"""
        return _pyAgrum.Instantiation_setFirstNotVar(self, v)


    def setLastNotVar(self, v: 'DiscreteVariable') -> "void":
        """setLastNotVar(self, v)"""
        return _pyAgrum.Instantiation_setLastNotVar(self, v)


    def setFirstVar(self, v: 'DiscreteVariable') -> "void":
        """setFirstVar(self, v)"""
        return _pyAgrum.Instantiation_setFirstVar(self, v)


    def setLastVar(self, v: 'DiscreteVariable') -> "void":
        """setLastVar(self, v)"""
        return _pyAgrum.Instantiation_setLastVar(self, v)


    def actAsSlave(self, aMD: 'MultiDimAdressable') -> "bool":
        """actAsSlave(self, aMD) -> bool"""
        return _pyAgrum.Instantiation_actAsSlave(self, aMD)


    def forgetMaster(self) -> "bool":
        """forgetMaster(self) -> bool"""
        return _pyAgrum.Instantiation_forgetMaster(self)


    def isSlave(self) -> "bool":
        """isSlave(self) -> bool"""
        return _pyAgrum.Instantiation_isSlave(self)


    def isMaster(self, *args) -> "bool":
        """
        isMaster(self, m) -> bool
        isMaster(self, m) -> bool
        """
        return _pyAgrum.Instantiation_isMaster(self, *args)


    def synchronizeWithMaster(self, m: 'MultiDimAdressable') -> "void":
        """synchronizeWithMaster(self, m)"""
        return _pyAgrum.Instantiation_synchronizeWithMaster(self, m)


    def addWithMaster(self, m: 'MultiDimAdressable', v: 'DiscreteVariable') -> "void":
        """addWithMaster(self, m, v)"""
        return _pyAgrum.Instantiation_addWithMaster(self, m, v)


    def eraseWithMaster(self, m: 'MultiDimAdressable', v: 'DiscreteVariable') -> "void":
        """eraseWithMaster(self, m, v)"""
        return _pyAgrum.Instantiation_eraseWithMaster(self, m, v)


    def __iadd__(self, depl: 'gum::Size') -> "gum::Instantiation &":
        """__iadd__(self, depl) -> Instantiation"""
        return _pyAgrum.Instantiation___iadd__(self, depl)


    def __isub__(self, depl: 'gum::Size') -> "gum::Instantiation &":
        """__isub__(self, depl) -> Instantiation"""
        return _pyAgrum.Instantiation___isub__(self, depl)


    def hamming(self) -> "gum::Idx":
        """hamming(self) -> gum::Idx"""
        return _pyAgrum.Instantiation_hamming(self)


    def __str__(self) -> "std::string":
        """__str__(self) -> std::string"""
        return _pyAgrum.Instantiation___str__(self)


    def reorder(self, *args) -> "void":
        """
        reorder(self, v)
        reorder(self, i)
        """
        return _pyAgrum.Instantiation_reorder(self, *args)

Instantiation_swigregister = _pyAgrum.Instantiation_swigregister
Instantiation_swigregister(Instantiation)

GUM_DEFAULT_ITERATOR_NUMBER = _pyAgrum.GUM_DEFAULT_ITERATOR_NUMBER
class DAGmodel(_object):
    """Proxy of C++ gum::DAGmodel class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DAGmodel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DAGmodel, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_DAGmodel
    __del__ = lambda self: None

    def property(self, name: 'std::string const &') -> "std::string const &":
        """property(self, name) -> std::string const &"""
        return _pyAgrum.DAGmodel_property(self, name)


    def propertyWithDefault(self, name: 'std::string const &', byDefault: 'std::string const &') -> "std::string const &":
        """propertyWithDefault(self, name, byDefault) -> std::string const &"""
        return _pyAgrum.DAGmodel_propertyWithDefault(self, name, byDefault)


    def setProperty(self, name: 'std::string const &', value: 'std::string const &') -> "void":
        """setProperty(self, name, value)"""
        return _pyAgrum.DAGmodel_setProperty(self, name, value)


    def dag(self) -> "gum::DAG const &":
        """dag(self) -> DAG"""
        return _pyAgrum.DAGmodel_dag(self)


    def variableNodeMap(self) -> "gum::VariableNodeMap const &":
        """variableNodeMap(self) -> VariableNodeMap"""
        return _pyAgrum.DAGmodel_variableNodeMap(self)


    def size(self) -> "gum::Size":
        """size(self) -> gum::Size"""
        return _pyAgrum.DAGmodel_size(self)


    def sizeArcs(self) -> "gum::Size":
        """sizeArcs(self) -> gum::Size"""
        return _pyAgrum.DAGmodel_sizeArcs(self)


    def empty(self) -> "bool":
        """empty(self) -> bool"""
        return _pyAgrum.DAGmodel_empty(self)


    def variable(self, id: 'gum::NodeId') -> "gum::DiscreteVariable const &":
        """variable(self, id) -> DiscreteVariable"""
        return _pyAgrum.DAGmodel_variable(self, id)


    def nodeId(self, var: 'DiscreteVariable') -> "gum::NodeId":
        """nodeId(self, var) -> gum::NodeId"""
        return _pyAgrum.DAGmodel_nodeId(self, var)


    def idFromName(self, name: 'std::string const &') -> "gum::NodeId":
        """idFromName(self, name) -> gum::NodeId"""
        return _pyAgrum.DAGmodel_idFromName(self, name)


    def variableFromName(self, name: 'std::string const &') -> "gum::DiscreteVariable const &":
        """variableFromName(self, name) -> DiscreteVariable"""
        return _pyAgrum.DAGmodel_variableFromName(self, name)


    def completeInstantiation(self, I: 'Instantiation') -> "void":
        """completeInstantiation(self, I)"""
        return _pyAgrum.DAGmodel_completeInstantiation(self, I)


    def arcs(self) -> "gum::ArcSet const &":
        """arcs(self) -> gum::ArcSet const &"""
        return _pyAgrum.DAGmodel_arcs(self)


    def moralGraph(self, clear: 'bool'=True) -> "gum::UndiGraph const &":
        """
        moralGraph(self, clear=True) -> UndiGraph
        moralGraph(self) -> UndiGraph
        """
        return _pyAgrum.DAGmodel_moralGraph(self, clear)


    def topologicalOrder(self, clear: 'bool'=True) -> "gum::Sequence< gum::NodeId > const &":
        """
        topologicalOrder(self, clear=True) -> gum::Sequence< gum::NodeId > const
        topologicalOrder(self) -> gum::Sequence< gum::NodeId > const &
        """
        return _pyAgrum.DAGmodel_topologicalOrder(self, clear)


    def log10DomainSize(self) -> "double":
        """log10DomainSize(self) -> double"""
        return _pyAgrum.DAGmodel_log10DomainSize(self)


    def hasSameStructure(self, other: 'DAGmodel') -> "bool":
        """hasSameStructure(self, other) -> bool"""
        return _pyAgrum.DAGmodel_hasSameStructure(self, other)

DAGmodel_swigregister = _pyAgrum.DAGmodel_swigregister
DAGmodel_swigregister(DAGmodel)
cvar = _pyAgrum.cvar
__list_end_safe = cvar.__list_end_safe
__list_end = cvar.__list_end

class EssentialGraph(_object):
    """Proxy of C++ gum::EssentialGraph class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EssentialGraph, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EssentialGraph, name)
    __repr__ = _swig_repr

    def __init__(self, m: 'DAGmodel'):
        """__init__(self, m) -> EssentialGraph"""
        this = _pyAgrum.new_EssentialGraph(m)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_EssentialGraph
    __del__ = lambda self: None

    def mixedGraph(self) -> "gum::MixedGraph":
        """mixedGraph(self) -> MixedGraph"""
        return _pyAgrum.EssentialGraph_mixedGraph(self)


    def toDot(self) -> "std::string":
        """toDot(self) -> std::string"""
        return _pyAgrum.EssentialGraph_toDot(self)


    def parents(self, id: 'gum::NodeId const') -> "gum::NodeSet const &":
        """parents(self, id) -> gum::NodeSet const &"""
        return _pyAgrum.EssentialGraph_parents(self, id)


    def children(self, id: 'gum::NodeId const') -> "gum::NodeSet const &":
        """children(self, id) -> gum::NodeSet const &"""
        return _pyAgrum.EssentialGraph_children(self, id)


    def neighbours(self, id: 'gum::NodeId const') -> "gum::NodeSet const &":
        """neighbours(self, id) -> gum::NodeSet const &"""
        return _pyAgrum.EssentialGraph_neighbours(self, id)


    def sizeArcs(self) -> "gum::Size":
        """sizeArcs(self) -> gum::Size"""
        return _pyAgrum.EssentialGraph_sizeArcs(self)


    def arcs(self) -> "gum::ArcSet const &":
        """arcs(self) -> gum::ArcSet const &"""
        return _pyAgrum.EssentialGraph_arcs(self)


    def sizeEdges(self) -> "gum::Size":
        """sizeEdges(self) -> gum::Size"""
        return _pyAgrum.EssentialGraph_sizeEdges(self)


    def edges(self) -> "gum::EdgeSet const &":
        """edges(self) -> gum::EdgeSet const &"""
        return _pyAgrum.EssentialGraph_edges(self)


    def sizeNodes(self) -> "gum::Size":
        """sizeNodes(self) -> gum::Size"""
        return _pyAgrum.EssentialGraph_sizeNodes(self)


    def size(self) -> "gum::Size":
        """size(self) -> gum::Size"""
        return _pyAgrum.EssentialGraph_size(self)

EssentialGraph_swigregister = _pyAgrum.EssentialGraph_swigregister
EssentialGraph_swigregister(EssentialGraph)

class MarkovBlanket(_object):
    """Proxy of C++ gum::MarkovBlanket class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkovBlanket, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MarkovBlanket, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, m, n) -> MarkovBlanket
        __init__(self, m, name) -> MarkovBlanket
        """
        this = _pyAgrum.new_MarkovBlanket(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_MarkovBlanket
    __del__ = lambda self: None

    def mb(self) -> "gum::DiGraph":
        """mb(self) -> DiGraph"""
        return _pyAgrum.MarkovBlanket_mb(self)


    def toDot(self) -> "std::string":
        """toDot(self) -> std::string"""
        return _pyAgrum.MarkovBlanket_toDot(self)


    def parents(self, id: 'gum::NodeId const') -> "gum::NodeSet const &":
        """parents(self, id) -> gum::NodeSet const &"""
        return _pyAgrum.MarkovBlanket_parents(self, id)


    def children(self, id: 'gum::NodeId const') -> "gum::NodeSet const &":
        """children(self, id) -> gum::NodeSet const &"""
        return _pyAgrum.MarkovBlanket_children(self, id)


    def sizeArcs(self) -> "gum::Size":
        """sizeArcs(self) -> gum::Size"""
        return _pyAgrum.MarkovBlanket_sizeArcs(self)


    def arcs(self) -> "gum::ArcSet const &":
        """arcs(self) -> gum::ArcSet const &"""
        return _pyAgrum.MarkovBlanket_arcs(self)


    def sizeNodes(self) -> "gum::Size":
        """sizeNodes(self) -> gum::Size"""
        return _pyAgrum.MarkovBlanket_sizeNodes(self)


    def size(self) -> "gum::Size":
        """size(self) -> gum::Size"""
        return _pyAgrum.MarkovBlanket_size(self)


    def hasSameStructure(self, other: 'DAGmodel') -> "bool":
        """hasSameStructure(self, other) -> bool"""
        return _pyAgrum.MarkovBlanket_hasSameStructure(self, other)

MarkovBlanket_swigregister = _pyAgrum.MarkovBlanket_swigregister
MarkovBlanket_swigregister(MarkovBlanket)

class ApproximationScheme(_object):
    """Proxy of C++ gum::ApproximationScheme class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ApproximationScheme, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ApproximationScheme, name)
    __repr__ = _swig_repr

    def __init__(self, v: 'bool'=False):
        """
        __init__(self, v=False) -> ApproximationScheme
        __init__(self) -> ApproximationScheme
        """
        this = _pyAgrum.new_ApproximationScheme(v)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_ApproximationScheme
    __del__ = lambda self: None

    def setEpsilon(self, eps: 'double') -> "void":
        """setEpsilon(self, eps)"""
        return _pyAgrum.ApproximationScheme_setEpsilon(self, eps)


    def epsilon(self) -> "double":
        """epsilon(self) -> double"""
        return _pyAgrum.ApproximationScheme_epsilon(self)


    def disableEpsilon(self) -> "void":
        """disableEpsilon(self)"""
        return _pyAgrum.ApproximationScheme_disableEpsilon(self)


    def enableEpsilon(self) -> "void":
        """enableEpsilon(self)"""
        return _pyAgrum.ApproximationScheme_enableEpsilon(self)


    def isEnabledEpsilon(self) -> "bool":
        """isEnabledEpsilon(self) -> bool"""
        return _pyAgrum.ApproximationScheme_isEnabledEpsilon(self)


    def setMinEpsilonRate(self, rate: 'double') -> "void":
        """setMinEpsilonRate(self, rate)"""
        return _pyAgrum.ApproximationScheme_setMinEpsilonRate(self, rate)


    def minEpsilonRate(self) -> "double":
        """minEpsilonRate(self) -> double"""
        return _pyAgrum.ApproximationScheme_minEpsilonRate(self)


    def disableMinEpsilonRate(self) -> "void":
        """disableMinEpsilonRate(self)"""
        return _pyAgrum.ApproximationScheme_disableMinEpsilonRate(self)


    def enableMinEpsilonRate(self) -> "void":
        """enableMinEpsilonRate(self)"""
        return _pyAgrum.ApproximationScheme_enableMinEpsilonRate(self)


    def isEnabledMinEpsilonRate(self) -> "bool":
        """isEnabledMinEpsilonRate(self) -> bool"""
        return _pyAgrum.ApproximationScheme_isEnabledMinEpsilonRate(self)


    def setMaxIter(self, max: 'gum::Size') -> "void":
        """setMaxIter(self, max)"""
        return _pyAgrum.ApproximationScheme_setMaxIter(self, max)


    def maxIter(self) -> "gum::Size":
        """maxIter(self) -> gum::Size"""
        return _pyAgrum.ApproximationScheme_maxIter(self)


    def disableMaxIter(self) -> "void":
        """disableMaxIter(self)"""
        return _pyAgrum.ApproximationScheme_disableMaxIter(self)


    def enableMaxIter(self) -> "void":
        """enableMaxIter(self)"""
        return _pyAgrum.ApproximationScheme_enableMaxIter(self)


    def isEnabledMaxIter(self) -> "bool":
        """isEnabledMaxIter(self) -> bool"""
        return _pyAgrum.ApproximationScheme_isEnabledMaxIter(self)


    def setMaxTime(self, timeout: 'double') -> "void":
        """setMaxTime(self, timeout)"""
        return _pyAgrum.ApproximationScheme_setMaxTime(self, timeout)


    def maxTime(self) -> "double":
        """maxTime(self) -> double"""
        return _pyAgrum.ApproximationScheme_maxTime(self)


    def currentTime(self) -> "double":
        """currentTime(self) -> double"""
        return _pyAgrum.ApproximationScheme_currentTime(self)


    def disableMaxTime(self) -> "void":
        """disableMaxTime(self)"""
        return _pyAgrum.ApproximationScheme_disableMaxTime(self)


    def enableMaxTime(self) -> "void":
        """enableMaxTime(self)"""
        return _pyAgrum.ApproximationScheme_enableMaxTime(self)


    def isEnabledMaxTime(self) -> "bool":
        """isEnabledMaxTime(self) -> bool"""
        return _pyAgrum.ApproximationScheme_isEnabledMaxTime(self)


    def setPeriodSize(self, p: 'gum::Size') -> "void":
        """setPeriodSize(self, p)"""
        return _pyAgrum.ApproximationScheme_setPeriodSize(self, p)


    def periodSize(self) -> "gum::Size":
        """periodSize(self) -> gum::Size"""
        return _pyAgrum.ApproximationScheme_periodSize(self)


    def setBurnIn(self, b: 'gum::Size') -> "void":
        """setBurnIn(self, b)"""
        return _pyAgrum.ApproximationScheme_setBurnIn(self, b)


    def burnIn(self) -> "gum::Size":
        """burnIn(self) -> gum::Size"""
        return _pyAgrum.ApproximationScheme_burnIn(self)


    def setVerbosity(self, v: 'bool') -> "void":
        """setVerbosity(self, v)"""
        return _pyAgrum.ApproximationScheme_setVerbosity(self, v)


    def verbosity(self) -> "bool":
        """verbosity(self) -> bool"""
        return _pyAgrum.ApproximationScheme_verbosity(self)


    def stateApproximationScheme(self) -> "gum::IApproximationSchemeConfiguration::ApproximationSchemeSTATE":
        """stateApproximationScheme(self) -> gum::IApproximationSchemeConfiguration::ApproximationSchemeSTATE"""
        return _pyAgrum.ApproximationScheme_stateApproximationScheme(self)


    def nbrIterations(self) -> "gum::Size":
        """nbrIterations(self) -> gum::Size"""
        return _pyAgrum.ApproximationScheme_nbrIterations(self)


    def history(self) -> "std::vector< double,std::allocator< double > > const &":
        """history(self) -> Vector_double"""
        return _pyAgrum.ApproximationScheme_history(self)


    def initApproximationScheme(self) -> "void":
        """initApproximationScheme(self)"""
        return _pyAgrum.ApproximationScheme_initApproximationScheme(self)


    def startOfPeriod(self) -> "bool":
        """startOfPeriod(self) -> bool"""
        return _pyAgrum.ApproximationScheme_startOfPeriod(self)


    def updateApproximationScheme(self, incr: 'unsigned int'=1) -> "void":
        """
        updateApproximationScheme(self, incr=1)
        updateApproximationScheme(self)
        """
        return _pyAgrum.ApproximationScheme_updateApproximationScheme(self, incr)


    def remainingBurnIn(self) -> "gum::Size":
        """remainingBurnIn(self) -> gum::Size"""
        return _pyAgrum.ApproximationScheme_remainingBurnIn(self)


    def stopApproximationScheme(self) -> "void":
        """stopApproximationScheme(self)"""
        return _pyAgrum.ApproximationScheme_stopApproximationScheme(self)


    def continueApproximationScheme(self, error: 'double') -> "bool":
        """continueApproximationScheme(self, error) -> bool"""
        return _pyAgrum.ApproximationScheme_continueApproximationScheme(self, error)

ApproximationScheme_swigregister = _pyAgrum.ApproximationScheme_swigregister
ApproximationScheme_swigregister(ApproximationScheme)

RelevantPotentialsFinderType_FIND_ALL = _pyAgrum.RelevantPotentialsFinderType_FIND_ALL
RelevantPotentialsFinderType_DSEP_BAYESBALL_NODES = _pyAgrum.RelevantPotentialsFinderType_DSEP_BAYESBALL_NODES
RelevantPotentialsFinderType_DSEP_BAYESBALL_POTENTIALS = _pyAgrum.RelevantPotentialsFinderType_DSEP_BAYESBALL_POTENTIALS
RelevantPotentialsFinderType_DSEP_KOLLER_FRIEDMAN_2009 = _pyAgrum.RelevantPotentialsFinderType_DSEP_KOLLER_FRIEDMAN_2009
FindBarrenNodesType_FIND_NO_BARREN_NODES = _pyAgrum.FindBarrenNodesType_FIND_NO_BARREN_NODES
FindBarrenNodesType_FIND_BARREN_NODES = _pyAgrum.FindBarrenNodesType_FIND_BARREN_NODES

def randomDistribution_double(n: 'gum::Size') -> "std::vector< double,std::allocator< double > >":
    """randomDistribution_double(n) -> Vector_double"""
    return _pyAgrum.randomDistribution_double(n)
class DiscretizedVariable_double(DiscreteVariable):
    """

    DiscretizedVariable is a discrete random variable with a set of ``ticks`` defining intervalls.

    Available constructors:

        ``DiscretizedVariable(aName, aDesc='') -> DiscretizedVariable``

        ``DiscretizedVariable(aDDRV) -> DiscretizedVariable``

    Parameters
    ----------
    aName: str
      The name of the variable
    aDesc: str
      The (optional) description of the variable
    aDDRV: pyAgrum.DiscretizedVariable
      Another `DiscretizedVariable` that will be copied

    Examples
    --------
    >>> import pyAgrum as gum
    >>> v=gum.DiscretizedVariable('v','a descr')
    >>> print(v)
    v<>
    >>> v.addTick(1).addTick(3.14).addTick(0.4).addTick(0.2)
    >>> print(w)
    a<[0.2;0.4[,[0.4;1[,[1;3.14]>

    """

    __swig_setmethods__ = {}
    for _s in [DiscreteVariable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiscretizedVariable_double, name, value)
    __swig_getmethods__ = {}
    for _s in [DiscreteVariable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DiscretizedVariable_double, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, aName, aDesc) -> DiscretizedVariable_double
        __init__(self, aDRV) -> DiscretizedVariable_double
        """
        this = _pyAgrum.new_DiscretizedVariable_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_DiscretizedVariable_double
    __del__ = lambda self: None

    def clone(self) -> "gum::DiscreteVariable *":
        """clone(self) -> DiscreteVariable"""
        return _pyAgrum.DiscretizedVariable_double_clone(self)


    def varType(self) -> "gum::DiscreteVariable::VarType":
        """varType(self) -> gum::DiscreteVariable::VarType"""
        return _pyAgrum.DiscretizedVariable_double_varType(self)


    def isTick(self, aTick: 'double const &') -> "bool":
        """isTick(self, aTick) -> bool"""
        return _pyAgrum.DiscretizedVariable_double_isTick(self, aTick)


    def addTick(self,*args):
      _pyAgrum.DiscretizedVariable_double_addTick(self,*args)
      return self



    def eraseTicks(self) -> "void":
        """eraseTicks(self)"""
        return _pyAgrum.DiscretizedVariable_double_eraseTicks(self)


    def label(self, i: 'gum::Idx') -> "std::string":
        """label(self, i) -> std::string"""
        return _pyAgrum.DiscretizedVariable_double_label(self, i)


    def numerical(self, indice: 'gum::Idx') -> "double":
        """numerical(self, indice) -> double"""
        return _pyAgrum.DiscretizedVariable_double_numerical(self, indice)


    def index(self, label: 'std::string const &') -> "gum::Idx":
        """index(self, label) -> gum::Idx"""
        return _pyAgrum.DiscretizedVariable_double_index(self, label)


    def domainSize(self) -> "gum::Size":
        """domainSize(self) -> gum::Size"""
        return _pyAgrum.DiscretizedVariable_double_domainSize(self)


    def domain(self) -> "std::string const":
        """
        domain(self) -> std::string const


        Returns
        -------
        str
            the domain of the variable as a string

        """
        return _pyAgrum.DiscretizedVariable_double_domain(self)


    def tick(self, i: 'gum::Idx') -> "double const &":
        """tick(self, i) -> double const &"""
        return _pyAgrum.DiscretizedVariable_double_tick(self, i)

DiscretizedVariable_double_swigregister = _pyAgrum.DiscretizedVariable_double_swigregister
DiscretizedVariable_double_swigregister(DiscretizedVariable_double)

class MultiDimContainer_double(_object):
    """Proxy of C++ gum::MultiDimContainer<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiDimContainer_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MultiDimContainer_double, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_MultiDimContainer_double
    __del__ = lambda self: None

    def set(self, i: 'Instantiation', value: 'double const &') -> "void":
        """set(self, i, value)"""
        return _pyAgrum.MultiDimContainer_double_set(self, i, value)


    def get(self, i: 'Instantiation') -> "double":
        """get(self, i) -> double"""
        return _pyAgrum.MultiDimContainer_double_get(self, i)


    def fill(self, d: 'double const &') -> "void":
        """fill(self, d)"""
        return _pyAgrum.MultiDimContainer_double_fill(self, d)


    def populate(self, *args) -> "void":
        """
        populate(self, v)
        populate(self, l)
        """
        return _pyAgrum.MultiDimContainer_double_populate(self, *args)


    def copyFrom(self, *args) -> "void":
        """
        copyFrom(self, src)
        copyFrom(self, src, p_i)
        """
        return _pyAgrum.MultiDimContainer_double_copyFrom(self, *args)


    def extractFrom(self, src: 'MultiDimContainer_double', mask: 'Instantiation') -> "void":
        """extractFrom(self, src, mask)"""
        return _pyAgrum.MultiDimContainer_double_extractFrom(self, src, mask)


    def content(self, *args) -> "gum::MultiDimImplementation< double > *":
        """
        content(self) -> gum::MultiDimImplementation< double > const
        content(self) -> gum::MultiDimImplementation< double > *
        """
        return _pyAgrum.MultiDimContainer_double_content(self, *args)


    def getMasterRef(self, *args) -> "gum::MultiDimAdressable const &":
        """
        getMasterRef(self) -> MultiDimAdressable
        getMasterRef(self) -> MultiDimAdressable
        """
        return _pyAgrum.MultiDimContainer_double_getMasterRef(self, *args)


    def copy(self, src: 'MultiDimContainer_double') -> "void":
        """copy(self, src)"""
        return _pyAgrum.MultiDimContainer_double_copy(self, src)


    def newFactory(self) -> "gum::MultiDimContainer< double > *":
        """newFactory(self) -> MultiDimContainer_double"""
        return _pyAgrum.MultiDimContainer_double_newFactory(self)


    def __str__(self) -> "std::string const":
        """__str__(self) -> std::string const"""
        return _pyAgrum.MultiDimContainer_double___str__(self)


    def toString(self, i: 'Instantiation') -> "std::string const":
        """toString(self, i) -> std::string const"""
        return _pyAgrum.MultiDimContainer_double_toString(self, i)


    def __eq__(self, p: 'MultiDimContainer_double') -> "bool":
        """__eq__(self, p) -> bool"""
        return _pyAgrum.MultiDimContainer_double___eq__(self, p)


    def __ne__(self, p: 'MultiDimContainer_double') -> "bool":
        """__ne__(self, p) -> bool"""
        return _pyAgrum.MultiDimContainer_double___ne__(self, p)


    def apply(self, f: 'std::function< double (double) >') -> "void":
        """apply(self, f)"""
        return _pyAgrum.MultiDimContainer_double_apply(self, f)


    def reduce(self, f: 'std::function< double (double,double) >', base: 'double') -> "double":
        """reduce(self, f, base) -> double"""
        return _pyAgrum.MultiDimContainer_double_reduce(self, f, base)


    def beginMultipleChanges(self) -> "void":
        """beginMultipleChanges(self)"""
        return _pyAgrum.MultiDimContainer_double_beginMultipleChanges(self)


    def endMultipleChanges(self, *args) -> "void":
        """
        endMultipleChanges(self)
        endMultipleChanges(self, v)
        """
        return _pyAgrum.MultiDimContainer_double_endMultipleChanges(self, *args)

MultiDimContainer_double_swigregister = _pyAgrum.MultiDimContainer_double_swigregister
MultiDimContainer_double_swigregister(MultiDimContainer_double)

class Potential_double(_object):
    """Proxy of C++ gum::Potential<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Potential_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Potential_double, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self) -> Potential_double
        __init__(self, aContent) -> Potential_double
        __init__(self, aContent, src) -> Potential_double
        __init__(self, src) -> Potential_double
        __init__(self, arg2) -> Potential_double
        """
        this = _pyAgrum.new_Potential_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self._notSync=True



    __swig_destroy__ = _pyAgrum.delete_Potential_double
    __del__ = lambda self: None

    def newFactory(self) -> "gum::Potential< double > *":
        """newFactory(self) -> Potential_double"""
        return _pyAgrum.Potential_double_newFactory(self)


    def isNonZeroMap(self) -> "gum::Potential< double >":
        """isNonZeroMap(self) -> Potential_double"""
        return _pyAgrum.Potential_double_isNonZeroMap(self)


    def sum(self) -> "double":
        """sum(self) -> double"""
        return _pyAgrum.Potential_double_sum(self)


    def product(self) -> "double":
        """product(self) -> double"""
        return _pyAgrum.Potential_double_product(self)


    def max(self) -> "double":
        """max(self) -> double"""
        return _pyAgrum.Potential_double_max(self)


    def min(self) -> "double":
        """min(self) -> double"""
        return _pyAgrum.Potential_double_min(self)


    def maxNonOne(self) -> "double":
        """maxNonOne(self) -> double"""
        return _pyAgrum.Potential_double_maxNonOne(self)


    def minNonZero(self) -> "double":
        """minNonZero(self) -> double"""
        return _pyAgrum.Potential_double_minNonZero(self)


    def entropy(self) -> "double":
        """entropy(self) -> double"""
        return _pyAgrum.Potential_double_entropy(self)


    def fillWith(self, *args) -> "gum::Potential< double > const &":
        """
        fillWith(self, v) -> Potential_double
        fillWith(self, v) -> Potential_double
        """
        val = _pyAgrum.Potential_double_fillWith(self, *args)

        self._notSync=True
        return self


        return val


    def abs(self) -> "gum::Potential< double > const &":
        """abs(self) -> Potential_double"""
        val = _pyAgrum.Potential_double_abs(self)

        self._notSync=True
        return self


        return val


    def normalize(self) -> "gum::Potential< double > const &":
        """normalize(self) -> Potential_double"""
        val = _pyAgrum.Potential_double_normalize(self)

        self._notSync=True
        return self


        return val


    def sq(self) -> "gum::Potential< double > const &":
        """sq(self) -> Potential_double"""
        val = _pyAgrum.Potential_double_sq(self)

        self._notSync=True
        return self


        return val


    def KL(self, p: 'Potential_double') -> "double":
        """KL(self, p) -> double"""
        return _pyAgrum.Potential_double_KL(self, p)


    def fastKL(self, p: 'Potential_double') -> "double":
        """fastKL(self, p) -> double"""
        return _pyAgrum.Potential_double_fastKL(self, p)


    def normalizeAsCPT(self) -> "void":
        """normalizeAsCPT(self)"""
        val = _pyAgrum.Potential_double_normalizeAsCPT(self)

        self._notSync=True
        return self


        return val


    def scale(self, v: 'double') -> "gum::Potential< double > const &":
        """scale(self, v) -> Potential_double"""
        val = _pyAgrum.Potential_double_scale(self, v)

        self._notSync=True
        return self


        return val


    def translate(self, v: 'double') -> "gum::Potential< double > const &":
        """translate(self, v) -> Potential_double"""
        val = _pyAgrum.Potential_double_translate(self, v)

        self._notSync=True
        return self


        return val


    def __add__(self, p2: 'Potential_double') -> "gum::Potential< double >":
        """__add__(self, p2) -> Potential_double"""
        return _pyAgrum.Potential_double___add__(self, p2)


    def __sub__(self, p2: 'Potential_double') -> "gum::Potential< double >":
        """__sub__(self, p2) -> Potential_double"""
        return _pyAgrum.Potential_double___sub__(self, p2)


    def __mul__(self, p2: 'Potential_double') -> "gum::Potential< double >":
        """__mul__(self, p2) -> Potential_double"""
        return _pyAgrum.Potential_double___mul__(self, p2)


    def __iadd__(self, r: 'Potential_double') -> "gum::Potential< double > &":
        """__iadd__(self, r) -> Potential_double"""
        return _pyAgrum.Potential_double___iadd__(self, r)


    def __imul__(self, r: 'Potential_double') -> "gum::Potential< double > &":
        """__imul__(self, r) -> Potential_double"""
        return _pyAgrum.Potential_double___imul__(self, r)


    def __isub__(self, r: 'Potential_double') -> "gum::Potential< double > &":
        """__isub__(self, r) -> Potential_double"""
        return _pyAgrum.Potential_double___isub__(self, r)


    def __itruediv__(self, *args):
        return _pyAgrum.Potential_double___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __str__(self) -> "std::string const":
        """__str__(self) -> std::string const"""
        return _pyAgrum.Potential_double___str__(self)


    def extract(self, *args) -> "gum::Potential< double >":
        """
        extract(self, inst) -> Potential_double
        extract(self, dict) -> Potential_double
        """
        return _pyAgrum.Potential_double_extract(self, *args)


    def reorganize(self, *args) -> "gum::Potential< double >":
        """
        reorganize(self, vars) -> Potential_double
        reorganize(self, varnames) -> Potential_double
        """
        return _pyAgrum.Potential_double_reorganize(self, *args)


    def putFirst(self, varname: 'PyObject *') -> "gum::Potential< double >":
        """putFirst(self, varname) -> Potential_double"""
        return _pyAgrum.Potential_double_putFirst(self, varname)


    def margSumOut(self, varnames: 'PyObject *') -> "gum::Potential< double >":
        """margSumOut(self, varnames) -> Potential_double"""
        return _pyAgrum.Potential_double_margSumOut(self, varnames)


    def margProdOut(self, varnames: 'PyObject *') -> "gum::Potential< double >":
        """margProdOut(self, varnames) -> Potential_double"""
        return _pyAgrum.Potential_double_margProdOut(self, varnames)


    def margMaxOut(self, varnames: 'PyObject *') -> "gum::Potential< double >":
        """margMaxOut(self, varnames) -> Potential_double"""
        return _pyAgrum.Potential_double_margMaxOut(self, varnames)


    def margMinOut(self, varnames: 'PyObject *') -> "gum::Potential< double >":
        """margMinOut(self, varnames) -> Potential_double"""
        return _pyAgrum.Potential_double_margMinOut(self, varnames)


    def margSumIn(self, varnames: 'PyObject *') -> "gum::Potential< double >":
        """margSumIn(self, varnames) -> Potential_double"""
        return _pyAgrum.Potential_double_margSumIn(self, varnames)


    def margProdIn(self, varnames: 'PyObject *') -> "gum::Potential< double >":
        """margProdIn(self, varnames) -> Potential_double"""
        return _pyAgrum.Potential_double_margProdIn(self, varnames)


    def margMaxIn(self, varnames: 'PyObject *') -> "gum::Potential< double >":
        """margMaxIn(self, varnames) -> Potential_double"""
        return _pyAgrum.Potential_double_margMaxIn(self, varnames)


    def margMinIn(self, varnames: 'PyObject *') -> "gum::Potential< double >":
        """margMinIn(self, varnames) -> Potential_double"""
        return _pyAgrum.Potential_double_margMinIn(self, varnames)


    def __truediv__(self, *args) -> "gum::Potential< double >":
        """
        __truediv__(self, p2) -> Potential_double
        __truediv__(self, b) -> Potential_double
        """
        return _pyAgrum.Potential_double___truediv__(self, *args)


    def __div__(self, b: 'Potential_double') -> "gum::Potential< double >":
        """__div__(self, b) -> Potential_double"""
        return _pyAgrum.Potential_double___div__(self, b)


    def __eq__(self, *args) -> "bool":
        """
        __eq__(self, r) -> bool
        __eq__(self, b) -> bool
        """
        return _pyAgrum.Potential_double___eq__(self, *args)


    def __ne__(self, *args) -> "bool":
        """
        __ne__(self, r) -> bool
        __ne__(self, b) -> bool
        """
        return _pyAgrum.Potential_double___ne__(self, *args)



    def variablesSequence(self):
        varlist = []
        for i in range(0, self.nbrDim()):
            varlist.append(self.variable(i))
        return varlist


    def __fill_distrib__(self):
      if not hasattr(self,'_notSync'):
        self._notSync=True

      if self._notSync:
        self._notSync=False
        self._var_names = []
        self._var_dims = []
        if self.empty():
            i = Instantiation(self)
            content = [self.get(i)]
            self.__distrib__ = numpy.array(content, dtype=numpy.float64) #M
            return

        content = []
        i = Instantiation(self)
        i.setFirst()
        while not i.end():
            content.append(self.get(i))
            i.inc()
        self.__distrib__ = numpy.array(content, dtype=numpy.float64) #M
        for var in self.variablesSequence():
            self._var_names.append(var.name())
            self._var_dims.append(var.domainSize())
        self._var_names.reverse()
        self._var_dims.reverse()
        self.__distrib__.shape = tuple(self._var_dims)



    def __indexfromdict__(self, id_dict):
        index = []
        for name, dim in zip(self._var_names, self._var_dims):
            if name in id_dict:
                id_value = id_dict[name]
                if isinstance(id_value, str):
    # id_value is a label of a LabelizedVar
                    i = self._var_names.index(name)
                    var = self.variable(len(self._var_names) - 1 - i)
                    id_value = var[id_value]
                if id_value >= dim:
                    raise IndexError("\"%s\" size is %d !"%(name, dim))
                index.append(id_value)
            else:
                index.append(slice(None, None, None)) # equivalent to ':'
        return tuple(index)



    def tolist(self):
        self.__fill_distrib__()
        return self.__distrib__.tolist()



    def toarray(self):
        return numpy.array(self.tolist())



    def __getitem__(self, id):
        self.__fill_distrib__()
        if self.empty():
            return self.__distrib__[0]

        if isinstance(id, dict):
            id_slice = self.__indexfromdict__(id)
        else:
            id_slice = id
        return self.__distrib__[id_slice]



    def __setitem__(self, id, value):
        self.__fill_distrib__()
        if self.empty():
            self.fill(value)
            self.__distrib__= numpy.array([value], dtype=numpy.float64) #M
            return 

        if isinstance(id, dict):
            id_slice = self.__indexfromdict__(id)
        else:
            id_slice = id
        self.__distrib__[id_slice] = value
        self.populate(self.__distrib__.reshape(self.__distrib__.size).tolist())



    @property
    def var_names(self):
        self.__fill_distrib__()
        return self._var_names



    @property
    def var_dims(self):
        self.__fill_distrib__()
        return self._var_dims



    def get(self, i: 'Instantiation') -> "double":
        """get(self, i) -> double"""
        return _pyAgrum.Potential_double_get(self, i)


    def set(self, i: 'Instantiation', value: 'double const &') -> "void":
        """set(self, i, value)"""
        val = _pyAgrum.Potential_double_set(self, i, value)

        self._notSync=True


        return val


    def empty(self) -> "bool":
        """empty(self) -> bool"""
        return _pyAgrum.Potential_double_empty(self)


    def pos(self, v: 'DiscreteVariable') -> "gum::Idx":
        """pos(self, v) -> gum::Idx"""
        return _pyAgrum.Potential_double_pos(self, v)


    def contains(self, v: 'DiscreteVariable') -> "bool":
        """contains(self, v) -> bool"""
        return _pyAgrum.Potential_double_contains(self, v)


    def nbrDim(self) -> "gum::Idx":
        """nbrDim(self) -> gum::Idx"""
        return _pyAgrum.Potential_double_nbrDim(self)


    def variable(self, i: 'gum::Idx') -> "gum::DiscreteVariable const &":
        """variable(self, i) -> DiscreteVariable"""
        return _pyAgrum.Potential_double_variable(self, i)


    def populate(self, v: 'Vector_double') -> "void":
        """populate(self, v)"""
        return _pyAgrum.Potential_double_populate(self, v)


    def fill(self, d: 'double const &') -> "void":
        """fill(self, d)"""
        return _pyAgrum.Potential_double_fill(self, d)


    def remove(self, var: 'DiscreteVariable') -> "void":
        """remove(self, var)"""
        val = _pyAgrum.Potential_double_remove(self, var)

        self._notSync=True


        return val


    def add(self, v: 'DiscreteVariable') -> "void":
        """add(self, v)"""
        val = _pyAgrum.Potential_double_add(self, v)

        self._notSync=True
        return self


        return val

Potential_double_swigregister = _pyAgrum.Potential_double_swigregister
Potential_double_swigregister(Potential_double)

class UtilityTable_double(_object):
    """Proxy of C++ gum::UtilityTable<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UtilityTable_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UtilityTable_double, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_UtilityTable_double
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(self) -> UtilityTable_double
        __init__(self, aContent) -> UtilityTable_double
        __init__(self, toCopy) -> UtilityTable_double
        """
        this = _pyAgrum.new_UtilityTable_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self._notSync=True




    def newFactory(self) -> "gum::UtilityTable< double > *":
        """newFactory(self) -> UtilityTable_double"""
        return _pyAgrum.UtilityTable_double_newFactory(self)


    def variablesSequence(self):
        varlist = []
        for i in range(0, self.nbrDim()):
            varlist.append(self.variable(i))
        return varlist

    def __mul__(self,p2):
        """
        return self * p2
        """
        p=UtilityTable()
        p.multiplicate(self,p2)
        return p

    def eliminates(self,var):
        """
        eliminates a variable in the UtilityTable. Returns the new UtilityTable or self if the variable is not in self.
        @warning : returns a list with only one scalar if eliminates remove the last variable
        """
        if var.name() in self.var_names:
            q=UtilityTable()
            for i in range(self.nbrDim()):
                if self.variable(i)!=var:
                    q.add(self.variable(i))
            if q.nbrDim()>0:
                q.marginalize(self)
            else:
                q=[self.sum()]
            return q
        else:
            return self


    def __fill_distrib__(self):
      if not hasattr(self,'_notSync'):
        self._notSync=True

      if self._notSync:
        self._notSync=False
        self._var_names = []
        self._var_dims = []
        content = []
        if self.empty():
            self.__distrib__ = numpy.array(content, dtype=numpy.float64) #M
            return
        i = Instantiation(self)
        i.setFirst()
        while not i.end():
            content.append(self.get(i))
            i.inc()
        self.__distrib__ = numpy.array(content, dtype=numpy.float64) #M
        for var in self.variablesSequence():
            self._var_names.append(var.name())
            self._var_dims.append(var.domainSize())
        self._var_names.reverse()
        self._var_dims.reverse()
        self.__distrib__.shape = tuple(self._var_dims)



    def __indexfromdict__(self, id_dict):
        index = []
        for name, dim in zip(self._var_names, self._var_dims):
            if name in id_dict:
                id_value = id_dict[name]
                if isinstance(id_value, str):
    # id_value is a label of a LabelizedVar
                    i = self._var_names.index(name)
                    var = self.variable(len(self._var_names) - 1 - i)
                    id_value = var[id_value]
                if id_value >= dim:
                    raise IndexError("\"%s\" size is %d !"%(name, dim))
                index.append(id_value)
            else:
                index.append(slice(None, None, None)) # equivalent to ':'
        return tuple(index)



    def __str__(self) -> "char const *":
        """__str__(self) -> char const *"""
        return _pyAgrum.UtilityTable_double___str__(self)


    def tolist(self):
        self.__fill_distrib__()
        return self.__distrib__.tolist()



    def toarray(self):
        return numpy.array(self.tolist())



    def __getitem__(self, id):
        self.__fill_distrib__()
        if self.empty():
            raise IndexError("%s is empty !!"%(str(self)))
        if isinstance(id, dict):
            id_slice = self.__indexfromdict__(id)
        else:
            id_slice = id
        return self.__distrib__[id_slice]



    def __setitem__(self, id, value):
        self.__fill_distrib__()
        if self.empty():
            raise IndexError("%s is empty !!"%(str(self)))
        if isinstance(id, dict):
            id_slice = self.__indexfromdict__(id)
        else:
            id_slice = id
        self.__distrib__[id_slice] = value
        self.populate(self.__distrib__.reshape(self.__distrib__.size).tolist())



    @property
    def var_names(self):
        self.__fill_distrib__()
        return self._var_names



    @property
    def var_dims(self):
        self.__fill_distrib__()
        return self._var_dims



    def get(self, i: 'Instantiation') -> "double":
        """get(self, i) -> double"""
        return _pyAgrum.UtilityTable_double_get(self, i)


    def set(self, i: 'Instantiation', value: 'double const &') -> "void":
        """set(self, i, value)"""
        val = _pyAgrum.UtilityTable_double_set(self, i, value)

        self._notSync=True


        return val


    def empty(self) -> "bool":
        """empty(self) -> bool"""
        return _pyAgrum.UtilityTable_double_empty(self)


    def pos(self, v: 'DiscreteVariable') -> "gum::Idx":
        """pos(self, v) -> gum::Idx"""
        return _pyAgrum.UtilityTable_double_pos(self, v)


    def contains(self, v: 'DiscreteVariable') -> "bool":
        """contains(self, v) -> bool"""
        return _pyAgrum.UtilityTable_double_contains(self, v)


    def nbrDim(self) -> "gum::Idx":
        """nbrDim(self) -> gum::Idx"""
        return _pyAgrum.UtilityTable_double_nbrDim(self)


    def variable(self, i: 'gum::Idx') -> "gum::DiscreteVariable const &":
        """variable(self, i) -> DiscreteVariable"""
        return _pyAgrum.UtilityTable_double_variable(self, i)


    def populate(self, v: 'Vector_double') -> "void":
        """populate(self, v)"""
        return _pyAgrum.UtilityTable_double_populate(self, v)


    def fill(self, d: 'double const &') -> "void":
        """fill(self, d)"""
        return _pyAgrum.UtilityTable_double_fill(self, d)


    def remove(self, var: 'DiscreteVariable') -> "void":
        """remove(self, var)"""
        val = _pyAgrum.UtilityTable_double_remove(self, var)

        self._notSync=True


        return val


    def add(self, v: 'DiscreteVariable') -> "void":
        """add(self, v)"""
        val = _pyAgrum.UtilityTable_double_add(self, v)

        self._notSync=True


        return val

UtilityTable_double_swigregister = _pyAgrum.UtilityTable_double_swigregister
UtilityTable_double_swigregister(UtilityTable_double)

class IBayesNet_double(DAGmodel):
    """Proxy of C++ gum::IBayesNet<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [DAGmodel]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IBayesNet_double, name, value)
    __swig_getmethods__ = {}
    for _s in [DAGmodel]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IBayesNet_double, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_IBayesNet_double
    __del__ = lambda self: None

    def cpt(self, varId: 'gum::NodeId') -> "gum::Potential< double > const &":
        """cpt(self, varId) -> Potential_double"""
        return _pyAgrum.IBayesNet_double_cpt(self, varId)


    def variableNodeMap(self) -> "gum::VariableNodeMap const &":
        """variableNodeMap(self) -> VariableNodeMap"""
        return _pyAgrum.IBayesNet_double_variableNodeMap(self)


    def variable(self, id: 'gum::NodeId') -> "gum::DiscreteVariable const &":
        """variable(self, id) -> DiscreteVariable"""
        return _pyAgrum.IBayesNet_double_variable(self, id)


    def nodeId(self, var: 'DiscreteVariable') -> "gum::NodeId":
        """nodeId(self, var) -> gum::NodeId"""
        return _pyAgrum.IBayesNet_double_nodeId(self, var)


    def idFromName(self, name: 'std::string const &') -> "gum::NodeId":
        """idFromName(self, name) -> gum::NodeId"""
        return _pyAgrum.IBayesNet_double_idFromName(self, name)


    def variableFromName(self, name: 'std::string const &') -> "gum::DiscreteVariable const &":
        """variableFromName(self, name) -> DiscreteVariable"""
        return _pyAgrum.IBayesNet_double_variableFromName(self, name)


    def jointProbability(self, i: 'Instantiation') -> "double":
        """jointProbability(self, i) -> double"""
        return _pyAgrum.IBayesNet_double_jointProbability(self, i)


    def log2JointProbability(self, i: 'Instantiation') -> "double":
        """log2JointProbability(self, i) -> double"""
        return _pyAgrum.IBayesNet_double_log2JointProbability(self, i)


    def __eq__(self, src: 'IBayesNet_double') -> "bool":
        """__eq__(self, src) -> bool"""
        return _pyAgrum.IBayesNet_double___eq__(self, src)


    def __ne__(self, src: 'IBayesNet_double') -> "bool":
        """__ne__(self, src) -> bool"""
        return _pyAgrum.IBayesNet_double___ne__(self, src)


    def dim(self) -> "gum::Size":
        """dim(self) -> gum::Size"""
        return _pyAgrum.IBayesNet_double_dim(self)


    def maxVarDomainSize(self) -> "gum::Size":
        """maxVarDomainSize(self) -> gum::Size"""
        return _pyAgrum.IBayesNet_double_maxVarDomainSize(self)


    def minParam(self) -> "double":
        """minParam(self) -> double"""
        return _pyAgrum.IBayesNet_double_minParam(self)


    def maxParam(self) -> "double":
        """maxParam(self) -> double"""
        return _pyAgrum.IBayesNet_double_maxParam(self)


    def minNonZeroParam(self) -> "double":
        """minNonZeroParam(self) -> double"""
        return _pyAgrum.IBayesNet_double_minNonZeroParam(self)


    def maxNonOneParam(self) -> "double":
        """maxNonOneParam(self) -> double"""
        return _pyAgrum.IBayesNet_double_maxNonOneParam(self)


    def toDot(self) -> "std::string":
        """toDot(self) -> std::string"""
        return _pyAgrum.IBayesNet_double_toDot(self)


    def __str__(self) -> "std::string":
        """__str__(self) -> std::string"""
        return _pyAgrum.IBayesNet_double___str__(self)


    def ids(self) -> "PyObject *":
        """ids(self) -> PyObject *"""
        return _pyAgrum.IBayesNet_double_ids(self)


    def names(self) -> "PyObject *":
        """names(self) -> PyObject *"""
        return _pyAgrum.IBayesNet_double_names(self)


    def arcs(self) -> "PyObject *":
        """arcs(self) -> PyObject *"""
        return _pyAgrum.IBayesNet_double_arcs(self)


    def parents(self, id: 'gum::NodeId const') -> "PyObject *":
        """parents(self, id) -> PyObject *"""
        return _pyAgrum.IBayesNet_double_parents(self, id)


    def children(self, id: 'gum::NodeId const') -> "PyObject *":
        """children(self, id) -> PyObject *"""
        return _pyAgrum.IBayesNet_double_children(self, id)


    def minimalCondSet(self, *args) -> "PyObject *":
        """
        minimalCondSet(self, target, soids) -> gum::NodeSet
        minimalCondSet(self, target, soids) -> gum::NodeSet
        minimalCondSet(self, target, list) -> PyObject
        minimalCondSet(self, targets, list) -> PyObject *
        """
        return _pyAgrum.IBayesNet_double_minimalCondSet(self, *args)

IBayesNet_double_swigregister = _pyAgrum.IBayesNet_double_swigregister
IBayesNet_double_swigregister(IBayesNet_double)

class BayesNet_double(IBayesNet_double):
    """

    BayesNet represents a Bayesian Network.

    Available constructors:
        ``BayesNet(name='') -> BayesNet``

        ``BayesNet(source) -> BayesNet``

    Parameters
    ----------
    name: str
      the name of the Bayes Net (optional)
    source : :class:BayesNet
      the Bayesian network to copy

    """

    __swig_setmethods__ = {}
    for _s in [IBayesNet_double]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BayesNet_double, name, value)
    __swig_getmethods__ = {}
    for _s in [IBayesNet_double]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BayesNet_double, name)
    __repr__ = _swig_repr

    def fastPrototype(dotlike: 'std::string const &', domainSize: 'gum::Size'=2) -> "gum::BayesNet< double >":
        """
        fastPrototype(dotlike, domainSize=2) -> BayesNet_double
        fastPrototype(dotlike) -> BayesNet_double



        """
        return _pyAgrum.BayesNet_double_fastPrototype(dotlike, domainSize)

    fastPrototype = staticmethod(fastPrototype)
    __swig_destroy__ = _pyAgrum.delete_BayesNet_double
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(self) -> BayesNet_double
        __init__(self, name) -> BayesNet_double
        __init__(self, source) -> BayesNet_double
        """
        this = _pyAgrum.new_BayesNet_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def cpt(self, *args) -> "gum::Potential< double > const &":
        """
        cpt(self, varId) -> Potential_double
        cpt(self, name) -> Potential_double


        FOO BAR

        """
        val = _pyAgrum.BayesNet_double_cpt(self, *args)

        val.__fill_distrib__()


        return val


    def variableNodeMap(self) -> "gum::VariableNodeMap const &":
        """variableNodeMap(self) -> VariableNodeMap"""
        return _pyAgrum.BayesNet_double_variableNodeMap(self)


    def add(self, *args) -> "gum::NodeId":
        """
        add(self, variable) -> gum::NodeId
        add(self, name, nbrmod) -> gum::NodeId
        add(self, variable, aContent) -> gum::NodeId
        add(self, variable, id) -> gum::NodeId
        add(self, variable, aContent, id) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_add(self, *args)


    def erase(self, *args) -> "void":
        """
        erase(self, id)
        erase(self, name)
        erase(self, var)


        FOO BAR

        """
        return _pyAgrum.BayesNet_double_erase(self, *args)


    def variable(self, *args) -> "gum::DiscreteVariable const &":
        """
        variable(self, id) -> DiscreteVariable
        variable(self, name) -> DiscreteVariable
        """
        return _pyAgrum.BayesNet_double_variable(self, *args)


    def changeVariableName(self, *args) -> "void":
        """
        changeVariableName(self, id, new_name)
        changeVariableName(self, name, new_name)
        """
        return _pyAgrum.BayesNet_double_changeVariableName(self, *args)


    def nodeId(self, var: 'DiscreteVariable') -> "gum::NodeId":
        """nodeId(self, var) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_nodeId(self, var)


    def idFromName(self, name: 'std::string const &') -> "gum::NodeId":
        """idFromName(self, name) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_idFromName(self, name)


    def variableFromName(self, name: 'std::string const &') -> "gum::DiscreteVariable const &":
        """variableFromName(self, name) -> DiscreteVariable"""
        return _pyAgrum.BayesNet_double_variableFromName(self, name)


    def addArc(self, *args) -> "void":
        """
        addArc(self, tail, head)
        addArc(self, tail, head)
        """
        return _pyAgrum.BayesNet_double_addArc(self, *args)


    def eraseArc(self, *args) -> "void":
        """
        eraseArc(self, arc)
        eraseArc(self, tail, head)
        eraseArc(self, tail, head)
        """
        return _pyAgrum.BayesNet_double_eraseArc(self, *args)


    def beginTopologyTransformation(self) -> "void":
        """beginTopologyTransformation(self)"""
        return _pyAgrum.BayesNet_double_beginTopologyTransformation(self)


    def endTopologyTransformation(self) -> "void":
        """endTopologyTransformation(self)"""
        return _pyAgrum.BayesNet_double_endTopologyTransformation(self)


    def reverseArc(self, *args) -> "void":
        """
        reverseArc(self, tail, head)
        reverseArc(self, tail, head)
        reverseArc(self, arc)
        """
        return _pyAgrum.BayesNet_double_reverseArc(self, *args)


    def addNoisyOR(self, *args) -> "gum::NodeId":
        """
        addNoisyOR(self, variable, externalWeight) -> gum::NodeId
        addNoisyOR(self, variable, externalWeight, id) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyOR(self, *args)


    def addNoisyORNet(self, *args) -> "gum::NodeId":
        """
        addNoisyORNet(self, variable, externalWeight) -> gum::NodeId
        addNoisyORNet(self, variable, externalWeight, id) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyORNet(self, *args)


    def addNoisyORCompound(self, *args) -> "gum::NodeId":
        """
        addNoisyORCompound(self, variable, externalWeight) -> gum::NodeId
        addNoisyORCompound(self, variable, externalWeight, id) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyORCompound(self, *args)


    def addNoisyAND(self, *args) -> "gum::NodeId":
        """
        addNoisyAND(self, variable, externalWeight, id) -> gum::NodeId
        addNoisyAND(self, variable, externalWeight) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyAND(self, *args)


    def addLogit(self, *args) -> "gum::NodeId":
        """
        addLogit(self, variable, externalWeight, id) -> gum::NodeId
        addLogit(self, variable, externalWeight) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addLogit(self, *args)


    def addOR(self, variable: 'DiscreteVariable') -> "gum::NodeId":
        """addOR(self, variable) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_addOR(self, variable)


    def addAND(self, variable: 'DiscreteVariable') -> "gum::NodeId":
        """addAND(self, variable) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_addAND(self, variable)


    def addAMPLITUDE(self, variable: 'DiscreteVariable') -> "gum::NodeId":
        """addAMPLITUDE(self, variable) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_addAMPLITUDE(self, variable)


    def addCOUNT(self, variable: 'DiscreteVariable', Value: 'gum::Idx'=1) -> "gum::NodeId":
        """
        addCOUNT(self, variable, Value=1) -> gum::NodeId
        addCOUNT(self, variable) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addCOUNT(self, variable, Value)


    def addEXISTS(self, variable: 'DiscreteVariable', Value: 'gum::Idx'=1) -> "gum::NodeId":
        """
        addEXISTS(self, variable, Value=1) -> gum::NodeId
        addEXISTS(self, variable) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addEXISTS(self, variable, Value)


    def addFORALL(self, variable: 'DiscreteVariable', Value: 'gum::Idx'=1) -> "gum::NodeId":
        """
        addFORALL(self, variable, Value=1) -> gum::NodeId
        addFORALL(self, variable) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addFORALL(self, variable, Value)


    def addMAX(self, variable: 'DiscreteVariable') -> "gum::NodeId":
        """addMAX(self, variable) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_addMAX(self, variable)


    def addMEDIAN(self, variable: 'DiscreteVariable') -> "gum::NodeId":
        """addMEDIAN(self, variable) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_addMEDIAN(self, variable)


    def addMIN(self, variable: 'DiscreteVariable') -> "gum::NodeId":
        """addMIN(self, variable) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_addMIN(self, variable)


    def addWeightedArc(self, *args) -> "void":
        """
        addWeightedArc(self, tail, head, causalWeight)
        addWeightedArc(self, tail, head, causalWeight)
        """
        return _pyAgrum.BayesNet_double_addWeightedArc(self, *args)


    def generateCPTs(self) -> "void":
        """generateCPTs(self)"""
        return _pyAgrum.BayesNet_double_generateCPTs(self)


    def generateCPT(self, *args) -> "void":
        """
        generateCPT(self, node)
        generateCPT(self, name)
        """
        return _pyAgrum.BayesNet_double_generateCPT(self, *args)


    def changePotential(self, *args) -> "void":
        """
        changePotential(self, id, newPot)
        changePotential(self, name, newPot)
        """
        return _pyAgrum.BayesNet_double_changePotential(self, *args)


    def dag(self) -> "gum::DAG const &":
        """dag(self) -> DAG"""
        return _pyAgrum.BayesNet_double_dag(self)


    def size(self) -> "gum::Size":
        """size(self) -> gum::Size"""
        return _pyAgrum.BayesNet_double_size(self)


    def log10DomainSize(self) -> "double":
        """log10DomainSize(self) -> double"""
        return _pyAgrum.BayesNet_double_log10DomainSize(self)


    def ids(self) -> "PyObject *":
        """ids(self) -> PyObject *"""
        return _pyAgrum.BayesNet_double_ids(self)


    def names(self) -> "PyObject *":
        """names(self) -> PyObject *"""
        return _pyAgrum.BayesNet_double_names(self)


    def arcs(self) -> "PyObject *":
        """arcs(self) -> PyObject *"""
        return _pyAgrum.BayesNet_double_arcs(self)


    def parents(self, id: 'gum::NodeId const') -> "PyObject *":
        """parents(self, id) -> PyObject *"""
        return _pyAgrum.BayesNet_double_parents(self, id)


    def children(self, id: 'gum::NodeId const') -> "PyObject *":
        """children(self, id) -> PyObject *"""
        return _pyAgrum.BayesNet_double_children(self, id)


    def minimalCondSet(self, *args) -> "PyObject *":
        """
        minimalCondSet(self, target, list) -> PyObject
        minimalCondSet(self, targets, list) -> PyObject *
        """
        return _pyAgrum.BayesNet_double_minimalCondSet(self, *args)


    def loadBIF(self, *args) -> "std::string":
        """
        loadBIF(self, name, l) -> std::string
        loadBIF(self, name) -> std::string


        FOO BAR

        """
        return _pyAgrum.BayesNet_double_loadBIF(self, *args)


    def saveBIF(self, name: 'std::string') -> "void":
        """saveBIF(self, name)"""
        return _pyAgrum.BayesNet_double_saveBIF(self, name)


    def loadDSL(self, *args) -> "std::string":
        """
        loadDSL(self, name, l) -> std::string
        loadDSL(self, name) -> std::string
        """
        return _pyAgrum.BayesNet_double_loadDSL(self, *args)


    def saveDSL(self, name: 'std::string') -> "void":
        """saveDSL(self, name)"""
        return _pyAgrum.BayesNet_double_saveDSL(self, name)


    def loadNET(self, *args) -> "std::string":
        """
        loadNET(self, name, l) -> std::string
        loadNET(self, name) -> std::string
        """
        return _pyAgrum.BayesNet_double_loadNET(self, *args)


    def saveNET(self, name: 'std::string') -> "void":
        """saveNET(self, name)"""
        return _pyAgrum.BayesNet_double_saveNET(self, name)


    def loadPRM(self, *args) -> "std::string":
        """
        loadPRM(self, name, system, classpath, l) -> std::string
        loadPRM(self, name, system, classpath) -> std::string
        loadPRM(self, name, system) -> std::string
        loadPRM(self, name) -> std::string
        """
        return _pyAgrum.BayesNet_double_loadPRM(self, *args)


    def loadBIFXML(self, *args) -> "std::string":
        """
        loadBIFXML(self, name, l) -> std::string
        loadBIFXML(self, name) -> std::string
        """
        return _pyAgrum.BayesNet_double_loadBIFXML(self, *args)


    def saveBIFXML(self, name: 'std::string') -> "void":
        """saveBIFXML(self, name)"""
        return _pyAgrum.BayesNet_double_saveBIFXML(self, name)


    def loadUAI(self, *args) -> "std::string":
        """
        loadUAI(self, name, l) -> std::string
        loadUAI(self, name) -> std::string
        """
        return _pyAgrum.BayesNet_double_loadUAI(self, *args)


    def saveUAI(self, name: 'std::string') -> "void":
        """saveUAI(self, name)"""
        return _pyAgrum.BayesNet_double_saveUAI(self, name)

BayesNet_double_swigregister = _pyAgrum.BayesNet_double_swigregister
BayesNet_double_swigregister(BayesNet_double)

def BayesNet_double_fastPrototype(dotlike: 'std::string const &', domainSize: 'gum::Size'=2) -> "gum::BayesNet< double >":
    """
    fastPrototype(dotlike, domainSize=2) -> BayesNet_double
    BayesNet_double_fastPrototype(dotlike) -> BayesNet_double



    """
    return _pyAgrum.BayesNet_double_fastPrototype(dotlike, domainSize)

class BayesNetInference_double(_object):
    """Proxy of C++ gum::BayesNetInference<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BayesNetInference_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BayesNetInference_double, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    StateOfInference_OutdatedBNStructure = _pyAgrum.BayesNetInference_double_StateOfInference_OutdatedBNStructure
    StateOfInference_OutdatedBNPotentials = _pyAgrum.BayesNetInference_double_StateOfInference_OutdatedBNPotentials
    StateOfInference_InferenceReady = _pyAgrum.BayesNetInference_double_StateOfInference_InferenceReady
    StateOfInference_Done = _pyAgrum.BayesNetInference_double_StateOfInference_Done
    __swig_destroy__ = _pyAgrum.delete_BayesNetInference_double
    __del__ = lambda self: None

    def setBN(self, bn: 'IBayesNet_double') -> "void":
        """setBN(self, bn)"""
        return _pyAgrum.BayesNetInference_double_setBN(self, bn)


    def BN(self) -> "gum::IBayesNet< double > const &":
        """BN(self) -> IBayesNet_double"""
        return _pyAgrum.BayesNetInference_double_BN(self)


    def domainSizes(self) -> "gum::NodeProperty< gum::Size > const &":
        """domainSizes(self) -> gum::NodeProperty< gum::Size > const &"""
        return _pyAgrum.BayesNetInference_double_domainSizes(self)


    def isInferenceReady(self) -> "bool":
        """isInferenceReady(self) -> bool"""
        return _pyAgrum.BayesNetInference_double_isInferenceReady(self)


    def isDone(self) -> "bool":
        """isDone(self) -> bool"""
        return _pyAgrum.BayesNetInference_double_isDone(self)


    def prepareInference(self) -> "void":
        """prepareInference(self)"""
        return _pyAgrum.BayesNetInference_double_prepareInference(self)


    def makeInference(self) -> "void":
        """makeInference(self)"""
        return _pyAgrum.BayesNetInference_double_makeInference(self)


    def clear(self) -> "void":
        """clear(self)"""
        return _pyAgrum.BayesNetInference_double_clear(self)


    def state(self) -> "gum::BayesNetInference< double >::StateOfInference":
        """state(self) -> gum::BayesNetInference< double >::StateOfInference"""
        return _pyAgrum.BayesNetInference_double_state(self)


    def addEvidence(self, *args) -> "void":
        """
        addEvidence(self, id, val)
        addEvidence(self, nodeName, val)
        addEvidence(self, id, label)
        addEvidence(self, nodeName, label)
        addEvidence(self, id, vals)
        addEvidence(self, nodeName, vals)
        addEvidence(self, pot)
        addEvidence(self, pot)
        """
        return _pyAgrum.BayesNetInference_double_addEvidence(self, *args)


    def addSetOfEvidence(self, potlist: 'gum::Set< gum::Potential< double > const * > const &') -> "void":
        """addSetOfEvidence(self, potlist)"""
        return _pyAgrum.BayesNetInference_double_addSetOfEvidence(self, potlist)


    def addListOfEvidence(self, potlist: 'gum::List< gum::Potential< double > const * > const &') -> "void":
        """addListOfEvidence(self, potlist)"""
        return _pyAgrum.BayesNetInference_double_addListOfEvidence(self, potlist)


    def chgEvidence(self, *args) -> "void":
        """
        chgEvidence(self, id, val)
        chgEvidence(self, nodeName, val)
        chgEvidence(self, id, label)
        chgEvidence(self, nodeName, label)
        chgEvidence(self, id, vals)
        chgEvidence(self, nodeName, vals)
        chgEvidence(self, pot)
        """
        return _pyAgrum.BayesNetInference_double_chgEvidence(self, *args)


    def eraseAllEvidence(self) -> "void":
        """eraseAllEvidence(self)"""
        return _pyAgrum.BayesNetInference_double_eraseAllEvidence(self)


    def eraseEvidence(self, *args) -> "void":
        """
        eraseEvidence(self, id)
        eraseEvidence(self, nodeName)
        """
        return _pyAgrum.BayesNetInference_double_eraseEvidence(self, *args)


    def hasEvidence(self, *args) -> "bool":
        """
        hasEvidence(self) -> bool
        hasEvidence(self, id) -> bool
        hasEvidence(self, nodeName) -> bool
        """
        return _pyAgrum.BayesNetInference_double_hasEvidence(self, *args)


    def hasHardEvidence(self, *args) -> "bool":
        """
        hasHardEvidence(self, id) -> bool
        hasHardEvidence(self, nodeName) -> bool
        """
        return _pyAgrum.BayesNetInference_double_hasHardEvidence(self, *args)


    def hasSoftEvidence(self, *args) -> "bool":
        """
        hasSoftEvidence(self, id) -> bool
        hasSoftEvidence(self, nodeName) -> bool
        """
        return _pyAgrum.BayesNetInference_double_hasSoftEvidence(self, *args)


    def nbrEvidence(self) -> "gum::Size":
        """nbrEvidence(self) -> gum::Size"""
        return _pyAgrum.BayesNetInference_double_nbrEvidence(self)


    def nbrHardEvidence(self) -> "gum::Size":
        """nbrHardEvidence(self) -> gum::Size"""
        return _pyAgrum.BayesNetInference_double_nbrHardEvidence(self)


    def nbrSoftEvidence(self) -> "gum::Size":
        """nbrSoftEvidence(self) -> gum::Size"""
        return _pyAgrum.BayesNetInference_double_nbrSoftEvidence(self)


    def evidence(self) -> "gum::NodeProperty< gum::Potential< double > const * > const &":
        """evidence(self) -> gum::NodeProperty< gum::Potential< double > const * > const &"""
        return _pyAgrum.BayesNetInference_double_evidence(self)


    def softEvidenceNodes(self) -> "gum::NodeSet const &":
        """softEvidenceNodes(self) -> gum::NodeSet const &"""
        return _pyAgrum.BayesNetInference_double_softEvidenceNodes(self)


    def hardEvidenceNodes(self) -> "gum::NodeSet const &":
        """hardEvidenceNodes(self) -> gum::NodeSet const &"""
        return _pyAgrum.BayesNetInference_double_hardEvidenceNodes(self)


    def hardEvidence(self) -> "gum::NodeProperty< gum::Idx > const &":
        """hardEvidence(self) -> gum::NodeProperty< gum::Idx > const &"""
        return _pyAgrum.BayesNetInference_double_hardEvidence(self)

BayesNetInference_double_swigregister = _pyAgrum.BayesNetInference_double_swigregister
BayesNetInference_double_swigregister(BayesNetInference_double)

class LazyPropagation_double(_object):
    """Proxy of C++ gum::LazyPropagation<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LazyPropagation_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LazyPropagation_double, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, BN, arg3, arg4, use_binary_join_tree=True) -> LazyPropagation_double
        __init__(self, BN, arg3, arg4) -> LazyPropagation_double
        __init__(self, BN, arg3) -> LazyPropagation_double
        __init__(self, BN) -> LazyPropagation_double
        """
        this = _pyAgrum.new_LazyPropagation_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_LazyPropagation_double
    __del__ = lambda self: None

    def setTriangulation(self, new_triangulation: 'Triangulation') -> "void":
        """setTriangulation(self, new_triangulation)"""
        return _pyAgrum.LazyPropagation_double_setTriangulation(self, new_triangulation)


    def setRelevantPotentialsFinderType(self, type: 'gum::RelevantPotentialsFinderType') -> "void":
        """setRelevantPotentialsFinderType(self, type)"""
        return _pyAgrum.LazyPropagation_double_setRelevantPotentialsFinderType(self, type)


    def setFindBarrenNodesType(self, type: 'gum::FindBarrenNodesType') -> "void":
        """setFindBarrenNodesType(self, type)"""
        return _pyAgrum.LazyPropagation_double_setFindBarrenNodesType(self, type)


    def joinTree(self) -> "gum::JoinTree const *":
        """joinTree(self) -> CliqueGraph"""
        return _pyAgrum.LazyPropagation_double_joinTree(self)


    def junctionTree(self) -> "gum::JunctionTree const *":
        """junctionTree(self) -> CliqueGraph"""
        return _pyAgrum.LazyPropagation_double_junctionTree(self)


    def evidenceProbability(self) -> "double":
        """evidenceProbability(self) -> double"""
        return _pyAgrum.LazyPropagation_double_evidenceProbability(self)


    def setEvidence(self, evidces):
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
        self.eraseAllEvidence()
        for k,v in evidces.items():
            self.addEvidence(k,v)



    def updateEvidence(self, evidces):
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))

        for k,v in evidces.items():
            if self.hasEvidence(k):
                self.chgEvidence(k,v)
            else:
                self.addEvidence(k,v)



    def setTargets(self, targets):
        if not isinstance(targets, set):
            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))

        self.eraseAllTargets()
        for k in targets:
            self.addTarget(k)



    def hardEvidenceNodes(self) -> "PyObject *":
        """hardEvidenceNodes(self) -> PyObject *"""
        return _pyAgrum.LazyPropagation_double_hardEvidenceNodes(self)


    def softEvidenceNodes(self) -> "PyObject *":
        """softEvidenceNodes(self) -> PyObject *"""
        return _pyAgrum.LazyPropagation_double_softEvidenceNodes(self)


    def targets(self) -> "PyObject *":
        """targets(self) -> PyObject *"""
        return _pyAgrum.LazyPropagation_double_targets(self)


    def jointPosterior(self, list: 'PyObject *') -> "gum::Potential< double >":
        """jointPosterior(self, list) -> Potential_double"""
        return _pyAgrum.LazyPropagation_double_jointPosterior(self, list)


    def addJointTarget(self, list: 'PyObject *') -> "void":
        """addJointTarget(self, list)"""
        return _pyAgrum.LazyPropagation_double_addJointTarget(self, list)


    def eraseJointTarget(self, list: 'PyObject *') -> "void":
        """eraseJointTarget(self, list)"""
        return _pyAgrum.LazyPropagation_double_eraseJointTarget(self, list)


    def isJointTarget(self, list: 'PyObject *') -> "bool":
        """isJointTarget(self, list) -> bool"""
        return _pyAgrum.LazyPropagation_double_isJointTarget(self, list)


    def jointTargets(self) -> "PyObject *":
        """jointTargets(self) -> PyObject *"""
        return _pyAgrum.LazyPropagation_double_jointTargets(self)


    def makeInference(self) -> "void":
        """makeInference(self)"""
        return _pyAgrum.LazyPropagation_double_makeInference(self)


    def posterior(self, *args) -> "gum::Potential< double > const":
        """
        posterior(self, var) -> Potential_double
        posterior(self, nodeName) -> Potential_double
        """
        return _pyAgrum.LazyPropagation_double_posterior(self, *args)


    def BN(self) -> "gum::IBayesNet< double > const &":
        """BN(self) -> IBayesNet_double"""
        return _pyAgrum.LazyPropagation_double_BN(self)


    def addEvidence(self, *args) -> "void":
        """
        addEvidence(self, id, val)
        addEvidence(self, nodeName, val)
        addEvidence(self, id, val)
        addEvidence(self, nodeName, val)
        addEvidence(self, id, vals)
        addEvidence(self, nodeName, vals)
        """
        return _pyAgrum.LazyPropagation_double_addEvidence(self, *args)


    def chgEvidence(self, *args) -> "void":
        """
        chgEvidence(self, id, val)
        chgEvidence(self, nodeName, val)
        chgEvidence(self, id, val)
        chgEvidence(self, nodeName, val)
        chgEvidence(self, id, vals)
        chgEvidence(self, nodeName, vals)
        """
        return _pyAgrum.LazyPropagation_double_chgEvidence(self, *args)


    def hasEvidence(self, *args) -> "bool":
        """
        hasEvidence(self, id) -> bool
        hasEvidence(self, nodeName) -> bool
        """
        return _pyAgrum.LazyPropagation_double_hasEvidence(self, *args)


    def eraseAllEvidence(self) -> "void":
        """eraseAllEvidence(self)"""
        return _pyAgrum.LazyPropagation_double_eraseAllEvidence(self)


    def eraseEvidence(self, *args) -> "void":
        """
        eraseEvidence(self, id)
        eraseEvidence(self, nodeName)
        """
        return _pyAgrum.LazyPropagation_double_eraseEvidence(self, *args)


    def hasHardEvidence(self, nodeName: 'std::string const &') -> "bool":
        """hasHardEvidence(self, nodeName) -> bool"""
        return _pyAgrum.LazyPropagation_double_hasHardEvidence(self, nodeName)


    def hasSoftEvidence(self, *args) -> "bool":
        """
        hasSoftEvidence(self, id) -> bool
        hasSoftEvidence(self, nodeName) -> bool
        """
        return _pyAgrum.LazyPropagation_double_hasSoftEvidence(self, *args)


    def nbrEvidence(self) -> "gum::Size":
        """nbrEvidence(self) -> gum::Size"""
        return _pyAgrum.LazyPropagation_double_nbrEvidence(self)


    def nbrHardEvidence(self) -> "gum::Size":
        """nbrHardEvidence(self) -> gum::Size"""
        return _pyAgrum.LazyPropagation_double_nbrHardEvidence(self)


    def nbrSoftEvidence(self) -> "gum::Size":
        """nbrSoftEvidence(self) -> gum::Size"""
        return _pyAgrum.LazyPropagation_double_nbrSoftEvidence(self)


    def eraseAllTargets(self) -> "void":
        """eraseAllTargets(self)"""
        return _pyAgrum.LazyPropagation_double_eraseAllTargets(self)


    def addAllTargets(self) -> "void":
        """addAllTargets(self)"""
        return _pyAgrum.LazyPropagation_double_addAllTargets(self)


    def addTarget(self, *args) -> "void":
        """
        addTarget(self, target)
        addTarget(self, nodeName)
        """
        return _pyAgrum.LazyPropagation_double_addTarget(self, *args)


    def eraseTarget(self, *args) -> "void":
        """
        eraseTarget(self, target)
        eraseTarget(self, nodeName)
        """
        return _pyAgrum.LazyPropagation_double_eraseTarget(self, *args)


    def isTarget(self, *args) -> "bool":
        """
        isTarget(self, variable) -> bool
        isTarget(self, nodeName) -> bool
        """
        return _pyAgrum.LazyPropagation_double_isTarget(self, *args)


    def nbrTargets(self) -> "gum::Size":
        """nbrTargets(self) -> gum::Size"""
        return _pyAgrum.LazyPropagation_double_nbrTargets(self)


    def H(self, *args) -> "double":
        """
        H(self, X) -> double
        H(self, nodeName) -> double
        """
        return _pyAgrum.LazyPropagation_double_H(self, *args)


    def evidenceImpact(self, *args) -> "gum::Potential< double >":
        """
        evidenceImpact(self, target, evs) -> Potential_double
        evidenceImpact(self, target, evs) -> Potential_double
        """
        return _pyAgrum.LazyPropagation_double_evidenceImpact(self, *args)


    def eraseAllJointTargets(self) -> "void":
        """eraseAllJointTargets(self)"""
        return _pyAgrum.LazyPropagation_double_eraseAllJointTargets(self)


    def eraseAllMarginalTargets(self) -> "void":
        """eraseAllMarginalTargets(self)"""
        return _pyAgrum.LazyPropagation_double_eraseAllMarginalTargets(self)


    def nbrJointTargets(self) -> "gum::Size":
        """nbrJointTargets(self) -> gum::Size"""
        return _pyAgrum.LazyPropagation_double_nbrJointTargets(self)


    def I(self, X: 'gum::NodeId const', Y: 'gum::NodeId const') -> "double":
        """I(self, X, Y) -> double"""
        return _pyAgrum.LazyPropagation_double_I(self, X, Y)


    def VI(self, X: 'gum::NodeId const', Y: 'gum::NodeId const') -> "double":
        """VI(self, X, Y) -> double"""
        return _pyAgrum.LazyPropagation_double_VI(self, X, Y)


    def evidenceJointImpact(self, *args) -> "gum::Potential< double >":
        """
        evidenceJointImpact(self, targets, evs) -> Potential_double
        evidenceJointImpact(self, targets, evs) -> Potential_double
        """
        return _pyAgrum.LazyPropagation_double_evidenceJointImpact(self, *args)

LazyPropagation_double_swigregister = _pyAgrum.LazyPropagation_double_swigregister
LazyPropagation_double_swigregister(LazyPropagation_double)

class ShaferShenoyInference_double(_object):
    """Proxy of C++ gum::ShaferShenoyInference<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShaferShenoyInference_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ShaferShenoyInference_double, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, BN, barren_type, use_binary_join_tree=True) -> ShaferShenoyInference_double
        __init__(self, BN, barren_type) -> ShaferShenoyInference_double
        __init__(self, BN) -> ShaferShenoyInference_double
        """
        this = _pyAgrum.new_ShaferShenoyInference_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_ShaferShenoyInference_double
    __del__ = lambda self: None

    def setTriangulation(self, new_triangulation: 'Triangulation') -> "void":
        """setTriangulation(self, new_triangulation)"""
        return _pyAgrum.ShaferShenoyInference_double_setTriangulation(self, new_triangulation)


    def setFindBarrenNodesType(self, type: 'gum::FindBarrenNodesType') -> "void":
        """setFindBarrenNodesType(self, type)"""
        return _pyAgrum.ShaferShenoyInference_double_setFindBarrenNodesType(self, type)


    def joinTree(self) -> "gum::JoinTree const *":
        """joinTree(self) -> CliqueGraph"""
        return _pyAgrum.ShaferShenoyInference_double_joinTree(self)


    def junctionTree(self) -> "gum::JunctionTree const *":
        """junctionTree(self) -> CliqueGraph"""
        return _pyAgrum.ShaferShenoyInference_double_junctionTree(self)


    def evidenceProbability(self) -> "double":
        """evidenceProbability(self) -> double"""
        return _pyAgrum.ShaferShenoyInference_double_evidenceProbability(self)


    def setEvidence(self, evidces):
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
        self.eraseAllEvidence()
        for k,v in evidces.items():
            self.addEvidence(k,v)



    def updateEvidence(self, evidces):
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))

        for k,v in evidces.items():
            if self.hasEvidence(k):
                self.chgEvidence(k,v)
            else:
                self.addEvidence(k,v)



    def setTargets(self, targets):
        if not isinstance(targets, set):
            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))

        self.eraseAllTargets()
        for k in targets:
            self.addTarget(k)



    def hardEvidenceNodes(self) -> "PyObject *":
        """hardEvidenceNodes(self) -> PyObject *"""
        return _pyAgrum.ShaferShenoyInference_double_hardEvidenceNodes(self)


    def softEvidenceNodes(self) -> "PyObject *":
        """softEvidenceNodes(self) -> PyObject *"""
        return _pyAgrum.ShaferShenoyInference_double_softEvidenceNodes(self)


    def targets(self) -> "PyObject *":
        """targets(self) -> PyObject *"""
        return _pyAgrum.ShaferShenoyInference_double_targets(self)


    def jointPosterior(self, list: 'PyObject *') -> "gum::Potential< double >":
        """jointPosterior(self, list) -> Potential_double"""
        return _pyAgrum.ShaferShenoyInference_double_jointPosterior(self, list)


    def addJointTarget(self, list: 'PyObject *') -> "void":
        """addJointTarget(self, list)"""
        return _pyAgrum.ShaferShenoyInference_double_addJointTarget(self, list)


    def eraseJointTarget(self, list: 'PyObject *') -> "void":
        """eraseJointTarget(self, list)"""
        return _pyAgrum.ShaferShenoyInference_double_eraseJointTarget(self, list)


    def isJointTarget(self, list: 'PyObject *') -> "bool":
        """isJointTarget(self, list) -> bool"""
        return _pyAgrum.ShaferShenoyInference_double_isJointTarget(self, list)


    def jointTargets(self) -> "PyObject *":
        """jointTargets(self) -> PyObject *"""
        return _pyAgrum.ShaferShenoyInference_double_jointTargets(self)


    def makeInference(self) -> "void":
        """makeInference(self)"""
        return _pyAgrum.ShaferShenoyInference_double_makeInference(self)


    def posterior(self, *args) -> "gum::Potential< double > const":
        """
        posterior(self, var) -> Potential_double
        posterior(self, nodeName) -> Potential_double
        """
        return _pyAgrum.ShaferShenoyInference_double_posterior(self, *args)


    def BN(self) -> "gum::IBayesNet< double > const &":
        """BN(self) -> IBayesNet_double"""
        return _pyAgrum.ShaferShenoyInference_double_BN(self)


    def addEvidence(self, *args) -> "void":
        """
        addEvidence(self, id, val)
        addEvidence(self, nodeName, val)
        addEvidence(self, id, val)
        addEvidence(self, nodeName, val)
        addEvidence(self, id, vals)
        addEvidence(self, nodeName, vals)
        """
        return _pyAgrum.ShaferShenoyInference_double_addEvidence(self, *args)


    def chgEvidence(self, *args) -> "void":
        """
        chgEvidence(self, id, val)
        chgEvidence(self, nodeName, val)
        chgEvidence(self, id, val)
        chgEvidence(self, nodeName, val)
        chgEvidence(self, id, vals)
        chgEvidence(self, nodeName, vals)
        """
        return _pyAgrum.ShaferShenoyInference_double_chgEvidence(self, *args)


    def hasEvidence(self, *args) -> "bool":
        """
        hasEvidence(self, id) -> bool
        hasEvidence(self, nodeName) -> bool
        """
        return _pyAgrum.ShaferShenoyInference_double_hasEvidence(self, *args)


    def eraseAllEvidence(self) -> "void":
        """eraseAllEvidence(self)"""
        return _pyAgrum.ShaferShenoyInference_double_eraseAllEvidence(self)


    def eraseEvidence(self, *args) -> "void":
        """
        eraseEvidence(self, id)
        eraseEvidence(self, nodeName)
        """
        return _pyAgrum.ShaferShenoyInference_double_eraseEvidence(self, *args)


    def hasHardEvidence(self, nodeName: 'std::string const &') -> "bool":
        """hasHardEvidence(self, nodeName) -> bool"""
        return _pyAgrum.ShaferShenoyInference_double_hasHardEvidence(self, nodeName)


    def hasSoftEvidence(self, *args) -> "bool":
        """
        hasSoftEvidence(self, id) -> bool
        hasSoftEvidence(self, nodeName) -> bool
        """
        return _pyAgrum.ShaferShenoyInference_double_hasSoftEvidence(self, *args)


    def nbrEvidence(self) -> "gum::Size":
        """nbrEvidence(self) -> gum::Size"""
        return _pyAgrum.ShaferShenoyInference_double_nbrEvidence(self)


    def nbrHardEvidence(self) -> "gum::Size":
        """nbrHardEvidence(self) -> gum::Size"""
        return _pyAgrum.ShaferShenoyInference_double_nbrHardEvidence(self)


    def nbrSoftEvidence(self) -> "gum::Size":
        """nbrSoftEvidence(self) -> gum::Size"""
        return _pyAgrum.ShaferShenoyInference_double_nbrSoftEvidence(self)


    def eraseAllTargets(self) -> "void":
        """eraseAllTargets(self)"""
        return _pyAgrum.ShaferShenoyInference_double_eraseAllTargets(self)


    def addAllTargets(self) -> "void":
        """addAllTargets(self)"""
        return _pyAgrum.ShaferShenoyInference_double_addAllTargets(self)


    def addTarget(self, *args) -> "void":
        """
        addTarget(self, target)
        addTarget(self, nodeName)
        """
        return _pyAgrum.ShaferShenoyInference_double_addTarget(self, *args)


    def eraseTarget(self, *args) -> "void":
        """
        eraseTarget(self, target)
        eraseTarget(self, nodeName)
        """
        return _pyAgrum.ShaferShenoyInference_double_eraseTarget(self, *args)


    def isTarget(self, *args) -> "bool":
        """
        isTarget(self, variable) -> bool
        isTarget(self, nodeName) -> bool
        """
        return _pyAgrum.ShaferShenoyInference_double_isTarget(self, *args)


    def nbrTargets(self) -> "gum::Size":
        """nbrTargets(self) -> gum::Size"""
        return _pyAgrum.ShaferShenoyInference_double_nbrTargets(self)


    def H(self, *args) -> "double":
        """
        H(self, X) -> double
        H(self, nodeName) -> double
        """
        return _pyAgrum.ShaferShenoyInference_double_H(self, *args)


    def evidenceImpact(self, *args) -> "gum::Potential< double >":
        """
        evidenceImpact(self, target, evs) -> Potential_double
        evidenceImpact(self, target, evs) -> Potential_double
        """
        return _pyAgrum.ShaferShenoyInference_double_evidenceImpact(self, *args)


    def eraseAllJointTargets(self) -> "void":
        """eraseAllJointTargets(self)"""
        return _pyAgrum.ShaferShenoyInference_double_eraseAllJointTargets(self)


    def eraseAllMarginalTargets(self) -> "void":
        """eraseAllMarginalTargets(self)"""
        return _pyAgrum.ShaferShenoyInference_double_eraseAllMarginalTargets(self)


    def nbrJointTargets(self) -> "gum::Size":
        """nbrJointTargets(self) -> gum::Size"""
        return _pyAgrum.ShaferShenoyInference_double_nbrJointTargets(self)


    def I(self, X: 'gum::NodeId const', Y: 'gum::NodeId const') -> "double":
        """I(self, X, Y) -> double"""
        return _pyAgrum.ShaferShenoyInference_double_I(self, X, Y)


    def VI(self, X: 'gum::NodeId const', Y: 'gum::NodeId const') -> "double":
        """VI(self, X, Y) -> double"""
        return _pyAgrum.ShaferShenoyInference_double_VI(self, X, Y)


    def evidenceJointImpact(self, *args) -> "gum::Potential< double >":
        """
        evidenceJointImpact(self, targets, evs) -> Potential_double
        evidenceJointImpact(self, targets, evs) -> Potential_double
        """
        return _pyAgrum.ShaferShenoyInference_double_evidenceJointImpact(self, *args)

ShaferShenoyInference_double_swigregister = _pyAgrum.ShaferShenoyInference_double_swigregister
ShaferShenoyInference_double_swigregister(ShaferShenoyInference_double)

class VariableElimination_double(_object):
    """Proxy of C++ gum::VariableElimination<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VariableElimination_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VariableElimination_double, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, BN, relevant_type, arg4) -> VariableElimination_double
        __init__(self, BN, relevant_type) -> VariableElimination_double
        __init__(self, BN) -> VariableElimination_double
        """
        this = _pyAgrum.new_VariableElimination_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_VariableElimination_double
    __del__ = lambda self: None

    def setTriangulation(self, new_triangulation: 'Triangulation') -> "void":
        """setTriangulation(self, new_triangulation)"""
        return _pyAgrum.VariableElimination_double_setTriangulation(self, new_triangulation)


    def setRelevantPotentialsFinderType(self, type: 'gum::RelevantPotentialsFinderType') -> "void":
        """setRelevantPotentialsFinderType(self, type)"""
        return _pyAgrum.VariableElimination_double_setRelevantPotentialsFinderType(self, type)


    def setFindBarrenNodesType(self, type: 'gum::FindBarrenNodesType') -> "void":
        """setFindBarrenNodesType(self, type)"""
        return _pyAgrum.VariableElimination_double_setFindBarrenNodesType(self, type)


    def junctionTree(self, id: 'gum::NodeId const') -> "gum::JunctionTree const *":
        """junctionTree(self, id) -> CliqueGraph"""
        return _pyAgrum.VariableElimination_double_junctionTree(self, id)


    def setEvidence(self, evidces):
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
        self.eraseAllEvidence()
        for k,v in evidces.items():
            self.addEvidence(k,v)



    def updateEvidence(self, evidces):
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))

        for k,v in evidces.items():
            if self.hasEvidence(k):
                self.chgEvidence(k,v)
            else:
                self.addEvidence(k,v)



    def setTargets(self, targets):
        if not isinstance(targets, set):
            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))

        self.eraseAllTargets()
        for k in targets:
            self.addTarget(k)



    def hardEvidenceNodes(self) -> "PyObject *":
        """hardEvidenceNodes(self) -> PyObject *"""
        return _pyAgrum.VariableElimination_double_hardEvidenceNodes(self)


    def softEvidenceNodes(self) -> "PyObject *":
        """softEvidenceNodes(self) -> PyObject *"""
        return _pyAgrum.VariableElimination_double_softEvidenceNodes(self)


    def targets(self) -> "PyObject *":
        """targets(self) -> PyObject *"""
        return _pyAgrum.VariableElimination_double_targets(self)


    def jointPosterior(self, list: 'PyObject *') -> "gum::Potential< double >":
        """jointPosterior(self, list) -> Potential_double"""
        return _pyAgrum.VariableElimination_double_jointPosterior(self, list)


    def addJointTarget(self, list: 'PyObject *') -> "void":
        """addJointTarget(self, list)"""
        return _pyAgrum.VariableElimination_double_addJointTarget(self, list)


    def eraseJointTarget(self, list: 'PyObject *') -> "void":
        """eraseJointTarget(self, list)"""
        return _pyAgrum.VariableElimination_double_eraseJointTarget(self, list)


    def isJointTarget(self, list: 'PyObject *') -> "bool":
        """isJointTarget(self, list) -> bool"""
        return _pyAgrum.VariableElimination_double_isJointTarget(self, list)


    def jointTargets(self) -> "PyObject *":
        """jointTargets(self) -> PyObject *"""
        return _pyAgrum.VariableElimination_double_jointTargets(self)


    def makeInference(self) -> "void":
        """makeInference(self)"""
        return _pyAgrum.VariableElimination_double_makeInference(self)


    def posterior(self, *args) -> "gum::Potential< double > const":
        """
        posterior(self, var) -> Potential_double
        posterior(self, nodeName) -> Potential_double
        """
        return _pyAgrum.VariableElimination_double_posterior(self, *args)


    def BN(self) -> "gum::IBayesNet< double > const &":
        """BN(self) -> IBayesNet_double"""
        return _pyAgrum.VariableElimination_double_BN(self)


    def addEvidence(self, *args) -> "void":
        """
        addEvidence(self, id, val)
        addEvidence(self, nodeName, val)
        addEvidence(self, id, val)
        addEvidence(self, nodeName, val)
        addEvidence(self, id, vals)
        addEvidence(self, nodeName, vals)
        """
        return _pyAgrum.VariableElimination_double_addEvidence(self, *args)


    def chgEvidence(self, *args) -> "void":
        """
        chgEvidence(self, id, val)
        chgEvidence(self, nodeName, val)
        chgEvidence(self, id, val)
        chgEvidence(self, nodeName, val)
        chgEvidence(self, id, vals)
        chgEvidence(self, nodeName, vals)
        """
        return _pyAgrum.VariableElimination_double_chgEvidence(self, *args)


    def hasEvidence(self, *args) -> "bool":
        """
        hasEvidence(self, id) -> bool
        hasEvidence(self, nodeName) -> bool
        """
        return _pyAgrum.VariableElimination_double_hasEvidence(self, *args)


    def eraseAllEvidence(self) -> "void":
        """eraseAllEvidence(self)"""
        return _pyAgrum.VariableElimination_double_eraseAllEvidence(self)


    def eraseEvidence(self, *args) -> "void":
        """
        eraseEvidence(self, id)
        eraseEvidence(self, nodeName)
        """
        return _pyAgrum.VariableElimination_double_eraseEvidence(self, *args)


    def hasHardEvidence(self, nodeName: 'std::string const &') -> "bool":
        """hasHardEvidence(self, nodeName) -> bool"""
        return _pyAgrum.VariableElimination_double_hasHardEvidence(self, nodeName)


    def hasSoftEvidence(self, *args) -> "bool":
        """
        hasSoftEvidence(self, id) -> bool
        hasSoftEvidence(self, nodeName) -> bool
        """
        return _pyAgrum.VariableElimination_double_hasSoftEvidence(self, *args)


    def nbrEvidence(self) -> "gum::Size":
        """nbrEvidence(self) -> gum::Size"""
        return _pyAgrum.VariableElimination_double_nbrEvidence(self)


    def nbrHardEvidence(self) -> "gum::Size":
        """nbrHardEvidence(self) -> gum::Size"""
        return _pyAgrum.VariableElimination_double_nbrHardEvidence(self)


    def nbrSoftEvidence(self) -> "gum::Size":
        """nbrSoftEvidence(self) -> gum::Size"""
        return _pyAgrum.VariableElimination_double_nbrSoftEvidence(self)


    def eraseAllTargets(self) -> "void":
        """eraseAllTargets(self)"""
        return _pyAgrum.VariableElimination_double_eraseAllTargets(self)


    def addAllTargets(self) -> "void":
        """addAllTargets(self)"""
        return _pyAgrum.VariableElimination_double_addAllTargets(self)


    def addTarget(self, *args) -> "void":
        """
        addTarget(self, target)
        addTarget(self, nodeName)
        """
        return _pyAgrum.VariableElimination_double_addTarget(self, *args)


    def eraseTarget(self, *args) -> "void":
        """
        eraseTarget(self, target)
        eraseTarget(self, nodeName)
        """
        return _pyAgrum.VariableElimination_double_eraseTarget(self, *args)


    def isTarget(self, *args) -> "bool":
        """
        isTarget(self, variable) -> bool
        isTarget(self, nodeName) -> bool
        """
        return _pyAgrum.VariableElimination_double_isTarget(self, *args)


    def nbrTargets(self) -> "gum::Size":
        """nbrTargets(self) -> gum::Size"""
        return _pyAgrum.VariableElimination_double_nbrTargets(self)


    def H(self, *args) -> "double":
        """
        H(self, X) -> double
        H(self, nodeName) -> double
        """
        return _pyAgrum.VariableElimination_double_H(self, *args)


    def evidenceImpact(self, *args) -> "gum::Potential< double >":
        """
        evidenceImpact(self, target, evs) -> Potential_double
        evidenceImpact(self, target, evs) -> Potential_double
        """
        return _pyAgrum.VariableElimination_double_evidenceImpact(self, *args)

VariableElimination_double_swigregister = _pyAgrum.VariableElimination_double_swigregister
VariableElimination_double_swigregister(VariableElimination_double)

class GibbsInference_double(ApproximationScheme):
    """Proxy of C++ gum::GibbsInference<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [ApproximationScheme]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GibbsInference_double, name, value)
    __swig_getmethods__ = {}
    for _s in [ApproximationScheme]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GibbsInference_double, name)
    __repr__ = _swig_repr

    def __init__(self, BN: 'IBayesNet_double'):
        """__init__(self, BN) -> GibbsInference_double"""
        this = _pyAgrum.new_GibbsInference_double(BN)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_GibbsInference_double
    __del__ = lambda self: None

    def setEvidence(self, evidces):
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
        self.eraseAllEvidence()
        for k,v in evidces.items():
            self.addEvidence(k,v)



    def updateEvidence(self, evidces):
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))

        for k,v in evidces.items():
            if self.hasEvidence(k):
                self.chgEvidence(k,v)
            else:
                self.addEvidence(k,v)



    def setTargets(self, targets):
        if not isinstance(targets, set):
            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))

        self.eraseAllTargets()
        for k in targets:
            self.addTarget(k)



    def hardEvidenceNodes(self) -> "PyObject *":
        """hardEvidenceNodes(self) -> PyObject *"""
        return _pyAgrum.GibbsInference_double_hardEvidenceNodes(self)


    def softEvidenceNodes(self) -> "PyObject *":
        """softEvidenceNodes(self) -> PyObject *"""
        return _pyAgrum.GibbsInference_double_softEvidenceNodes(self)


    def targets(self) -> "PyObject *":
        """targets(self) -> PyObject *"""
        return _pyAgrum.GibbsInference_double_targets(self)


    def setVerbosity(self, v: 'bool') -> "void":
        """setVerbosity(self, v)"""
        return _pyAgrum.GibbsInference_double_setVerbosity(self, v)


    def setEpsilon(self, eps: 'double') -> "void":
        """setEpsilon(self, eps)"""
        return _pyAgrum.GibbsInference_double_setEpsilon(self, eps)


    def setMinEpsilonRate(self, rate: 'double') -> "void":
        """setMinEpsilonRate(self, rate)"""
        return _pyAgrum.GibbsInference_double_setMinEpsilonRate(self, rate)


    def setMaxIter(self, max: 'gum::Size') -> "void":
        """setMaxIter(self, max)"""
        return _pyAgrum.GibbsInference_double_setMaxIter(self, max)


    def setMaxTime(self, timeout: 'double') -> "void":
        """setMaxTime(self, timeout)"""
        return _pyAgrum.GibbsInference_double_setMaxTime(self, timeout)


    def setPeriodSize(self, p: 'gum::Size') -> "void":
        """setPeriodSize(self, p)"""
        return _pyAgrum.GibbsInference_double_setPeriodSize(self, p)


    def setBurnIn(self, b: 'gum::Size') -> "void":
        """setBurnIn(self, b)"""
        return _pyAgrum.GibbsInference_double_setBurnIn(self, b)


    def verbosity(self) -> "bool":
        """verbosity(self) -> bool"""
        return _pyAgrum.GibbsInference_double_verbosity(self)


    def epsilon(self) -> "double":
        """epsilon(self) -> double"""
        return _pyAgrum.GibbsInference_double_epsilon(self)


    def minEpsilonRate(self) -> "double":
        """minEpsilonRate(self) -> double"""
        return _pyAgrum.GibbsInference_double_minEpsilonRate(self)


    def maxIter(self) -> "gum::Size":
        """maxIter(self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_maxIter(self)


    def maxTime(self) -> "double":
        """maxTime(self) -> double"""
        return _pyAgrum.GibbsInference_double_maxTime(self)


    def periodSize(self) -> "gum::Size":
        """periodSize(self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_periodSize(self)


    def burnIn(self) -> "gum::Size":
        """burnIn(self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_burnIn(self)


    def nbrIterations(self) -> "gum::Size":
        """nbrIterations(self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_nbrIterations(self)


    def currentTime(self) -> "double":
        """currentTime(self) -> double"""
        return _pyAgrum.GibbsInference_double_currentTime(self)


    def messageApproximationScheme(self) -> "std::string":
        """messageApproximationScheme(self) -> std::string"""
        return _pyAgrum.GibbsInference_double_messageApproximationScheme(self)


    def history(self) -> "std::vector< double,std::allocator< double > > const &":
        """history(self) -> Vector_double"""
        return _pyAgrum.GibbsInference_double_history(self)


    def asIApproximationSchemeConfiguration(self) -> "gum::IApproximationSchemeConfiguration const &":
        """asIApproximationSchemeConfiguration(self) -> IApproximationSchemeConfiguration"""
        return _pyAgrum.GibbsInference_double_asIApproximationSchemeConfiguration(self)


    def makeInference(self) -> "void":
        """makeInference(self)"""
        return _pyAgrum.GibbsInference_double_makeInference(self)


    def posterior(self, *args) -> "gum::Potential< double > const":
        """
        posterior(self, var) -> Potential_double
        posterior(self, nodeName) -> Potential_double
        """
        return _pyAgrum.GibbsInference_double_posterior(self, *args)


    def BN(self) -> "gum::IBayesNet< double > const &":
        """BN(self) -> IBayesNet_double"""
        return _pyAgrum.GibbsInference_double_BN(self)


    def addEvidence(self, *args) -> "void":
        """
        addEvidence(self, id, val)
        addEvidence(self, nodeName, val)
        addEvidence(self, id, val)
        addEvidence(self, nodeName, val)
        addEvidence(self, id, vals)
        addEvidence(self, nodeName, vals)
        """
        return _pyAgrum.GibbsInference_double_addEvidence(self, *args)


    def chgEvidence(self, *args) -> "void":
        """
        chgEvidence(self, id, val)
        chgEvidence(self, nodeName, val)
        chgEvidence(self, id, val)
        chgEvidence(self, nodeName, val)
        chgEvidence(self, id, vals)
        chgEvidence(self, nodeName, vals)
        """
        return _pyAgrum.GibbsInference_double_chgEvidence(self, *args)


    def hasEvidence(self, *args) -> "bool":
        """
        hasEvidence(self, id) -> bool
        hasEvidence(self, nodeName) -> bool
        """
        return _pyAgrum.GibbsInference_double_hasEvidence(self, *args)


    def eraseAllEvidence(self) -> "void":
        """eraseAllEvidence(self)"""
        return _pyAgrum.GibbsInference_double_eraseAllEvidence(self)


    def eraseEvidence(self, *args) -> "void":
        """
        eraseEvidence(self, id)
        eraseEvidence(self, nodeName)
        """
        return _pyAgrum.GibbsInference_double_eraseEvidence(self, *args)


    def hasHardEvidence(self, nodeName: 'std::string const &') -> "bool":
        """hasHardEvidence(self, nodeName) -> bool"""
        return _pyAgrum.GibbsInference_double_hasHardEvidence(self, nodeName)


    def hasSoftEvidence(self, *args) -> "bool":
        """
        hasSoftEvidence(self, id) -> bool
        hasSoftEvidence(self, nodeName) -> bool
        """
        return _pyAgrum.GibbsInference_double_hasSoftEvidence(self, *args)


    def nbrEvidence(self) -> "gum::Size":
        """nbrEvidence(self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_nbrEvidence(self)


    def nbrHardEvidence(self) -> "gum::Size":
        """nbrHardEvidence(self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_nbrHardEvidence(self)


    def nbrSoftEvidence(self) -> "gum::Size":
        """nbrSoftEvidence(self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_nbrSoftEvidence(self)


    def eraseAllTargets(self) -> "void":
        """eraseAllTargets(self)"""
        return _pyAgrum.GibbsInference_double_eraseAllTargets(self)


    def addAllTargets(self) -> "void":
        """addAllTargets(self)"""
        return _pyAgrum.GibbsInference_double_addAllTargets(self)


    def addTarget(self, *args) -> "void":
        """
        addTarget(self, target)
        addTarget(self, nodeName)
        """
        return _pyAgrum.GibbsInference_double_addTarget(self, *args)


    def eraseTarget(self, *args) -> "void":
        """
        eraseTarget(self, target)
        eraseTarget(self, nodeName)
        """
        return _pyAgrum.GibbsInference_double_eraseTarget(self, *args)


    def isTarget(self, *args) -> "bool":
        """
        isTarget(self, variable) -> bool
        isTarget(self, nodeName) -> bool
        """
        return _pyAgrum.GibbsInference_double_isTarget(self, *args)


    def nbrTargets(self) -> "gum::Size":
        """nbrTargets(self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_nbrTargets(self)


    def H(self, *args) -> "double":
        """
        H(self, X) -> double
        H(self, nodeName) -> double
        """
        return _pyAgrum.GibbsInference_double_H(self, *args)


    def evidenceImpact(self, *args) -> "gum::Potential< double >":
        """
        evidenceImpact(self, target, evs) -> Potential_double
        evidenceImpact(self, target, evs) -> Potential_double
        """
        return _pyAgrum.GibbsInference_double_evidenceImpact(self, *args)

GibbsInference_double_swigregister = _pyAgrum.GibbsInference_double_swigregister
GibbsInference_double_swigregister(GibbsInference_double)

class LoopyBeliefPropagation_double(ApproximationScheme):
    """Proxy of C++ gum::LoopyBeliefPropagation<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [ApproximationScheme]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoopyBeliefPropagation_double, name, value)
    __swig_getmethods__ = {}
    for _s in [ApproximationScheme]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoopyBeliefPropagation_double, name)
    __repr__ = _swig_repr

    def __init__(self, BN: 'IBayesNet_double'):
        """__init__(self, BN) -> LoopyBeliefPropagation_double"""
        this = _pyAgrum.new_LoopyBeliefPropagation_double(BN)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_LoopyBeliefPropagation_double
    __del__ = lambda self: None

    def setEvidence(self, evidces):
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
        self.eraseAllEvidence()
        for k,v in evidces.items():
            self.addEvidence(k,v)



    def updateEvidence(self, evidces):
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))

        for k,v in evidces.items():
            if self.hasEvidence(k):
                self.chgEvidence(k,v)
            else:
                self.addEvidence(k,v)



    def setTargets(self, targets):
        if not isinstance(targets, set):
            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))

        self.eraseAllTargets()
        for k in targets:
            self.addTarget(k)



    def hardEvidenceNodes(self) -> "PyObject *":
        """hardEvidenceNodes(self) -> PyObject *"""
        return _pyAgrum.LoopyBeliefPropagation_double_hardEvidenceNodes(self)


    def softEvidenceNodes(self) -> "PyObject *":
        """softEvidenceNodes(self) -> PyObject *"""
        return _pyAgrum.LoopyBeliefPropagation_double_softEvidenceNodes(self)


    def targets(self) -> "PyObject *":
        """targets(self) -> PyObject *"""
        return _pyAgrum.LoopyBeliefPropagation_double_targets(self)


    def setVerbosity(self, v: 'bool') -> "void":
        """setVerbosity(self, v)"""
        return _pyAgrum.LoopyBeliefPropagation_double_setVerbosity(self, v)


    def setEpsilon(self, eps: 'double') -> "void":
        """setEpsilon(self, eps)"""
        return _pyAgrum.LoopyBeliefPropagation_double_setEpsilon(self, eps)


    def setMinEpsilonRate(self, rate: 'double') -> "void":
        """setMinEpsilonRate(self, rate)"""
        return _pyAgrum.LoopyBeliefPropagation_double_setMinEpsilonRate(self, rate)


    def setMaxIter(self, max: 'gum::Size') -> "void":
        """setMaxIter(self, max)"""
        return _pyAgrum.LoopyBeliefPropagation_double_setMaxIter(self, max)


    def setMaxTime(self, timeout: 'double') -> "void":
        """setMaxTime(self, timeout)"""
        return _pyAgrum.LoopyBeliefPropagation_double_setMaxTime(self, timeout)


    def setPeriodSize(self, p: 'gum::Size') -> "void":
        """setPeriodSize(self, p)"""
        return _pyAgrum.LoopyBeliefPropagation_double_setPeriodSize(self, p)


    def setBurnIn(self, b: 'gum::Size') -> "void":
        """setBurnIn(self, b)"""
        return _pyAgrum.LoopyBeliefPropagation_double_setBurnIn(self, b)


    def verbosity(self) -> "bool":
        """verbosity(self) -> bool"""
        return _pyAgrum.LoopyBeliefPropagation_double_verbosity(self)


    def epsilon(self) -> "double":
        """epsilon(self) -> double"""
        return _pyAgrum.LoopyBeliefPropagation_double_epsilon(self)


    def minEpsilonRate(self) -> "double":
        """minEpsilonRate(self) -> double"""
        return _pyAgrum.LoopyBeliefPropagation_double_minEpsilonRate(self)


    def maxIter(self) -> "gum::Size":
        """maxIter(self) -> gum::Size"""
        return _pyAgrum.LoopyBeliefPropagation_double_maxIter(self)


    def maxTime(self) -> "double":
        """maxTime(self) -> double"""
        return _pyAgrum.LoopyBeliefPropagation_double_maxTime(self)


    def periodSize(self) -> "gum::Size":
        """periodSize(self) -> gum::Size"""
        return _pyAgrum.LoopyBeliefPropagation_double_periodSize(self)


    def burnIn(self) -> "gum::Size":
        """burnIn(self) -> gum::Size"""
        return _pyAgrum.LoopyBeliefPropagation_double_burnIn(self)


    def nbrIterations(self) -> "gum::Size":
        """nbrIterations(self) -> gum::Size"""
        return _pyAgrum.LoopyBeliefPropagation_double_nbrIterations(self)


    def currentTime(self) -> "double":
        """currentTime(self) -> double"""
        return _pyAgrum.LoopyBeliefPropagation_double_currentTime(self)


    def messageApproximationScheme(self) -> "std::string":
        """messageApproximationScheme(self) -> std::string"""
        return _pyAgrum.LoopyBeliefPropagation_double_messageApproximationScheme(self)


    def history(self) -> "std::vector< double,std::allocator< double > > const &":
        """history(self) -> Vector_double"""
        return _pyAgrum.LoopyBeliefPropagation_double_history(self)


    def asIApproximationSchemeConfiguration(self) -> "gum::IApproximationSchemeConfiguration const &":
        """asIApproximationSchemeConfiguration(self) -> IApproximationSchemeConfiguration"""
        return _pyAgrum.LoopyBeliefPropagation_double_asIApproximationSchemeConfiguration(self)


    def makeInference(self) -> "void":
        """makeInference(self)"""
        return _pyAgrum.LoopyBeliefPropagation_double_makeInference(self)


    def posterior(self, *args) -> "gum::Potential< double > const":
        """
        posterior(self, var) -> Potential_double
        posterior(self, nodeName) -> Potential_double
        """
        return _pyAgrum.LoopyBeliefPropagation_double_posterior(self, *args)


    def BN(self) -> "gum::IBayesNet< double > const &":
        """BN(self) -> IBayesNet_double"""
        return _pyAgrum.LoopyBeliefPropagation_double_BN(self)


    def addEvidence(self, *args) -> "void":
        """
        addEvidence(self, id, val)
        addEvidence(self, nodeName, val)
        addEvidence(self, id, val)
        addEvidence(self, nodeName, val)
        addEvidence(self, id, vals)
        addEvidence(self, nodeName, vals)
        """
        return _pyAgrum.LoopyBeliefPropagation_double_addEvidence(self, *args)


    def chgEvidence(self, *args) -> "void":
        """
        chgEvidence(self, id, val)
        chgEvidence(self, nodeName, val)
        chgEvidence(self, id, val)
        chgEvidence(self, nodeName, val)
        chgEvidence(self, id, vals)
        chgEvidence(self, nodeName, vals)
        """
        return _pyAgrum.LoopyBeliefPropagation_double_chgEvidence(self, *args)


    def hasEvidence(self, *args) -> "bool":
        """
        hasEvidence(self, id) -> bool
        hasEvidence(self, nodeName) -> bool
        """
        return _pyAgrum.LoopyBeliefPropagation_double_hasEvidence(self, *args)


    def eraseAllEvidence(self) -> "void":
        """eraseAllEvidence(self)"""
        return _pyAgrum.LoopyBeliefPropagation_double_eraseAllEvidence(self)


    def eraseEvidence(self, *args) -> "void":
        """
        eraseEvidence(self, id)
        eraseEvidence(self, nodeName)
        """
        return _pyAgrum.LoopyBeliefPropagation_double_eraseEvidence(self, *args)


    def hasHardEvidence(self, nodeName: 'std::string const &') -> "bool":
        """hasHardEvidence(self, nodeName) -> bool"""
        return _pyAgrum.LoopyBeliefPropagation_double_hasHardEvidence(self, nodeName)


    def hasSoftEvidence(self, *args) -> "bool":
        """
        hasSoftEvidence(self, id) -> bool
        hasSoftEvidence(self, nodeName) -> bool
        """
        return _pyAgrum.LoopyBeliefPropagation_double_hasSoftEvidence(self, *args)


    def nbrEvidence(self) -> "gum::Size":
        """nbrEvidence(self) -> gum::Size"""
        return _pyAgrum.LoopyBeliefPropagation_double_nbrEvidence(self)


    def nbrHardEvidence(self) -> "gum::Size":
        """nbrHardEvidence(self) -> gum::Size"""
        return _pyAgrum.LoopyBeliefPropagation_double_nbrHardEvidence(self)


    def nbrSoftEvidence(self) -> "gum::Size":
        """nbrSoftEvidence(self) -> gum::Size"""
        return _pyAgrum.LoopyBeliefPropagation_double_nbrSoftEvidence(self)


    def eraseAllTargets(self) -> "void":
        """eraseAllTargets(self)"""
        return _pyAgrum.LoopyBeliefPropagation_double_eraseAllTargets(self)


    def addAllTargets(self) -> "void":
        """addAllTargets(self)"""
        return _pyAgrum.LoopyBeliefPropagation_double_addAllTargets(self)


    def addTarget(self, *args) -> "void":
        """
        addTarget(self, target)
        addTarget(self, nodeName)
        """
        return _pyAgrum.LoopyBeliefPropagation_double_addTarget(self, *args)


    def eraseTarget(self, *args) -> "void":
        """
        eraseTarget(self, target)
        eraseTarget(self, nodeName)
        """
        return _pyAgrum.LoopyBeliefPropagation_double_eraseTarget(self, *args)


    def isTarget(self, *args) -> "bool":
        """
        isTarget(self, variable) -> bool
        isTarget(self, nodeName) -> bool
        """
        return _pyAgrum.LoopyBeliefPropagation_double_isTarget(self, *args)


    def nbrTargets(self) -> "gum::Size":
        """nbrTargets(self) -> gum::Size"""
        return _pyAgrum.LoopyBeliefPropagation_double_nbrTargets(self)


    def H(self, *args) -> "double":
        """
        H(self, X) -> double
        H(self, nodeName) -> double
        """
        return _pyAgrum.LoopyBeliefPropagation_double_H(self, *args)


    def evidenceImpact(self, *args) -> "gum::Potential< double >":
        """
        evidenceImpact(self, target, evs) -> Potential_double
        evidenceImpact(self, target, evs) -> Potential_double
        """
        return _pyAgrum.LoopyBeliefPropagation_double_evidenceImpact(self, *args)

LoopyBeliefPropagation_double_swigregister = _pyAgrum.LoopyBeliefPropagation_double_swigregister
LoopyBeliefPropagation_double_swigregister(LoopyBeliefPropagation_double)

class BruteForceKL_double(_object):
    """Proxy of C++ gum::BruteForceKL<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BruteForceKL_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BruteForceKL_double, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, P, Q) -> BruteForceKL_double
        __init__(self, kl) -> BruteForceKL_double
        """
        this = _pyAgrum.new_BruteForceKL_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_BruteForceKL_double
    __del__ = lambda self: None

    def compute(self) -> "PyObject *":
        """compute(self) -> PyObject *"""
        return _pyAgrum.BruteForceKL_double_compute(self)

BruteForceKL_double_swigregister = _pyAgrum.BruteForceKL_double_swigregister
BruteForceKL_double_swigregister(BruteForceKL_double)

class GibbsKL_double(ApproximationScheme):
    """Proxy of C++ gum::GibbsKL<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [ApproximationScheme]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GibbsKL_double, name, value)
    __swig_getmethods__ = {}
    for _s in [ApproximationScheme]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GibbsKL_double, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, P, Q) -> GibbsKL_double
        __init__(self, kl) -> GibbsKL_double
        """
        this = _pyAgrum.new_GibbsKL_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_GibbsKL_double
    __del__ = lambda self: None

    def compute(self) -> "PyObject *":
        """compute(self) -> PyObject *"""
        return _pyAgrum.GibbsKL_double_compute(self)


    def setVerbosity(self, v: 'bool') -> "void":
        """setVerbosity(self, v)"""
        return _pyAgrum.GibbsKL_double_setVerbosity(self, v)


    def setEpsilon(self, eps: 'double') -> "void":
        """setEpsilon(self, eps)"""
        return _pyAgrum.GibbsKL_double_setEpsilon(self, eps)


    def setMinEpsilonRate(self, rate: 'double') -> "void":
        """setMinEpsilonRate(self, rate)"""
        return _pyAgrum.GibbsKL_double_setMinEpsilonRate(self, rate)


    def setMaxIter(self, max: 'gum::Size') -> "void":
        """setMaxIter(self, max)"""
        return _pyAgrum.GibbsKL_double_setMaxIter(self, max)


    def setMaxTime(self, timeout: 'double') -> "void":
        """setMaxTime(self, timeout)"""
        return _pyAgrum.GibbsKL_double_setMaxTime(self, timeout)


    def setPeriodSize(self, p: 'gum::Size') -> "void":
        """setPeriodSize(self, p)"""
        return _pyAgrum.GibbsKL_double_setPeriodSize(self, p)


    def setBurnIn(self, b: 'gum::Size') -> "void":
        """setBurnIn(self, b)"""
        return _pyAgrum.GibbsKL_double_setBurnIn(self, b)


    def verbosity(self) -> "bool":
        """verbosity(self) -> bool"""
        return _pyAgrum.GibbsKL_double_verbosity(self)


    def epsilon(self) -> "double":
        """epsilon(self) -> double"""
        return _pyAgrum.GibbsKL_double_epsilon(self)


    def minEpsilonRate(self) -> "double":
        """minEpsilonRate(self) -> double"""
        return _pyAgrum.GibbsKL_double_minEpsilonRate(self)


    def maxIter(self) -> "gum::Size":
        """maxIter(self) -> gum::Size"""
        return _pyAgrum.GibbsKL_double_maxIter(self)


    def maxTime(self) -> "double":
        """maxTime(self) -> double"""
        return _pyAgrum.GibbsKL_double_maxTime(self)


    def periodSize(self) -> "gum::Size":
        """periodSize(self) -> gum::Size"""
        return _pyAgrum.GibbsKL_double_periodSize(self)


    def burnIn(self) -> "gum::Size":
        """burnIn(self) -> gum::Size"""
        return _pyAgrum.GibbsKL_double_burnIn(self)


    def nbrIterations(self) -> "gum::Size":
        """nbrIterations(self) -> gum::Size"""
        return _pyAgrum.GibbsKL_double_nbrIterations(self)


    def currentTime(self) -> "double":
        """currentTime(self) -> double"""
        return _pyAgrum.GibbsKL_double_currentTime(self)


    def messageApproximationScheme(self) -> "std::string":
        """messageApproximationScheme(self) -> std::string"""
        return _pyAgrum.GibbsKL_double_messageApproximationScheme(self)


    def history(self) -> "std::vector< double,std::allocator< double > > const &":
        """history(self) -> Vector_double"""
        return _pyAgrum.GibbsKL_double_history(self)


    def asIApproximationSchemeConfiguration(self) -> "gum::IApproximationSchemeConfiguration const &":
        """asIApproximationSchemeConfiguration(self) -> IApproximationSchemeConfiguration"""
        return _pyAgrum.GibbsKL_double_asIApproximationSchemeConfiguration(self)

GibbsKL_double_swigregister = _pyAgrum.GibbsKL_double_swigregister
GibbsKL_double_swigregister(GibbsKL_double)

class CredalNet_double(_object):
    """Proxy of C++ gum::credal::CredalNet<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CredalNet_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CredalNet_double, name)
    __repr__ = _swig_repr
    NodeType_Precise = _pyAgrum.CredalNet_double_NodeType_Precise
    NodeType_Credal = _pyAgrum.CredalNet_double_NodeType_Credal
    NodeType_Vacuous = _pyAgrum.CredalNet_double_NodeType_Vacuous
    NodeType_Indic = _pyAgrum.CredalNet_double_NodeType_Indic

    def __init__(self, *args):
        """
        __init__(self) -> CredalNet_double
        __init__(self, src_min_num, src_max_den) -> CredalNet_double
        __init__(self, src_min_num) -> CredalNet_double
        __init__(self, src_min_num, src_max_den) -> CredalNet_double
        __init__(self, src_min_num) -> CredalNet_double
        """
        this = _pyAgrum.new_CredalNet_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_CredalNet_double
    __del__ = lambda self: None

    def addNode(self, name: 'std::string const &', card: 'gum::Size const &') -> "gum::NodeId":
        """addNode(self, name, card) -> gum::NodeId"""
        return _pyAgrum.CredalNet_double_addNode(self, name, card)


    def addArc(self, tail: 'gum::NodeId const &', head: 'gum::NodeId const &') -> "void":
        """addArc(self, tail, head)"""
        return _pyAgrum.CredalNet_double_addArc(self, tail, head)


    def setCPTs(self, id: 'gum::NodeId const &', cpt: 'std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > > const &') -> "void":
        """setCPTs(self, id, cpt)"""
        return _pyAgrum.CredalNet_double_setCPTs(self, id, cpt)


    def setCPT(self, *args) -> "void":
        """
        setCPT(self, id, entry, cpt)
        setCPT(self, id, ins, cpt)
        """
        return _pyAgrum.CredalNet_double_setCPT(self, *args)


    def fillConstraints(self, id: 'gum::NodeId const &', lower: 'Vector_double', upper: 'Vector_double') -> "void":
        """fillConstraints(self, id, lower, upper)"""
        return _pyAgrum.CredalNet_double_fillConstraints(self, id, lower, upper)


    def fillConstraint(self, *args) -> "void":
        """
        fillConstraint(self, id, entry, lower, upper)
        fillConstraint(self, id, ins, lower, upper)
        """
        return _pyAgrum.CredalNet_double_fillConstraint(self, *args)


    def instantiation(self, id: 'gum::NodeId const &') -> "gum::Instantiation":
        """instantiation(self, id) -> Instantiation"""
        return _pyAgrum.CredalNet_double_instantiation(self, id)


    def domainSize(self, id: 'gum::NodeId const &') -> "gum::Size":
        """domainSize(self, id) -> gum::Size"""
        return _pyAgrum.CredalNet_double_domainSize(self, id)


    def bnToCredal(self, beta: 'double const', oneNet: 'bool const', keepZeroes: 'bool const'=False) -> "void":
        """
        bnToCredal(self, beta, oneNet, keepZeroes=False)
        bnToCredal(self, beta, oneNet)
        """
        return _pyAgrum.CredalNet_double_bnToCredal(self, beta, oneNet, keepZeroes)


    def intervalToCredalWithFiles(self) -> "void":
        """intervalToCredalWithFiles(self)"""
        return _pyAgrum.CredalNet_double_intervalToCredalWithFiles(self)


    def intervalToCredal(self) -> "void":
        """intervalToCredal(self)"""
        return _pyAgrum.CredalNet_double_intervalToCredal(self)


    def lagrangeNormalization(self) -> "void":
        """lagrangeNormalization(self)"""
        return _pyAgrum.CredalNet_double_lagrangeNormalization(self)


    def idmLearning(self, s: 'gum::Idx const'=0, keepZeroes: 'bool const'=False) -> "void":
        """
        idmLearning(self, s=0, keepZeroes=False)
        idmLearning(self, s=0)
        idmLearning(self)
        """
        return _pyAgrum.CredalNet_double_idmLearning(self, s, keepZeroes)


    def approximatedBinarization(self) -> "void":
        """approximatedBinarization(self)"""
        return _pyAgrum.CredalNet_double_approximatedBinarization(self)


    def saveBNsMinMax(self, min_path: 'std::string const &', max_path: 'std::string const &') -> "void":
        """saveBNsMinMax(self, min_path, max_path)"""
        return _pyAgrum.CredalNet_double_saveBNsMinMax(self, min_path, max_path)


    def __str__(self) -> "std::string":
        """__str__(self) -> std::string"""
        return _pyAgrum.CredalNet_double___str__(self)


    def computeCPTMinMax(self) -> "void":
        """computeCPTMinMax(self)"""
        return _pyAgrum.CredalNet_double_computeCPTMinMax(self)


    def src_bn(self) -> "gum::BayesNet< double > const &":
        """src_bn(self) -> BayesNet_double"""
        return _pyAgrum.CredalNet_double_src_bn(self)


    def current_bn(self) -> "gum::BayesNet< double > const &":
        """current_bn(self) -> BayesNet_double"""
        return _pyAgrum.CredalNet_double_current_bn(self)


    def credalNet_currentCpt(self) -> "gum::NodeProperty< std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > > > const &":
        """credalNet_currentCpt(self) -> gum::NodeProperty< std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > > > const &"""
        return _pyAgrum.CredalNet_double_credalNet_currentCpt(self)


    def credalNet_srcCpt(self) -> "gum::NodeProperty< std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > > > const &":
        """credalNet_srcCpt(self) -> gum::NodeProperty< std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > > > const &"""
        return _pyAgrum.CredalNet_double_credalNet_srcCpt(self)


    def currentNodeType(self, id: 'gum::NodeId const &') -> "gum::credal::CredalNet< double >::NodeType":
        """currentNodeType(self, id) -> gum::credal::CredalNet< double >::NodeType"""
        return _pyAgrum.CredalNet_double_currentNodeType(self, id)


    def nodeType(self, id: 'gum::NodeId const &') -> "gum::credal::CredalNet< double >::NodeType":
        """nodeType(self, id) -> gum::credal::CredalNet< double >::NodeType"""
        return _pyAgrum.CredalNet_double_nodeType(self, id)


    def epsilonMin(self) -> "double const &":
        """epsilonMin(self) -> double const &"""
        return _pyAgrum.CredalNet_double_epsilonMin(self)


    def epsilonMax(self) -> "double const &":
        """epsilonMax(self) -> double const &"""
        return _pyAgrum.CredalNet_double_epsilonMax(self)


    def epsilonMean(self) -> "double const &":
        """epsilonMean(self) -> double const &"""
        return _pyAgrum.CredalNet_double_epsilonMean(self)


    def isSeparatelySpecified(self) -> "bool const":
        """isSeparatelySpecified(self) -> bool const"""
        return _pyAgrum.CredalNet_double_isSeparatelySpecified(self)


    def hasComputedCPTMinMax(self) -> "bool const":
        """hasComputedCPTMinMax(self) -> bool const"""
        return _pyAgrum.CredalNet_double_hasComputedCPTMinMax(self)


    def get_CPT_min(self) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &":
        """get_CPT_min(self) -> std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &"""
        return _pyAgrum.CredalNet_double_get_CPT_min(self)


    def get_CPT_max(self) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &":
        """get_CPT_max(self) -> std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &"""
        return _pyAgrum.CredalNet_double_get_CPT_max(self)

CredalNet_double_swigregister = _pyAgrum.CredalNet_double_swigregister
CredalNet_double_swigregister(CredalNet_double)

class CNMonteCarloSampling_double(_object):
    """Proxy of C++ gum::credal::CNMonteCarloSampling<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNMonteCarloSampling_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CNMonteCarloSampling_double, name)
    __repr__ = _swig_repr

    def __init__(self, credalNet: 'CredalNet_double'):
        """__init__(self, credalNet) -> CNMonteCarloSampling_double"""
        this = _pyAgrum.new_CNMonteCarloSampling_double(credalNet)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_CNMonteCarloSampling_double
    __del__ = lambda self: None

    def makeInference(self) -> "void":
        """makeInference(self)"""
        return _pyAgrum.CNMonteCarloSampling_double_makeInference(self)


    def insertEvidenceFile(self, path: 'std::string const &') -> "void":
        """insertEvidenceFile(self, path)"""
        return _pyAgrum.CNMonteCarloSampling_double_insertEvidenceFile(self, path)


    def setVerbosity(self, v: 'bool') -> "void":
        """setVerbosity(self, v)"""
        return _pyAgrum.CNMonteCarloSampling_double_setVerbosity(self, v)


    def setEpsilon(self, eps: 'double') -> "void":
        """setEpsilon(self, eps)"""
        return _pyAgrum.CNMonteCarloSampling_double_setEpsilon(self, eps)


    def setMinEpsilonRate(self, rate: 'double') -> "void":
        """setMinEpsilonRate(self, rate)"""
        return _pyAgrum.CNMonteCarloSampling_double_setMinEpsilonRate(self, rate)


    def setMaxIter(self, max: 'gum::Size') -> "void":
        """setMaxIter(self, max)"""
        return _pyAgrum.CNMonteCarloSampling_double_setMaxIter(self, max)


    def setMaxTime(self, timeout: 'double') -> "void":
        """setMaxTime(self, timeout)"""
        return _pyAgrum.CNMonteCarloSampling_double_setMaxTime(self, timeout)


    def setPeriodSize(self, p: 'gum::Size') -> "void":
        """setPeriodSize(self, p)"""
        return _pyAgrum.CNMonteCarloSampling_double_setPeriodSize(self, p)


    def setBurnIn(self, b: 'gum::Size') -> "void":
        """setBurnIn(self, b)"""
        return _pyAgrum.CNMonteCarloSampling_double_setBurnIn(self, b)


    def verbosity(self) -> "bool":
        """verbosity(self) -> bool"""
        return _pyAgrum.CNMonteCarloSampling_double_verbosity(self)


    def epsilon(self) -> "double":
        """epsilon(self) -> double"""
        return _pyAgrum.CNMonteCarloSampling_double_epsilon(self)


    def minEpsilonRate(self) -> "double":
        """minEpsilonRate(self) -> double"""
        return _pyAgrum.CNMonteCarloSampling_double_minEpsilonRate(self)


    def maxIter(self) -> "gum::Size":
        """maxIter(self) -> gum::Size"""
        return _pyAgrum.CNMonteCarloSampling_double_maxIter(self)


    def maxTime(self) -> "double":
        """maxTime(self) -> double"""
        return _pyAgrum.CNMonteCarloSampling_double_maxTime(self)


    def periodSize(self) -> "gum::Size":
        """periodSize(self) -> gum::Size"""
        return _pyAgrum.CNMonteCarloSampling_double_periodSize(self)


    def burnIn(self) -> "gum::Size":
        """burnIn(self) -> gum::Size"""
        return _pyAgrum.CNMonteCarloSampling_double_burnIn(self)


    def nbrIterations(self) -> "gum::Size":
        """nbrIterations(self) -> gum::Size"""
        return _pyAgrum.CNMonteCarloSampling_double_nbrIterations(self)


    def currentTime(self) -> "double":
        """currentTime(self) -> double"""
        return _pyAgrum.CNMonteCarloSampling_double_currentTime(self)


    def messageApproximationScheme(self) -> "std::string":
        """messageApproximationScheme(self) -> std::string"""
        return _pyAgrum.CNMonteCarloSampling_double_messageApproximationScheme(self)


    def history(self) -> "std::vector< double,std::allocator< double > > const &":
        """history(self) -> Vector_double"""
        return _pyAgrum.CNMonteCarloSampling_double_history(self)


    def asIApproximationSchemeConfiguration(self) -> "gum::IApproximationSchemeConfiguration const &":
        """asIApproximationSchemeConfiguration(self) -> IApproximationSchemeConfiguration"""
        return _pyAgrum.CNMonteCarloSampling_double_asIApproximationSchemeConfiguration(self)


    def setRepetitiveInd(self, flag: 'bool const') -> "void":
        """setRepetitiveInd(self, flag)"""
        return _pyAgrum.CNMonteCarloSampling_double_setRepetitiveInd(self, flag)


    def marginalMax(self, *args) -> "std::vector< double,std::allocator< double > > const &":
        """
        marginalMax(self, id) -> Vector_double
        marginalMax(self, name) -> Vector_double
        """
        return _pyAgrum.CNMonteCarloSampling_double_marginalMax(self, *args)


    def marginalMin(self, *args) -> "std::vector< double,std::allocator< double > > const &":
        """
        marginalMin(self, id) -> Vector_double
        marginalMin(self, name) -> Vector_double
        """
        return _pyAgrum.CNMonteCarloSampling_double_marginalMin(self, *args)


    def insertModalsFile(self, path: 'std::string const &') -> "void":
        """insertModalsFile(self, path)"""
        return _pyAgrum.CNMonteCarloSampling_double_insertModalsFile(self, path)


    def dynamicExpMax(self, varName: 'std::string const &') -> "std::vector< double,std::allocator< double > > const &":
        """dynamicExpMax(self, varName) -> Vector_double"""
        return _pyAgrum.CNMonteCarloSampling_double_dynamicExpMax(self, varName)


    def dynamicExpMin(self, varName: 'std::string const &') -> "std::vector< double,std::allocator< double > > const &":
        """dynamicExpMin(self, varName) -> Vector_double"""
        return _pyAgrum.CNMonteCarloSampling_double_dynamicExpMin(self, varName)

CNMonteCarloSampling_double_swigregister = _pyAgrum.CNMonteCarloSampling_double_swigregister
CNMonteCarloSampling_double_swigregister(CNMonteCarloSampling_double)

class CNLoopyPropagation_double(_object):
    """Proxy of C++ gum::credal::CNLoopyPropagation<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNLoopyPropagation_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CNLoopyPropagation_double, name)
    __repr__ = _swig_repr
    InferenceType_nodeToNeighbours = _pyAgrum.CNLoopyPropagation_double_InferenceType_nodeToNeighbours
    InferenceType_ordered = _pyAgrum.CNLoopyPropagation_double_InferenceType_ordered
    InferenceType_randomOrder = _pyAgrum.CNLoopyPropagation_double_InferenceType_randomOrder

    def makeInference(self) -> "void":
        """makeInference(self)"""
        return _pyAgrum.CNLoopyPropagation_double_makeInference(self)


    def inferenceType(self, *args) -> "gum::credal::CNLoopyPropagation< double >::InferenceType":
        """
        inferenceType(self, inft)
        inferenceType(self) -> gum::credal::CNLoopyPropagation< double >::InferenceType
        """
        return _pyAgrum.CNLoopyPropagation_double_inferenceType(self, *args)


    def eraseAllEvidence(self) -> "void":
        """eraseAllEvidence(self)"""
        return _pyAgrum.CNLoopyPropagation_double_eraseAllEvidence(self)


    def saveInference(self, path: 'std::string const &') -> "void":
        """saveInference(self, path)"""
        return _pyAgrum.CNLoopyPropagation_double_saveInference(self, path)


    def __init__(self, cnet: 'CredalNet_double'):
        """__init__(self, cnet) -> CNLoopyPropagation_double"""
        this = _pyAgrum.new_CNLoopyPropagation_double(cnet)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_CNLoopyPropagation_double
    __del__ = lambda self: None

    def insertEvidenceFile(self, path: 'std::string const &') -> "void":
        """insertEvidenceFile(self, path)"""
        return _pyAgrum.CNLoopyPropagation_double_insertEvidenceFile(self, path)


    def setVerbosity(self, v: 'bool') -> "void":
        """setVerbosity(self, v)"""
        return _pyAgrum.CNLoopyPropagation_double_setVerbosity(self, v)


    def setEpsilon(self, eps: 'double') -> "void":
        """setEpsilon(self, eps)"""
        return _pyAgrum.CNLoopyPropagation_double_setEpsilon(self, eps)


    def setMinEpsilonRate(self, rate: 'double') -> "void":
        """setMinEpsilonRate(self, rate)"""
        return _pyAgrum.CNLoopyPropagation_double_setMinEpsilonRate(self, rate)


    def setMaxIter(self, max: 'gum::Size') -> "void":
        """setMaxIter(self, max)"""
        return _pyAgrum.CNLoopyPropagation_double_setMaxIter(self, max)


    def setMaxTime(self, timeout: 'double') -> "void":
        """setMaxTime(self, timeout)"""
        return _pyAgrum.CNLoopyPropagation_double_setMaxTime(self, timeout)


    def setPeriodSize(self, p: 'gum::Size') -> "void":
        """setPeriodSize(self, p)"""
        return _pyAgrum.CNLoopyPropagation_double_setPeriodSize(self, p)


    def setBurnIn(self, b: 'gum::Size') -> "void":
        """setBurnIn(self, b)"""
        return _pyAgrum.CNLoopyPropagation_double_setBurnIn(self, b)


    def verbosity(self) -> "bool":
        """verbosity(self) -> bool"""
        return _pyAgrum.CNLoopyPropagation_double_verbosity(self)


    def epsilon(self) -> "double":
        """epsilon(self) -> double"""
        return _pyAgrum.CNLoopyPropagation_double_epsilon(self)


    def minEpsilonRate(self) -> "double":
        """minEpsilonRate(self) -> double"""
        return _pyAgrum.CNLoopyPropagation_double_minEpsilonRate(self)


    def maxIter(self) -> "gum::Size":
        """maxIter(self) -> gum::Size"""
        return _pyAgrum.CNLoopyPropagation_double_maxIter(self)


    def maxTime(self) -> "double":
        """maxTime(self) -> double"""
        return _pyAgrum.CNLoopyPropagation_double_maxTime(self)


    def periodSize(self) -> "gum::Size":
        """periodSize(self) -> gum::Size"""
        return _pyAgrum.CNLoopyPropagation_double_periodSize(self)


    def burnIn(self) -> "gum::Size":
        """burnIn(self) -> gum::Size"""
        return _pyAgrum.CNLoopyPropagation_double_burnIn(self)


    def nbrIterations(self) -> "gum::Size":
        """nbrIterations(self) -> gum::Size"""
        return _pyAgrum.CNLoopyPropagation_double_nbrIterations(self)


    def currentTime(self) -> "double":
        """currentTime(self) -> double"""
        return _pyAgrum.CNLoopyPropagation_double_currentTime(self)


    def messageApproximationScheme(self) -> "std::string":
        """messageApproximationScheme(self) -> std::string"""
        return _pyAgrum.CNLoopyPropagation_double_messageApproximationScheme(self)


    def history(self) -> "std::vector< double,std::allocator< double > > const &":
        """history(self) -> Vector_double"""
        return _pyAgrum.CNLoopyPropagation_double_history(self)


    def asIApproximationSchemeConfiguration(self) -> "gum::IApproximationSchemeConfiguration const &":
        """asIApproximationSchemeConfiguration(self) -> IApproximationSchemeConfiguration"""
        return _pyAgrum.CNLoopyPropagation_double_asIApproximationSchemeConfiguration(self)


    def setRepetitiveInd(self, flag: 'bool const') -> "void":
        """setRepetitiveInd(self, flag)"""
        return _pyAgrum.CNLoopyPropagation_double_setRepetitiveInd(self, flag)


    def marginalMax(self, *args) -> "std::vector< double,std::allocator< double > > const &":
        """
        marginalMax(self, id) -> Vector_double
        marginalMax(self, name) -> Vector_double
        """
        return _pyAgrum.CNLoopyPropagation_double_marginalMax(self, *args)


    def marginalMin(self, *args) -> "std::vector< double,std::allocator< double > > const &":
        """
        marginalMin(self, id) -> Vector_double
        marginalMin(self, name) -> Vector_double
        """
        return _pyAgrum.CNLoopyPropagation_double_marginalMin(self, *args)


    def insertModalsFile(self, path: 'std::string const &') -> "void":
        """insertModalsFile(self, path)"""
        return _pyAgrum.CNLoopyPropagation_double_insertModalsFile(self, path)


    def dynamicExpMax(self, varName: 'std::string const &') -> "std::vector< double,std::allocator< double > > const &":
        """dynamicExpMax(self, varName) -> Vector_double"""
        return _pyAgrum.CNLoopyPropagation_double_dynamicExpMax(self, varName)


    def dynamicExpMin(self, varName: 'std::string const &') -> "std::vector< double,std::allocator< double > > const &":
        """dynamicExpMin(self, varName) -> Vector_double"""
        return _pyAgrum.CNLoopyPropagation_double_dynamicExpMin(self, varName)

CNLoopyPropagation_double_swigregister = _pyAgrum.CNLoopyPropagation_double_swigregister
CNLoopyPropagation_double_swigregister(CNLoopyPropagation_double)

class InfluenceDiagram_double(DAGmodel):
    """Proxy of C++ gum::InfluenceDiagram<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [DAGmodel]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InfluenceDiagram_double, name, value)
    __swig_getmethods__ = {}
    for _s in [DAGmodel]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InfluenceDiagram_double, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_InfluenceDiagram_double
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(self) -> InfluenceDiagram_double
        __init__(self, source) -> InfluenceDiagram_double
        """
        this = _pyAgrum.new_InfluenceDiagram_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def toDot(self) -> "std::string":
        """toDot(self) -> std::string"""
        return _pyAgrum.InfluenceDiagram_double_toDot(self)


    def __str__(self) -> "std::string":
        """__str__(self) -> std::string"""
        return _pyAgrum.InfluenceDiagram_double___str__(self)


    def cpt(self, varId: 'gum::NodeId') -> "gum::Potential< double > const &":
        """cpt(self, varId) -> Potential_double"""
        val = _pyAgrum.InfluenceDiagram_double_cpt(self, varId)

        val.__fill_distrib__()


        return val


    def utility(self, varId: 'gum::NodeId') -> "gum::UtilityTable< double > const &":
        """utility(self, varId) -> UtilityTable_double"""
        val = _pyAgrum.InfluenceDiagram_double_utility(self, varId)

        val.__fill_distrib__()


        return val


    def isUtilityNode(self, varId: 'gum::NodeId') -> "bool":
        """isUtilityNode(self, varId) -> bool"""
        return _pyAgrum.InfluenceDiagram_double_isUtilityNode(self, varId)


    def isDecisionNode(self, varId: 'gum::NodeId') -> "bool":
        """isDecisionNode(self, varId) -> bool"""
        return _pyAgrum.InfluenceDiagram_double_isDecisionNode(self, varId)


    def isChanceNode(self, varId: 'gum::NodeId') -> "bool":
        """isChanceNode(self, varId) -> bool"""
        return _pyAgrum.InfluenceDiagram_double_isChanceNode(self, varId)


    def utilityNodeSize(self) -> "gum::Size":
        """utilityNodeSize(self) -> gum::Size"""
        return _pyAgrum.InfluenceDiagram_double_utilityNodeSize(self)


    def chanceNodeSize(self) -> "gum::Size":
        """chanceNodeSize(self) -> gum::Size"""
        return _pyAgrum.InfluenceDiagram_double_chanceNodeSize(self)


    def decisionNodeSize(self) -> "gum::Size":
        """decisionNodeSize(self) -> gum::Size"""
        return _pyAgrum.InfluenceDiagram_double_decisionNodeSize(self)


    def variable(self, id: 'gum::NodeId') -> "gum::DiscreteVariable const &":
        """variable(self, id) -> DiscreteVariable"""
        return _pyAgrum.InfluenceDiagram_double_variable(self, id)


    def nodeId(self, var: 'DiscreteVariable') -> "gum::NodeId":
        """nodeId(self, var) -> gum::NodeId"""
        return _pyAgrum.InfluenceDiagram_double_nodeId(self, var)


    def idFromName(self, name: 'std::string const &') -> "gum::NodeId":
        """idFromName(self, name) -> gum::NodeId"""
        return _pyAgrum.InfluenceDiagram_double_idFromName(self, name)


    def variableFromName(self, name: 'std::string const &') -> "gum::DiscreteVariable const &":
        """variableFromName(self, name) -> DiscreteVariable"""
        return _pyAgrum.InfluenceDiagram_double_variableFromName(self, name)


    def add(self, variable: 'DiscreteVariable', id: 'gum::NodeId'=0) -> "gum::NodeId":
        """
        add(self, variable, id=0) -> gum::NodeId
        add(self, variable) -> gum::NodeId
        """
        return _pyAgrum.InfluenceDiagram_double_add(self, variable, id)


    def addDecisionNode(self, variable: 'DiscreteVariable', id: 'gum::NodeId'=0) -> "gum::NodeId":
        """
        addDecisionNode(self, variable, id=0) -> gum::NodeId
        addDecisionNode(self, variable) -> gum::NodeId
        """
        return _pyAgrum.InfluenceDiagram_double_addDecisionNode(self, variable, id)


    def addChanceNode(self, *args) -> "gum::NodeId":
        """
        addChanceNode(self, variable, id=0) -> gum::NodeId
        addChanceNode(self, variable) -> gum::NodeId
        addChanceNode(self, variable, aContent, id=0) -> gum::NodeId
        addChanceNode(self, variable, aContent) -> gum::NodeId
        """
        return _pyAgrum.InfluenceDiagram_double_addChanceNode(self, *args)


    def addUtilityNode(self, *args) -> "gum::NodeId":
        """
        addUtilityNode(self, variable, id=0) -> gum::NodeId
        addUtilityNode(self, variable) -> gum::NodeId
        addUtilityNode(self, variable, aContent, id=0) -> gum::NodeId
        addUtilityNode(self, variable, aContent) -> gum::NodeId
        """
        return _pyAgrum.InfluenceDiagram_double_addUtilityNode(self, *args)


    def erase(self, *args) -> "void":
        """
        erase(self, id)
        erase(self, var)
        """
        return _pyAgrum.InfluenceDiagram_double_erase(self, *args)


    def changeVariableName(self, id: 'gum::NodeId', new_name: 'std::string const &') -> "void":
        """changeVariableName(self, id, new_name)"""
        return _pyAgrum.InfluenceDiagram_double_changeVariableName(self, id, new_name)


    def addArc(self, tail: 'gum::NodeId', head: 'gum::NodeId') -> "void":
        """addArc(self, tail, head)"""
        return _pyAgrum.InfluenceDiagram_double_addArc(self, tail, head)


    def eraseArc(self, *args) -> "void":
        """
        eraseArc(self, arc)
        eraseArc(self, tail, head)
        """
        return _pyAgrum.InfluenceDiagram_double_eraseArc(self, *args)


    def decisionOrderExists(self) -> "bool":
        """decisionOrderExists(self) -> bool"""
        return _pyAgrum.InfluenceDiagram_double_decisionOrderExists(self)


    def getDecisionGraph(self) -> "gum::DAG *":
        """getDecisionGraph(self) -> DAG"""
        return _pyAgrum.InfluenceDiagram_double_getDecisionGraph(self)


    def getDecisionOrder(self) -> "std::vector< gum::NodeId,std::allocator< gum::NodeId > > *":
        """getDecisionOrder(self) -> Vector_int"""
        return _pyAgrum.InfluenceDiagram_double_getDecisionOrder(self)


    def existsPathBetween(self, src: 'gum::NodeId', dest: 'gum::NodeId') -> "bool":
        """existsPathBetween(self, src, dest) -> bool"""
        return _pyAgrum.InfluenceDiagram_double_existsPathBetween(self, src, dest)


    def names(self) -> "PyObject *":
        """names(self) -> PyObject *"""
        return _pyAgrum.InfluenceDiagram_double_names(self)


    def ids(self) -> "PyObject *":
        """ids(self) -> PyObject *"""
        return _pyAgrum.InfluenceDiagram_double_ids(self)


    def arcs(self) -> "PyObject *":
        """arcs(self) -> PyObject *"""
        return _pyAgrum.InfluenceDiagram_double_arcs(self)


    def parents(self, id: 'gum::NodeId const') -> "PyObject *":
        """parents(self, id) -> PyObject *"""
        return _pyAgrum.InfluenceDiagram_double_parents(self, id)


    def children(self, id: 'gum::NodeId const') -> "PyObject *":
        """children(self, id) -> PyObject *"""
        return _pyAgrum.InfluenceDiagram_double_children(self, id)


    def loadBIFXML(self, *args) -> "bool":
        """
        loadBIFXML(self, name, l) -> bool
        loadBIFXML(self, name) -> bool
        """
        return _pyAgrum.InfluenceDiagram_double_loadBIFXML(self, *args)


    def saveBIFXML(self, name: 'std::string') -> "void":
        """saveBIFXML(self, name)"""
        return _pyAgrum.InfluenceDiagram_double_saveBIFXML(self, name)

InfluenceDiagram_double_swigregister = _pyAgrum.InfluenceDiagram_double_swigregister
InfluenceDiagram_double_swigregister(InfluenceDiagram_double)

class InfluenceDiagramInference_double(_object):
    """Proxy of C++ gum::InfluenceDiagramInference<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InfluenceDiagramInference_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InfluenceDiagramInference_double, name)
    __repr__ = _swig_repr

    def __init__(self, infDiag: 'InfluenceDiagram_double'):
        """__init__(self, infDiag) -> InfluenceDiagramInference_double"""
        this = _pyAgrum.new_InfluenceDiagramInference_double(infDiag)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_InfluenceDiagramInference_double
    __del__ = lambda self: None

    def makeInference(self) -> "void":
        """makeInference(self)"""
        return _pyAgrum.InfluenceDiagramInference_double_makeInference(self)


    def getMEU(self) -> "double":
        """getMEU(self) -> double"""
        return _pyAgrum.InfluenceDiagramInference_double_getMEU(self)


    def getBestDecisionChoice(self, decisionId: 'gum::NodeId') -> "gum::Idx":
        """getBestDecisionChoice(self, decisionId) -> gum::Idx"""
        return _pyAgrum.InfluenceDiagramInference_double_getBestDecisionChoice(self, decisionId)


    def displayResult(self) -> "std::string":
        """displayResult(self) -> std::string"""
        return _pyAgrum.InfluenceDiagramInference_double_displayResult(self)


    def insertEvidence(self, evidenceList: 'gum::List< gum::Potential< double > const * > const &') -> "void":
        """insertEvidence(self, evidenceList)"""
        return _pyAgrum.InfluenceDiagramInference_double_insertEvidence(self, evidenceList)


    def eraseEvidence(self, evidence: 'Potential_double') -> "void":
        """eraseEvidence(self, evidence)"""
        return _pyAgrum.InfluenceDiagramInference_double_eraseEvidence(self, evidence)


    def eraseAllEvidence(self) -> "void":
        """eraseAllEvidence(self)"""
        return _pyAgrum.InfluenceDiagramInference_double_eraseAllEvidence(self)


    def displayStrongJunctionTree(self, *args) -> "void":
        """displayStrongJunctionTree(self, stream)"""
        return _pyAgrum.InfluenceDiagramInference_double_displayStrongJunctionTree(self, *args)


    def influenceDiagram(self) -> "gum::InfluenceDiagram< double > const &":
        """influenceDiagram(self) -> InfluenceDiagram_double"""
        return _pyAgrum.InfluenceDiagramInference_double_influenceDiagram(self)


    def setEvidence(self, evidces):
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be dict, not %s"%(type(evidces)))
        bn = self.influenceDiagram()

    # set evidences
        self.list_pot = []

        try:
          items=evidces.iteritems()
        except AttributeError:
          items=evidces.items()

        for var_name, evidce in items:
            pot = Potential_double()

            if isinstance(var_name, int):
                var = bn.variable(var_name)
            elif isinstance(var_name, str):
                var = bn.variableFromName(var_name)
            else:
                raise TypeError('values of the dict must be int or string')

            pot.add(var)
            if isinstance(evidce, (int, float, str)):
                pot[:] = 0
    # determine the var type
                try:
                    cast_var = var.toLabelizedVar()
                    if isinstance(evidce, int):
                        index = evidce
                    elif isinstance(evidce, str):
                        index = cast_var[evidce]
                    else:
                        raise TypeError('values of the dict must be int or string')
                except RuntimeError:
                    try:
                        cast_var = var.toRangeVar()
                        if isinstance(evidce, int):
                            index = cast_var[str(evidce)]
                        elif isinstance(evidce, str):
                            index = cast_var[evidce]
                        else:
                            raise TypeError('values of the dict must be int or string')
                    except RuntimeError:
                        cast_var = var.toDiscretizedVar()
                        if isinstance(evidce, float):
                            index = cast_var.index(evidce)
                        elif isinstance(evidce, str):
                            index = cast_var.index(float(evidce))
                        else:
                            raise TypeError('values of the dict must be float or string')
                pot[index] = 1
            elif isinstance(evidce, (list, tuple)):
                pot[:] = evidce
            else:
                raise TypeError('dict values must be number, string or sequence')
            self.list_pot.append(pot)

        self.eraseAllEvidence()
        self._setEvidence(self.list_pot)



    def _setEvidence(self, evidences: 'PyObject *') -> "void":
        """_setEvidence(self, evidences)"""
        return _pyAgrum.InfluenceDiagramInference_double__setEvidence(self, evidences)


    def junctionTreeToDot(self) -> "std::string const":
        """junctionTreeToDot(self) -> std::string const"""
        return _pyAgrum.InfluenceDiagramInference_double_junctionTreeToDot(self)

InfluenceDiagramInference_double_swigregister = _pyAgrum.InfluenceDiagramInference_double_swigregister
InfluenceDiagramInference_double_swigregister(InfluenceDiagramInference_double)

class BNLearner_double(_object):
    """Proxy of C++ gum::learning::BNLearner<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BNLearner_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BNLearner_double, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, filename) -> BNLearner_double
        __init__(self, db) -> BNLearner_double
        __init__(self, filename, modalities, parse_database=False) -> BNLearner_double
        __init__(self, filename, modalities) -> BNLearner_double
        __init__(self, filename, src, parse_database=False) -> BNLearner_double
        __init__(self, filename, src) -> BNLearner_double
        __init__(self, arg2) -> BNLearner_double
        __init__(self, arg2) -> BNLearner_double
        """
        this = _pyAgrum.new_BNLearner_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyAgrum.delete_BNLearner_double
    __del__ = lambda self: None

    def learnBN(self) -> "gum::BayesNet< double >":
        """learnBN(self) -> BayesNet_double"""
        return _pyAgrum.BNLearner_double_learnBN(self)


    def learnParameters(self, *args) -> "gum::BayesNet< double >":
        """
        learnParameters(self, dag, take_into_account_score=True) -> BayesNet_double
        learnParameters(self, dag) -> BayesNet_double
        learnParameters(self, bn, take_into_account_score=True) -> BayesNet_double
        learnParameters(self, bn) -> BayesNet_double
        """
        return _pyAgrum.BNLearner_double_learnParameters(self, *args)


    def setVerbosity(self, v: 'bool') -> "void":
        """setVerbosity(self, v)"""
        return _pyAgrum.BNLearner_double_setVerbosity(self, v)


    def setEpsilon(self, eps: 'double') -> "void":
        """setEpsilon(self, eps)"""
        return _pyAgrum.BNLearner_double_setEpsilon(self, eps)


    def setMinEpsilonRate(self, rate: 'double') -> "void":
        """setMinEpsilonRate(self, rate)"""
        return _pyAgrum.BNLearner_double_setMinEpsilonRate(self, rate)


    def setMaxIter(self, max: 'gum::Size') -> "void":
        """setMaxIter(self, max)"""
        return _pyAgrum.BNLearner_double_setMaxIter(self, max)


    def setMaxTime(self, timeout: 'double') -> "void":
        """setMaxTime(self, timeout)"""
        return _pyAgrum.BNLearner_double_setMaxTime(self, timeout)


    def setPeriodSize(self, p: 'gum::Size') -> "void":
        """setPeriodSize(self, p)"""
        return _pyAgrum.BNLearner_double_setPeriodSize(self, p)


    def setBurnIn(self, b: 'gum::Size') -> "void":
        """setBurnIn(self, b)"""
        return _pyAgrum.BNLearner_double_setBurnIn(self, b)


    def verbosity(self) -> "bool":
        """verbosity(self) -> bool"""
        return _pyAgrum.BNLearner_double_verbosity(self)


    def epsilon(self) -> "double":
        """epsilon(self) -> double"""
        return _pyAgrum.BNLearner_double_epsilon(self)


    def minEpsilonRate(self) -> "double":
        """minEpsilonRate(self) -> double"""
        return _pyAgrum.BNLearner_double_minEpsilonRate(self)


    def maxIter(self) -> "gum::Size":
        """maxIter(self) -> gum::Size"""
        return _pyAgrum.BNLearner_double_maxIter(self)


    def maxTime(self) -> "double":
        """maxTime(self) -> double"""
        return _pyAgrum.BNLearner_double_maxTime(self)


    def periodSize(self) -> "gum::Size":
        """periodSize(self) -> gum::Size"""
        return _pyAgrum.BNLearner_double_periodSize(self)


    def burnIn(self) -> "gum::Size":
        """burnIn(self) -> gum::Size"""
        return _pyAgrum.BNLearner_double_burnIn(self)


    def nbrIterations(self) -> "gum::Size":
        """nbrIterations(self) -> gum::Size"""
        return _pyAgrum.BNLearner_double_nbrIterations(self)


    def currentTime(self) -> "double":
        """currentTime(self) -> double"""
        return _pyAgrum.BNLearner_double_currentTime(self)


    def messageApproximationScheme(self) -> "std::string":
        """messageApproximationScheme(self) -> std::string"""
        return _pyAgrum.BNLearner_double_messageApproximationScheme(self)


    def history(self) -> "std::vector< double,std::allocator< double > > const &":
        """history(self) -> Vector_double"""
        return _pyAgrum.BNLearner_double_history(self)


    def asIApproximationSchemeConfiguration(self) -> "gum::IApproximationSchemeConfiguration const &":
        """asIApproximationSchemeConfiguration(self) -> IApproximationSchemeConfiguration"""
        return _pyAgrum.BNLearner_double_asIApproximationSchemeConfiguration(self)


    def learnDAG(self) -> "gum::DAG":
        """learnDAG(self) -> DAG"""
        return _pyAgrum.BNLearner_double_learnDAG(self)


    def names(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        """names(self) -> Vector_string"""
        return _pyAgrum.BNLearner_double_names(self)


    def modalities(self) -> "std::vector< gum::Size,std::allocator< gum::Size > > const &":
        """modalities(self) -> std::vector< gum::Size,std::allocator< gum::Size > > const &"""
        return _pyAgrum.BNLearner_double_modalities(self)


    def idFromName(self, var_name: 'std::string const &') -> "gum::NodeId":
        """idFromName(self, var_name) -> gum::NodeId"""
        return _pyAgrum.BNLearner_double_idFromName(self, var_name)


    def nameFromId(self, id: 'gum::NodeId') -> "std::string const &":
        """nameFromId(self, id) -> std::string const &"""
        return _pyAgrum.BNLearner_double_nameFromId(self, id)


    def useScoreAIC(self) -> "void":
        """useScoreAIC(self)"""
        return _pyAgrum.BNLearner_double_useScoreAIC(self)


    def useScoreBD(self) -> "void":
        """useScoreBD(self)"""
        return _pyAgrum.BNLearner_double_useScoreBD(self)


    def useScoreBDeu(self) -> "void":
        """useScoreBDeu(self)"""
        return _pyAgrum.BNLearner_double_useScoreBDeu(self)


    def useScoreBIC(self) -> "void":
        """useScoreBIC(self)"""
        return _pyAgrum.BNLearner_double_useScoreBIC(self)


    def useScoreK2(self) -> "void":
        """useScoreK2(self)"""
        return _pyAgrum.BNLearner_double_useScoreK2(self)


    def useScoreLog2Likelihood(self) -> "void":
        """useScoreLog2Likelihood(self)"""
        return _pyAgrum.BNLearner_double_useScoreLog2Likelihood(self)


    def setAprioriWeight(self, weight: 'double') -> "void":
        """setAprioriWeight(self, weight)"""
        return _pyAgrum.BNLearner_double_setAprioriWeight(self, weight)


    def useNoApriori(self) -> "void":
        """useNoApriori(self)"""
        return _pyAgrum.BNLearner_double_useNoApriori(self)


    def useAprioriSmoothing(self, *args) -> "void":
        """
        useAprioriSmoothing(self, weight=-1)
        useAprioriSmoothing(self)
        """
        return _pyAgrum.BNLearner_double_useAprioriSmoothing(self, *args)


    def useAprioriDirichlet(self, filename: 'std::string const &') -> "void":
        """useAprioriDirichlet(self, filename)"""
        return _pyAgrum.BNLearner_double_useAprioriDirichlet(self, filename)


    def useGreedyHillClimbing(self) -> "void":
        """useGreedyHillClimbing(self)"""
        return _pyAgrum.BNLearner_double_useGreedyHillClimbing(self)


    def useLocalSearchWithTabuList(self, *args) -> "void":
        """
        useLocalSearchWithTabuList(self, tabu_size=100, nb_decrease=2)
        useLocalSearchWithTabuList(self, tabu_size=100)
        useLocalSearchWithTabuList(self)
        """
        return _pyAgrum.BNLearner_double_useLocalSearchWithTabuList(self, *args)


    def useK2(self, *args) -> "void":
        """
        useK2(self, l)
        useK2(self, order)
        useK2(self, order)
        """
        return _pyAgrum.BNLearner_double_useK2(self, *args)


    def setMaxIndegree(self, max_indegree: 'gum::Size') -> "void":
        """setMaxIndegree(self, max_indegree)"""
        return _pyAgrum.BNLearner_double_setMaxIndegree(self, max_indegree)


    def setSliceOrder(self, *args) -> "void":
        """
        setSliceOrder(self, l)
        setSliceOrder(self, slice_order)
        """
        return _pyAgrum.BNLearner_double_setSliceOrder(self, *args)


    def addForbiddenArc(self, *args) -> "void":
        """
        addForbiddenArc(self, arc)
        addForbiddenArc(self, tail, head)
        addForbiddenArc(self, tail, head)
        """
        return _pyAgrum.BNLearner_double_addForbiddenArc(self, *args)


    def eraseForbiddenArc(self, *args) -> "void":
        """
        eraseForbiddenArc(self, arc)
        eraseForbiddenArc(self, tail, head)
        eraseForbiddenArc(self, tail, head)
        """
        return _pyAgrum.BNLearner_double_eraseForbiddenArc(self, *args)


    def addMandatoryArc(self, *args) -> "void":
        """
        addMandatoryArc(self, arc)
        addMandatoryArc(self, tail, head)
        addMandatoryArc(self, tail, head)
        """
        return _pyAgrum.BNLearner_double_addMandatoryArc(self, *args)


    def eraseMandatoryArc(self, *args) -> "void":
        """
        eraseMandatoryArc(self, arc)
        eraseMandatoryArc(self, tail, head)
        eraseMandatoryArc(self, tail, head)
        """
        return _pyAgrum.BNLearner_double_eraseMandatoryArc(self, *args)


    def setInitialDAG(self, g: 'DAG') -> "void":
        """setInitialDAG(self, g)"""
        return _pyAgrum.BNLearner_double_setInitialDAG(self, g)

BNLearner_double_swigregister = _pyAgrum.BNLearner_double_swigregister
BNLearner_double_swigregister(BNLearner_double)


def statsObj() -> "void":
    """statsObj()"""
    return _pyAgrum.statsObj()

Potential = Potential_double
UtilityTable = UtilityTable_double

randomDistribution = randomDistribution_double

SimpleBayesNet = IBayesNet_double
BayesNet = BayesNet_double

LazyPropagation = LazyPropagation_double
ShaferShenoyInference = ShaferShenoyInference_double
VariableElimination = VariableElimination_double

GibbsInference = GibbsInference_double
LoopyBeliefPropagation = LoopyBeliefPropagation_double

BruteForceKL = BruteForceKL_double
GibbsKL = GibbsKL_double

CredalNet = CredalNet_double
CNMonteCarloSampling = CNMonteCarloSampling_double
CNLoopyPropagation = CNLoopyPropagation_double

DiscretizedVariable = DiscretizedVariable_double

InfluenceDiagram = InfluenceDiagram_double
InfluenceDiagramInference = InfluenceDiagramInference_double

BNLearner =  BNLearner_double

# This file is compatible with both classic and new-style classes.


