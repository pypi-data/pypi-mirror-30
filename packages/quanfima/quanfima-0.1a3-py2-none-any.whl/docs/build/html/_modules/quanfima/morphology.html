

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>quanfima.morphology &mdash; quanfima 0.1a1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="quanfima 0.1a1 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../../index.html" class="fa fa-home"> quanfima</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../overview.html#requirements">Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../overview.html#installation">Installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#analysis-of-fibrous-2d-data">Analysis of fibrous 2D data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#analysis-of-3d-data-of-fibrous-material">Analysis of 3D data of fibrous material</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#estimation-of-p-values">Estimation of p-values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#simulate-and-count-particles-in-3d-data">Simulate and count particles in 3D data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#simulate-fibers-and-estimate-properties">Simulate fibers and estimate properties</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../quanfima.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../quanfima.html#module-quanfima.morphology">quanfima.morphology module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quanfima.html#module-quanfima.simulation">quanfima.simulation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quanfima.html#module-quanfima.utils">quanfima.utils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quanfima.html#module-quanfima.visualization">quanfima.visualization module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../change_log.html">ChangeLog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../change_log.html#version-0-1a1">Version 0.1a1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../change_log.html#version-0-1a2">Version 0.1a2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../change_log.html#version-0-1a3">Version 0.1a3</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">quanfima</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>quanfima.morphology</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for quanfima.morphology</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="k">import</span> <span class="n">feature</span><span class="p">,</span> <span class="n">measure</span><span class="p">,</span> <span class="n">filters</span>
<span class="kn">from</span> <span class="nn">skimage.util.shape</span> <span class="k">import</span> <span class="n">view_as_blocks</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span> <span class="k">as</span> <span class="n">ndi</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="k">import</span> <span class="n">distance</span>
<span class="kn">import</span> <span class="nn">vigra</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Pool</span>
<span class="kn">from</span> <span class="nn">quanfima</span> <span class="k">import</span> <span class="n">cuda_available</span>

<span class="k">if</span> <span class="n">cuda_available</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pycuda.autoinit</span>
    <span class="kn">import</span> <span class="nn">pycuda.driver</span> <span class="k">as</span> <span class="nn">cuda</span>
    <span class="kn">from</span> <span class="nn">pycuda.compiler</span> <span class="k">import</span> <span class="n">SourceModule</span>
    <span class="kn">from</span> <span class="nn">pycuda</span> <span class="k">import</span> <span class="n">gpuarray</span>

<span class="c"># Constants of object counter</span>
<span class="n">_MEASUREMENTS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;Label&#39;</span><span class="p">:</span> <span class="s">&#39;label&#39;</span><span class="p">,</span>
    <span class="s">&#39;Area&#39;</span><span class="p">:</span> <span class="s">&#39;area&#39;</span><span class="p">,</span>
    <span class="s">&#39;Perimeter&#39;</span><span class="p">:</span> <span class="s">&#39;perimeter&#39;</span>
<span class="p">}</span>


<div class="viewcode-block" id="cast_ray"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.cast_ray">[docs]</a><span class="k">def</span> <span class="nf">cast_ray</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">fiber_mask</span><span class="p">,</span> <span class="n">ray_len</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes a distance between two detected points at `fiber_mask`.</span>

<span class="sd">    Casts a ray from the point (x0, y0) at `fiber_mask` under angle `theta` of maximum</span>
<span class="sd">    length of `ray_len`. The ray is casted towards to opposite directions, thus two points</span>
<span class="sd">    (x1,y1) and (x2,y2) are detected at opposite borders of fiber. Finally, the Euclidean</span>
<span class="sd">    distance between these points is calculated and returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta : float</span>
<span class="sd">        Indicates the angle under which the ray is casted.</span>

<span class="sd">    y0 : integer</span>
<span class="sd">        Indicates the y-axis component of the origin of ray emission.</span>

<span class="sd">    x0 : integer</span>
<span class="sd">        Indicates the x-axis component of the origin of ray emission.</span>

<span class="sd">    fiber_mask : 2D array</span>
<span class="sd">        Indicates the binary array of fibers.</span>

<span class="sd">    ray_len : integer</span>
<span class="sd">        Indicates the maximum length of the ray.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    distance : float</span>
<span class="sd">        The distance between (x1,y0) and (x2,y2) detected points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">y1</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">ray_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y0</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y0</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.</span><span class="o">/</span><span class="n">m</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">fiber_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> \
           <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">fiber_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">continue</span>

        <span class="k">if</span> <span class="n">fiber_mask</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">y1</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ray_len</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y0</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y0</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.</span><span class="o">/</span><span class="n">m</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">fiber_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> \
           <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">fiber_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">continue</span>

        <span class="k">if</span> <span class="n">fiber_mask</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">y2</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>

    <span class="k">return</span> <span class="n">distance</span><span class="o">.</span><span class="n">euclidean</span><span class="p">((</span><span class="n">y1</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="p">(</span><span class="n">y2</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span></div>


<div class="viewcode-block" id="scan_fiber_thickness"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.scan_fiber_thickness">[docs]</a><span class="k">def</span> <span class="nf">scan_fiber_thickness</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">angular_step</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">tilt_range</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">ray_len</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes an average diameter of a structure within a patch.</span>

<span class="sd">    Estimates an average distance from sequence of distances calculated with `cast_ray`</span>
<span class="sd">    function for a range of angles `tilt_range`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orientation : float</span>
<span class="sd">        Indicates the orientation angle of a structure centered within a patch.</span>

<span class="sd">    patch : 2D array</span>
<span class="sd">        Indicates the patch with a centered structure having orientation `angle`.</span>

<span class="sd">    angular_step : float</span>
<span class="sd">        Indicates the angular step of the scanning range in degrees.</span>

<span class="sd">    tilt_range : integer</span>
<span class="sd">        Indicates the scanning range of steps to estimate the distance.</span>

<span class="sd">    ray_len : integer</span>
<span class="sd">        Indicates the maximum length of the ray.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    average_diameter : float</span>
<span class="sd">        The average diameter of a structure centered within a patch.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">thickness_dist</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">patch</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">patch</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">pi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span>
    <span class="n">rad_p_deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angular_step</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">tilt_amount</span> <span class="ow">in</span> <span class="n">tilt_range</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">+</span> <span class="n">pi2</span> <span class="o">+</span> <span class="n">tilt_amount</span> <span class="o">*</span> <span class="n">rad_p_deg</span>
        <span class="n">thickness_dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cast_ray</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">ray_len</span><span class="o">=</span><span class="n">ray_len</span><span class="p">))</span>

    <span class="n">average_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">thickness_dist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">average_distance</span></div>


<div class="viewcode-block" id="estimate_fiber_properties"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.estimate_fiber_properties">[docs]</a><span class="k">def</span> <span class="nf">estimate_fiber_properties</span><span class="p">(</span><span class="n">fiber_mask</span><span class="p">,</span> <span class="n">fiber_skel</span><span class="p">,</span> <span class="n">paddding</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">window_radius</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
                              <span class="n">orient_type</span><span class="o">=</span><span class="s">&#39;tensor&#39;</span><span class="p">,</span> <span class="n">diameter_window_radius</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes orientation and diameter of fibers at every point of a skeleton.</span>

<span class="sd">    Estimates orientation and diameter of fibers at every point of a skeleton. The orientation</span>
<span class="sd">    is estimated using either tensor-based or PCA-based approach. The distance is evaluated</span>
<span class="sd">    by scanning a mask of fibers in a speficied angular range.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fiber_mask : 2D array</span>
<span class="sd">        Indicates the binary data of fibers produced by the segmentation process.</span>

<span class="sd">    fiber_skel : 2D array</span>
<span class="sd">        Indicates the skeleton produced by thinning of the binary data of fibers.</span>

<span class="sd">    paddding : integer</span>
<span class="sd">        Indicates the amount of padding at the corners to prevent an estimation error.</span>

<span class="sd">    window_radius : integer</span>
<span class="sd">        Indicates the radius of the local window of orientation calculation, which leads to</span>
<span class="sd">        patches of size (`window_radius`*2+1) x (`window_radius`*2+1).</span>

<span class="sd">    orient_type : str</span>
<span class="sd">        Indicates the type of algorithm for orientation estimation (&#39;tensor&#39; or &#39;pca&#39;).</span>

<span class="sd">    diameter_window_radius : integer</span>
<span class="sd">        Indicates the radius of the local window of diameter estimation, which leads to</span>
<span class="sd">        patches of size (`diameter_window_radius`*2+1) x (`diameter_window_radius`*2+1).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (clear_fiber_skel, fiber_skel, output_orientation_map, output_diameter_map,</span>
<span class="sd">    orientation_vals, diameter_vals) : tuple of arrays</span>
<span class="sd">        The skeleton with removed intersections, the skeleton, the orientation map, the</span>
<span class="sd">        diameter map, the arrays of orientation and diameter values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">orientation_vals</span><span class="p">,</span> <span class="n">diameter_vals</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="n">padded_fiber_skel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">fiber_skel</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="p">(</span><span class="n">paddding</span><span class="p">,),</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">padded_fiber_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">fiber_mask</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="p">(</span><span class="n">paddding</span><span class="p">,),</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">output_orientation_map</span><span class="p">,</span> <span class="n">output_diameter_map</span> <span class="o">=</span> \
                            <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">padded_fiber_skel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> \
                            <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">padded_fiber_skel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">pcy</span><span class="p">,</span> <span class="n">pcx</span> <span class="o">=</span> <span class="p">(</span><span class="n">window_radius</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="p">(</span><span class="n">window_radius</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>

    <span class="n">ycords</span><span class="p">,</span> <span class="n">xcords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">padded_fiber_skel</span><span class="p">)</span>

    <span class="n">clear_padded_fiber_skel</span> <span class="o">=</span> <span class="n">padded_fiber_skel</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">method</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">corner_harris</span><span class="p">(</span><span class="n">clear_padded_fiber_skel</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
    <span class="n">corner_points</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">yy</span><span class="p">,</span> <span class="n">xx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">corner_points</span><span class="p">):</span>
        <span class="n">clear_padded_fiber_skel</span><span class="p">[</span><span class="n">yy</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">yy</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">xx</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">xx</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                                            <span class="n">dtype</span><span class="o">=</span><span class="n">clear_padded_fiber_skel</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c"># PCA-based approach</span>
    <span class="k">def</span> <span class="nf">calc_orientation_pca</span><span class="p">(</span><span class="n">patch</span><span class="p">):</span>
        <span class="n">lbls</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">ndi</span><span class="o">.</span><span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">rgns</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">lbls</span><span class="p">)</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="p">[(</span><span class="n">r</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">distance</span><span class="o">.</span><span class="n">euclidean</span><span class="p">((</span><span class="n">pcy</span><span class="p">,</span> <span class="n">pcx</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rgns</span><span class="p">]</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">orintations</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">orientation</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rgns</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">dists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">centroid</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rgns</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">dists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>

        <span class="n">orientation</span> <span class="o">=</span> <span class="n">orintations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">centroids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">orientation</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span>

    <span class="c"># Tensor-based approach</span>
    <span class="k">def</span> <span class="nf">calc_orientation_tensor</span><span class="p">(</span><span class="n">patch</span><span class="p">):</span>
        <span class="n">Axx</span><span class="p">,</span> <span class="n">Axy</span><span class="p">,</span> <span class="n">Ayy</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">structure_tensor</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="n">tensor_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Axx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Axy</span><span class="p">)],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Axy</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Ayy</span><span class="p">)]])</span>

        <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">tensor_vals</span><span class="p">)</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">w</span><span class="p">)])</span>
        <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">patch</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">patch</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>

        <span class="k">return</span> <span class="n">orientation</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">yy</span><span class="p">,</span> <span class="n">xx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ycords</span><span class="p">,</span> <span class="n">xcords</span><span class="p">)):</span>
        <span class="n">patch_skel</span> <span class="o">=</span> <span class="n">padded_fiber_skel</span><span class="p">[(</span><span class="n">yy</span><span class="o">-</span><span class="n">window_radius</span><span class="p">):(</span><span class="n">yy</span><span class="o">+</span><span class="n">window_radius</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                                       <span class="p">(</span><span class="n">xx</span><span class="o">-</span><span class="n">window_radius</span><span class="p">):(</span><span class="n">xx</span><span class="o">+</span><span class="n">window_radius</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

        <span class="n">patch_mask</span> <span class="o">=</span> <span class="n">padded_fiber_mask</span><span class="p">[(</span><span class="n">yy</span><span class="o">-</span><span class="n">window_radius</span><span class="p">):(</span><span class="n">yy</span><span class="o">+</span><span class="n">window_radius</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                                       <span class="p">(</span><span class="n">xx</span><span class="o">-</span><span class="n">window_radius</span><span class="p">):(</span><span class="n">xx</span><span class="o">+</span><span class="n">window_radius</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">orient_type</span> <span class="o">==</span> <span class="s">&#39;tensor&#39;</span><span class="p">:</span>
            <span class="n">orientation</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">calc_orientation_tensor</span><span class="p">(</span><span class="n">patch_skel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">orient_type</span> <span class="o">==</span> <span class="s">&#39;pca&#39;</span><span class="p">:</span>
            <span class="n">orientation</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">calc_orientation_pca</span><span class="p">(</span><span class="n">patch_skel</span><span class="p">)</span>

        <span class="n">final_orientation</span> <span class="o">=</span> <span class="n">orientation</span> <span class="k">if</span> <span class="n">orientation</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">orientation</span><span class="p">))</span>
        <span class="n">orientation_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_orientation</span><span class="p">)</span>
        <span class="n">output_orientation_map</span><span class="p">[</span><span class="n">yy</span><span class="p">,</span> <span class="n">xx</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_orientation</span>

        <span class="k">if</span> <span class="n">clear_padded_fiber_skel</span><span class="p">[</span><span class="n">yy</span><span class="p">,</span> <span class="n">xx</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gy</span><span class="p">,</span> <span class="n">gx</span> <span class="o">=</span> <span class="n">yy</span> <span class="o">-</span> <span class="n">window_radius</span> <span class="o">+</span> <span class="n">y0</span><span class="p">,</span> <span class="n">xx</span> <span class="o">-</span> <span class="n">window_radius</span> <span class="o">+</span> <span class="n">x0</span>

            <span class="n">fiber_tpatch</span> <span class="o">=</span> <span class="n">padded_fiber_mask</span><span class="p">[</span><span class="n">yy</span><span class="o">-</span><span class="n">diameter_window_radius</span><span class="p">:</span><span class="n">yy</span><span class="o">+</span><span class="n">diameter_window_radius</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                             <span class="n">xx</span><span class="o">-</span><span class="n">diameter_window_radius</span><span class="p">:</span><span class="n">xx</span><span class="o">+</span><span class="n">diameter_window_radius</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">final_thickness</span> <span class="o">=</span> <span class="n">scan_fiber_thickness</span><span class="p">(</span><span class="n">orientation</span><span class="p">,</span> <span class="n">patch_mask</span><span class="p">)</span>
            <span class="n">output_diameter_map</span><span class="p">[</span><span class="n">yy</span><span class="p">,</span> <span class="n">xx</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_thickness</span>
            <span class="n">diameter_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_thickness</span><span class="p">)</span>

    <span class="n">output_orientation_map</span> <span class="o">=</span> <span class="n">output_orientation_map</span><span class="p">[</span><span class="n">paddding</span><span class="p">:</span><span class="o">-</span><span class="n">paddding</span><span class="p">,</span> <span class="n">paddding</span><span class="p">:</span><span class="o">-</span><span class="n">paddding</span><span class="p">]</span>
    <span class="n">output_diameter_map</span> <span class="o">=</span> <span class="n">output_diameter_map</span><span class="p">[</span><span class="n">paddding</span><span class="p">:</span><span class="o">-</span><span class="n">paddding</span><span class="p">,</span> <span class="n">paddding</span><span class="p">:</span><span class="o">-</span><span class="n">paddding</span><span class="p">]</span>
    <span class="n">clear_fiber_skel</span> <span class="o">=</span> <span class="n">clear_padded_fiber_skel</span><span class="p">[</span><span class="n">paddding</span><span class="p">:</span><span class="o">-</span><span class="n">paddding</span><span class="p">,</span> <span class="n">paddding</span><span class="p">:</span><span class="o">-</span><span class="n">paddding</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">clear_fiber_skel</span><span class="p">,</span> <span class="n">fiber_skel</span><span class="p">,</span>
            <span class="n">output_orientation_map</span><span class="p">,</span> <span class="n">output_diameter_map</span><span class="p">,</span>
            <span class="n">orientation_vals</span><span class="p">,</span> <span class="n">diameter_vals</span><span class="p">)</span></div>

<div class="viewcode-block" id="estimate_fourier_orientation"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.estimate_fourier_orientation">[docs]</a><span class="k">def</span> <span class="nf">estimate_fourier_orientation</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">grid_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes orientation at every block of the subdivided image.</span>

<span class="sd">    Subdivides the image into the grid of blocks `grid_shape`, it computes</span>
<span class="sd">    2D FFT for every block, then the real components are segmented by</span>
<span class="sd">    the Otsu thresholding and the PCA-based approach calculates the orientation</span>
<span class="sd">    of structures within each block.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        Indicates the grayscale 2D image.</span>

<span class="sd">    grid_shape : tuple</span>
<span class="sd">        Indicates the number of blocks to subdivide the image.</span>

<span class="sd">    sigma : float</span>
<span class="sd">        Indicates the sigma value of the Gaussian filter to smooth the real part</span>
<span class="sd">        of 2D Fourier spectrum.</span>

<span class="sd">    zoom : float</span>
<span class="sd">        Indicates the upscaling factor of each block before applying 2D FFT.</span>

<span class="sd">    order : str</span>
<span class="sd">        Indicates the order of interpolation used in the upscaling procedure.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (orient_blocks, block_shape) : tuple of arrays</span>
<span class="sd">        The 2D array of the orientation angle within each block,</span>
<span class="sd">        the shape of a block.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">block_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">gs</span><span class="p">)))</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">gs</span> <span class="ow">in</span>
                                                <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">grid_shape</span><span class="p">)])</span>
    <span class="n">data_blocks</span> <span class="o">=</span> <span class="n">view_as_blocks</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">block_shape</span><span class="o">=</span><span class="n">block_shape</span><span class="p">)</span>
    <span class="n">orient_blocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">block_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="n">block_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> \
                     <span class="n">block_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">block_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">dblock</span> <span class="o">=</span> <span class="n">data_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">zoom</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">:</span>
                <span class="n">dblock</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">zoom</span><span class="p">(</span><span class="n">dblock</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

            <span class="n">dblock_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">dblock</span><span class="p">))</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
            <span class="n">dblock_freq</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">dblock_freq</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">dblock_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">dblock_freq</span> <span class="o">&gt;</span> <span class="n">filters</span><span class="o">.</span><span class="n">threshold_otsu</span><span class="p">(</span><span class="n">dblock_freq</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

            <span class="n">lbls</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">dblock_mask</span><span class="p">,</span>
                             <span class="n">structure</span><span class="o">=</span><span class="n">ndi</span><span class="o">.</span><span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rgns</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">lbls</span><span class="p">)</span>

            <span class="n">dists</span> <span class="o">=</span> <span class="p">[(</span><span class="n">r</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">area</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rgns</span><span class="p">]</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">orient_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">orientation</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rgns</span>
                                                <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">dists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">orient_blocks</span><span class="p">,</span> <span class="n">block_shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="numpy3d_to_array"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.numpy3d_to_array">[docs]</a><span class="k">def</span> <span class="nf">numpy3d_to_array</span><span class="p">(</span><span class="n">np_array</span><span class="p">,</span> <span class="n">allow_surface_bind</span><span class="o">=</span><span class="k">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts 3D numpy array to 3D device array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># numpy3d_to_array</span>
    <span class="c"># taken from pycuda mailing list (striped for C ordering only)</span>

    <span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">np_array</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">descr</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">ArrayDescriptor3D</span><span class="p">()</span>
    <span class="n">descr</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">w</span>
    <span class="n">descr</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">h</span>
    <span class="n">descr</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">d</span>
    <span class="n">descr</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">dtype_to_array_format</span><span class="p">(</span><span class="n">np_array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">descr</span><span class="o">.</span><span class="n">num_channels</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">descr</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">allow_surface_bind</span><span class="p">:</span>
        <span class="n">descr</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">array3d_flags</span><span class="o">.</span><span class="n">SURFACE_LDST</span>

    <span class="n">device_array</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">descr</span><span class="p">)</span>

    <span class="n">copy</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">Memcpy3D</span><span class="p">()</span>
    <span class="n">copy</span><span class="o">.</span><span class="n">set_src_host</span><span class="p">(</span><span class="n">np_array</span><span class="p">)</span>
    <span class="n">copy</span><span class="o">.</span><span class="n">set_dst_array</span><span class="p">(</span><span class="n">device_array</span><span class="p">)</span>
    <span class="n">copy</span><span class="o">.</span><span class="n">width_in_bytes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">src_pitch</span> <span class="o">=</span> <span class="n">np_array</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">copy</span><span class="o">.</span><span class="n">src_height</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">h</span>
    <span class="n">copy</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">d</span>

    <span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">device_array</span></div>


<span class="k">def</span> <span class="nf">_filter_coords</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">th_nval</span><span class="o">=</span><span class="mf">0.8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Filters coordinates of 3D local windows by number of non-zero values speficied by `th_nval`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ws2</span> <span class="o">=</span> <span class="n">ws</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">check_point</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">ws2</span><span class="p">,</span> <span class="n">th</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">lim0</span> <span class="o">=</span> <span class="n">pt</span> <span class="o">-</span> <span class="n">ws2</span>
        <span class="n">lim1</span> <span class="o">=</span> <span class="n">pt</span> <span class="o">+</span> <span class="n">ws2</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lim0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lim1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">return</span> <span class="k">False</span>

        <span class="n">z0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">lim0</span>
        <span class="n">z1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">lim1</span>

        <span class="n">vol</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">z0</span><span class="p">:</span><span class="n">z1</span><span class="p">,</span> <span class="n">y0</span><span class="p">:</span><span class="n">y1</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span><span class="n">x1</span><span class="p">]</span>
        <span class="n">nz_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">vol</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">vol</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ws2</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">th</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">False</span>

        <span class="k">return</span> <span class="k">True</span>

    <span class="n">filtered_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="k">if</span> <span class="n">check_point</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">ws2</span><span class="p">,</span> <span class="n">th_nval</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">filtered_coords</span><span class="p">)</span>


<div class="viewcode-block" id="extract_patch"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.extract_patch">[docs]</a><span class="k">def</span> <span class="nf">extract_patch</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">ws2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract a path from `data` of radius `ws2`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : 3D array</span>
<span class="sd">        Indicates the 3D data array.</span>

<span class="sd">    pt : array or tuple</span>
<span class="sd">        Indicates the coordinates of a point within `data`.</span>

<span class="sd">    ws2 : integer</span>
<span class="sd">        Indicates a half of the window size of the patch to be extracted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    patch : 3D array</span>
<span class="sd">        The 3D patch extracted from the local window around the point `pt` in the `data`</span>
<span class="sd">        with radius of `ws2`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lim0</span> <span class="o">=</span> <span class="n">pt</span> <span class="o">-</span> <span class="n">ws2</span>
    <span class="n">lim1</span> <span class="o">=</span> <span class="n">pt</span> <span class="o">+</span> <span class="n">ws2</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lim0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lim1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="k">return</span> <span class="k">None</span>

    <span class="n">z0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">lim0</span>
    <span class="n">z1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">lim1</span>
    <span class="n">patch</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">z0</span><span class="p">:</span><span class="n">z1</span><span class="p">,</span> <span class="n">y0</span><span class="p">:</span><span class="n">y1</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span><span class="n">x1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">patch</span></div>


<div class="viewcode-block" id="orientation_3d_tensor_vigra"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.orientation_3d_tensor_vigra">[docs]</a><span class="k">def</span> <span class="nf">orientation_3d_tensor_vigra</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes 3D orientation from a 3D structure tensor of `data`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        Indicates the N-dimensional array.</span>

<span class="sd">    sigma : float</span>
<span class="sd">        Indicates the sigma value of the Gaussian filter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (lat, azth) : tuple of floats</span>
<span class="sd">        The latitude / elevation and azimuth component of 3D orientation of structures within</span>
<span class="sd">        the patch `data`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">structureTensor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sigma_d</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">Axx</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">Axy</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">Axz</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">Ayy</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">Ayz</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">4</span><span class="p">]</span>
    <span class="n">Azz</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">5</span><span class="p">]</span>

    <span class="n">tensor_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Azz</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Ayz</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Axz</span><span class="p">)],</span>
                            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Ayz</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Ayy</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Axy</span><span class="p">)],</span>
                            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Axz</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Axy</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Axx</span><span class="p">)]])</span>

    <span class="n">tensor_vals</span> <span class="o">=</span> <span class="n">tensor_vals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">eps</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">8</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">tensor_vals</span><span class="p">)</span>

    <span class="n">mv</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">w</span><span class="p">)]</span>  <span class="c"># z, y, x</span>
    <span class="n">mv</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">mv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">azth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">mv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">mv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">if</span> <span class="n">mv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">azth</span><span class="p">)</span></div>


<div class="viewcode-block" id="estimate_tensor"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.estimate_tensor">[docs]</a><span class="k">def</span> <span class="nf">estimate_tensor</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">skel</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.025</span><span class="p">,</span> <span class="n">make_output</span><span class="o">=</span><span class="k">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes 3D orientation at every point of a skeleton of data.</span>

<span class="sd">    Estimates 3D orientation at every point of the skeleton `skel` extracted from the binary</span>
<span class="sd">    data `data` within a 3D local window of size `window_size` using the tensor-based approach</span>
<span class="sd">    with a Gaussian smoothing of `sigma`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Indicates the name of the output npy file.</span>

<span class="sd">    skel : 3D array</span>
<span class="sd">        Indicates the skeleton of the binary data.</span>

<span class="sd">    data : 3D array</span>
<span class="sd">        Indicates the 3D binary data.</span>

<span class="sd">    window_size : integer</span>
<span class="sd">        Indicates the size of the 3D local window.</span>

<span class="sd">    output_dir : str</span>
<span class="sd">        Indicates the path to the output folder where the data will be stored.</span>

<span class="sd">    output_fmt : str</span>
<span class="sd">        Indicates the format of</span>

<span class="sd">    sigma : float</span>
<span class="sd">        Indicates the sigma value of the Gaussian filter.</span>

<span class="sd">    make_output : boolean</span>
<span class="sd">        Specifies if the estimated data should be stored.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_props : dict</span>
<span class="sd">        The dictionary of properties specifying the sample name, the algorithm name, the number</span>
<span class="sd">        of processes, and the execution time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output_props</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="n">Z</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">skel</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">tens_lat_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">tens_azth_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">skel_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="n">ws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span>
    <span class="n">ws2</span> <span class="o">=</span> <span class="n">ws</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">skel_shape</span> <span class="o">=</span> <span class="n">skel</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;sample_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;tensor&#39;</span>
    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;n_processes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">ts</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">)):</span>
        <span class="n">lim0</span> <span class="o">=</span> <span class="n">pt</span> <span class="o">-</span> <span class="n">ws2</span>
        <span class="n">lim1</span> <span class="o">=</span> <span class="n">pt</span> <span class="o">+</span> <span class="n">ws2</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lim0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lim1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">skel_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">skel_est</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">continue</span>

        <span class="n">z0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">lim0</span>
        <span class="n">z1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">lim1</span>

        <span class="n">area</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">z0</span><span class="p">:</span><span class="n">z1</span><span class="p">,</span> <span class="n">y0</span><span class="p">:</span><span class="n">y1</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span><span class="n">x1</span><span class="p">]</span>

        <span class="n">lat</span><span class="p">,</span> <span class="n">azth</span> <span class="o">=</span> <span class="n">orientation_3d_tensor_vigra</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>

        <span class="n">tens_lat_arr</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">lat</span>
        <span class="n">tens_azth_arr</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">azth</span>
        <span class="n">skel_est</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>

    <span class="n">te</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">te</span><span class="o">-</span><span class="n">ts</span>

    <span class="nb">print</span> <span class="s">&quot;Tensor time: {}s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_props</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">make_output</span><span class="p">:</span>
        <span class="n">opath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s">&#39;{}.npy&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;output_path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">opath</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;lat&#39;</span><span class="p">:</span> <span class="n">tens_lat_arr</span><span class="p">,</span> <span class="s">&#39;azth&#39;</span><span class="p">:</span> <span class="n">tens_azth_arr</span><span class="p">,</span> <span class="s">&#39;skeleton&#39;</span><span class="p">:</span> <span class="n">skel_est</span><span class="p">,</span> <span class="s">&#39;indices&#39;</span><span class="p">:</span> <span class="n">skel_est</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">}</span>
        <span class="n">output</span><span class="p">[</span><span class="s">&#39;props&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_props</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">opath</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output_props</span></div>


<div class="viewcode-block" id="execute_tensor"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.execute_tensor">[docs]</a><span class="k">def</span> <span class="nf">execute_tensor</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Executes the tensor-based approach for a `patch` and `sigma` for Gaussian smoothing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    patch : 3D aray</span>
<span class="sd">        Indicates the data patch of some size.</span>

<span class="sd">    sigma : float</span>
<span class="sd">        Indicates the sigma value of the Gaussian filter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (lat, azth, 255) : tuple</span>
<span class="sd">        The latitude / elevation and azimuth components of 3D orientation with valid value</span>
<span class="sd">        for the point at the skeleton. If the patch is None, then return (0, 0, -1) where</span>
<span class="sd">        -1 indicates that this point of the skeleton is invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">patch</span> <span class="ow">is</span> <span class="k">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">lat</span><span class="p">,</span> <span class="n">azth</span> <span class="o">=</span> <span class="n">orientation_3d_tensor_vigra</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">azth</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span></div>


<div class="viewcode-block" id="unpack_execute_tensor"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.unpack_execute_tensor">[docs]</a><span class="k">def</span> <span class="nf">unpack_execute_tensor</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Unpack input arguments and return result of `execute_tensor` function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">execute_tensor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="estimate_tensor_parallel"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.estimate_tensor_parallel">[docs]</a><span class="k">def</span> <span class="nf">estimate_tensor_parallel</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">skel</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.025</span><span class="p">,</span>
                             <span class="n">make_output</span><span class="o">=</span><span class="k">True</span><span class="p">,</span> <span class="n">n_processes</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes 3D orientation at every point of a skeleton of data in parallel processes.</span>

<span class="sd">    Estimates 3D orientation at every point of the skeleton `skel` extracted from the binary</span>
<span class="sd">    data `data` within a 3D local window of size `window_size` using the tensor-based approach</span>
<span class="sd">    with a Gaussian smoothing of `sigma`. The orientation is estimated simultaneously at</span>
<span class="sd">    `n_processes` parallel processes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Indicates the name of the output npy file.</span>

<span class="sd">    skel : 3D array</span>
<span class="sd">        Indicates the skeleton of the binary data.</span>

<span class="sd">    data : 3D array</span>
<span class="sd">        Indicates the 3D binary data.</span>

<span class="sd">    window_size : integer</span>
<span class="sd">        Indicates the size of the 3D local window.</span>

<span class="sd">    output_dir : str</span>
<span class="sd">        Indicates the path to the output folder where the data will be stored.</span>

<span class="sd">    sigma : float</span>
<span class="sd">        Indicates the sigma value of the Gaussian filter.</span>

<span class="sd">    make_output : boolean</span>
<span class="sd">        Specifies if the estimated data should be stored.</span>

<span class="sd">    n_processes : integer</span>
<span class="sd">        Indicates the number of the parallel processes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_props : dict</span>
<span class="sd">        The dictionary of properties specifying the sample name, the algorithm name, the number</span>
<span class="sd">        of processes, and the execution time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output_props</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="n">Z</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">skel</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">tens_lat_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">tens_azth_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">skel_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="n">ws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span>
    <span class="n">ws2</span> <span class="o">=</span> <span class="n">ws</span><span class="o">/</span><span class="mi">2</span>

    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;sample_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;tensor_parallel&#39;</span>
    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;n_processes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_processes</span>

    <span class="n">ts</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">pts</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="n">data_patches</span> <span class="o">=</span> <span class="p">[</span><span class="n">extract_patch</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">ws2</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">pts</span><span class="p">]</span>
    <span class="nb">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_patches</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_patches</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span>

    <span class="n">proc_pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">n_processes</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">proc_pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">unpack_execute_tensor</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
    <span class="n">proc_pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">proc_pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">proc_pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>

    <span class="n">te</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">te</span><span class="o">-</span><span class="n">ts</span>

    <span class="n">lat_arr</span><span class="p">,</span> <span class="n">azth_arr</span><span class="p">,</span> <span class="n">skel_arr</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">T</span>
    <span class="n">tens_lat_arr</span><span class="p">[</span><span class="n">Z</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="n">lat_arr</span>
    <span class="n">tens_azth_arr</span><span class="p">[</span><span class="n">Z</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="n">azth_arr</span>
    <span class="n">skel_est</span><span class="p">[</span><span class="n">Z</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="n">skel_arr</span>

    <span class="nb">print</span> <span class="s">&quot;Tensor parallel time: %fs&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">output_props</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">make_output</span><span class="p">:</span>
        <span class="n">opath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s">&#39;{}.npy&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;output_path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">opath</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;lat&#39;</span><span class="p">:</span> <span class="n">tens_lat_arr</span><span class="p">,</span> <span class="s">&#39;azth&#39;</span><span class="p">:</span> <span class="n">tens_azth_arr</span><span class="p">,</span> <span class="s">&#39;skeleton&#39;</span><span class="p">:</span> <span class="n">skel_est</span><span class="p">,</span> <span class="s">&#39;indices&#39;</span><span class="p">:</span> <span class="n">skel_est</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">}</span>
        <span class="n">output</span><span class="p">[</span><span class="s">&#39;props&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_props</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">opath</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output_props</span></div>


<span class="k">def</span> <span class="nf">_diameter_kernel</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Returns the CUDA kernel to estimate 3D diameter of structures in a 3D local window.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diameter_kernel_src</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>

<span class="s">    texture&lt;float, cudaTextureType3D, cudaReadModeElementType&gt; tex_data;</span>

<span class="s">    __global__ void diameter3d (unsigned int width,</span>
<span class="s">                                unsigned int height,</span>
<span class="s">                                unsigned int depth,</span>
<span class="s">                                const int n_points,</span>
<span class="s">                                const float norm_factor,</span>
<span class="s">                                const int max_iters,</span>
<span class="s">                                const int n_scan_angles,</span>
<span class="s">                                const int *X,</span>
<span class="s">                                const int *Y,</span>
<span class="s">                                const int *Z,</span>
<span class="s">                                const float *scan_angl_arr,</span>
<span class="s">                                const float *azth_data,</span>
<span class="s">                                const float *lat_data,</span>
<span class="s">                                float *radius_arr)</span>
<span class="s">    {</span>
<span class="s">        unsigned long blockId, idx;</span>
<span class="s">        blockId = blockIdx.x + blockIdx.y * gridDim.x;</span>
<span class="s">        idx = blockId * (blockDim.x * blockDim.y) + (threadIdx.y * blockDim.x) + threadIdx.x;</span>

<span class="s">        if (idx &gt; n_points) {</span>
<span class="s">            return;</span>
<span class="s">        }</span>

<span class="s">        float _x, _y, _z;</span>
<span class="s">        _x = (float)X[idx] + 0.5;</span>
<span class="s">        _y = (float)Y[idx] + 0.5;</span>
<span class="s">        _z = (float)Z[idx] + 0.5;</span>

<span class="s">        // -----------------------------------------</span>
<span class="s">        // Find the diameter</span>

<span class="s">        float azth = azth_data[idx];</span>
<span class="s">        azth += M_PI_2;</span>
<span class="s">        float lat = lat_data[idx];</span>

<span class="s">        float cy = cosf(lat), sy = sinf(lat);</span>
<span class="s">        float cz = cosf(azth), sz = sinf(azth);</span>
<span class="s">        //float cz = -sinf(azth), sz = cosf(azth); // taking into account azth + pi/2</span>

<span class="s">        //vector along fiber</span>
<span class="s">        //float dx = -sy * sz;</span>
<span class="s">        //float dy = cy* sz;</span>
<span class="s">        //float dz = cy;</span>
<span class="s">        float uvec[3] = {0.0, 0.0, 1.0};</span>
<span class="s">        float fiber_vector_x[3] = {0.0,</span>
<span class="s">                                   uvec[2]*cy + uvec[3]*sy,</span>
<span class="s">                                  -uvec[2]*sy + uvec[3]*cy};</span>

<span class="s">        float fiber_vector_z[3] = {fiber_vector_x[0]*cz - fiber_vector_x[1]*sz,</span>
<span class="s">                                   fiber_vector_x[0]*sz + fiber_vector_x[1]*cz,</span>
<span class="s">                                   fiber_vector_x[2]};</span>

<span class="s">        float dx = fiber_vector_z[0], dy = fiber_vector_z[1], dz = fiber_vector_z[2];</span>

<span class="s">        //scan vector perpendicular to a fiber vector (rotation X -&gt; Z)</span>
<span class="s">        float scan_vec[3] = {0, 1, 0}; // unit vector perpendicular to default (0,0,1) direction</span>
<span class="s">        float rot_scan_vec_x[3] = {0.0,</span>
<span class="s">                                   scan_vec[1]*cy + scan_vec[2]*sy,</span>
<span class="s">                                  -scan_vec[1]*sy + scan_vec[2]*cy};</span>


<span class="s">        float rot_scan_vec_z[3] = {rot_scan_vec_x[0]*cz - rot_scan_vec_x[1]*sz,</span>
<span class="s">                                   rot_scan_vec_x[0]*sz + rot_scan_vec_x[1]*cz,</span>
<span class="s">                                   rot_scan_vec_x[2]};</span>

<span class="s">        float out_radius = 0;</span>

<span class="s">        for (int scan_angl_idx = 0; scan_angl_idx &lt; n_scan_angles; scan_angl_idx++) {</span>
<span class="s">            float theta = scan_angl_arr[scan_angl_idx];</span>

<span class="s">            float ct = cosf(theta), st = sinf(theta);</span>
<span class="s">            float x = rot_scan_vec_z[0], y = rot_scan_vec_z[1], z = rot_scan_vec_z[2];</span>
<span class="s">            float u = dx, v = dy, w = dz;</span>

<span class="s">            //rotation of point (x,y,z) around axis (u,v,w)</span>
<span class="s">            float scan_vec_coords[3] =</span>
<span class="s">                        {u*(u*x + v*y + w*z)*(1.0f - ct) + x*ct + (-w*y + v*z)*st,</span>
<span class="s">                         v*(u*x + v*y + w*z)*(1.0f - ct) + y*ct + (w*x - u*z)*st,</span>
<span class="s">                         w*(u*x + v*y + w*z)*(1.0f - ct) + z*ct + (-v*x + u*y)*st};</span>

<span class="s">            float nc[3] = {_x, _y, _z};</span>
<span class="s">            float p[3];</span>

<span class="s">            for (int i = 0; i &lt; max_iters; i++) {</span>
<span class="s">                nc[0] += scan_vec_coords[0];</span>
<span class="s">                nc[1] += scan_vec_coords[1];</span>
<span class="s">                nc[2] += scan_vec_coords[2];</span>

<span class="s">                if (tex3D(tex_data, nc[0], nc[1], nc[2]) == 0) {</span>
<span class="s">                        p[0] = nc[0];</span>
<span class="s">                        p[1] = nc[1];</span>
<span class="s">                        p[2] = nc[2];</span>
<span class="s">                        break;</span>
<span class="s">                }</span>
<span class="s">            }</span>

<span class="s">            out_radius += norm3df(p[0] - _x, p[1] - _y, p[2] - _z);</span>
<span class="s">        }</span>

<span class="s">        radius_arr[idx] = out_radius * norm_factor;</span>
<span class="s">    }</span>
<span class="s">    &quot;&quot;&quot;</span>

    <span class="n">dm_program</span> <span class="o">=</span> <span class="n">SourceModule</span><span class="p">(</span><span class="n">diameter_kernel_src</span><span class="p">)</span>
    <span class="n">diameter3d</span> <span class="o">=</span> <span class="n">dm_program</span><span class="o">.</span><span class="n">get_function</span><span class="p">(</span><span class="s">&quot;diameter3d&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dm_program</span><span class="p">,</span> <span class="n">diameter3d</span>


<div class="viewcode-block" id="estimate_diameter_gpu"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.estimate_diameter_gpu">[docs]</a><span class="k">def</span> <span class="nf">estimate_diameter_gpu</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">lat_data</span><span class="p">,</span> <span class="n">azth_data</span><span class="p">,</span> <span class="n">n_scan_angles</span><span class="p">,</span> <span class="n">max_iters</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">do_reshape</span><span class="o">=</span><span class="k">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes 3D diameter at every point of a skeleton of data using GPU.</span>

<span class="sd">    Estimates 3D diameter at every point of the skeleton `skel` extracted from the binary</span>
<span class="sd">    data `data` with help of orientation information provided by `lat_data` and `azth_data`</span>
<span class="sd">    arrays. The diameter is evaluated with a ray casting approach `cast_ray` adapted for</span>
<span class="sd">    a 3D case.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    skel : 3D array</span>
<span class="sd">        Indicates the skeleton of the binary data.</span>

<span class="sd">    data : 3D array</span>
<span class="sd">        Indicates the 3D binary data.</span>

<span class="sd">    lat_data : 3D array</span>
<span class="sd">        Indicates the 3D array containing latitude / elevation angle at every point of</span>
<span class="sd">        the skeleton in radians.</span>

<span class="sd">    azth_data : 3D array</span>
<span class="sd">        Indicates the 3D array containing azimuth angle at every point of the skeleton</span>
<span class="sd">        in radians.</span>

<span class="sd">    n_scan_angles : int</span>
<span class="sd">        Indicates the number of scanning angles on a range [0, 360] degrees.</span>

<span class="sd">    max_iters : int</span>
<span class="sd">        Indicates the maximum length of a ray in each direction.</span>

<span class="sd">    do_reshape : boolean</span>
<span class="sd">        Specifies if the output array should be reshaped immediately after estimation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dict</span>
<span class="sd">        The dictionary of the 3D array of estimated diameter and the execution time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cuda_available</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s">&#39;The pycuda package is not found. The diameter estimation cannot be done.&#39;</span>
        <span class="k">return</span> <span class="k">None</span>

    <span class="n">program</span><span class="p">,</span> <span class="n">diameter3d</span> <span class="o">=</span> <span class="n">_diameter_kernel</span><span class="p">()</span>

    <span class="n">Z</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">skel</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
    <span class="n">depth</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="n">skel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">scan_angl_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n_scan_angles</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="k">False</span><span class="p">)))</span>
    <span class="n">radius_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">lat_data_1d</span> <span class="o">=</span> <span class="n">lat_data</span><span class="p">[</span><span class="n">skel</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()]</span>
    <span class="n">azth_data_1d</span> <span class="o">=</span> <span class="n">azth_data</span><span class="p">[</span><span class="n">skel</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()]</span>

    <span class="n">gpu_X</span> <span class="o">=</span> <span class="n">gpuarray</span><span class="o">.</span><span class="n">to_gpu</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">gpu_Y</span> <span class="o">=</span> <span class="n">gpuarray</span><span class="o">.</span><span class="n">to_gpu</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
    <span class="n">gpu_Z</span> <span class="o">=</span> <span class="n">gpuarray</span><span class="o">.</span><span class="n">to_gpu</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>

    <span class="n">gpu_lat_data_1d</span> <span class="o">=</span> <span class="n">gpuarray</span><span class="o">.</span><span class="n">to_gpu</span><span class="p">(</span><span class="n">lat_data_1d</span><span class="p">)</span>
    <span class="n">gpu_azth_data_1d</span> <span class="o">=</span> <span class="n">gpuarray</span><span class="o">.</span><span class="n">to_gpu</span><span class="p">(</span><span class="n">azth_data_1d</span><span class="p">)</span>

    <span class="n">gpu_radius_arr</span> <span class="o">=</span> <span class="n">gpuarray</span><span class="o">.</span><span class="n">to_gpu</span><span class="p">(</span><span class="n">radius_arr</span><span class="p">)</span>
    <span class="n">gpu_scan_angl_arr</span> <span class="o">=</span> <span class="n">gpuarray</span><span class="o">.</span><span class="n">to_gpu</span><span class="p">(</span><span class="n">scan_angl_arr</span><span class="p">)</span>

    <span class="n">gpu_rad_tex</span> <span class="o">=</span> <span class="n">program</span><span class="o">.</span><span class="n">get_texref</span><span class="p">(</span><span class="s">&#39;tex_data&#39;</span><span class="p">)</span>
    <span class="n">gpu_data</span> <span class="o">=</span> <span class="n">numpy3d_to_array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">gpu_rad_tex</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">gpu_data</span><span class="p">)</span>

    <span class="n">n_scan_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="n">n_scan_angles</span><span class="p">)</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Z</span><span class="p">))</span>
    <span class="n">max_iters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="n">max_iters</span><span class="p">)</span>
    <span class="n">norm_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">n_scan_angles</span><span class="p">)</span>

    <span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">n_blocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">g_cols</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">g_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n_blocks</span> <span class="o">/</span> <span class="n">g_cols</span><span class="p">))</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">g_rows</span><span class="p">,</span> <span class="n">g_cols</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>

    <span class="n">start</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>  <span class="c"># start timing</span>
    <span class="n">diameter3d</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span>
               <span class="n">n_points</span><span class="p">,</span>
               <span class="n">norm_factor</span><span class="p">,</span>
               <span class="n">max_iters</span><span class="p">,</span>
               <span class="n">n_scan_angles</span><span class="p">,</span>
               <span class="n">gpu_X</span><span class="p">,</span>
               <span class="n">gpu_Y</span><span class="p">,</span>
               <span class="n">gpu_Z</span><span class="p">,</span>
               <span class="n">gpu_scan_angl_arr</span><span class="p">,</span>
               <span class="n">gpu_azth_data_1d</span><span class="p">,</span>
               <span class="n">gpu_lat_data_1d</span><span class="p">,</span>
               <span class="n">gpu_radius_arr</span><span class="p">,</span>
               <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
               <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>
    <span class="n">end</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>  <span class="c"># end timing</span>
    <span class="n">end</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>

    <span class="n">dm_time</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">time_till</span><span class="p">(</span><span class="n">end</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span>
    <span class="nb">print</span> <span class="s">&quot;Diameter estimation time: %fs&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dm_time</span><span class="p">)</span>

    <span class="n">radius_arr</span> <span class="o">=</span> <span class="n">gpu_radius_arr</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">do_reshape</span><span class="p">:</span>
        <span class="n">radius_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">radius_arr</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>

    <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;diameter&#39;</span><span class="p">:</span> <span class="n">radius_arr</span> <span class="o">*</span> <span class="mf">2.</span><span class="p">,</span> <span class="s">&#39;time&#39;</span><span class="p">:</span> <span class="n">dm_time</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="estimate_diameter_single_run"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.estimate_diameter_single_run">[docs]</a><span class="k">def</span> <span class="nf">estimate_diameter_single_run</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">skel</span><span class="p">,</span> <span class="n">lat_data</span><span class="p">,</span> <span class="n">azth_data</span><span class="p">,</span>
                                 <span class="n">n_scan_angles</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">make_output</span><span class="o">=</span><span class="k">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes 3D diameter using GPU and stores result in a npy file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Indicates the name of the output npy file.</span>

<span class="sd">    output_dir : str</span>
<span class="sd">        Indicates the path to the output folder where the data will be stored.</span>

<span class="sd">    data : 3D array</span>
<span class="sd">        Indicates the 3D binary data.</span>

<span class="sd">    skel : 3D array</span>
<span class="sd">        Indicates the skeleton of the binary data.</span>

<span class="sd">    lat_data : 3D array</span>
<span class="sd">        Indicates the 3D array containing latitude / elevation angle at every point of</span>
<span class="sd">        the skeleton in radians.</span>

<span class="sd">    azth_data : 3D array</span>
<span class="sd">        Indicates the 3D array containing azimuth angle at every point of the skeleton</span>
<span class="sd">        in radians.</span>

<span class="sd">    n_scan_angles : int</span>
<span class="sd">        Indicates the number of scanning angles on a range [0, 360] degrees.</span>

<span class="sd">    make_output : boolean</span>
<span class="sd">        Specifies if the estimated data should be stored.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_props : dict</span>
<span class="sd">        The dictionary of properties specifying the sample name, the algorithm name,</span>
<span class="sd">        the number of processes, and the execution time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cuda_available</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s">&#39;The pycuda package is not found. The diameter estimation cannot be done.&#39;</span>
        <span class="k">return</span> <span class="k">None</span>

    <span class="n">output</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">output_props</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="n">output</span><span class="p">[</span><span class="s">&#39;diameter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;sample_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;diameter_gpu&#39;</span>
    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;n_processes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">estimate_diameter_gpu</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">lat_data</span><span class="p">,</span> <span class="n">azth_data</span><span class="p">,</span> <span class="n">n_scan_angles</span><span class="p">,</span> <span class="n">do_reshape</span><span class="o">=</span><span class="k">False</span><span class="p">)</span>

    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">result</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">]</span>
    <span class="n">output</span><span class="p">[</span><span class="s">&#39;diameter&#39;</span><span class="p">][</span><span class="n">skel</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s">&#39;diameter&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="nb">print</span> <span class="s">&#39;Total diameter execution time: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_props</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">make_output</span><span class="p">:</span>
        <span class="n">opath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s">&#39;{}.npy&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;output_path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">opath</span>
        <span class="n">output</span><span class="p">[</span><span class="s">&#39;indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">skel</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">output</span><span class="p">[</span><span class="s">&#39;props&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_props</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">opath</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output_props</span></div>


<div class="viewcode-block" id="estimate_diameter_batches"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.estimate_diameter_batches">[docs]</a><span class="k">def</span> <span class="nf">estimate_diameter_batches</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">skel</span><span class="p">,</span> <span class="n">lat_data</span><span class="p">,</span> <span class="n">azth_data</span><span class="p">,</span> <span class="n">border_gap</span><span class="p">,</span>
                              <span class="n">n_scan_angles</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">out_arr_names</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;diameter&#39;</span><span class="p">],</span> <span class="n">make_output</span><span class="o">=</span><span class="k">True</span><span class="p">,</span>
                              <span class="n">slices_per_batch</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes 3D diameter using GPU in batches and stores result in a npy file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Indicates the name of the output npy file.</span>

<span class="sd">    output_dir : str</span>
<span class="sd">        Indicates the path to the output folder where the data will be stored.</span>

<span class="sd">    data : 3D array</span>
<span class="sd">        Indicates the 3D binary data.</span>

<span class="sd">    skel : 3D array</span>
<span class="sd">        Indicates the skeleton of the binary data.</span>

<span class="sd">    lat_data : 3D array</span>
<span class="sd">        Indicates the 3D array containing latitude / elevation angle at every point of</span>
<span class="sd">        the skeleton in radians.</span>

<span class="sd">    azth_data : 3D array</span>
<span class="sd">        Indicates the 3D array containing azimuth angle at every point of the skeleton</span>
<span class="sd">        in radians.</span>

<span class="sd">    border_gap : integer</span>
<span class="sd">        Indicates the number of overlapping slices along z-axis, usually it should be more or</span>
<span class="sd">        equal to a half of size of the 3D local window.</span>

<span class="sd">    n_scan_angles : int</span>
<span class="sd">        Indicates the number of scanning angles on a range [0, 360] degrees.</span>

<span class="sd">    out_arr_names : array of str</span>
<span class="sd">        Indicates the array of keys of the output dictionary.</span>

<span class="sd">    make_output : boolean</span>
<span class="sd">        Specifies if the estimated data should be stored.</span>

<span class="sd">    slices_per_batch : integer</span>
<span class="sd">        The number of slices along z-axis in a batch.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_props : dict</span>
<span class="sd">        The dictionary of properties specifying the sample name, the algorithm name,</span>
<span class="sd">        the number of processes, and the execution time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cuda_available</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s">&#39;The pycuda package is not found. The diameter estimation cannot be done.&#39;</span>
        <span class="k">return</span> <span class="k">None</span>

    <span class="n">output</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">output_props</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">arr_name</span> <span class="ow">in</span> <span class="n">out_arr_names</span><span class="p">:</span>
        <span class="n">output</span><span class="p">[</span><span class="n">arr_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;sample_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;diameter_gpu&#39;</span>
    <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;n_processes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">depth</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">batches_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">depth</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">depth</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">slices_per_batch</span><span class="p">)))</span>
    <span class="nb">print</span> <span class="n">batches_idxs</span>

    <span class="k">for</span> <span class="n">batch_idxs</span> <span class="ow">in</span> <span class="n">batches_idxs</span><span class="p">:</span>
        <span class="n">batch_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_idxs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">batch_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span> <span class="o">=</span> <span class="k">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">batch_idxs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">batch_idxs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">border_gap</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">gaped_batch_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">batch_idxs</span><span class="p">,</span> <span class="n">arr2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">batch_idxs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">batch_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">border_gap</span><span class="p">,</span> <span class="n">batch_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="k">None</span>
            <span class="n">gaped_batch_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">arr1</span><span class="p">,</span> <span class="n">batch_idxs</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">batch_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">border_gap</span><span class="p">,</span> <span class="n">batch_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> \
                            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">batch_idxs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">batch_idxs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">border_gap</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">gaped_batch_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">arr1</span><span class="p">,</span> <span class="n">batch_idxs</span><span class="p">,</span> <span class="n">arr2</span><span class="p">))</span>

        <span class="n">batched_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">gaped_batch_idxs</span><span class="p">]</span>
        <span class="n">batched_skel</span> <span class="o">=</span> <span class="n">skel</span><span class="p">[</span><span class="n">gaped_batch_idxs</span><span class="p">]</span>
        <span class="n">batched_lat_data</span> <span class="o">=</span> <span class="n">lat_data</span><span class="p">[</span><span class="n">gaped_batch_idxs</span><span class="p">]</span>
        <span class="n">batched_azth_data</span> <span class="o">=</span> <span class="n">azth_data</span><span class="p">[</span><span class="n">gaped_batch_idxs</span><span class="p">]</span>

        <span class="n">gaped_out_dict</span> <span class="o">=</span> <span class="n">estimate_diameter_gpu</span><span class="p">(</span><span class="n">batched_skel</span><span class="p">,</span>
                                               <span class="n">batched_data</span><span class="p">,</span>
                                               <span class="n">batched_lat_data</span><span class="p">,</span>
                                               <span class="n">batched_azth_data</span><span class="p">,</span>
                                               <span class="n">n_scan_angles</span><span class="p">,</span>
                                               <span class="n">do_reshape</span><span class="o">=</span><span class="k">False</span><span class="p">)</span>

        <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">gaped_out_dict</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">data_name</span> <span class="ow">in</span> <span class="n">out_arr_names</span><span class="p">:</span>
            <span class="n">gaped_arr_values</span> <span class="o">=</span> <span class="n">gaped_out_dict</span><span class="p">[</span><span class="n">data_name</span><span class="p">]</span>
            <span class="n">gaped_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">batched_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">gaped_arr</span><span class="p">[</span><span class="n">batched_skel</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()]</span> <span class="o">=</span> <span class="n">gaped_arr_values</span>

            <span class="k">if</span> <span class="n">batch_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="n">data_name</span><span class="p">][</span><span class="n">batch_idxs</span><span class="p">]</span> <span class="o">=</span> <span class="n">gaped_arr</span><span class="p">[:</span><span class="n">batch_len</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">batch_idxs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">output</span><span class="p">[</span><span class="n">data_name</span><span class="p">][</span><span class="n">batch_idxs</span><span class="p">]</span> <span class="o">=</span> <span class="n">gaped_arr</span><span class="p">[</span><span class="n">border_gap</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="n">data_name</span><span class="p">][</span><span class="n">batch_idxs</span><span class="p">]</span> <span class="o">=</span> <span class="n">gaped_arr</span><span class="p">[</span><span class="n">border_gap</span><span class="p">:</span><span class="n">border_gap</span><span class="o">+</span><span class="n">batch_len</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="nb">print</span> <span class="s">&#39;Total diameter execution time: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_props</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">make_output</span><span class="p">:</span>
        <span class="n">opath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s">&#39;{}.npy&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">output_props</span><span class="p">[</span><span class="s">&#39;output_path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">opath</span>
        <span class="n">output</span><span class="p">[</span><span class="s">&#39;indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s">&#39;diameter&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">output</span><span class="p">[</span><span class="s">&#39;props&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_props</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">opath</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output_props</span></div>


<span class="k">def</span> <span class="nf">_calc_sphericity</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">perimeter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes sphericity from volume and perimeter of an object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">((</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">volume</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">r</span><span class="p">))</span> <span class="o">/</span> <span class="n">perimeter</span>


<div class="viewcode-block" id="object_counter"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.object_counter">[docs]</a><span class="k">def</span> <span class="nf">object_counter</span><span class="p">(</span><span class="n">stack_binary_data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Label and counts particles in a binary data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stack_binary_data : 3D array</span>
<span class="sd">        Indicates the 3D binary data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (objects_stats, labeled_stack) : tuple</span>
<span class="sd">        The tuple of a DataFrame object of counted partilces and the labeled 3D data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">measurements_vals</span> <span class="o">=</span> <span class="n">_MEASUREMENTS</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="nb">print</span> <span class="s">&#39;Object counting - Labeling...&#39;</span>
    <span class="n">labeled_stack</span><span class="p">,</span> <span class="n">num_labels</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">measurements</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">stack_binary_data</span><span class="p">)</span>
    <span class="n">objects_stats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">measurements_vals</span><span class="p">)</span>

    <span class="nb">print</span> <span class="s">&#39;Object counting - Stats gathering...&#39;</span>
    <span class="k">for</span> <span class="n">slice_idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">labeled_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">labeled_stack</span><span class="p">[</span><span class="n">slice_idx</span><span class="p">]):</span>
            <span class="n">objects_stats</span> <span class="o">=</span> <span class="n">objects_stats</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">mname</span><span class="p">:</span> <span class="n">region</span><span class="p">[</span><span class="n">mval</span><span class="p">]</span>
                                        <span class="k">for</span> <span class="n">mname</span><span class="p">,</span> <span class="n">mval</span> <span class="ow">in</span> <span class="n">_MEASUREMENTS</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
                                            <span class="n">ignore_index</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>

    <span class="nb">print</span> <span class="s">&#39;Object counting - Stats grouping...&#39;</span>
    <span class="n">objects_stats</span> <span class="o">=</span> <span class="n">objects_stats</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">&#39;Label&#39;</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="k">False</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">objects_stats</span><span class="p">[</span><span class="s">&#39;Sphericity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_calc_sphericity</span><span class="p">(</span><span class="n">objects_stats</span><span class="p">[</span><span class="s">&#39;Area&#39;</span><span class="p">],</span>
                                                   <span class="n">objects_stats</span><span class="p">[</span><span class="s">&#39;Perimeter&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">objects_stats</span><span class="p">,</span> <span class="n">labeled_stack</span><span class="p">)</span></div>


<div class="viewcode-block" id="calc_porosity"><a class="viewcode-back" href="../../quanfima.html#quanfima.morphology.calc_porosity">[docs]</a><span class="k">def</span> <span class="nf">calc_porosity</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes porosity.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : 3D array</span>
<span class="sd">        Indicates the labeled 3D data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dict</span>
<span class="sd">        The dictionary of materials and corresponding porosity values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total_volume</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span>
    <span class="n">mats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;Material {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">):</span> \
                        <span class="mf">1.</span> <span class="o">-</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">==</span> <span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">/</span> <span class="n">total_volume</span><span class="p">)</span> \
                                                        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mats</span><span class="p">[</span><span class="n">mats</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]}</span>
    <span class="k">return</span> <span class="n">out</span></div>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Roman Shkarin, Andrei Shkarin.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.1a1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>