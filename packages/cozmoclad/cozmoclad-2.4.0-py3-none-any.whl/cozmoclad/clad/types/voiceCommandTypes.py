# Copyright (c) 2016-2017 Anki, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License in the file LICENSE.txt or at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Autogenerated python message buffer code.
Source: clad/types/voiceCommandTypes.clad
Full command line: ../tools/message-buffers/emitters/Python_emitter.py -C ./src/ -I ../robot/clad/src/ ../coretech/vision/clad/src/ ../coretech/common/clad/src/ ../lib/util/source/anki/clad -o ../generated/cladPython// clad/types/voiceCommandTypes.clad
"""

from __future__ import absolute_import
from __future__ import print_function

def _modify_path():
  import inspect, os, sys
  search_paths = [
    '../..',
    '../../../../tools/message-buffers/support/python',
  ]
  currentpath = os.path.abspath(os.path.dirname(inspect.getfile(inspect.currentframe())))
  for search_path in search_paths:
    search_path = os.path.normpath(os.path.abspath(os.path.realpath(os.path.join(currentpath, search_path))))
    if search_path not in sys.path:
      sys.path.insert(0, search_path)
_modify_path()

import msgbuffers

Anki = msgbuffers.Namespace()
Anki.Cozmo = msgbuffers.Namespace()
Anki.Cozmo.VoiceCommand = msgbuffers.Namespace()

class VoiceCommandType(object):
  "Automatically-generated uint_8 enumeration."
  Continue       = 0
  ComeHere       = 1
  DoADance       = 2
  DoATrick       = 3
  FistBump       = 4
  GoToSleep      = 5
  HeyCozmo       = 6
  HowAreYouDoing = 7
  LetsPlay       = 8
  PeekABoo       = 9
  NoThankYou     = 10
  YesPlease      = 11
  LookDown       = 12
  Invalid        = 13

Anki.Cozmo.VoiceCommand.VoiceCommandType = VoiceCommandType
del VoiceCommandType


class VoiceCommandListenContext(object):
  "Automatically-generated uint_8 enumeration."
  ContinuePrompt = 0
  TriggerPhrase  = 1
  CommandList    = 2
  SimplePrompt   = 3
  Invalid        = 4

Anki.Cozmo.VoiceCommand.VoiceCommandListenContext = VoiceCommandListenContext
del VoiceCommandListenContext


class AudioCapturePermissionState(object):
  "Automatically-generated uint_8 enumeration."
  Unknown          = 0
  Granted          = 1
  DeniedAllowRetry = 2
  DeniedNoRetry    = 3

Anki.Cozmo.VoiceCommand.AudioCapturePermissionState = AudioCapturePermissionState
del AudioCapturePermissionState


class RespondingToCommand(object):
  "Generated message-passing structure."

  __slots__ = (
    '_voiceCommandType', # Anki.Cozmo.VoiceCommand.VoiceCommandType
  )

  @property
  def voiceCommandType(self):
    "Anki.Cozmo.VoiceCommand.VoiceCommandType voiceCommandType struct property."
    return self._voiceCommandType

  @voiceCommandType.setter
  def voiceCommandType(self, value):
    self._voiceCommandType = msgbuffers.validate_integer(
      'RespondingToCommand.voiceCommandType', value, 0, 255)

  def __init__(self, voiceCommandType=Anki.Cozmo.VoiceCommand.VoiceCommandType.Continue):
    self.voiceCommandType = voiceCommandType

  @classmethod
  def unpack(cls, buffer):
    "Reads a new RespondingToCommand from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('RespondingToCommand.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new RespondingToCommand from the given BinaryReader."
    _voiceCommandType = reader.read('B')
    return cls(_voiceCommandType)

  def pack(self):
    "Writes the current RespondingToCommand, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current RespondingToCommand to the given BinaryWriter."
    writer.write(self._voiceCommandType, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return self._voiceCommandType == other._voiceCommandType
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._voiceCommandType, 'B'))

  def __str__(self):
    return '{type}(voiceCommandType={voiceCommandType})'.format(
      type=type(self).__name__,
      voiceCommandType=self._voiceCommandType)

  def __repr__(self):
    return '{type}(voiceCommandType={voiceCommandType})'.format(
      type=type(self).__name__,
      voiceCommandType=repr(self._voiceCommandType))

Anki.Cozmo.VoiceCommand.RespondingToCommand = RespondingToCommand
del RespondingToCommand


class RespondingToCommandStart(object):
  "Generated message-passing structure."

  __slots__ = (
    '_voiceCommandType', # Anki.Cozmo.VoiceCommand.VoiceCommandType
  )

  @property
  def voiceCommandType(self):
    "Anki.Cozmo.VoiceCommand.VoiceCommandType voiceCommandType struct property."
    return self._voiceCommandType

  @voiceCommandType.setter
  def voiceCommandType(self, value):
    self._voiceCommandType = msgbuffers.validate_integer(
      'RespondingToCommandStart.voiceCommandType', value, 0, 255)

  def __init__(self, voiceCommandType=Anki.Cozmo.VoiceCommand.VoiceCommandType.Continue):
    self.voiceCommandType = voiceCommandType

  @classmethod
  def unpack(cls, buffer):
    "Reads a new RespondingToCommandStart from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('RespondingToCommandStart.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new RespondingToCommandStart from the given BinaryReader."
    _voiceCommandType = reader.read('B')
    return cls(_voiceCommandType)

  def pack(self):
    "Writes the current RespondingToCommandStart, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current RespondingToCommandStart to the given BinaryWriter."
    writer.write(self._voiceCommandType, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return self._voiceCommandType == other._voiceCommandType
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._voiceCommandType, 'B'))

  def __str__(self):
    return '{type}(voiceCommandType={voiceCommandType})'.format(
      type=type(self).__name__,
      voiceCommandType=self._voiceCommandType)

  def __repr__(self):
    return '{type}(voiceCommandType={voiceCommandType})'.format(
      type=type(self).__name__,
      voiceCommandType=repr(self._voiceCommandType))

Anki.Cozmo.VoiceCommand.RespondingToCommandStart = RespondingToCommandStart
del RespondingToCommandStart


class RespondingToCommandEnd(object):
  "Generated message-passing structure."

  __slots__ = (
    '_voiceCommandType', # Anki.Cozmo.VoiceCommand.VoiceCommandType
  )

  @property
  def voiceCommandType(self):
    "Anki.Cozmo.VoiceCommand.VoiceCommandType voiceCommandType struct property."
    return self._voiceCommandType

  @voiceCommandType.setter
  def voiceCommandType(self, value):
    self._voiceCommandType = msgbuffers.validate_integer(
      'RespondingToCommandEnd.voiceCommandType', value, 0, 255)

  def __init__(self, voiceCommandType=Anki.Cozmo.VoiceCommand.VoiceCommandType.Continue):
    self.voiceCommandType = voiceCommandType

  @classmethod
  def unpack(cls, buffer):
    "Reads a new RespondingToCommandEnd from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('RespondingToCommandEnd.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new RespondingToCommandEnd from the given BinaryReader."
    _voiceCommandType = reader.read('B')
    return cls(_voiceCommandType)

  def pack(self):
    "Writes the current RespondingToCommandEnd, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current RespondingToCommandEnd to the given BinaryWriter."
    writer.write(self._voiceCommandType, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return self._voiceCommandType == other._voiceCommandType
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._voiceCommandType, 'B'))

  def __str__(self):
    return '{type}(voiceCommandType={voiceCommandType})'.format(
      type=type(self).__name__,
      voiceCommandType=self._voiceCommandType)

  def __repr__(self):
    return '{type}(voiceCommandType={voiceCommandType})'.format(
      type=type(self).__name__,
      voiceCommandType=repr(self._voiceCommandType))

Anki.Cozmo.VoiceCommand.RespondingToCommandEnd = RespondingToCommandEnd
del RespondingToCommandEnd


class StateData(object):
  "Generated message-passing structure."

  __slots__ = (
    '_isVCEnabled',            # bool
    '_capturePermissionState', # Anki.Cozmo.VoiceCommand.AudioCapturePermissionState
  )

  @property
  def isVCEnabled(self):
    "bool isVCEnabled struct property."
    return self._isVCEnabled

  @isVCEnabled.setter
  def isVCEnabled(self, value):
    self._isVCEnabled = msgbuffers.validate_bool(
      'StateData.isVCEnabled', value)

  @property
  def capturePermissionState(self):
    "Anki.Cozmo.VoiceCommand.AudioCapturePermissionState capturePermissionState struct property."
    return self._capturePermissionState

  @capturePermissionState.setter
  def capturePermissionState(self, value):
    self._capturePermissionState = msgbuffers.validate_integer(
      'StateData.capturePermissionState', value, 0, 255)

  def __init__(self, isVCEnabled=False, capturePermissionState=Anki.Cozmo.VoiceCommand.AudioCapturePermissionState.Unknown):
    self.isVCEnabled = isVCEnabled
    self.capturePermissionState = capturePermissionState

  @classmethod
  def unpack(cls, buffer):
    "Reads a new StateData from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('StateData.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new StateData from the given BinaryReader."
    _isVCEnabled = bool(reader.read('b'))
    _capturePermissionState = reader.read('B')
    return cls(_isVCEnabled, _capturePermissionState)

  def pack(self):
    "Writes the current StateData, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current StateData to the given BinaryWriter."
    writer.write(int(self._isVCEnabled), 'b')
    writer.write(self._capturePermissionState, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._isVCEnabled == other._isVCEnabled and
        self._capturePermissionState == other._capturePermissionState)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._isVCEnabled, 'b') +
      msgbuffers.size(self._capturePermissionState, 'B'))

  def __str__(self):
    return '{type}(isVCEnabled={isVCEnabled}, capturePermissionState={capturePermissionState})'.format(
      type=type(self).__name__,
      isVCEnabled=self._isVCEnabled,
      capturePermissionState=self._capturePermissionState)

  def __repr__(self):
    return '{type}(isVCEnabled={isVCEnabled}, capturePermissionState={capturePermissionState})'.format(
      type=type(self).__name__,
      isVCEnabled=repr(self._isVCEnabled),
      capturePermissionState=repr(self._capturePermissionState))

Anki.Cozmo.VoiceCommand.StateData = StateData
del StateData


class UserResponseToPrompt(object):
  "Generated message-passing structure."

  __slots__ = (
    '_positiveResponse', # bool
  )

  @property
  def positiveResponse(self):
    "bool positiveResponse struct property."
    return self._positiveResponse

  @positiveResponse.setter
  def positiveResponse(self, value):
    self._positiveResponse = msgbuffers.validate_bool(
      'UserResponseToPrompt.positiveResponse', value)

  def __init__(self, positiveResponse=False):
    self.positiveResponse = positiveResponse

  @classmethod
  def unpack(cls, buffer):
    "Reads a new UserResponseToPrompt from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('UserResponseToPrompt.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new UserResponseToPrompt from the given BinaryReader."
    _positiveResponse = bool(reader.read('b'))
    return cls(_positiveResponse)

  def pack(self):
    "Writes the current UserResponseToPrompt, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current UserResponseToPrompt to the given BinaryWriter."
    writer.write(int(self._positiveResponse), 'b')

  def __eq__(self, other):
    if type(self) is type(other):
      return self._positiveResponse == other._positiveResponse
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._positiveResponse, 'b'))

  def __str__(self):
    return '{type}(positiveResponse={positiveResponse})'.format(
      type=type(self).__name__,
      positiveResponse=self._positiveResponse)

  def __repr__(self):
    return '{type}(positiveResponse={positiveResponse})'.format(
      type=type(self).__name__,
      positiveResponse=repr(self._positiveResponse))

Anki.Cozmo.VoiceCommand.UserResponseToPrompt = UserResponseToPrompt
del UserResponseToPrompt


class RequestStatusUpdate(object):
  "Generated message-passing structure."

  __slots__ = ()

  def __init__(self):
    pass

  @classmethod
  def unpack(cls, buffer):
    "Reads a new RequestStatusUpdate from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('RequestStatusUpdate.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new RequestStatusUpdate from the given BinaryReader."
    return cls()

  def pack(self):
    "Writes the current RequestStatusUpdate, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current RequestStatusUpdate to the given BinaryWriter."

  def __eq__(self, other):
    if type(self) is type(other):
      return True
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return 0

  def __str__(self):
    return '{type}()'.format(type=type(self).__name__)

  def __repr__(self):
    return '{type}()'.format(type=type(self).__name__)

Anki.Cozmo.VoiceCommand.RequestStatusUpdate = RequestStatusUpdate
del RequestStatusUpdate


class ChangeEnabledStatus(object):
  "Generated message-passing structure."

  __slots__ = (
    '_isVCEnabled', # bool
  )

  @property
  def isVCEnabled(self):
    "bool isVCEnabled struct property."
    return self._isVCEnabled

  @isVCEnabled.setter
  def isVCEnabled(self, value):
    self._isVCEnabled = msgbuffers.validate_bool(
      'ChangeEnabledStatus.isVCEnabled', value)

  def __init__(self, isVCEnabled=False):
    self.isVCEnabled = isVCEnabled

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ChangeEnabledStatus from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ChangeEnabledStatus.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ChangeEnabledStatus from the given BinaryReader."
    _isVCEnabled = bool(reader.read('b'))
    return cls(_isVCEnabled)

  def pack(self):
    "Writes the current ChangeEnabledStatus, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ChangeEnabledStatus to the given BinaryWriter."
    writer.write(int(self._isVCEnabled), 'b')

  def __eq__(self, other):
    if type(self) is type(other):
      return self._isVCEnabled == other._isVCEnabled
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._isVCEnabled, 'b'))

  def __str__(self):
    return '{type}(isVCEnabled={isVCEnabled})'.format(
      type=type(self).__name__,
      isVCEnabled=self._isVCEnabled)

  def __repr__(self):
    return '{type}(isVCEnabled={isVCEnabled})'.format(
      type=type(self).__name__,
      isVCEnabled=repr(self._isVCEnabled))

Anki.Cozmo.VoiceCommand.ChangeEnabledStatus = ChangeEnabledStatus
del ChangeEnabledStatus


class ChangeContext(object):
  "Generated message-passing structure."

  __slots__ = (
    '_newContext', # Anki.Cozmo.VoiceCommand.VoiceCommandListenContext
  )

  @property
  def newContext(self):
    "Anki.Cozmo.VoiceCommand.VoiceCommandListenContext newContext struct property."
    return self._newContext

  @newContext.setter
  def newContext(self, value):
    self._newContext = msgbuffers.validate_integer(
      'ChangeContext.newContext', value, 0, 255)

  def __init__(self, newContext=Anki.Cozmo.VoiceCommand.VoiceCommandListenContext.ContinuePrompt):
    self.newContext = newContext

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ChangeContext from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ChangeContext.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ChangeContext from the given BinaryReader."
    _newContext = reader.read('B')
    return cls(_newContext)

  def pack(self):
    "Writes the current ChangeContext, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ChangeContext to the given BinaryWriter."
    writer.write(self._newContext, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return self._newContext == other._newContext
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._newContext, 'B'))

  def __str__(self):
    return '{type}(newContext={newContext})'.format(
      type=type(self).__name__,
      newContext=self._newContext)

  def __repr__(self):
    return '{type}(newContext={newContext})'.format(
      type=type(self).__name__,
      newContext=repr(self._newContext))

Anki.Cozmo.VoiceCommand.ChangeContext = ChangeContext
del ChangeContext


class VoiceCommandEventUnion(object):
  "Generated message-passing union."

  __slots__ = ('_tag', '_data')

  class Tag(object):
    "The type indicator for this union."
    respondingToCommand      = 0 # Anki.Cozmo.VoiceCommand.RespondingToCommand
    respondingToCommandStart = 1 # Anki.Cozmo.VoiceCommand.RespondingToCommandStart
    respondingToCommandEnd   = 2 # Anki.Cozmo.VoiceCommand.RespondingToCommandEnd
    stateData                = 3 # Anki.Cozmo.VoiceCommand.StateData
    responseToPrompt         = 4 # Anki.Cozmo.VoiceCommand.UserResponseToPrompt
    requestStatusUpdate      = 5 # Anki.Cozmo.VoiceCommand.RequestStatusUpdate
    changeEnabledStatus      = 6 # Anki.Cozmo.VoiceCommand.ChangeEnabledStatus
    changeContext            = 7 # Anki.Cozmo.VoiceCommand.ChangeContext

  @property
  def tag(self):
    "The current tag for this union."
    return self._tag

  @property
  def tag_name(self):
    "The name of the current tag for this union."
    if self._tag in self._tags_by_value:
      return self._tags_by_value[self._tag]
    else:
      return None

  @property
  def data(self):
    "The data held by this union. None if no data is set."
    return self._data

  @property
  def respondingToCommand(self):
    "Anki.Cozmo.VoiceCommand.RespondingToCommand respondingToCommand union property."
    msgbuffers.safety_check_tag('respondingToCommand', self._tag, self.Tag.respondingToCommand, self._tags_by_value)
    return self._data

  @respondingToCommand.setter
  def respondingToCommand(self, value):
    self._data = msgbuffers.validate_object(
      'VoiceCommandEventUnion.respondingToCommand', value, Anki.Cozmo.VoiceCommand.RespondingToCommand)
    self._tag = self.Tag.respondingToCommand

  @property
  def respondingToCommandStart(self):
    "Anki.Cozmo.VoiceCommand.RespondingToCommandStart respondingToCommandStart union property."
    msgbuffers.safety_check_tag('respondingToCommandStart', self._tag, self.Tag.respondingToCommandStart, self._tags_by_value)
    return self._data

  @respondingToCommandStart.setter
  def respondingToCommandStart(self, value):
    self._data = msgbuffers.validate_object(
      'VoiceCommandEventUnion.respondingToCommandStart', value, Anki.Cozmo.VoiceCommand.RespondingToCommandStart)
    self._tag = self.Tag.respondingToCommandStart

  @property
  def respondingToCommandEnd(self):
    "Anki.Cozmo.VoiceCommand.RespondingToCommandEnd respondingToCommandEnd union property."
    msgbuffers.safety_check_tag('respondingToCommandEnd', self._tag, self.Tag.respondingToCommandEnd, self._tags_by_value)
    return self._data

  @respondingToCommandEnd.setter
  def respondingToCommandEnd(self, value):
    self._data = msgbuffers.validate_object(
      'VoiceCommandEventUnion.respondingToCommandEnd', value, Anki.Cozmo.VoiceCommand.RespondingToCommandEnd)
    self._tag = self.Tag.respondingToCommandEnd

  @property
  def stateData(self):
    "Anki.Cozmo.VoiceCommand.StateData stateData union property."
    msgbuffers.safety_check_tag('stateData', self._tag, self.Tag.stateData, self._tags_by_value)
    return self._data

  @stateData.setter
  def stateData(self, value):
    self._data = msgbuffers.validate_object(
      'VoiceCommandEventUnion.stateData', value, Anki.Cozmo.VoiceCommand.StateData)
    self._tag = self.Tag.stateData

  @property
  def responseToPrompt(self):
    "Anki.Cozmo.VoiceCommand.UserResponseToPrompt responseToPrompt union property."
    msgbuffers.safety_check_tag('responseToPrompt', self._tag, self.Tag.responseToPrompt, self._tags_by_value)
    return self._data

  @responseToPrompt.setter
  def responseToPrompt(self, value):
    self._data = msgbuffers.validate_object(
      'VoiceCommandEventUnion.responseToPrompt', value, Anki.Cozmo.VoiceCommand.UserResponseToPrompt)
    self._tag = self.Tag.responseToPrompt

  @property
  def requestStatusUpdate(self):
    "Anki.Cozmo.VoiceCommand.RequestStatusUpdate requestStatusUpdate union property."
    msgbuffers.safety_check_tag('requestStatusUpdate', self._tag, self.Tag.requestStatusUpdate, self._tags_by_value)
    return self._data

  @requestStatusUpdate.setter
  def requestStatusUpdate(self, value):
    self._data = msgbuffers.validate_object(
      'VoiceCommandEventUnion.requestStatusUpdate', value, Anki.Cozmo.VoiceCommand.RequestStatusUpdate)
    self._tag = self.Tag.requestStatusUpdate

  @property
  def changeEnabledStatus(self):
    "Anki.Cozmo.VoiceCommand.ChangeEnabledStatus changeEnabledStatus union property."
    msgbuffers.safety_check_tag('changeEnabledStatus', self._tag, self.Tag.changeEnabledStatus, self._tags_by_value)
    return self._data

  @changeEnabledStatus.setter
  def changeEnabledStatus(self, value):
    self._data = msgbuffers.validate_object(
      'VoiceCommandEventUnion.changeEnabledStatus', value, Anki.Cozmo.VoiceCommand.ChangeEnabledStatus)
    self._tag = self.Tag.changeEnabledStatus

  @property
  def changeContext(self):
    "Anki.Cozmo.VoiceCommand.ChangeContext changeContext union property."
    msgbuffers.safety_check_tag('changeContext', self._tag, self.Tag.changeContext, self._tags_by_value)
    return self._data

  @changeContext.setter
  def changeContext(self, value):
    self._data = msgbuffers.validate_object(
      'VoiceCommandEventUnion.changeContext', value, Anki.Cozmo.VoiceCommand.ChangeContext)
    self._tag = self.Tag.changeContext

  def __init__(self, **kwargs):
    if not kwargs:
      self._tag = None
      self._data = None

    elif len(kwargs) == 1:
      key, value = next(iter(kwargs.items()))
      if key not in self._tags_by_name:
        raise TypeError("'{argument}' is an invalid keyword argument for this method.".format(argument=key))
      # calls the correct property
      setattr(self, key, value)

    else:
      raise TypeError('This method only accepts up to one keyword argument.')

  @classmethod
  def unpack(cls, buffer):
    "Reads a new VoiceCommandEventUnion from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('VoiceCommandEventUnion.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new VoiceCommandEventUnion from the given BinaryReader."
    tag = reader.read('B')
    if tag in cls._tags_by_value:
      value = cls()
      setattr(value, cls._tags_by_value[tag], cls._tag_unpack_methods[tag](reader))
      return value
    else:
      raise ValueError('VoiceCommandEventUnion attempted to unpack unknown tag {tag}.'.format(tag=tag))

  def pack(self):
    "Writes the current VoiceCommandEventUnion, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current SampleUnion to the given BinaryWriter."
    if self._tag in self._tags_by_value:
      writer.write(self._tag, 'B')
      self._tag_pack_methods[self._tag](writer, self._data)
    else:
      raise ValueError('Cannot pack an empty VoiceCommandEventUnion.')

  def clear(self):
    self._tag = None
    self._data = None

  @classmethod
  def typeByTag(cls, tag):
    return cls._type_by_tag_value[tag]()

  def __eq__(self, other):
    if type(self) is type(other):
      return self._tag == other._tag and self._data == other._data
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    if 0 <= self._tag < 8:
      return self._tag_size_methods[self._tag](self._data)
    else:
      return 1

  def __str__(self):
    if 0 <= self._tag < 8:
      return '{type}({name}={value})'.format(
        type=type(self).__name__,
        name=self.tag_name,
        value=self._data)
    else:
      return '{type}()'.format(
        type=type(self).__name__)

  def __repr__(self):
    if 0 <= self._tag < 8:
      return '{type}({name}={value})'.format(
        type=type(self).__name__,
        name=self.tag_name,
        value=repr(self._data))
    else:
      return '{type}()'.format(
        type=type(self).__name__)

  _tags_by_name = dict(
    respondingToCommand=0,
    respondingToCommandStart=1,
    respondingToCommandEnd=2,
    stateData=3,
    responseToPrompt=4,
    requestStatusUpdate=5,
    changeEnabledStatus=6,
    changeContext=7,
  )

  _tags_by_value = dict()
  _tags_by_value[0] = 'respondingToCommand'
  _tags_by_value[1] = 'respondingToCommandStart'
  _tags_by_value[2] = 'respondingToCommandEnd'
  _tags_by_value[3] = 'stateData'
  _tags_by_value[4] = 'responseToPrompt'
  _tags_by_value[5] = 'requestStatusUpdate'
  _tags_by_value[6] = 'changeEnabledStatus'
  _tags_by_value[7] = 'changeContext'
  

  _tag_unpack_methods = dict()
  _tag_unpack_methods[0] = lambda reader: reader.read_object(Anki.Cozmo.VoiceCommand.RespondingToCommand.unpack_from)
  _tag_unpack_methods[1] = lambda reader: reader.read_object(Anki.Cozmo.VoiceCommand.RespondingToCommandStart.unpack_from)
  _tag_unpack_methods[2] = lambda reader: reader.read_object(Anki.Cozmo.VoiceCommand.RespondingToCommandEnd.unpack_from)
  _tag_unpack_methods[3] = lambda reader: reader.read_object(Anki.Cozmo.VoiceCommand.StateData.unpack_from)
  _tag_unpack_methods[4] = lambda reader: reader.read_object(Anki.Cozmo.VoiceCommand.UserResponseToPrompt.unpack_from)
  _tag_unpack_methods[5] = lambda reader: reader.read_object(Anki.Cozmo.VoiceCommand.RequestStatusUpdate.unpack_from)
  _tag_unpack_methods[6] = lambda reader: reader.read_object(Anki.Cozmo.VoiceCommand.ChangeEnabledStatus.unpack_from)
  _tag_unpack_methods[7] = lambda reader: reader.read_object(Anki.Cozmo.VoiceCommand.ChangeContext.unpack_from)
  

  _tag_pack_methods = dict()
  _tag_pack_methods[0] = lambda writer, value: writer.write_object(value)
  _tag_pack_methods[1] = lambda writer, value: writer.write_object(value)
  _tag_pack_methods[2] = lambda writer, value: writer.write_object(value)
  _tag_pack_methods[3] = lambda writer, value: writer.write_object(value)
  _tag_pack_methods[4] = lambda writer, value: writer.write_object(value)
  _tag_pack_methods[5] = lambda writer, value: writer.write_object(value)
  _tag_pack_methods[6] = lambda writer, value: writer.write_object(value)
  _tag_pack_methods[7] = lambda writer, value: writer.write_object(value)
  

  _tag_size_methods = dict()
  _tag_size_methods[0] = lambda value: msgbuffers.size_object(value)
  _tag_size_methods[1] = lambda value: msgbuffers.size_object(value)
  _tag_size_methods[2] = lambda value: msgbuffers.size_object(value)
  _tag_size_methods[3] = lambda value: msgbuffers.size_object(value)
  _tag_size_methods[4] = lambda value: msgbuffers.size_object(value)
  _tag_size_methods[5] = lambda value: msgbuffers.size_object(value)
  _tag_size_methods[6] = lambda value: msgbuffers.size_object(value)
  _tag_size_methods[7] = lambda value: msgbuffers.size_object(value)
  

  _type_by_tag_value = dict()
  _type_by_tag_value[0] = lambda : Anki.Cozmo.VoiceCommand.RespondingToCommand
  _type_by_tag_value[1] = lambda : Anki.Cozmo.VoiceCommand.RespondingToCommandStart
  _type_by_tag_value[2] = lambda : Anki.Cozmo.VoiceCommand.RespondingToCommandEnd
  _type_by_tag_value[3] = lambda : Anki.Cozmo.VoiceCommand.StateData
  _type_by_tag_value[4] = lambda : Anki.Cozmo.VoiceCommand.UserResponseToPrompt
  _type_by_tag_value[5] = lambda : Anki.Cozmo.VoiceCommand.RequestStatusUpdate
  _type_by_tag_value[6] = lambda : Anki.Cozmo.VoiceCommand.ChangeEnabledStatus
  _type_by_tag_value[7] = lambda : Anki.Cozmo.VoiceCommand.ChangeContext
  

Anki.Cozmo.VoiceCommand.VoiceCommandEventUnion = VoiceCommandEventUnion
del VoiceCommandEventUnion


class VoiceCommandEvent(object):
  "Generated message-passing message."

  __slots__ = (
    '_voiceCommandEvent', # Anki.Cozmo.VoiceCommand.VoiceCommandEventUnion
  )

  @property
  def voiceCommandEvent(self):
    "Anki.Cozmo.VoiceCommand.VoiceCommandEventUnion voiceCommandEvent struct property."
    return self._voiceCommandEvent

  @voiceCommandEvent.setter
  def voiceCommandEvent(self, value):
    self._voiceCommandEvent = msgbuffers.validate_object(
      'VoiceCommandEvent.voiceCommandEvent', value, Anki.Cozmo.VoiceCommand.VoiceCommandEventUnion)

  def __init__(self, voiceCommandEvent=Anki.Cozmo.VoiceCommand.VoiceCommandEventUnion()):
    self.voiceCommandEvent = voiceCommandEvent

  @classmethod
  def unpack(cls, buffer):
    "Reads a new VoiceCommandEvent from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('VoiceCommandEvent.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new VoiceCommandEvent from the given BinaryReader."
    _voiceCommandEvent = reader.read_object(Anki.Cozmo.VoiceCommand.VoiceCommandEventUnion.unpack_from)
    return cls(_voiceCommandEvent)

  def pack(self):
    "Writes the current VoiceCommandEvent, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current VoiceCommandEvent to the given BinaryWriter."
    writer.write_object(self._voiceCommandEvent)

  def __eq__(self, other):
    if type(self) is type(other):
      return self._voiceCommandEvent == other._voiceCommandEvent
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size_object(self._voiceCommandEvent))

  def __str__(self):
    return '{type}(voiceCommandEvent={voiceCommandEvent})'.format(
      type=type(self).__name__,
      voiceCommandEvent=self._voiceCommandEvent)

  def __repr__(self):
    return '{type}(voiceCommandEvent={voiceCommandEvent})'.format(
      type=type(self).__name__,
      voiceCommandEvent=repr(self._voiceCommandEvent))

Anki.Cozmo.VoiceCommand.VoiceCommandEvent = VoiceCommandEvent
del VoiceCommandEvent


