# coding: utf-8

"""
    Nucleus REST API


    OpenAPI spec version: 0.4.3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class DefaultApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def activate_client(self, client_code, **kwargs):
        """
        
        Reactivates a deactivated client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.activate_client(client_code, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_code: Code of the client to activate (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.activate_client_with_http_info(client_code, **kwargs)
        else:
            (data) = self.activate_client_with_http_info(client_code, **kwargs)
            return data

    def activate_client_with_http_info(self, client_code, **kwargs):
        """
        
        Reactivates a deactivated client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.activate_client_with_http_info(client_code, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_code: Code of the client to activate (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_code']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method activate_client" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_code' is set
        if ('client_code' not in params) or (params['client_code'] is None):
            raise ValueError("Missing the required parameter `client_code` when calling `activate_client`")

        resource_path = '/clients/activate/code-{client_code}'.replace('{format}', 'json')
        path_params = {}
        if 'client_code' in params:
            path_params['client_code'] = params['client_code']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def activate_user(self, activation_key, updates, **kwargs):
        """
        
        Activate a user's account.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.activate_user(activation_key, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str activation_key:  (required)
        :param UserActivation updates:  (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.activate_user_with_http_info(activation_key, updates, **kwargs)
        else:
            (data) = self.activate_user_with_http_info(activation_key, updates, **kwargs)
            return data

    def activate_user_with_http_info(self, activation_key, updates, **kwargs):
        """
        
        Activate a user's account.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.activate_user_with_http_info(activation_key, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str activation_key:  (required)
        :param UserActivation updates:  (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['activation_key', 'updates']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method activate_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'activation_key' is set
        if ('activation_key' not in params) or (params['activation_key'] is None):
            raise ValueError("Missing the required parameter `activation_key` when calling `activate_user`")
        # verify the required parameter 'updates' is set
        if ('updates' not in params) or (params['updates'] is None):
            raise ValueError("Missing the required parameter `updates` when calling `activate_user`")

        resource_path = '/user-activations/{activation_key}'.replace('{format}', 'json')
        path_params = {}
        if 'activation_key' in params:
            path_params['activation_key'] = params['activation_key']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'updates' in params:
            body_params = params['updates']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='User',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_api_key(self, user, **kwargs):
        """
        
        Add a new API key for a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_api_key(user, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ApiKey user:  (required)
        :param str client_id: 
        :return: ApiKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_api_key_with_http_info(user, **kwargs)
        else:
            (data) = self.add_api_key_with_http_info(user, **kwargs)
            return data

    def add_api_key_with_http_info(self, user, **kwargs):
        """
        
        Add a new API key for a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_api_key_with_http_info(user, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ApiKey user:  (required)
        :param str client_id: 
        :return: ApiKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_api_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params) or (params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `add_api_key`")

        resource_path = '/api-keys'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user' in params:
            body_params = params['user']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ApiKey',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_block_type(self, block_type, **kwargs):
        """
        
        Add a block type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_block_type(block_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param BlockType block_type:  (required)
        :return: BlockType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_block_type_with_http_info(block_type, **kwargs)
        else:
            (data) = self.add_block_type_with_http_info(block_type, **kwargs)
            return data

    def add_block_type_with_http_info(self, block_type, **kwargs):
        """
        
        Add a block type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_block_type_with_http_info(block_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param BlockType block_type:  (required)
        :return: BlockType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['block_type']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_block_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'block_type' is set
        if ('block_type' not in params) or (params['block_type'] is None):
            raise ValueError("Missing the required parameter `block_type` when calling `add_block_type`")

        resource_path = '/block-types'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'block_type' in params:
            body_params = params['block_type']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='BlockType',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_client(self, client, **kwargs):
        """
        
        Add a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_client(client, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Client client: Client to add. (required)
        :return: Client
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_client_with_http_info(client, **kwargs)
        else:
            (data) = self.add_client_with_http_info(client, **kwargs)
            return data

    def add_client_with_http_info(self, client, **kwargs):
        """
        
        Add a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_client_with_http_info(client, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Client client: Client to add. (required)
        :return: Client
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_client" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client' is set
        if ('client' not in params) or (params['client'] is None):
            raise ValueError("Missing the required parameter `client` when calling `add_client`")

        resource_path = '/clients'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'client' in params:
            body_params = params['client']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Client',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_dataset(self, client_id, dataset, **kwargs):
        """
        
        Add a new dataset to a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_dataset(client_id, dataset, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :param Dataset dataset: Dataset to add. (required)
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_dataset_with_http_info(client_id, dataset, **kwargs)
        else:
            (data) = self.add_dataset_with_http_info(client_id, dataset, **kwargs)
            return data

    def add_dataset_with_http_info(self, client_id, dataset, **kwargs):
        """
        
        Add a new dataset to a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_dataset_with_http_info(client_id, dataset, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :param Dataset dataset: Dataset to add. (required)
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'dataset']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dataset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `add_dataset`")
        # verify the required parameter 'dataset' is set
        if ('dataset' not in params) or (params['dataset'] is None):
            raise ValueError("Missing the required parameter `dataset` when calling `add_dataset`")

        resource_path = '/datasets'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dataset' in params:
            body_params = params['dataset']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Dataset',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_dataset_type(self, dataset_type, **kwargs):
        """
        
        Adds a dataset type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_dataset_type(dataset_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param DatasetType dataset_type: Dataset type to add. (required)
        :return: DatasetType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_dataset_type_with_http_info(dataset_type, **kwargs)
        else:
            (data) = self.add_dataset_type_with_http_info(dataset_type, **kwargs)
            return data

    def add_dataset_type_with_http_info(self, dataset_type, **kwargs):
        """
        
        Adds a dataset type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_dataset_type_with_http_info(dataset_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param DatasetType dataset_type: Dataset type to add. (required)
        :return: DatasetType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dataset_type']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dataset_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dataset_type' is set
        if ('dataset_type' not in params) or (params['dataset_type'] is None):
            raise ValueError("Missing the required parameter `dataset_type` when calling `add_dataset_type`")

        resource_path = '/dataset-types'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dataset_type' in params:
            body_params = params['dataset_type']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DatasetType',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_integration(self, client_id, integration, **kwargs):
        """
        
        Add an integration to a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_integration(client_id, integration, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :param Integration integration:  (required)
        :return: Client
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_integration_with_http_info(client_id, integration, **kwargs)
        else:
            (data) = self.add_integration_with_http_info(client_id, integration, **kwargs)
            return data

    def add_integration_with_http_info(self, client_id, integration, **kwargs):
        """
        
        Add an integration to a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_integration_with_http_info(client_id, integration, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :param Integration integration:  (required)
        :return: Client
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'integration']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_integration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `add_integration`")
        # verify the required parameter 'integration' is set
        if ('integration' not in params) or (params['integration'] is None):
            raise ValueError("Missing the required parameter `integration` when calling `add_integration`")

        resource_path = '/integrations'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'integration' in params:
            body_params = params['integration']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Client',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_integration_type(self, integration_type, **kwargs):
        """
        
        Add an integration type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_integration_type(integration_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param IntegrationType integration_type:  (required)
        :return: IntegrationType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_integration_type_with_http_info(integration_type, **kwargs)
        else:
            (data) = self.add_integration_type_with_http_info(integration_type, **kwargs)
            return data

    def add_integration_type_with_http_info(self, integration_type, **kwargs):
        """
        
        Add an integration type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_integration_type_with_http_info(integration_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param IntegrationType integration_type:  (required)
        :return: IntegrationType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['integration_type']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_integration_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'integration_type' is set
        if ('integration_type' not in params) or (params['integration_type'] is None):
            raise ValueError("Missing the required parameter `integration_type` when calling `add_integration_type`")

        resource_path = '/integration-types'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'integration_type' in params:
            body_params = params['integration_type']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='IntegrationType',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_user(self, user, **kwargs):
        """
        
        Add a user to a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_user(user, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param User user:  (required)
        :param str client_id: 
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_user_with_http_info(user, **kwargs)
        else:
            (data) = self.add_user_with_http_info(user, **kwargs)
            return data

    def add_user_with_http_info(self, user, **kwargs):
        """
        
        Add a user to a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_user_with_http_info(user, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param User user:  (required)
        :param str client_id: 
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params) or (params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `add_user`")

        resource_path = '/users'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user' in params:
            body_params = params['user']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='User',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_view(self, client_id, view, **kwargs):
        """
        
        Add a view for a specific client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_view(client_id, view, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :param View view: View to add. (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_view_with_http_info(client_id, view, **kwargs)
        else:
            (data) = self.add_view_with_http_info(client_id, view, **kwargs)
            return data

    def add_view_with_http_info(self, client_id, view, **kwargs):
        """
        
        Add a view for a specific client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_view_with_http_info(client_id, view, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :param View view: View to add. (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'view']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_view" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `add_view`")
        # verify the required parameter 'view' is set
        if ('view' not in params) or (params['view'] is None):
            raise ValueError("Missing the required parameter `view` when calling `add_view`")

        resource_path = '/views'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'view' in params:
            body_params = params['view']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='View',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_view_type(self, view_type, **kwargs):
        """
        
        Add a new view type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_view_type(view_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ViewType view_type:  (required)
        :return: ViewType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_view_type_with_http_info(view_type, **kwargs)
        else:
            (data) = self.add_view_type_with_http_info(view_type, **kwargs)
            return data

    def add_view_type_with_http_info(self, view_type, **kwargs):
        """
        
        Add a new view type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_view_type_with_http_info(view_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ViewType view_type:  (required)
        :return: ViewType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['view_type']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_view_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'view_type' is set
        if ('view_type' not in params) or (params['view_type'] is None):
            raise ValueError("Missing the required parameter `view_type` when calling `add_view_type`")

        resource_path = '/view-types'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'view_type' in params:
            body_params = params['view_type']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ViewType',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_widget_type(self, widget_type, **kwargs):
        """
        
        Add a widget type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_widget_type(widget_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param WidgetType widget_type:  (required)
        :return: WidgetType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_widget_type_with_http_info(widget_type, **kwargs)
        else:
            (data) = self.add_widget_type_with_http_info(widget_type, **kwargs)
            return data

    def add_widget_type_with_http_info(self, widget_type, **kwargs):
        """
        
        Add a widget type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_widget_type_with_http_info(widget_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param WidgetType widget_type:  (required)
        :return: WidgetType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['widget_type']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_widget_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'widget_type' is set
        if ('widget_type' not in params) or (params['widget_type'] is None):
            raise ValueError("Missing the required parameter `widget_type` when calling `add_widget_type`")

        resource_path = '/widget-types'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'widget_type' in params:
            body_params = params['widget_type']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='WidgetType',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def change_password(self, user_id, change_request, **kwargs):
        """
        
        Change password.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.change_password(user_id, change_request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id:  (required)
        :param PasswordChangeRequest change_request:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.change_password_with_http_info(user_id, change_request, **kwargs)
        else:
            (data) = self.change_password_with_http_info(user_id, change_request, **kwargs)
            return data

    def change_password_with_http_info(self, user_id, change_request, **kwargs):
        """
        
        Change password.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.change_password_with_http_info(user_id, change_request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id:  (required)
        :param PasswordChangeRequest change_request:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'change_request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_password" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `change_password`")
        # verify the required parameter 'change_request' is set
        if ('change_request' not in params) or (params['change_request'] is None):
            raise ValueError("Missing the required parameter `change_request` when calling `change_password`")

        resource_path = '/password-changes/{user_id}'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'change_request' in params:
            body_params = params['change_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_full_page(self, client_id, page, **kwargs):
        """
        
        Creates a full page for a client. This route should only be used by sysadmins.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_full_page(client_id, page, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :param Page page:  (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_full_page_with_http_info(client_id, page, **kwargs)
        else:
            (data) = self.create_full_page_with_http_info(client_id, page, **kwargs)
            return data

    def create_full_page_with_http_info(self, client_id, page, **kwargs):
        """
        
        Creates a full page for a client. This route should only be used by sysadmins.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_full_page_with_http_info(client_id, page, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :param Page page:  (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'page']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_full_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `create_full_page`")
        # verify the required parameter 'page' is set
        if ('page' not in params) or (params['page'] is None):
            raise ValueError("Missing the required parameter `page` when calling `create_full_page`")

        resource_path = '/pages/full'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'page' in params:
            body_params = params['page']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Page',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_activity_by_external_key(self, external_key, client_id, integration_id, **kwargs):
        """
        
        Delete an activity by external key.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_activity_by_external_key(external_key, client_id, integration_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str external_key:  (required)
        :param str client_id:  (required)
        :param str integration_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_activity_by_external_key_with_http_info(external_key, client_id, integration_id, **kwargs)
        else:
            (data) = self.delete_activity_by_external_key_with_http_info(external_key, client_id, integration_id, **kwargs)
            return data

    def delete_activity_by_external_key_with_http_info(self, external_key, client_id, integration_id, **kwargs):
        """
        
        Delete an activity by external key.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_activity_by_external_key_with_http_info(external_key, client_id, integration_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str external_key:  (required)
        :param str client_id:  (required)
        :param str integration_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['external_key', 'client_id', 'integration_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_activity_by_external_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'external_key' is set
        if ('external_key' not in params) or (params['external_key'] is None):
            raise ValueError("Missing the required parameter `external_key` when calling `delete_activity_by_external_key`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `delete_activity_by_external_key`")
        # verify the required parameter 'integration_id' is set
        if ('integration_id' not in params) or (params['integration_id'] is None):
            raise ValueError("Missing the required parameter `integration_id` when calling `delete_activity_by_external_key`")

        resource_path = '/activities/external-key-{external_key}'.replace('{format}', 'json')
        path_params = {}
        if 'external_key' in params:
            path_params['external_key'] = params['external_key']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']
        if 'integration_id' in params:
            query_params['integration_id'] = params['integration_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_api_key(self, user_id, client_id, **kwargs):
        """
        
        Revoke an API key.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_api_key(user_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id:  (required)
        :param str client_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_api_key_with_http_info(user_id, client_id, **kwargs)
        else:
            (data) = self.delete_api_key_with_http_info(user_id, client_id, **kwargs)
            return data

    def delete_api_key_with_http_info(self, user_id, client_id, **kwargs):
        """
        
        Revoke an API key.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_api_key_with_http_info(user_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id:  (required)
        :param str client_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_api_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_api_key`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `delete_api_key`")

        resource_path = '/api-keys/{user_id}'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_block_type(self, block_type_id, **kwargs):
        """
        
        Delete a block type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_block_type(block_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str block_type_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_block_type_with_http_info(block_type_id, **kwargs)
        else:
            (data) = self.delete_block_type_with_http_info(block_type_id, **kwargs)
            return data

    def delete_block_type_with_http_info(self, block_type_id, **kwargs):
        """
        
        Delete a block type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_block_type_with_http_info(block_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str block_type_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['block_type_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_block_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'block_type_id' is set
        if ('block_type_id' not in params) or (params['block_type_id'] is None):
            raise ValueError("Missing the required parameter `block_type_id` when calling `delete_block_type`")

        resource_path = '/block-types/{block_type_id}'.replace('{format}', 'json')
        path_params = {}
        if 'block_type_id' in params:
            path_params['block_type_id'] = params['block_type_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_client(self, client_id, **kwargs):
        """
        
        Delete a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_client(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: Id of client to get. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_client_with_http_info(client_id, **kwargs)
        else:
            (data) = self.delete_client_with_http_info(client_id, **kwargs)
            return data

    def delete_client_with_http_info(self, client_id, **kwargs):
        """
        
        Delete a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_client_with_http_info(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: Id of client to get. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_client" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `delete_client`")

        resource_path = '/clients/{client_id}'.replace('{format}', 'json')
        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_dataset(self, dataset_id, client_id, **kwargs):
        """
        
        Delete a dataset.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_dataset(dataset_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_id:  (required)
        :param str client_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_dataset_with_http_info(dataset_id, client_id, **kwargs)
        else:
            (data) = self.delete_dataset_with_http_info(dataset_id, client_id, **kwargs)
            return data

    def delete_dataset_with_http_info(self, dataset_id, client_id, **kwargs):
        """
        
        Delete a dataset.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_dataset_with_http_info(dataset_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_id:  (required)
        :param str client_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dataset_id', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dataset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dataset_id' is set
        if ('dataset_id' not in params) or (params['dataset_id'] is None):
            raise ValueError("Missing the required parameter `dataset_id` when calling `delete_dataset`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `delete_dataset`")

        resource_path = '/datasets/{dataset_id}'.replace('{format}', 'json')
        path_params = {}
        if 'dataset_id' in params:
            path_params['dataset_id'] = params['dataset_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_dataset_type(self, dataset_type_id, **kwargs):
        """
        
        Delete a dataset type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_dataset_type(dataset_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_type_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_dataset_type_with_http_info(dataset_type_id, **kwargs)
        else:
            (data) = self.delete_dataset_type_with_http_info(dataset_type_id, **kwargs)
            return data

    def delete_dataset_type_with_http_info(self, dataset_type_id, **kwargs):
        """
        
        Delete a dataset type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_dataset_type_with_http_info(dataset_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_type_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dataset_type_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dataset_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dataset_type_id' is set
        if ('dataset_type_id' not in params) or (params['dataset_type_id'] is None):
            raise ValueError("Missing the required parameter `dataset_type_id` when calling `delete_dataset_type`")

        resource_path = '/dataset-types/{dataset_type_id}'.replace('{format}', 'json')
        path_params = {}
        if 'dataset_type_id' in params:
            path_params['dataset_type_id'] = params['dataset_type_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_integration(self, integration_id, client_id, **kwargs):
        """
        
        Delete an integration from a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_integration(integration_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str integration_id:  (required)
        :param str client_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_integration_with_http_info(integration_id, client_id, **kwargs)
        else:
            (data) = self.delete_integration_with_http_info(integration_id, client_id, **kwargs)
            return data

    def delete_integration_with_http_info(self, integration_id, client_id, **kwargs):
        """
        
        Delete an integration from a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_integration_with_http_info(integration_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str integration_id:  (required)
        :param str client_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['integration_id', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_integration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'integration_id' is set
        if ('integration_id' not in params) or (params['integration_id'] is None):
            raise ValueError("Missing the required parameter `integration_id` when calling `delete_integration`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `delete_integration`")

        resource_path = '/integrations/{integration_id}'.replace('{format}', 'json')
        path_params = {}
        if 'integration_id' in params:
            path_params['integration_id'] = params['integration_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_page(self, page_id, client_id, **kwargs):
        """
        
        Delete a page.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page(page_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str page_id:  (required)
        :param str client_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_page_with_http_info(page_id, client_id, **kwargs)
        else:
            (data) = self.delete_page_with_http_info(page_id, client_id, **kwargs)
            return data

    def delete_page_with_http_info(self, page_id, client_id, **kwargs):
        """
        
        Delete a page.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page_with_http_info(page_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str page_id:  (required)
        :param str client_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_id', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'page_id' is set
        if ('page_id' not in params) or (params['page_id'] is None):
            raise ValueError("Missing the required parameter `page_id` when calling `delete_page`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `delete_page`")

        resource_path = '/pages/{page_id}'.replace('{format}', 'json')
        path_params = {}
        if 'page_id' in params:
            path_params['page_id'] = params['page_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_page_preferences_by_page(self, page_id, client_id, **kwargs):
        """
        
        Delete page preferences for a specific page.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page_preferences_by_page(page_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str page_id:  (required)
        :param str client_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_page_preferences_by_page_with_http_info(page_id, client_id, **kwargs)
        else:
            (data) = self.delete_page_preferences_by_page_with_http_info(page_id, client_id, **kwargs)
            return data

    def delete_page_preferences_by_page_with_http_info(self, page_id, client_id, **kwargs):
        """
        
        Delete page preferences for a specific page.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page_preferences_by_page_with_http_info(page_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str page_id:  (required)
        :param str client_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_id', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_page_preferences_by_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'page_id' is set
        if ('page_id' not in params) or (params['page_id'] is None):
            raise ValueError("Missing the required parameter `page_id` when calling `delete_page_preferences_by_page`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `delete_page_preferences_by_page`")

        resource_path = '/page-preferences/page-id-{page_id}'.replace('{format}', 'json')
        path_params = {}
        if 'page_id' in params:
            path_params['page_id'] = params['page_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_user(self, email, client_id, **kwargs):
        """
        
        Delete a user.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_user(email, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str email: Email address of the user to get. (required)
        :param str client_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_user_with_http_info(email, client_id, **kwargs)
        else:
            (data) = self.delete_user_with_http_info(email, client_id, **kwargs)
            return data

    def delete_user_with_http_info(self, email, client_id, **kwargs):
        """
        
        Delete a user.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_user_with_http_info(email, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str email: Email address of the user to get. (required)
        :param str client_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params) or (params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `delete_user`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `delete_user`")

        resource_path = '/users/email-{email}'.replace('{format}', 'json')
        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_view_type(self, view_type_id, **kwargs):
        """
        
        Delete a view type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_view_type(view_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str view_type_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_view_type_with_http_info(view_type_id, **kwargs)
        else:
            (data) = self.delete_view_type_with_http_info(view_type_id, **kwargs)
            return data

    def delete_view_type_with_http_info(self, view_type_id, **kwargs):
        """
        
        Delete a view type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_view_type_with_http_info(view_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str view_type_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['view_type_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_view_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'view_type_id' is set
        if ('view_type_id' not in params) or (params['view_type_id'] is None):
            raise ValueError("Missing the required parameter `view_type_id` when calling `delete_view_type`")

        resource_path = '/view-types/{view_type_id}'.replace('{format}', 'json')
        path_params = {}
        if 'view_type_id' in params:
            path_params['view_type_id'] = params['view_type_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_widget_type(self, widget_type_id, **kwargs):
        """
        
        Delete a widget type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_widget_type(widget_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str widget_type_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_widget_type_with_http_info(widget_type_id, **kwargs)
        else:
            (data) = self.delete_widget_type_with_http_info(widget_type_id, **kwargs)
            return data

    def delete_widget_type_with_http_info(self, widget_type_id, **kwargs):
        """
        
        Delete a widget type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_widget_type_with_http_info(widget_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str widget_type_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['widget_type_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_widget_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'widget_type_id' is set
        if ('widget_type_id' not in params) or (params['widget_type_id'] is None):
            raise ValueError("Missing the required parameter `widget_type_id` when calling `delete_widget_type`")

        resource_path = '/widget-types/{widget_type_id}'.replace('{format}', 'json')
        path_params = {}
        if 'widget_type_id' in params:
            path_params['widget_type_id'] = params['widget_type_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_activities(self, client_id, activity_type, **kwargs):
        """
        
        Get activities in a custom dataset

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_activities(client_id, activity_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :param str activity_type:  (required)
        :param str integration_id: 
        :param str format: 
        :param bool all: 
        :param int page: 
        :return: Activity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_activities_with_http_info(client_id, activity_type, **kwargs)
        else:
            (data) = self.get_activities_with_http_info(client_id, activity_type, **kwargs)
            return data

    def get_activities_with_http_info(self, client_id, activity_type, **kwargs):
        """
        
        Get activities in a custom dataset

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_activities_with_http_info(client_id, activity_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :param str activity_type:  (required)
        :param str integration_id: 
        :param str format: 
        :param bool all: 
        :param int page: 
        :return: Activity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'activity_type', 'integration_id', 'format', 'all', 'page']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_activities" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_activities`")
        # verify the required parameter 'activity_type' is set
        if ('activity_type' not in params) or (params['activity_type'] is None):
            raise ValueError("Missing the required parameter `activity_type` when calling `get_activities`")

        resource_path = '/activities'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']
        if 'integration_id' in params:
            query_params['integration_id'] = params['integration_id']
        if 'activity_type' in params:
            query_params['activity_type'] = params['activity_type']
        if 'format' in params:
            query_params['format'] = params['format']
        if 'all' in params:
            query_params['all'] = params['all']
        if 'page' in params:
            query_params['page'] = params['page']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt', 'basic']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Activity',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_api_key(self, user_id, client_id, **kwargs):
        """
        
        Get a specific API key by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_api_key(user_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id:  (required)
        :param str client_id:  (required)
        :return: list[ApiKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_api_key_with_http_info(user_id, client_id, **kwargs)
        else:
            (data) = self.get_api_key_with_http_info(user_id, client_id, **kwargs)
            return data

    def get_api_key_with_http_info(self, user_id, client_id, **kwargs):
        """
        
        Get a specific API key by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_api_key_with_http_info(user_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id:  (required)
        :param str client_id:  (required)
        :return: list[ApiKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_api_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_api_key`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_api_key`")

        resource_path = '/api-keys/{user_id}'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ApiKey]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_api_keys(self, client_id, **kwargs):
        """
        
        Get a list of API keys for a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_api_keys(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :return: list[ApiKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_api_keys_with_http_info(client_id, **kwargs)
        else:
            (data) = self.get_api_keys_with_http_info(client_id, **kwargs)
            return data

    def get_api_keys_with_http_info(self, client_id, **kwargs):
        """
        
        Get a list of API keys for a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_api_keys_with_http_info(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :return: list[ApiKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_api_keys" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_api_keys`")

        resource_path = '/api-keys'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ApiKey]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_block_type(self, block_type_id, **kwargs):
        """
        
        Get a block type by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_block_type(block_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str block_type_id:  (required)
        :return: BlockType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_block_type_with_http_info(block_type_id, **kwargs)
        else:
            (data) = self.get_block_type_with_http_info(block_type_id, **kwargs)
            return data

    def get_block_type_with_http_info(self, block_type_id, **kwargs):
        """
        
        Get a block type by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_block_type_with_http_info(block_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str block_type_id:  (required)
        :return: BlockType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['block_type_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_block_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'block_type_id' is set
        if ('block_type_id' not in params) or (params['block_type_id'] is None):
            raise ValueError("Missing the required parameter `block_type_id` when calling `get_block_type`")

        resource_path = '/block-types/{block_type_id}'.replace('{format}', 'json')
        path_params = {}
        if 'block_type_id' in params:
            path_params['block_type_id'] = params['block_type_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='BlockType',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_block_type_by_name(self, block_type_name, **kwargs):
        """
        
        Gets a block type by name.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_block_type_by_name(block_type_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str block_type_name:  (required)
        :return: BlockType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_block_type_by_name_with_http_info(block_type_name, **kwargs)
        else:
            (data) = self.get_block_type_by_name_with_http_info(block_type_name, **kwargs)
            return data

    def get_block_type_by_name_with_http_info(self, block_type_name, **kwargs):
        """
        
        Gets a block type by name.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_block_type_by_name_with_http_info(block_type_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str block_type_name:  (required)
        :return: BlockType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['block_type_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_block_type_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'block_type_name' is set
        if ('block_type_name' not in params) or (params['block_type_name'] is None):
            raise ValueError("Missing the required parameter `block_type_name` when calling `get_block_type_by_name`")

        resource_path = '/block-types/name-{block_type_name}'.replace('{format}', 'json')
        path_params = {}
        if 'block_type_name' in params:
            path_params['block_type_name'] = params['block_type_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='BlockType',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_block_types(self, **kwargs):
        """
        
        Get a list of all block types.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_block_types(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[BlockType]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_block_types_with_http_info(**kwargs)
        else:
            (data) = self.get_block_types_with_http_info(**kwargs)
            return data

    def get_block_types_with_http_info(self, **kwargs):
        """
        
        Get a list of all block types.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_block_types_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[BlockType]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_block_types" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/block-types'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BlockType]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_client(self, client_id, **kwargs):
        """
        
        Gets a client by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_client(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: Id of client to get. (required)
        :return: Client
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_client_with_http_info(client_id, **kwargs)
        else:
            (data) = self.get_client_with_http_info(client_id, **kwargs)
            return data

    def get_client_with_http_info(self, client_id, **kwargs):
        """
        
        Gets a client by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_client_with_http_info(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: Id of client to get. (required)
        :return: Client
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_client" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_client`")

        resource_path = '/clients/{client_id}'.replace('{format}', 'json')
        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Client',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_client_by_code(self, client_code, **kwargs):
        """
        
        Gets a client by code.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_client_by_code(client_code, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_code: Code of the client to get. (required)
        :return: Client
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_client_by_code_with_http_info(client_code, **kwargs)
        else:
            (data) = self.get_client_by_code_with_http_info(client_code, **kwargs)
            return data

    def get_client_by_code_with_http_info(self, client_code, **kwargs):
        """
        
        Gets a client by code.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_client_by_code_with_http_info(client_code, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_code: Code of the client to get. (required)
        :return: Client
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_code']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_client_by_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_code' is set
        if ('client_code' not in params) or (params['client_code'] is None):
            raise ValueError("Missing the required parameter `client_code` when calling `get_client_by_code`")

        resource_path = '/clients/code-{client_code}'.replace('{format}', 'json')
        path_params = {}
        if 'client_code' in params:
            path_params['client_code'] = params['client_code']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Client',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_clients(self, **kwargs):
        """
        
        Gets a list of all clients or a client by ID.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_clients(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[Client]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_clients_with_http_info(**kwargs)
        else:
            (data) = self.get_clients_with_http_info(**kwargs)
            return data

    def get_clients_with_http_info(self, **kwargs):
        """
        
        Gets a list of all clients or a client by ID.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_clients_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[Client]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_clients" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/clients'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Client]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_completed_jobs(self, **kwargs):
        """
        
        Get a description of completed Spark jobs.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_completed_jobs(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: 
        :param str status: 
        :param str type: 
        :param int page: 
        :param int per_page: 
        :return: list[Job]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_completed_jobs_with_http_info(**kwargs)
        else:
            (data) = self.get_completed_jobs_with_http_info(**kwargs)
            return data

    def get_completed_jobs_with_http_info(self, **kwargs):
        """
        
        Get a description of completed Spark jobs.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_completed_jobs_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: 
        :param str status: 
        :param str type: 
        :param int page: 
        :param int per_page: 
        :return: list[Job]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'status', 'type', 'page', 'per_page']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_completed_jobs" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/admin/jobs/completed'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']
        if 'status' in params:
            query_params['status'] = params['status']
        if 'type' in params:
            query_params['type'] = params['type']
        if 'page' in params:
            query_params['page'] = params['page']
        if 'per_page' in params:
            query_params['per_page'] = params['per_page']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Job]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_dataset(self, dataset_id, client_id, **kwargs):
        """
        
        Get a dataset.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dataset(dataset_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_id:  (required)
        :param str client_id:  (required)
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_dataset_with_http_info(dataset_id, client_id, **kwargs)
        else:
            (data) = self.get_dataset_with_http_info(dataset_id, client_id, **kwargs)
            return data

    def get_dataset_with_http_info(self, dataset_id, client_id, **kwargs):
        """
        
        Get a dataset.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dataset_with_http_info(dataset_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_id:  (required)
        :param str client_id:  (required)
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dataset_id', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dataset_id' is set
        if ('dataset_id' not in params) or (params['dataset_id'] is None):
            raise ValueError("Missing the required parameter `dataset_id` when calling `get_dataset`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_dataset`")

        resource_path = '/datasets/{dataset_id}'.replace('{format}', 'json')
        path_params = {}
        if 'dataset_id' in params:
            path_params['dataset_id'] = params['dataset_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Dataset',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_dataset_by_name(self, dataset_name, client_id, **kwargs):
        """
        
        Get a dataset by name.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dataset_by_name(dataset_name, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_name:  (required)
        :param str client_id:  (required)
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_dataset_by_name_with_http_info(dataset_name, client_id, **kwargs)
        else:
            (data) = self.get_dataset_by_name_with_http_info(dataset_name, client_id, **kwargs)
            return data

    def get_dataset_by_name_with_http_info(self, dataset_name, client_id, **kwargs):
        """
        
        Get a dataset by name.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dataset_by_name_with_http_info(dataset_name, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_name:  (required)
        :param str client_id:  (required)
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dataset_name', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dataset_name' is set
        if ('dataset_name' not in params) or (params['dataset_name'] is None):
            raise ValueError("Missing the required parameter `dataset_name` when calling `get_dataset_by_name`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_dataset_by_name`")

        resource_path = '/datasets/name-{dataset_name}'.replace('{format}', 'json')
        path_params = {}
        if 'dataset_name' in params:
            path_params['dataset_name'] = params['dataset_name']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Dataset',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_dataset_by_slug(self, dataset_slug, client_id, **kwargs):
        """
        
        Get a dataset by slug.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dataset_by_slug(dataset_slug, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_slug:  (required)
        :param str client_id:  (required)
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_dataset_by_slug_with_http_info(dataset_slug, client_id, **kwargs)
        else:
            (data) = self.get_dataset_by_slug_with_http_info(dataset_slug, client_id, **kwargs)
            return data

    def get_dataset_by_slug_with_http_info(self, dataset_slug, client_id, **kwargs):
        """
        
        Get a dataset by slug.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dataset_by_slug_with_http_info(dataset_slug, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_slug:  (required)
        :param str client_id:  (required)
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dataset_slug', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset_by_slug" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dataset_slug' is set
        if ('dataset_slug' not in params) or (params['dataset_slug'] is None):
            raise ValueError("Missing the required parameter `dataset_slug` when calling `get_dataset_by_slug`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_dataset_by_slug`")

        resource_path = '/datasets/slug-{dataset_slug}'.replace('{format}', 'json')
        path_params = {}
        if 'dataset_slug' in params:
            path_params['dataset_slug'] = params['dataset_slug']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Dataset',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_dataset_type(self, dataset_type_id, **kwargs):
        """
        
        Get a dataset type by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dataset_type(dataset_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_type_id:  (required)
        :return: DatasetType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_dataset_type_with_http_info(dataset_type_id, **kwargs)
        else:
            (data) = self.get_dataset_type_with_http_info(dataset_type_id, **kwargs)
            return data

    def get_dataset_type_with_http_info(self, dataset_type_id, **kwargs):
        """
        
        Get a dataset type by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dataset_type_with_http_info(dataset_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_type_id:  (required)
        :return: DatasetType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dataset_type_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dataset_type_id' is set
        if ('dataset_type_id' not in params) or (params['dataset_type_id'] is None):
            raise ValueError("Missing the required parameter `dataset_type_id` when calling `get_dataset_type`")

        resource_path = '/dataset-types/{dataset_type_id}'.replace('{format}', 'json')
        path_params = {}
        if 'dataset_type_id' in params:
            path_params['dataset_type_id'] = params['dataset_type_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DatasetType',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_dataset_type_by_name(self, dataset_type_name, **kwargs):
        """
        
        Get a dataset type by name.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dataset_type_by_name(dataset_type_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_type_name:  (required)
        :return: DatasetType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_dataset_type_by_name_with_http_info(dataset_type_name, **kwargs)
        else:
            (data) = self.get_dataset_type_by_name_with_http_info(dataset_type_name, **kwargs)
            return data

    def get_dataset_type_by_name_with_http_info(self, dataset_type_name, **kwargs):
        """
        
        Get a dataset type by name.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dataset_type_by_name_with_http_info(dataset_type_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_type_name:  (required)
        :return: DatasetType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dataset_type_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset_type_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dataset_type_name' is set
        if ('dataset_type_name' not in params) or (params['dataset_type_name'] is None):
            raise ValueError("Missing the required parameter `dataset_type_name` when calling `get_dataset_type_by_name`")

        resource_path = '/dataset-types/name-{dataset_type_name}'.replace('{format}', 'json')
        path_params = {}
        if 'dataset_type_name' in params:
            path_params['dataset_type_name'] = params['dataset_type_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DatasetType',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_dataset_types(self, **kwargs):
        """
        
        Get a list of available dataset types.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dataset_types(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[DatasetType]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_dataset_types_with_http_info(**kwargs)
        else:
            (data) = self.get_dataset_types_with_http_info(**kwargs)
            return data

    def get_dataset_types_with_http_info(self, **kwargs):
        """
        
        Get a list of available dataset types.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dataset_types_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[DatasetType]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset_types" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/dataset-types'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[DatasetType]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_datasets(self, client_id, **kwargs):
        """
        
        Get a list of datasets for a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_datasets(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :return: list[Dataset]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_datasets_with_http_info(client_id, **kwargs)
        else:
            (data) = self.get_datasets_with_http_info(client_id, **kwargs)
            return data

    def get_datasets_with_http_info(self, client_id, **kwargs):
        """
        
        Get a list of datasets for a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_datasets_with_http_info(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :return: list[Dataset]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_datasets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_datasets`")

        resource_path = '/datasets'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Dataset]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_entity_batch(self, batch_id, client_id, **kwargs):
        """
        
        Get an entity batch descriptor by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_entity_batch(batch_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str batch_id:  (required)
        :param str client_id:  (required)
        :return: EntityBatch
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_entity_batch_with_http_info(batch_id, client_id, **kwargs)
        else:
            (data) = self.get_entity_batch_with_http_info(batch_id, client_id, **kwargs)
            return data

    def get_entity_batch_with_http_info(self, batch_id, client_id, **kwargs):
        """
        
        Get an entity batch descriptor by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_entity_batch_with_http_info(batch_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str batch_id:  (required)
        :param str client_id:  (required)
        :return: EntityBatch
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['batch_id', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_entity_batch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'batch_id' is set
        if ('batch_id' not in params) or (params['batch_id'] is None):
            raise ValueError("Missing the required parameter `batch_id` when calling `get_entity_batch`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_entity_batch`")

        resource_path = '/entity-batches/{batch_id}'.replace('{format}', 'json')
        path_params = {}
        if 'batch_id' in params:
            path_params['batch_id'] = params['batch_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='EntityBatch',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_entity_batch_health_report(self, client_id, **kwargs):
        """
        
        Get an overview of batch processing health.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_entity_batch_health_report(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :param str after: 
        :return: list[EntityBatchHealthReport]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_entity_batch_health_report_with_http_info(client_id, **kwargs)
        else:
            (data) = self.get_entity_batch_health_report_with_http_info(client_id, **kwargs)
            return data

    def get_entity_batch_health_report_with_http_info(self, client_id, **kwargs):
        """
        
        Get an overview of batch processing health.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_entity_batch_health_report_with_http_info(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :param str after: 
        :return: list[EntityBatchHealthReport]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'after']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_entity_batch_health_report" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_entity_batch_health_report`")

        resource_path = '/admin/entity-batches/health'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']
        if 'after' in params:
            query_params['after'] = params['after']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[EntityBatchHealthReport]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_entity_batches(self, **kwargs):
        """
        
        Get a list of entity batches that were queued for a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_entity_batches(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: 
        :param str dt: 
        :param int page: 
        :return: list[EntityBatch]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_entity_batches_with_http_info(**kwargs)
        else:
            (data) = self.get_entity_batches_with_http_info(**kwargs)
            return data

    def get_entity_batches_with_http_info(self, **kwargs):
        """
        
        Get a list of entity batches that were queued for a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_entity_batches_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: 
        :param str dt: 
        :param int page: 
        :return: list[EntityBatch]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'dt', 'page']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_entity_batches" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/entity-batches'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']
        if 'dt' in params:
            query_params['dt'] = params['dt']
        if 'page' in params:
            query_params['page'] = params['page']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[EntityBatch]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_incomplete_jobs(self, **kwargs):
        """
        
        Get a description of incomplete Spark jobs.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_incomplete_jobs(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: 
        :param str status: 
        :param str type: 
        :param int page: 
        :param int per_page: 
        :return: list[Job]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_incomplete_jobs_with_http_info(**kwargs)
        else:
            (data) = self.get_incomplete_jobs_with_http_info(**kwargs)
            return data

    def get_incomplete_jobs_with_http_info(self, **kwargs):
        """
        
        Get a description of incomplete Spark jobs.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_incomplete_jobs_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: 
        :param str status: 
        :param str type: 
        :param int page: 
        :param int per_page: 
        :return: list[Job]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'status', 'type', 'page', 'per_page']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_incomplete_jobs" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/admin/jobs/incomplete'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']
        if 'status' in params:
            query_params['status'] = params['status']
        if 'type' in params:
            query_params['type'] = params['type']
        if 'page' in params:
            query_params['page'] = params['page']
        if 'per_page' in params:
            query_params['per_page'] = params['per_page']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Job]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_integration(self, integration_id, client_id, **kwargs):
        """
        
        Get an integration by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_integration(integration_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str integration_id:  (required)
        :param str client_id:  (required)
        :return: Integration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_integration_with_http_info(integration_id, client_id, **kwargs)
        else:
            (data) = self.get_integration_with_http_info(integration_id, client_id, **kwargs)
            return data

    def get_integration_with_http_info(self, integration_id, client_id, **kwargs):
        """
        
        Get an integration by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_integration_with_http_info(integration_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str integration_id:  (required)
        :param str client_id:  (required)
        :return: Integration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['integration_id', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_integration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'integration_id' is set
        if ('integration_id' not in params) or (params['integration_id'] is None):
            raise ValueError("Missing the required parameter `integration_id` when calling `get_integration`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_integration`")

        resource_path = '/integrations/{integration_id}'.replace('{format}', 'json')
        path_params = {}
        if 'integration_id' in params:
            path_params['integration_id'] = params['integration_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Integration',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_integration_type(self, integration_type_id, **kwargs):
        """
        
        Get an integration type by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_integration_type(integration_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str integration_type_id:  (required)
        :return: IntegrationType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_integration_type_with_http_info(integration_type_id, **kwargs)
        else:
            (data) = self.get_integration_type_with_http_info(integration_type_id, **kwargs)
            return data

    def get_integration_type_with_http_info(self, integration_type_id, **kwargs):
        """
        
        Get an integration type by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_integration_type_with_http_info(integration_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str integration_type_id:  (required)
        :return: IntegrationType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['integration_type_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_integration_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'integration_type_id' is set
        if ('integration_type_id' not in params) or (params['integration_type_id'] is None):
            raise ValueError("Missing the required parameter `integration_type_id` when calling `get_integration_type`")

        resource_path = '/integration-types/{integration_type_id}'.replace('{format}', 'json')
        path_params = {}
        if 'integration_type_id' in params:
            path_params['integration_type_id'] = params['integration_type_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='IntegrationType',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_integration_type_by_name(self, integration_type_name, **kwargs):
        """
        
        Get an integration type by name.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_integration_type_by_name(integration_type_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str integration_type_name:  (required)
        :return: IntegrationType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_integration_type_by_name_with_http_info(integration_type_name, **kwargs)
        else:
            (data) = self.get_integration_type_by_name_with_http_info(integration_type_name, **kwargs)
            return data

    def get_integration_type_by_name_with_http_info(self, integration_type_name, **kwargs):
        """
        
        Get an integration type by name.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_integration_type_by_name_with_http_info(integration_type_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str integration_type_name:  (required)
        :return: IntegrationType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['integration_type_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_integration_type_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'integration_type_name' is set
        if ('integration_type_name' not in params) or (params['integration_type_name'] is None):
            raise ValueError("Missing the required parameter `integration_type_name` when calling `get_integration_type_by_name`")

        resource_path = '/integration-types/name-{integration_type_name}'.replace('{format}', 'json')
        path_params = {}
        if 'integration_type_name' in params:
            path_params['integration_type_name'] = params['integration_type_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='IntegrationType',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_integration_types(self, **kwargs):
        """
        
        Get a list of all integration types.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_integration_types(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[IntegrationType]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_integration_types_with_http_info(**kwargs)
        else:
            (data) = self.get_integration_types_with_http_info(**kwargs)
            return data

    def get_integration_types_with_http_info(self, **kwargs):
        """
        
        Get a list of all integration types.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_integration_types_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[IntegrationType]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_integration_types" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/integration-types'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[IntegrationType]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_integrations(self, **kwargs):
        """
        
        Get a list of integrations for a client or integration type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_integrations(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: 
        :param str integration_type_id: 
        :return: list[Integration]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_integrations_with_http_info(**kwargs)
        else:
            (data) = self.get_integrations_with_http_info(**kwargs)
            return data

    def get_integrations_with_http_info(self, **kwargs):
        """
        
        Get a list of integrations for a client or integration type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_integrations_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: 
        :param str integration_type_id: 
        :return: list[Integration]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'integration_type_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_integrations" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/integrations'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']
        if 'integration_type_id' in params:
            query_params['integration_type_id'] = params['integration_type_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Integration]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_job_overview(self, **kwargs):
        """
        
        Get an overview of all Spark jobs.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_job_overview(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: 
        :return: JobOverview
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_job_overview_with_http_info(**kwargs)
        else:
            (data) = self.get_job_overview_with_http_info(**kwargs)
            return data

    def get_job_overview_with_http_info(self, **kwargs):
        """
        
        Get an overview of all Spark jobs.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_job_overview_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: 
        :return: JobOverview
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_overview" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/admin/jobs/overview'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='JobOverview',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_me(self, **kwargs):
        """
        
        Authenticates a user, and returns their user details.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_me(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: 
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_me_with_http_info(**kwargs)
        else:
            (data) = self.get_me_with_http_info(**kwargs)
            return data

    def get_me_with_http_info(self, **kwargs):
        """
        
        Authenticates a user, and returns their user details.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_me_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: 
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_me" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/users/me'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['basic']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='User',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_page(self, page_id, client_id, **kwargs):
        """
        
        Get a page by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page(page_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str page_id:  (required)
        :param str client_id:  (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_with_http_info(page_id, client_id, **kwargs)
        else:
            (data) = self.get_page_with_http_info(page_id, client_id, **kwargs)
            return data

    def get_page_with_http_info(self, page_id, client_id, **kwargs):
        """
        
        Get a page by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_with_http_info(page_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str page_id:  (required)
        :param str client_id:  (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_id', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'page_id' is set
        if ('page_id' not in params) or (params['page_id'] is None):
            raise ValueError("Missing the required parameter `page_id` when calling `get_page`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_page`")

        resource_path = '/pages/{page_id}'.replace('{format}', 'json')
        path_params = {}
        if 'page_id' in params:
            path_params['page_id'] = params['page_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Page',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_page_by_slug(self, slug, client_id, **kwargs):
        """
        
        Gets a page by slug

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_by_slug(slug, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str slug:  (required)
        :param str client_id:  (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_by_slug_with_http_info(slug, client_id, **kwargs)
        else:
            (data) = self.get_page_by_slug_with_http_info(slug, client_id, **kwargs)
            return data

    def get_page_by_slug_with_http_info(self, slug, client_id, **kwargs):
        """
        
        Gets a page by slug

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_by_slug_with_http_info(slug, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str slug:  (required)
        :param str client_id:  (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['slug', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_by_slug" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'slug' is set
        if ('slug' not in params) or (params['slug'] is None):
            raise ValueError("Missing the required parameter `slug` when calling `get_page_by_slug`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_page_by_slug`")

        resource_path = '/pages/slug-{slug}'.replace('{format}', 'json')
        path_params = {}
        if 'slug' in params:
            path_params['slug'] = params['slug']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Page',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_page_preferences(self, client_id, **kwargs):
        """
        
        Gets a list of page preferences for a user.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_preferences(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :return: list[PagePreferences]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_preferences_with_http_info(client_id, **kwargs)
        else:
            (data) = self.get_page_preferences_with_http_info(client_id, **kwargs)
            return data

    def get_page_preferences_with_http_info(self, client_id, **kwargs):
        """
        
        Gets a list of page preferences for a user.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_preferences_with_http_info(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :return: list[PagePreferences]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_preferences" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_page_preferences`")

        resource_path = '/page-preferences'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[PagePreferences]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_page_preferences_by_page(self, page_id, client_id, **kwargs):
        """
        
        Get page preferences for a specific page.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_preferences_by_page(page_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str page_id:  (required)
        :param str client_id:  (required)
        :return: PagePreferences
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_preferences_by_page_with_http_info(page_id, client_id, **kwargs)
        else:
            (data) = self.get_page_preferences_by_page_with_http_info(page_id, client_id, **kwargs)
            return data

    def get_page_preferences_by_page_with_http_info(self, page_id, client_id, **kwargs):
        """
        
        Get page preferences for a specific page.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_preferences_by_page_with_http_info(page_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str page_id:  (required)
        :param str client_id:  (required)
        :return: PagePreferences
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_id', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_preferences_by_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'page_id' is set
        if ('page_id' not in params) or (params['page_id'] is None):
            raise ValueError("Missing the required parameter `page_id` when calling `get_page_preferences_by_page`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_page_preferences_by_page`")

        resource_path = '/page-preferences/page-id-{page_id}'.replace('{format}', 'json')
        path_params = {}
        if 'page_id' in params:
            path_params['page_id'] = params['page_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PagePreferences',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_pages(self, client_id, **kwargs):
        """
        
        Get a list of pages for a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pages(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :return: list[Page]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pages_with_http_info(client_id, **kwargs)
        else:
            (data) = self.get_pages_with_http_info(client_id, **kwargs)
            return data

    def get_pages_with_http_info(self, client_id, **kwargs):
        """
        
        Get a list of pages for a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pages_with_http_info(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :return: list[Page]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pages" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_pages`")

        resource_path = '/pages'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Page]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_user(self, user_id, **kwargs):
        """
        
        Get a user.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id:  (required)
        :param str client_id: 
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_user_with_http_info(user_id, **kwargs)
        else:
            (data) = self.get_user_with_http_info(user_id, **kwargs)
            return data

    def get_user_with_http_info(self, user_id, **kwargs):
        """
        
        Get a user.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_with_http_info(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id:  (required)
        :param str client_id: 
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_user`")

        resource_path = '/users/{user_id}'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='User',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_user_by_activation_key(self, activation_key, **kwargs):
        """
        
        Get a user by activation key.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_by_activation_key(activation_key, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str activation_key:  (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_user_by_activation_key_with_http_info(activation_key, **kwargs)
        else:
            (data) = self.get_user_by_activation_key_with_http_info(activation_key, **kwargs)
            return data

    def get_user_by_activation_key_with_http_info(self, activation_key, **kwargs):
        """
        
        Get a user by activation key.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_by_activation_key_with_http_info(activation_key, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str activation_key:  (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['activation_key']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_by_activation_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'activation_key' is set
        if ('activation_key' not in params) or (params['activation_key'] is None):
            raise ValueError("Missing the required parameter `activation_key` when calling `get_user_by_activation_key`")

        resource_path = '/user-activations/{activation_key}'.replace('{format}', 'json')
        path_params = {}
        if 'activation_key' in params:
            path_params['activation_key'] = params['activation_key']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='User',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_user_by_email(self, email, **kwargs):
        """
        
        Get a user by email.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_by_email(email, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str email: Email address of the user to get. (required)
        :param str client_id: 
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_user_by_email_with_http_info(email, **kwargs)
        else:
            (data) = self.get_user_by_email_with_http_info(email, **kwargs)
            return data

    def get_user_by_email_with_http_info(self, email, **kwargs):
        """
        
        Get a user by email.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_by_email_with_http_info(email, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str email: Email address of the user to get. (required)
        :param str client_id: 
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_by_email" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params) or (params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `get_user_by_email`")

        resource_path = '/users/email-{email}'.replace('{format}', 'json')
        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='User',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_user_by_reset_key(self, reset_key, **kwargs):
        """
        
        Get a user by their reset key.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_by_reset_key(reset_key, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str reset_key:  (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_user_by_reset_key_with_http_info(reset_key, **kwargs)
        else:
            (data) = self.get_user_by_reset_key_with_http_info(reset_key, **kwargs)
            return data

    def get_user_by_reset_key_with_http_info(self, reset_key, **kwargs):
        """
        
        Get a user by their reset key.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_by_reset_key_with_http_info(reset_key, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str reset_key:  (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reset_key']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_by_reset_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'reset_key' is set
        if ('reset_key' not in params) or (params['reset_key'] is None):
            raise ValueError("Missing the required parameter `reset_key` when calling `get_user_by_reset_key`")

        resource_path = '/password-resets/{reset_key}'.replace('{format}', 'json')
        path_params = {}
        if 'reset_key' in params:
            path_params['reset_key'] = params['reset_key']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='User',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_users(self, client_id, **kwargs):
        """
        
        Get a list of users for a single client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_users(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_users_with_http_info(client_id, **kwargs)
        else:
            (data) = self.get_users_with_http_info(client_id, **kwargs)
            return data

    def get_users_with_http_info(self, client_id, **kwargs):
        """
        
        Get a list of users for a single client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_users_with_http_info(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_users`")

        resource_path = '/users'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='User',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_view(self, view_id, client_id, **kwargs):
        """
        
        Get a view by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_view(view_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str view_id:  (required)
        :param str client_id:  (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_view_with_http_info(view_id, client_id, **kwargs)
        else:
            (data) = self.get_view_with_http_info(view_id, client_id, **kwargs)
            return data

    def get_view_with_http_info(self, view_id, client_id, **kwargs):
        """
        
        Get a view by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_view_with_http_info(view_id, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str view_id:  (required)
        :param str client_id:  (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['view_id', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_view" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'view_id' is set
        if ('view_id' not in params) or (params['view_id'] is None):
            raise ValueError("Missing the required parameter `view_id` when calling `get_view`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_view`")

        resource_path = '/views/{view_id}'.replace('{format}', 'json')
        path_params = {}
        if 'view_id' in params:
            path_params['view_id'] = params['view_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='View',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_view_type(self, view_type_id, **kwargs):
        """
        
        Get a view type by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_view_type(view_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str view_type_id:  (required)
        :return: ViewType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_view_type_with_http_info(view_type_id, **kwargs)
        else:
            (data) = self.get_view_type_with_http_info(view_type_id, **kwargs)
            return data

    def get_view_type_with_http_info(self, view_type_id, **kwargs):
        """
        
        Get a view type by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_view_type_with_http_info(view_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str view_type_id:  (required)
        :return: ViewType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['view_type_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_view_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'view_type_id' is set
        if ('view_type_id' not in params) or (params['view_type_id'] is None):
            raise ValueError("Missing the required parameter `view_type_id` when calling `get_view_type`")

        resource_path = '/view-types/{view_type_id}'.replace('{format}', 'json')
        path_params = {}
        if 'view_type_id' in params:
            path_params['view_type_id'] = params['view_type_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ViewType',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_view_type_by_name(self, view_type_name, **kwargs):
        """
        
        Get a view type by name.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_view_type_by_name(view_type_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str view_type_name:  (required)
        :return: ViewType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_view_type_by_name_with_http_info(view_type_name, **kwargs)
        else:
            (data) = self.get_view_type_by_name_with_http_info(view_type_name, **kwargs)
            return data

    def get_view_type_by_name_with_http_info(self, view_type_name, **kwargs):
        """
        
        Get a view type by name.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_view_type_by_name_with_http_info(view_type_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str view_type_name:  (required)
        :return: ViewType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['view_type_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_view_type_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'view_type_name' is set
        if ('view_type_name' not in params) or (params['view_type_name'] is None):
            raise ValueError("Missing the required parameter `view_type_name` when calling `get_view_type_by_name`")

        resource_path = '/view-types/name-{view_type_name}'.replace('{format}', 'json')
        path_params = {}
        if 'view_type_name' in params:
            path_params['view_type_name'] = params['view_type_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ViewType',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_view_types(self, **kwargs):
        """
        
        Get a list of all view types.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_view_types(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[ViewType]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_view_types_with_http_info(**kwargs)
        else:
            (data) = self.get_view_types_with_http_info(**kwargs)
            return data

    def get_view_types_with_http_info(self, **kwargs):
        """
        
        Get a list of all view types.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_view_types_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[ViewType]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_view_types" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/view-types'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ViewType]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_views(self, client_id, **kwargs):
        """
        
        Get a list of views for a specific client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_views(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :return: list[View]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_views_with_http_info(client_id, **kwargs)
        else:
            (data) = self.get_views_with_http_info(client_id, **kwargs)
            return data

    def get_views_with_http_info(self, client_id, **kwargs):
        """
        
        Get a list of views for a specific client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_views_with_http_info(client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :return: list[View]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_views" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_views`")

        resource_path = '/views'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[View]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_views_by_hash_keys(self, hash_keys, client_id, **kwargs):
        """
        
        Get a list of views by a list of hash keys.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_views_by_hash_keys(hash_keys, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str hash_keys:  (required)
        :param str client_id:  (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_views_by_hash_keys_with_http_info(hash_keys, client_id, **kwargs)
        else:
            (data) = self.get_views_by_hash_keys_with_http_info(hash_keys, client_id, **kwargs)
            return data

    def get_views_by_hash_keys_with_http_info(self, hash_keys, client_id, **kwargs):
        """
        
        Get a list of views by a list of hash keys.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_views_by_hash_keys_with_http_info(hash_keys, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str hash_keys:  (required)
        :param str client_id:  (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash_keys', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_views_by_hash_keys" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash_keys' is set
        if ('hash_keys' not in params) or (params['hash_keys'] is None):
            raise ValueError("Missing the required parameter `hash_keys` when calling `get_views_by_hash_keys`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_views_by_hash_keys`")

        resource_path = '/views/view-hashes-{hash_keys}'.replace('{format}', 'json')
        path_params = {}
        if 'hash_keys' in params:
            path_params['hash_keys'] = params['hash_keys']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='View',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_widget_type(self, widget_type_id, **kwargs):
        """
        
        Get a widget type by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_widget_type(widget_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str widget_type_id:  (required)
        :return: WidgetType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_widget_type_with_http_info(widget_type_id, **kwargs)
        else:
            (data) = self.get_widget_type_with_http_info(widget_type_id, **kwargs)
            return data

    def get_widget_type_with_http_info(self, widget_type_id, **kwargs):
        """
        
        Get a widget type by id.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_widget_type_with_http_info(widget_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str widget_type_id:  (required)
        :return: WidgetType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['widget_type_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_widget_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'widget_type_id' is set
        if ('widget_type_id' not in params) or (params['widget_type_id'] is None):
            raise ValueError("Missing the required parameter `widget_type_id` when calling `get_widget_type`")

        resource_path = '/widget-types/{widget_type_id}'.replace('{format}', 'json')
        path_params = {}
        if 'widget_type_id' in params:
            path_params['widget_type_id'] = params['widget_type_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='WidgetType',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_widget_type_by_name(self, widget_type_name, **kwargs):
        """
        
        Gets a widget type by name.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_widget_type_by_name(widget_type_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str widget_type_name:  (required)
        :return: WidgetType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_widget_type_by_name_with_http_info(widget_type_name, **kwargs)
        else:
            (data) = self.get_widget_type_by_name_with_http_info(widget_type_name, **kwargs)
            return data

    def get_widget_type_by_name_with_http_info(self, widget_type_name, **kwargs):
        """
        
        Gets a widget type by name.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_widget_type_by_name_with_http_info(widget_type_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str widget_type_name:  (required)
        :return: WidgetType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['widget_type_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_widget_type_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'widget_type_name' is set
        if ('widget_type_name' not in params) or (params['widget_type_name'] is None):
            raise ValueError("Missing the required parameter `widget_type_name` when calling `get_widget_type_by_name`")

        resource_path = '/widget-types/name-{widget_type_name}'.replace('{format}', 'json')
        path_params = {}
        if 'widget_type_name' in params:
            path_params['widget_type_name'] = params['widget_type_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='WidgetType',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_widget_types(self, **kwargs):
        """
        
        Get a list of all widget types.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_widget_types(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[WidgetType]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_widget_types_with_http_info(**kwargs)
        else:
            (data) = self.get_widget_types_with_http_info(**kwargs)
            return data

    def get_widget_types_with_http_info(self, **kwargs):
        """
        
        Get a list of all widget types.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_widget_types_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[WidgetType]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_widget_types" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/widget-types'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[WidgetType]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def queue_entity_batch(self, entity_batch, **kwargs):
        """
        
        Queue a batch of entities.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.queue_entity_batch(entity_batch, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param EntityBatch entity_batch:  (required)
        :param str client_id: 
        :return: BatchReceipt
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.queue_entity_batch_with_http_info(entity_batch, **kwargs)
        else:
            (data) = self.queue_entity_batch_with_http_info(entity_batch, **kwargs)
            return data

    def queue_entity_batch_with_http_info(self, entity_batch, **kwargs):
        """
        
        Queue a batch of entities.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.queue_entity_batch_with_http_info(entity_batch, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param EntityBatch entity_batch:  (required)
        :param str client_id: 
        :return: BatchReceipt
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entity_batch', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method queue_entity_batch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entity_batch' is set
        if ('entity_batch' not in params) or (params['entity_batch'] is None):
            raise ValueError("Missing the required parameter `entity_batch` when calling `queue_entity_batch`")

        resource_path = '/entity-batches'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entity_batch' in params:
            body_params = params['entity_batch']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='BatchReceipt',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def queue_partner_entity_batch(self, partner_batch, integration_type_id, **kwargs):
        """
        
        Queue a batch of partner entities.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.queue_partner_entity_batch(partner_batch, integration_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param PartnerEntityBatch partner_batch:  (required)
        :param str integration_type_id:  (required)
        :return: BatchReceipt
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.queue_partner_entity_batch_with_http_info(partner_batch, integration_type_id, **kwargs)
        else:
            (data) = self.queue_partner_entity_batch_with_http_info(partner_batch, integration_type_id, **kwargs)
            return data

    def queue_partner_entity_batch_with_http_info(self, partner_batch, integration_type_id, **kwargs):
        """
        
        Queue a batch of partner entities.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.queue_partner_entity_batch_with_http_info(partner_batch, integration_type_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param PartnerEntityBatch partner_batch:  (required)
        :param str integration_type_id:  (required)
        :return: BatchReceipt
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['partner_batch', 'integration_type_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method queue_partner_entity_batch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'partner_batch' is set
        if ('partner_batch' not in params) or (params['partner_batch'] is None):
            raise ValueError("Missing the required parameter `partner_batch` when calling `queue_partner_entity_batch`")
        # verify the required parameter 'integration_type_id' is set
        if ('integration_type_id' not in params) or (params['integration_type_id'] is None):
            raise ValueError("Missing the required parameter `integration_type_id` when calling `queue_partner_entity_batch`")

        resource_path = '/entity-batches/partner-batches'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'integration_type_id' in params:
            query_params['integration_type_id'] = params['integration_type_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'partner_batch' in params:
            body_params = params['partner_batch']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='BatchReceipt',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_page(self, page_id, client_id, page, **kwargs):
        """
        
        Replaces an existing page with a new one.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_page(page_id, client_id, page, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str page_id:  (required)
        :param str client_id:  (required)
        :param Page page:  (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_page_with_http_info(page_id, client_id, page, **kwargs)
        else:
            (data) = self.replace_page_with_http_info(page_id, client_id, page, **kwargs)
            return data

    def replace_page_with_http_info(self, page_id, client_id, page, **kwargs):
        """
        
        Replaces an existing page with a new one.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_page_with_http_info(page_id, client_id, page, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str page_id:  (required)
        :param str client_id:  (required)
        :param Page page:  (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_id', 'client_id', 'page']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'page_id' is set
        if ('page_id' not in params) or (params['page_id'] is None):
            raise ValueError("Missing the required parameter `page_id` when calling `replace_page`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `replace_page`")
        # verify the required parameter 'page' is set
        if ('page' not in params) or (params['page'] is None):
            raise ValueError("Missing the required parameter `page` when calling `replace_page`")

        resource_path = '/pages/{page_id}'.replace('{format}', 'json')
        path_params = {}
        if 'page_id' in params:
            path_params['page_id'] = params['page_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'page' in params:
            body_params = params['page']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Page',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def request_password_reset(self, client_id, reset_request, **kwargs):
        """
        
        Create a request to reset password.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.request_password_reset(client_id, reset_request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :param PasswordResetRequest reset_request:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.request_password_reset_with_http_info(client_id, reset_request, **kwargs)
        else:
            (data) = self.request_password_reset_with_http_info(client_id, reset_request, **kwargs)
            return data

    def request_password_reset_with_http_info(self, client_id, reset_request, **kwargs):
        """
        
        Create a request to reset password.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.request_password_reset_with_http_info(client_id, reset_request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id:  (required)
        :param PasswordResetRequest reset_request:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'reset_request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method request_password_reset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `request_password_reset`")
        # verify the required parameter 'reset_request' is set
        if ('reset_request' not in params) or (params['reset_request'] is None):
            raise ValueError("Missing the required parameter `reset_request` when calling `request_password_reset`")

        resource_path = '/password-reset-requests'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'reset_request' in params:
            body_params = params['reset_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def reset_password(self, reset_key, changes, **kwargs):
        """
        
        Reset a user's password.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.reset_password(reset_key, changes, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str reset_key:  (required)
        :param PasswordResetChange changes:  (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.reset_password_with_http_info(reset_key, changes, **kwargs)
        else:
            (data) = self.reset_password_with_http_info(reset_key, changes, **kwargs)
            return data

    def reset_password_with_http_info(self, reset_key, changes, **kwargs):
        """
        
        Reset a user's password.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.reset_password_with_http_info(reset_key, changes, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str reset_key:  (required)
        :param PasswordResetChange changes:  (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reset_key', 'changes']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_password" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'reset_key' is set
        if ('reset_key' not in params) or (params['reset_key'] is None):
            raise ValueError("Missing the required parameter `reset_key` when calling `reset_password`")
        # verify the required parameter 'changes' is set
        if ('changes' not in params) or (params['changes'] is None):
            raise ValueError("Missing the required parameter `changes` when calling `reset_password`")

        resource_path = '/password-resets/{reset_key}'.replace('{format}', 'json')
        path_params = {}
        if 'reset_key' in params:
            path_params['reset_key'] = params['reset_key']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'changes' in params:
            body_params = params['changes']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='User',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_api_key(self, user_id, client_id, updates, **kwargs):
        """
        
        Update the name of an API key.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_api_key(user_id, client_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id:  (required)
        :param str client_id:  (required)
        :param ApiKey updates:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_api_key_with_http_info(user_id, client_id, updates, **kwargs)
        else:
            (data) = self.update_api_key_with_http_info(user_id, client_id, updates, **kwargs)
            return data

    def update_api_key_with_http_info(self, user_id, client_id, updates, **kwargs):
        """
        
        Update the name of an API key.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_api_key_with_http_info(user_id, client_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id:  (required)
        :param str client_id:  (required)
        :param ApiKey updates:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'client_id', 'updates']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_api_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `update_api_key`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `update_api_key`")
        # verify the required parameter 'updates' is set
        if ('updates' not in params) or (params['updates'] is None):
            raise ValueError("Missing the required parameter `updates` when calling `update_api_key`")

        resource_path = '/api-keys/{user_id}'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'updates' in params:
            body_params = params['updates']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_block_type(self, block_type_id, block_type, **kwargs):
        """
        
        Updates a block type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_block_type(block_type_id, block_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str block_type_id:  (required)
        :param BlockType block_type:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_block_type_with_http_info(block_type_id, block_type, **kwargs)
        else:
            (data) = self.update_block_type_with_http_info(block_type_id, block_type, **kwargs)
            return data

    def update_block_type_with_http_info(self, block_type_id, block_type, **kwargs):
        """
        
        Updates a block type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_block_type_with_http_info(block_type_id, block_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str block_type_id:  (required)
        :param BlockType block_type:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['block_type_id', 'block_type']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_block_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'block_type_id' is set
        if ('block_type_id' not in params) or (params['block_type_id'] is None):
            raise ValueError("Missing the required parameter `block_type_id` when calling `update_block_type`")
        # verify the required parameter 'block_type' is set
        if ('block_type' not in params) or (params['block_type'] is None):
            raise ValueError("Missing the required parameter `block_type` when calling `update_block_type`")

        resource_path = '/block-types/{block_type_id}'.replace('{format}', 'json')
        path_params = {}
        if 'block_type_id' in params:
            path_params['block_type_id'] = params['block_type_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'block_type' in params:
            body_params = params['block_type']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_client(self, client_id, updates, **kwargs):
        """
        
        Update a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_client(client_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: Id of client to get. (required)
        :param ClientUpdate updates: Updates to make to the client. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_client_with_http_info(client_id, updates, **kwargs)
        else:
            (data) = self.update_client_with_http_info(client_id, updates, **kwargs)
            return data

    def update_client_with_http_info(self, client_id, updates, **kwargs):
        """
        
        Update a client.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_client_with_http_info(client_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str client_id: Id of client to get. (required)
        :param ClientUpdate updates: Updates to make to the client. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'updates']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_client" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `update_client`")
        # verify the required parameter 'updates' is set
        if ('updates' not in params) or (params['updates'] is None):
            raise ValueError("Missing the required parameter `updates` when calling `update_client`")

        resource_path = '/clients/{client_id}'.replace('{format}', 'json')
        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'updates' in params:
            body_params = params['updates']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_dataset(self, dataset_id, client_id, updates, **kwargs):
        """
        
        Update a dataset.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_dataset(dataset_id, client_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_id:  (required)
        :param str client_id:  (required)
        :param Dataset updates: Dataset updates. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_dataset_with_http_info(dataset_id, client_id, updates, **kwargs)
        else:
            (data) = self.update_dataset_with_http_info(dataset_id, client_id, updates, **kwargs)
            return data

    def update_dataset_with_http_info(self, dataset_id, client_id, updates, **kwargs):
        """
        
        Update a dataset.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_dataset_with_http_info(dataset_id, client_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_id:  (required)
        :param str client_id:  (required)
        :param Dataset updates: Dataset updates. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dataset_id', 'client_id', 'updates']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dataset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dataset_id' is set
        if ('dataset_id' not in params) or (params['dataset_id'] is None):
            raise ValueError("Missing the required parameter `dataset_id` when calling `update_dataset`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `update_dataset`")
        # verify the required parameter 'updates' is set
        if ('updates' not in params) or (params['updates'] is None):
            raise ValueError("Missing the required parameter `updates` when calling `update_dataset`")

        resource_path = '/datasets/{dataset_id}'.replace('{format}', 'json')
        path_params = {}
        if 'dataset_id' in params:
            path_params['dataset_id'] = params['dataset_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'updates' in params:
            body_params = params['updates']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_dataset_type(self, dataset_type_id, updates, **kwargs):
        """
        
        Update a dataset type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_dataset_type(dataset_type_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_type_id:  (required)
        :param DatasetType updates: Dataset type updates. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_dataset_type_with_http_info(dataset_type_id, updates, **kwargs)
        else:
            (data) = self.update_dataset_type_with_http_info(dataset_type_id, updates, **kwargs)
            return data

    def update_dataset_type_with_http_info(self, dataset_type_id, updates, **kwargs):
        """
        
        Update a dataset type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_dataset_type_with_http_info(dataset_type_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dataset_type_id:  (required)
        :param DatasetType updates: Dataset type updates. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dataset_type_id', 'updates']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dataset_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dataset_type_id' is set
        if ('dataset_type_id' not in params) or (params['dataset_type_id'] is None):
            raise ValueError("Missing the required parameter `dataset_type_id` when calling `update_dataset_type`")
        # verify the required parameter 'updates' is set
        if ('updates' not in params) or (params['updates'] is None):
            raise ValueError("Missing the required parameter `updates` when calling `update_dataset_type`")

        resource_path = '/dataset-types/{dataset_type_id}'.replace('{format}', 'json')
        path_params = {}
        if 'dataset_type_id' in params:
            path_params['dataset_type_id'] = params['dataset_type_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'updates' in params:
            body_params = params['updates']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_integration(self, integration_id, client_id, updates, **kwargs):
        """
        
        Update an integration.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_integration(integration_id, client_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str integration_id:  (required)
        :param str client_id:  (required)
        :param IntegrationUpdate updates:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_integration_with_http_info(integration_id, client_id, updates, **kwargs)
        else:
            (data) = self.update_integration_with_http_info(integration_id, client_id, updates, **kwargs)
            return data

    def update_integration_with_http_info(self, integration_id, client_id, updates, **kwargs):
        """
        
        Update an integration.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_integration_with_http_info(integration_id, client_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str integration_id:  (required)
        :param str client_id:  (required)
        :param IntegrationUpdate updates:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['integration_id', 'client_id', 'updates']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_integration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'integration_id' is set
        if ('integration_id' not in params) or (params['integration_id'] is None):
            raise ValueError("Missing the required parameter `integration_id` when calling `update_integration`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `update_integration`")
        # verify the required parameter 'updates' is set
        if ('updates' not in params) or (params['updates'] is None):
            raise ValueError("Missing the required parameter `updates` when calling `update_integration`")

        resource_path = '/integrations/{integration_id}'.replace('{format}', 'json')
        path_params = {}
        if 'integration_id' in params:
            path_params['integration_id'] = params['integration_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'updates' in params:
            body_params = params['updates']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_integration_type(self, integration_type_id, updates, **kwargs):
        """
        
        Update an integration type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_integration_type(integration_type_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str integration_type_id:  (required)
        :param IntegrationType updates:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_integration_type_with_http_info(integration_type_id, updates, **kwargs)
        else:
            (data) = self.update_integration_type_with_http_info(integration_type_id, updates, **kwargs)
            return data

    def update_integration_type_with_http_info(self, integration_type_id, updates, **kwargs):
        """
        
        Update an integration type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_integration_type_with_http_info(integration_type_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str integration_type_id:  (required)
        :param IntegrationType updates:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['integration_type_id', 'updates']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_integration_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'integration_type_id' is set
        if ('integration_type_id' not in params) or (params['integration_type_id'] is None):
            raise ValueError("Missing the required parameter `integration_type_id` when calling `update_integration_type`")
        # verify the required parameter 'updates' is set
        if ('updates' not in params) or (params['updates'] is None):
            raise ValueError("Missing the required parameter `updates` when calling `update_integration_type`")

        resource_path = '/integration-types/{integration_type_id}'.replace('{format}', 'json')
        path_params = {}
        if 'integration_type_id' in params:
            path_params['integration_type_id'] = params['integration_type_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'updates' in params:
            body_params = params['updates']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_page(self, page_id, updates, client_id, **kwargs):
        """
        
        Update a page.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_page(page_id, updates, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str page_id:  (required)
        :param PageUpdate updates:  (required)
        :param str client_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_page_with_http_info(page_id, updates, client_id, **kwargs)
        else:
            (data) = self.update_page_with_http_info(page_id, updates, client_id, **kwargs)
            return data

    def update_page_with_http_info(self, page_id, updates, client_id, **kwargs):
        """
        
        Update a page.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_page_with_http_info(page_id, updates, client_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str page_id:  (required)
        :param PageUpdate updates:  (required)
        :param str client_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_id', 'updates', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'page_id' is set
        if ('page_id' not in params) or (params['page_id'] is None):
            raise ValueError("Missing the required parameter `page_id` when calling `update_page`")
        # verify the required parameter 'updates' is set
        if ('updates' not in params) or (params['updates'] is None):
            raise ValueError("Missing the required parameter `updates` when calling `update_page`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `update_page`")

        resource_path = '/pages/{page_id}'.replace('{format}', 'json')
        path_params = {}
        if 'page_id' in params:
            path_params['page_id'] = params['page_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'updates' in params:
            body_params = params['updates']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_page_preferences_by_page(self, page_id, client_id, updates, **kwargs):
        """
        
        Update page preferences for a specific page.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_page_preferences_by_page(page_id, client_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str page_id:  (required)
        :param str client_id:  (required)
        :param PagePreferences updates:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_page_preferences_by_page_with_http_info(page_id, client_id, updates, **kwargs)
        else:
            (data) = self.update_page_preferences_by_page_with_http_info(page_id, client_id, updates, **kwargs)
            return data

    def update_page_preferences_by_page_with_http_info(self, page_id, client_id, updates, **kwargs):
        """
        
        Update page preferences for a specific page.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_page_preferences_by_page_with_http_info(page_id, client_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str page_id:  (required)
        :param str client_id:  (required)
        :param PagePreferences updates:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_id', 'client_id', 'updates']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_page_preferences_by_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'page_id' is set
        if ('page_id' not in params) or (params['page_id'] is None):
            raise ValueError("Missing the required parameter `page_id` when calling `update_page_preferences_by_page`")
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params) or (params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `update_page_preferences_by_page`")
        # verify the required parameter 'updates' is set
        if ('updates' not in params) or (params['updates'] is None):
            raise ValueError("Missing the required parameter `updates` when calling `update_page_preferences_by_page`")

        resource_path = '/page-preferences/page-id-{page_id}'.replace('{format}', 'json')
        path_params = {}
        if 'page_id' in params:
            path_params['page_id'] = params['page_id']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'updates' in params:
            body_params = params['updates']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_user(self, email, updates, **kwargs):
        """
        
        Update a user.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_user(email, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str email: Email address of the user to get. (required)
        :param UserUpdate updates:  (required)
        :param str client_id: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_user_with_http_info(email, updates, **kwargs)
        else:
            (data) = self.update_user_with_http_info(email, updates, **kwargs)
            return data

    def update_user_with_http_info(self, email, updates, **kwargs):
        """
        
        Update a user.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_user_with_http_info(email, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str email: Email address of the user to get. (required)
        :param UserUpdate updates:  (required)
        :param str client_id: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'updates', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params) or (params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `update_user`")
        # verify the required parameter 'updates' is set
        if ('updates' not in params) or (params['updates'] is None):
            raise ValueError("Missing the required parameter `updates` when calling `update_user`")

        resource_path = '/users/email-{email}'.replace('{format}', 'json')
        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']

        query_params = {}
        if 'client_id' in params:
            query_params['client_id'] = params['client_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'updates' in params:
            body_params = params['updates']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_view_type(self, view_type_id, updates, **kwargs):
        """
        
        Update a view type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_view_type(view_type_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str view_type_id:  (required)
        :param ViewTypeUpdate updates:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_view_type_with_http_info(view_type_id, updates, **kwargs)
        else:
            (data) = self.update_view_type_with_http_info(view_type_id, updates, **kwargs)
            return data

    def update_view_type_with_http_info(self, view_type_id, updates, **kwargs):
        """
        
        Update a view type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_view_type_with_http_info(view_type_id, updates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str view_type_id:  (required)
        :param ViewTypeUpdate updates:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['view_type_id', 'updates']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_view_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'view_type_id' is set
        if ('view_type_id' not in params) or (params['view_type_id'] is None):
            raise ValueError("Missing the required parameter `view_type_id` when calling `update_view_type`")
        # verify the required parameter 'updates' is set
        if ('updates' not in params) or (params['updates'] is None):
            raise ValueError("Missing the required parameter `updates` when calling `update_view_type`")

        resource_path = '/view-types/{view_type_id}'.replace('{format}', 'json')
        path_params = {}
        if 'view_type_id' in params:
            path_params['view_type_id'] = params['view_type_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'updates' in params:
            body_params = params['updates']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_widget_type(self, widget_type_id, widget_type, **kwargs):
        """
        
        Updates a widget type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_widget_type(widget_type_id, widget_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str widget_type_id:  (required)
        :param WidgetType widget_type:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_widget_type_with_http_info(widget_type_id, widget_type, **kwargs)
        else:
            (data) = self.update_widget_type_with_http_info(widget_type_id, widget_type, **kwargs)
            return data

    def update_widget_type_with_http_info(self, widget_type_id, widget_type, **kwargs):
        """
        
        Updates a widget type.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_widget_type_with_http_info(widget_type_id, widget_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str widget_type_id:  (required)
        :param WidgetType widget_type:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['widget_type_id', 'widget_type']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_widget_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'widget_type_id' is set
        if ('widget_type_id' not in params) or (params['widget_type_id'] is None):
            raise ValueError("Missing the required parameter `widget_type_id` when calling `update_widget_type`")
        # verify the required parameter 'widget_type' is set
        if ('widget_type' not in params) or (params['widget_type'] is None):
            raise ValueError("Missing the required parameter `widget_type` when calling `update_widget_type`")

        resource_path = '/widget-types/{widget_type_id}'.replace('{format}', 'json')
        path_params = {}
        if 'widget_type_id' in params:
            path_params['widget_type_id'] = params['widget_type_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'widget_type' in params:
            body_params = params['widget_type']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key', 'jwt']

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))
