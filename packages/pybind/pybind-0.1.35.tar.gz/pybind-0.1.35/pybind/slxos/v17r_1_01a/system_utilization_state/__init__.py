
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class system_utilization_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-systemutilization-operational - based on the path /system-utilization-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: System Utilization statistics
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__profile_name','__total_system_memory','__total_used_memory','__total_free_memory','__cached_memory','__buffers','__user_free_memory','__kernel_free_memory','__total_swap_memory','__total_free_swap_memory','__total_used_swap_memory','__user_process','__system_process','__niced_process','__iowait','__hw_interrupt','__sw_interrupt','__idle_state','__steal_time','__uptime',)

  _yang_name = 'system-utilization-state'
  _rest_name = 'system-utilization-state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__total_free_swap_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-free-swap-memory", rest_name="total-free-swap-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__niced_process = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="niced-process", rest_name="niced-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__kernel_free_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="kernel-free-memory", rest_name="kernel-free-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__total_system_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-system-memory", rest_name="total-system-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__user_free_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="user-free-memory", rest_name="user-free-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__iowait = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="iowait", rest_name="iowait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__total_free_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-free-memory", rest_name="total-free-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__total_swap_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-swap-memory", rest_name="total-swap-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__system_process = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="system-process", rest_name="system-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__idle_state = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="idle-state", rest_name="idle-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__user_process = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="user-process", rest_name="user-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__total_used_swap_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-used-swap-memory", rest_name="total-used-swap-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__sw_interrupt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sw-interrupt", rest_name="sw-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__profile_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="profile-name", rest_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='string', is_config=False)
    self.__cached_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cached-memory", rest_name="cached-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__steal_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="steal-time", rest_name="steal-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__uptime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="uptime", rest_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__total_used_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-used-memory", rest_name="total-used-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__buffers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="buffers", rest_name="buffers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    self.__hw_interrupt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hw-interrupt", rest_name="hw-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'system-utilization-state']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'system-utilization-state']

  def _get_profile_name(self):
    """
    Getter method for profile_name, mapped from YANG variable /system_utilization_state/profile_name (string)

    YANG Description: Profile name
    """
    return self.__profile_name
      
  def _set_profile_name(self, v, load=False):
    """
    Setter method for profile_name, mapped from YANG variable /system_utilization_state/profile_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_profile_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_profile_name() directly.

    YANG Description: Profile name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="profile-name", rest_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """profile_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="profile-name", rest_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='string', is_config=False)""",
        })

    self.__profile_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_profile_name(self):
    self.__profile_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="profile-name", rest_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='string', is_config=False)


  def _get_total_system_memory(self):
    """
    Getter method for total_system_memory, mapped from YANG variable /system_utilization_state/total_system_memory (uint32)

    YANG Description: Total System memory
    """
    return self.__total_system_memory
      
  def _set_total_system_memory(self, v, load=False):
    """
    Setter method for total_system_memory, mapped from YANG variable /system_utilization_state/total_system_memory (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total_system_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total_system_memory() directly.

    YANG Description: Total System memory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-system-memory", rest_name="total-system-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total_system_memory must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-system-memory", rest_name="total-system-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__total_system_memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total_system_memory(self):
    self.__total_system_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-system-memory", rest_name="total-system-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_total_used_memory(self):
    """
    Getter method for total_used_memory, mapped from YANG variable /system_utilization_state/total_used_memory (uint32)

    YANG Description: Total System memory
    """
    return self.__total_used_memory
      
  def _set_total_used_memory(self, v, load=False):
    """
    Setter method for total_used_memory, mapped from YANG variable /system_utilization_state/total_used_memory (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total_used_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total_used_memory() directly.

    YANG Description: Total System memory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-used-memory", rest_name="total-used-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total_used_memory must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-used-memory", rest_name="total-used-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__total_used_memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total_used_memory(self):
    self.__total_used_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-used-memory", rest_name="total-used-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_total_free_memory(self):
    """
    Getter method for total_free_memory, mapped from YANG variable /system_utilization_state/total_free_memory (uint32)

    YANG Description: Total Free memory
    """
    return self.__total_free_memory
      
  def _set_total_free_memory(self, v, load=False):
    """
    Setter method for total_free_memory, mapped from YANG variable /system_utilization_state/total_free_memory (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total_free_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total_free_memory() directly.

    YANG Description: Total Free memory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-free-memory", rest_name="total-free-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total_free_memory must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-free-memory", rest_name="total-free-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__total_free_memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total_free_memory(self):
    self.__total_free_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-free-memory", rest_name="total-free-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_cached_memory(self):
    """
    Getter method for cached_memory, mapped from YANG variable /system_utilization_state/cached_memory (uint32)

    YANG Description: Cached memory
    """
    return self.__cached_memory
      
  def _set_cached_memory(self, v, load=False):
    """
    Setter method for cached_memory, mapped from YANG variable /system_utilization_state/cached_memory (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cached_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cached_memory() directly.

    YANG Description: Cached memory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cached-memory", rest_name="cached-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cached_memory must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cached-memory", rest_name="cached-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__cached_memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cached_memory(self):
    self.__cached_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cached-memory", rest_name="cached-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_buffers(self):
    """
    Getter method for buffers, mapped from YANG variable /system_utilization_state/buffers (uint32)

    YANG Description: Number of buffers
    """
    return self.__buffers
      
  def _set_buffers(self, v, load=False):
    """
    Setter method for buffers, mapped from YANG variable /system_utilization_state/buffers (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_buffers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_buffers() directly.

    YANG Description: Number of buffers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="buffers", rest_name="buffers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """buffers must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="buffers", rest_name="buffers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__buffers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_buffers(self):
    self.__buffers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="buffers", rest_name="buffers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_user_free_memory(self):
    """
    Getter method for user_free_memory, mapped from YANG variable /system_utilization_state/user_free_memory (uint32)

    YANG Description: Free memory in user space
    """
    return self.__user_free_memory
      
  def _set_user_free_memory(self, v, load=False):
    """
    Setter method for user_free_memory, mapped from YANG variable /system_utilization_state/user_free_memory (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_free_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_free_memory() directly.

    YANG Description: Free memory in user space
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="user-free-memory", rest_name="user-free-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_free_memory must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="user-free-memory", rest_name="user-free-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__user_free_memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_free_memory(self):
    self.__user_free_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="user-free-memory", rest_name="user-free-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_kernel_free_memory(self):
    """
    Getter method for kernel_free_memory, mapped from YANG variable /system_utilization_state/kernel_free_memory (uint32)

    YANG Description: Free memory in kernel space
    """
    return self.__kernel_free_memory
      
  def _set_kernel_free_memory(self, v, load=False):
    """
    Setter method for kernel_free_memory, mapped from YANG variable /system_utilization_state/kernel_free_memory (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_kernel_free_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_kernel_free_memory() directly.

    YANG Description: Free memory in kernel space
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="kernel-free-memory", rest_name="kernel-free-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """kernel_free_memory must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="kernel-free-memory", rest_name="kernel-free-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__kernel_free_memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_kernel_free_memory(self):
    self.__kernel_free_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="kernel-free-memory", rest_name="kernel-free-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_total_swap_memory(self):
    """
    Getter method for total_swap_memory, mapped from YANG variable /system_utilization_state/total_swap_memory (uint32)

    YANG Description: Total swap memory
    """
    return self.__total_swap_memory
      
  def _set_total_swap_memory(self, v, load=False):
    """
    Setter method for total_swap_memory, mapped from YANG variable /system_utilization_state/total_swap_memory (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total_swap_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total_swap_memory() directly.

    YANG Description: Total swap memory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-swap-memory", rest_name="total-swap-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total_swap_memory must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-swap-memory", rest_name="total-swap-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__total_swap_memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total_swap_memory(self):
    self.__total_swap_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-swap-memory", rest_name="total-swap-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_total_free_swap_memory(self):
    """
    Getter method for total_free_swap_memory, mapped from YANG variable /system_utilization_state/total_free_swap_memory (uint32)

    YANG Description: Total swap memory available
    """
    return self.__total_free_swap_memory
      
  def _set_total_free_swap_memory(self, v, load=False):
    """
    Setter method for total_free_swap_memory, mapped from YANG variable /system_utilization_state/total_free_swap_memory (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total_free_swap_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total_free_swap_memory() directly.

    YANG Description: Total swap memory available
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-free-swap-memory", rest_name="total-free-swap-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total_free_swap_memory must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-free-swap-memory", rest_name="total-free-swap-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__total_free_swap_memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total_free_swap_memory(self):
    self.__total_free_swap_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-free-swap-memory", rest_name="total-free-swap-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_total_used_swap_memory(self):
    """
    Getter method for total_used_swap_memory, mapped from YANG variable /system_utilization_state/total_used_swap_memory (uint32)

    YANG Description: Total swap memory used
    """
    return self.__total_used_swap_memory
      
  def _set_total_used_swap_memory(self, v, load=False):
    """
    Setter method for total_used_swap_memory, mapped from YANG variable /system_utilization_state/total_used_swap_memory (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total_used_swap_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total_used_swap_memory() directly.

    YANG Description: Total swap memory used
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-used-swap-memory", rest_name="total-used-swap-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total_used_swap_memory must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-used-swap-memory", rest_name="total-used-swap-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__total_used_swap_memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total_used_swap_memory(self):
    self.__total_used_swap_memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-used-swap-memory", rest_name="total-used-swap-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_user_process(self):
    """
    Getter method for user_process, mapped from YANG variable /system_utilization_state/user_process (uint32)

    YANG Description: Number of user processes
    """
    return self.__user_process
      
  def _set_user_process(self, v, load=False):
    """
    Setter method for user_process, mapped from YANG variable /system_utilization_state/user_process (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_process is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_process() directly.

    YANG Description: Number of user processes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="user-process", rest_name="user-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_process must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="user-process", rest_name="user-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__user_process = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_process(self):
    self.__user_process = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="user-process", rest_name="user-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_system_process(self):
    """
    Getter method for system_process, mapped from YANG variable /system_utilization_state/system_process (uint32)

    YANG Description: Number of system processes
    """
    return self.__system_process
      
  def _set_system_process(self, v, load=False):
    """
    Setter method for system_process, mapped from YANG variable /system_utilization_state/system_process (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_process is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_process() directly.

    YANG Description: Number of system processes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="system-process", rest_name="system-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_process must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="system-process", rest_name="system-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__system_process = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_process(self):
    self.__system_process = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="system-process", rest_name="system-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_niced_process(self):
    """
    Getter method for niced_process, mapped from YANG variable /system_utilization_state/niced_process (uint32)

    YANG Description: Number of niced processes
    """
    return self.__niced_process
      
  def _set_niced_process(self, v, load=False):
    """
    Setter method for niced_process, mapped from YANG variable /system_utilization_state/niced_process (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_niced_process is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_niced_process() directly.

    YANG Description: Number of niced processes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="niced-process", rest_name="niced-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """niced_process must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="niced-process", rest_name="niced-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__niced_process = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_niced_process(self):
    self.__niced_process = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="niced-process", rest_name="niced-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_iowait(self):
    """
    Getter method for iowait, mapped from YANG variable /system_utilization_state/iowait (uint32)

    YANG Description: iowait
    """
    return self.__iowait
      
  def _set_iowait(self, v, load=False):
    """
    Setter method for iowait, mapped from YANG variable /system_utilization_state/iowait (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_iowait is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_iowait() directly.

    YANG Description: iowait
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="iowait", rest_name="iowait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """iowait must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="iowait", rest_name="iowait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__iowait = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_iowait(self):
    self.__iowait = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="iowait", rest_name="iowait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_hw_interrupt(self):
    """
    Getter method for hw_interrupt, mapped from YANG variable /system_utilization_state/hw_interrupt (uint32)

    YANG Description: hardware interrupt
    """
    return self.__hw_interrupt
      
  def _set_hw_interrupt(self, v, load=False):
    """
    Setter method for hw_interrupt, mapped from YANG variable /system_utilization_state/hw_interrupt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hw_interrupt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hw_interrupt() directly.

    YANG Description: hardware interrupt
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hw-interrupt", rest_name="hw-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hw_interrupt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hw-interrupt", rest_name="hw-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__hw_interrupt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hw_interrupt(self):
    self.__hw_interrupt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hw-interrupt", rest_name="hw-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_sw_interrupt(self):
    """
    Getter method for sw_interrupt, mapped from YANG variable /system_utilization_state/sw_interrupt (uint32)

    YANG Description: software interrupt
    """
    return self.__sw_interrupt
      
  def _set_sw_interrupt(self, v, load=False):
    """
    Setter method for sw_interrupt, mapped from YANG variable /system_utilization_state/sw_interrupt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sw_interrupt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sw_interrupt() directly.

    YANG Description: software interrupt
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sw-interrupt", rest_name="sw-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sw_interrupt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sw-interrupt", rest_name="sw-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__sw_interrupt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sw_interrupt(self):
    self.__sw_interrupt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sw-interrupt", rest_name="sw-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_idle_state(self):
    """
    Getter method for idle_state, mapped from YANG variable /system_utilization_state/idle_state (uint32)

    YANG Description: idle state
    """
    return self.__idle_state
      
  def _set_idle_state(self, v, load=False):
    """
    Setter method for idle_state, mapped from YANG variable /system_utilization_state/idle_state (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_idle_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_idle_state() directly.

    YANG Description: idle state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="idle-state", rest_name="idle-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """idle_state must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="idle-state", rest_name="idle-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__idle_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_idle_state(self):
    self.__idle_state = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="idle-state", rest_name="idle-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_steal_time(self):
    """
    Getter method for steal_time, mapped from YANG variable /system_utilization_state/steal_time (uint32)

    YANG Description: steal state
    """
    return self.__steal_time
      
  def _set_steal_time(self, v, load=False):
    """
    Setter method for steal_time, mapped from YANG variable /system_utilization_state/steal_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_steal_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_steal_time() directly.

    YANG Description: steal state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="steal-time", rest_name="steal-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """steal_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="steal-time", rest_name="steal-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__steal_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_steal_time(self):
    self.__steal_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="steal-time", rest_name="steal-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)


  def _get_uptime(self):
    """
    Getter method for uptime, mapped from YANG variable /system_utilization_state/uptime (uint32)

    YANG Description: uptime
    """
    return self.__uptime
      
  def _set_uptime(self, v, load=False):
    """
    Setter method for uptime, mapped from YANG variable /system_utilization_state/uptime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uptime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uptime() directly.

    YANG Description: uptime
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="uptime", rest_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uptime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="uptime", rest_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)""",
        })

    self.__uptime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uptime(self):
    self.__uptime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="uptime", rest_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='uint32', is_config=False)

  profile_name = __builtin__.property(_get_profile_name)
  total_system_memory = __builtin__.property(_get_total_system_memory)
  total_used_memory = __builtin__.property(_get_total_used_memory)
  total_free_memory = __builtin__.property(_get_total_free_memory)
  cached_memory = __builtin__.property(_get_cached_memory)
  buffers = __builtin__.property(_get_buffers)
  user_free_memory = __builtin__.property(_get_user_free_memory)
  kernel_free_memory = __builtin__.property(_get_kernel_free_memory)
  total_swap_memory = __builtin__.property(_get_total_swap_memory)
  total_free_swap_memory = __builtin__.property(_get_total_free_swap_memory)
  total_used_swap_memory = __builtin__.property(_get_total_used_swap_memory)
  user_process = __builtin__.property(_get_user_process)
  system_process = __builtin__.property(_get_system_process)
  niced_process = __builtin__.property(_get_niced_process)
  iowait = __builtin__.property(_get_iowait)
  hw_interrupt = __builtin__.property(_get_hw_interrupt)
  sw_interrupt = __builtin__.property(_get_sw_interrupt)
  idle_state = __builtin__.property(_get_idle_state)
  steal_time = __builtin__.property(_get_steal_time)
  uptime = __builtin__.property(_get_uptime)


  _pyangbind_elements = {'profile_name': profile_name, 'total_system_memory': total_system_memory, 'total_used_memory': total_used_memory, 'total_free_memory': total_free_memory, 'cached_memory': cached_memory, 'buffers': buffers, 'user_free_memory': user_free_memory, 'kernel_free_memory': kernel_free_memory, 'total_swap_memory': total_swap_memory, 'total_free_swap_memory': total_free_swap_memory, 'total_used_swap_memory': total_used_swap_memory, 'user_process': user_process, 'system_process': system_process, 'niced_process': niced_process, 'iowait': iowait, 'hw_interrupt': hw_interrupt, 'sw_interrupt': sw_interrupt, 'idle_state': idle_state, 'steal_time': steal_time, 'uptime': uptime, }


