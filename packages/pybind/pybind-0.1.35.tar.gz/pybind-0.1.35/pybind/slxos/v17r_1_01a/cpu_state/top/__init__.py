
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import cpu_top_process_information
class top(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-RAS-operational - based on the path /cpu-state/top. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top CPU utilization
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__cpu_curr_time','__cpu_system_uptime','__cpu_no_of_users','__cpu_load_average_one_min','__cpu_load_average_five_min','__cpu_load_average_fifteen_min','__cpu_total_task','__cpu_running_task','__cpu_sleeping_task','__cpu_stopped_task','__cpu_zombie_task','__cpu_util_user','__cpu_util_kernel','__cpu_util_nice','__cpu_util_idle','__cpu_util_iowait','__cpu_util_hi','__cpu_util_si','__cpu_util_st','__cpu_total_mem','__cpu_used_mem','__cpu_free_mem','__cpu_buffer_mem','__cpu_total_mem_swap','__cpu_used_mem_swap','__cpu_free_mem_swap','__cpu_cache_mem_swap','__cpu_top_process_information',)

  _yang_name = 'top'
  _rest_name = 'top'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__cpu_no_of_users = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-no-of-users", rest_name="cpu-no-of-users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    self.__cpu_util_kernel = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-kernel", rest_name="cpu-util-kernel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    self.__cpu_running_task = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-running-task", rest_name="cpu-running-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    self.__cpu_sleeping_task = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-sleeping-task", rest_name="cpu-sleeping-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    self.__cpu_stopped_task = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-stopped-task", rest_name="cpu-stopped-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    self.__cpu_cache_mem_swap = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-cache-mem-swap", rest_name="cpu-cache-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    self.__cpu_total_mem_swap = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-total-mem-swap", rest_name="cpu-total-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    self.__cpu_buffer_mem = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-buffer-mem", rest_name="cpu-buffer-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    self.__cpu_util_iowait = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-iowait", rest_name="cpu-util-iowait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    self.__cpu_total_task = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-total-task", rest_name="cpu-total-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    self.__cpu_util_nice = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-nice", rest_name="cpu-util-nice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    self.__cpu_load_average_fifteen_min = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-load-average-fifteen-min", rest_name="cpu-load-average-fifteen-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    self.__cpu_load_average_five_min = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-load-average-five-min", rest_name="cpu-load-average-five-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    self.__cpu_util_hi = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-hi", rest_name="cpu-util-hi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    self.__cpu_util_idle = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-idle", rest_name="cpu-util-idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    self.__cpu_system_uptime = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-system-uptime", rest_name="cpu-system-uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    self.__cpu_util_user = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-user", rest_name="cpu-util-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    self.__cpu_load_average_one_min = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-load-average-one-min", rest_name="cpu-load-average-one-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    self.__cpu_used_mem = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-used-mem", rest_name="cpu-used-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    self.__cpu_curr_time = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-curr-time", rest_name="cpu-curr-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    self.__cpu_total_mem = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-total-mem", rest_name="cpu-total-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    self.__cpu_top_process_information = YANGDynClass(base=YANGListType("cpu_process_id",cpu_top_process_information.cpu_top_process_information, yang_name="cpu-top-process-information", rest_name="cpu-top-process-information", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cpu-process-id', extensions={u'tailf-common': {u'callpoint': u'RAS-cpu-top-process-information', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-top-process-information", rest_name="cpu-top-process-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'RAS-cpu-top-process-information', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='list', is_config=False)
    self.__cpu_free_mem = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-free-mem", rest_name="cpu-free-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    self.__cpu_zombie_task = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-zombie-task", rest_name="cpu-zombie-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    self.__cpu_util_si = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-si", rest_name="cpu-util-si", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    self.__cpu_util_st = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-st", rest_name="cpu-util-st", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    self.__cpu_free_mem_swap = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-free-mem-swap", rest_name="cpu-free-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    self.__cpu_used_mem_swap = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-used-mem-swap", rest_name="cpu-used-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'cpu-state', u'top']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'cpu-state', u'top']

  def _get_cpu_curr_time(self):
    """
    Getter method for cpu_curr_time, mapped from YANG variable /cpu_state/top/cpu_curr_time (string)

    YANG Description: Current time of the system
    """
    return self.__cpu_curr_time
      
  def _set_cpu_curr_time(self, v, load=False):
    """
    Setter method for cpu_curr_time, mapped from YANG variable /cpu_state/top/cpu_curr_time (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_curr_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_curr_time() directly.

    YANG Description: Current time of the system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cpu-curr-time", rest_name="cpu-curr-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_curr_time must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-curr-time", rest_name="cpu-curr-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)""",
        })

    self.__cpu_curr_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_curr_time(self):
    self.__cpu_curr_time = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-curr-time", rest_name="cpu-curr-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)


  def _get_cpu_system_uptime(self):
    """
    Getter method for cpu_system_uptime, mapped from YANG variable /cpu_state/top/cpu_system_uptime (string)

    YANG Description: System uptime since last boot
    """
    return self.__cpu_system_uptime
      
  def _set_cpu_system_uptime(self, v, load=False):
    """
    Setter method for cpu_system_uptime, mapped from YANG variable /cpu_state/top/cpu_system_uptime (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_system_uptime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_system_uptime() directly.

    YANG Description: System uptime since last boot
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cpu-system-uptime", rest_name="cpu-system-uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_system_uptime must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-system-uptime", rest_name="cpu-system-uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)""",
        })

    self.__cpu_system_uptime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_system_uptime(self):
    self.__cpu_system_uptime = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-system-uptime", rest_name="cpu-system-uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)


  def _get_cpu_no_of_users(self):
    """
    Getter method for cpu_no_of_users, mapped from YANG variable /cpu_state/top/cpu_no_of_users (uint32)

    YANG Description: Current number of users logged in
    """
    return self.__cpu_no_of_users
      
  def _set_cpu_no_of_users(self, v, load=False):
    """
    Setter method for cpu_no_of_users, mapped from YANG variable /cpu_state/top/cpu_no_of_users (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_no_of_users is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_no_of_users() directly.

    YANG Description: Current number of users logged in
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-no-of-users", rest_name="cpu-no-of-users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_no_of_users must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-no-of-users", rest_name="cpu-no-of-users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)""",
        })

    self.__cpu_no_of_users = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_no_of_users(self):
    self.__cpu_no_of_users = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-no-of-users", rest_name="cpu-no-of-users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)


  def _get_cpu_load_average_one_min(self):
    """
    Getter method for cpu_load_average_one_min, mapped from YANG variable /cpu_state/top/cpu_load_average_one_min (decimal64)

    YANG Description: CPU load average in the last one minute
    """
    return self.__cpu_load_average_one_min
      
  def _set_cpu_load_average_one_min(self, v, load=False):
    """
    Setter method for cpu_load_average_one_min, mapped from YANG variable /cpu_state/top/cpu_load_average_one_min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_load_average_one_min is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_load_average_one_min() directly.

    YANG Description: CPU load average in the last one minute
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-load-average-one-min", rest_name="cpu-load-average-one-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_load_average_one_min must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-load-average-one-min", rest_name="cpu-load-average-one-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)""",
        })

    self.__cpu_load_average_one_min = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_load_average_one_min(self):
    self.__cpu_load_average_one_min = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-load-average-one-min", rest_name="cpu-load-average-one-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)


  def _get_cpu_load_average_five_min(self):
    """
    Getter method for cpu_load_average_five_min, mapped from YANG variable /cpu_state/top/cpu_load_average_five_min (decimal64)

    YANG Description: CPU load average in the last five minute
    """
    return self.__cpu_load_average_five_min
      
  def _set_cpu_load_average_five_min(self, v, load=False):
    """
    Setter method for cpu_load_average_five_min, mapped from YANG variable /cpu_state/top/cpu_load_average_five_min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_load_average_five_min is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_load_average_five_min() directly.

    YANG Description: CPU load average in the last five minute
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-load-average-five-min", rest_name="cpu-load-average-five-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_load_average_five_min must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-load-average-five-min", rest_name="cpu-load-average-five-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)""",
        })

    self.__cpu_load_average_five_min = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_load_average_five_min(self):
    self.__cpu_load_average_five_min = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-load-average-five-min", rest_name="cpu-load-average-five-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)


  def _get_cpu_load_average_fifteen_min(self):
    """
    Getter method for cpu_load_average_fifteen_min, mapped from YANG variable /cpu_state/top/cpu_load_average_fifteen_min (decimal64)

    YANG Description: CPU load average in the last fifteen minute
    """
    return self.__cpu_load_average_fifteen_min
      
  def _set_cpu_load_average_fifteen_min(self, v, load=False):
    """
    Setter method for cpu_load_average_fifteen_min, mapped from YANG variable /cpu_state/top/cpu_load_average_fifteen_min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_load_average_fifteen_min is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_load_average_fifteen_min() directly.

    YANG Description: CPU load average in the last fifteen minute
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-load-average-fifteen-min", rest_name="cpu-load-average-fifteen-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_load_average_fifteen_min must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-load-average-fifteen-min", rest_name="cpu-load-average-fifteen-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)""",
        })

    self.__cpu_load_average_fifteen_min = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_load_average_fifteen_min(self):
    self.__cpu_load_average_fifteen_min = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-load-average-fifteen-min", rest_name="cpu-load-average-fifteen-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)


  def _get_cpu_total_task(self):
    """
    Getter method for cpu_total_task, mapped from YANG variable /cpu_state/top/cpu_total_task (uint32)

    YANG Description: Total number of tasks running
    """
    return self.__cpu_total_task
      
  def _set_cpu_total_task(self, v, load=False):
    """
    Setter method for cpu_total_task, mapped from YANG variable /cpu_state/top/cpu_total_task (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_total_task is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_total_task() directly.

    YANG Description: Total number of tasks running
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-total-task", rest_name="cpu-total-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_total_task must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-total-task", rest_name="cpu-total-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)""",
        })

    self.__cpu_total_task = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_total_task(self):
    self.__cpu_total_task = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-total-task", rest_name="cpu-total-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)


  def _get_cpu_running_task(self):
    """
    Getter method for cpu_running_task, mapped from YANG variable /cpu_state/top/cpu_running_task (uint32)

    YANG Description: Number of running tasks 
    """
    return self.__cpu_running_task
      
  def _set_cpu_running_task(self, v, load=False):
    """
    Setter method for cpu_running_task, mapped from YANG variable /cpu_state/top/cpu_running_task (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_running_task is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_running_task() directly.

    YANG Description: Number of running tasks 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-running-task", rest_name="cpu-running-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_running_task must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-running-task", rest_name="cpu-running-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)""",
        })

    self.__cpu_running_task = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_running_task(self):
    self.__cpu_running_task = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-running-task", rest_name="cpu-running-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)


  def _get_cpu_sleeping_task(self):
    """
    Getter method for cpu_sleeping_task, mapped from YANG variable /cpu_state/top/cpu_sleeping_task (uint32)

    YANG Description: N umber of sleeping tasks 
    """
    return self.__cpu_sleeping_task
      
  def _set_cpu_sleeping_task(self, v, load=False):
    """
    Setter method for cpu_sleeping_task, mapped from YANG variable /cpu_state/top/cpu_sleeping_task (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_sleeping_task is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_sleeping_task() directly.

    YANG Description: N umber of sleeping tasks 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-sleeping-task", rest_name="cpu-sleeping-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_sleeping_task must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-sleeping-task", rest_name="cpu-sleeping-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)""",
        })

    self.__cpu_sleeping_task = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_sleeping_task(self):
    self.__cpu_sleeping_task = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-sleeping-task", rest_name="cpu-sleeping-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)


  def _get_cpu_stopped_task(self):
    """
    Getter method for cpu_stopped_task, mapped from YANG variable /cpu_state/top/cpu_stopped_task (uint32)

    YANG Description: Number of stopped tasks 
    """
    return self.__cpu_stopped_task
      
  def _set_cpu_stopped_task(self, v, load=False):
    """
    Setter method for cpu_stopped_task, mapped from YANG variable /cpu_state/top/cpu_stopped_task (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_stopped_task is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_stopped_task() directly.

    YANG Description: Number of stopped tasks 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-stopped-task", rest_name="cpu-stopped-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_stopped_task must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-stopped-task", rest_name="cpu-stopped-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)""",
        })

    self.__cpu_stopped_task = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_stopped_task(self):
    self.__cpu_stopped_task = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-stopped-task", rest_name="cpu-stopped-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)


  def _get_cpu_zombie_task(self):
    """
    Getter method for cpu_zombie_task, mapped from YANG variable /cpu_state/top/cpu_zombie_task (uint32)

    YANG Description: Number of zombie tasks 
    """
    return self.__cpu_zombie_task
      
  def _set_cpu_zombie_task(self, v, load=False):
    """
    Setter method for cpu_zombie_task, mapped from YANG variable /cpu_state/top/cpu_zombie_task (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_zombie_task is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_zombie_task() directly.

    YANG Description: Number of zombie tasks 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-zombie-task", rest_name="cpu-zombie-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_zombie_task must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-zombie-task", rest_name="cpu-zombie-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)""",
        })

    self.__cpu_zombie_task = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_zombie_task(self):
    self.__cpu_zombie_task = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cpu-zombie-task", rest_name="cpu-zombie-task", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)


  def _get_cpu_util_user(self):
    """
    Getter method for cpu_util_user, mapped from YANG variable /cpu_state/top/cpu_util_user (decimal64)

    YANG Description: CPU utlization % by user processes
    """
    return self.__cpu_util_user
      
  def _set_cpu_util_user(self, v, load=False):
    """
    Setter method for cpu_util_user, mapped from YANG variable /cpu_state/top/cpu_util_user (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_util_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_util_user() directly.

    YANG Description: CPU utlization % by user processes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-user", rest_name="cpu-util-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_util_user must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-user", rest_name="cpu-util-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)""",
        })

    self.__cpu_util_user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_util_user(self):
    self.__cpu_util_user = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-user", rest_name="cpu-util-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)


  def _get_cpu_util_kernel(self):
    """
    Getter method for cpu_util_kernel, mapped from YANG variable /cpu_state/top/cpu_util_kernel (decimal64)

    YANG Description: CPU utlization % by kernel processes
    """
    return self.__cpu_util_kernel
      
  def _set_cpu_util_kernel(self, v, load=False):
    """
    Setter method for cpu_util_kernel, mapped from YANG variable /cpu_state/top/cpu_util_kernel (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_util_kernel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_util_kernel() directly.

    YANG Description: CPU utlization % by kernel processes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-kernel", rest_name="cpu-util-kernel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_util_kernel must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-kernel", rest_name="cpu-util-kernel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)""",
        })

    self.__cpu_util_kernel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_util_kernel(self):
    self.__cpu_util_kernel = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-kernel", rest_name="cpu-util-kernel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)


  def _get_cpu_util_nice(self):
    """
    Getter method for cpu_util_nice, mapped from YANG variable /cpu_state/top/cpu_util_nice (decimal64)

    YANG Description: CPU utlization % by processes with nice value
    """
    return self.__cpu_util_nice
      
  def _set_cpu_util_nice(self, v, load=False):
    """
    Setter method for cpu_util_nice, mapped from YANG variable /cpu_state/top/cpu_util_nice (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_util_nice is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_util_nice() directly.

    YANG Description: CPU utlization % by processes with nice value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-nice", rest_name="cpu-util-nice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_util_nice must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-nice", rest_name="cpu-util-nice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)""",
        })

    self.__cpu_util_nice = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_util_nice(self):
    self.__cpu_util_nice = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-nice", rest_name="cpu-util-nice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)


  def _get_cpu_util_idle(self):
    """
    Getter method for cpu_util_idle, mapped from YANG variable /cpu_state/top/cpu_util_idle (decimal64)

    YANG Description: CPU utlization % at idle state
    """
    return self.__cpu_util_idle
      
  def _set_cpu_util_idle(self, v, load=False):
    """
    Setter method for cpu_util_idle, mapped from YANG variable /cpu_state/top/cpu_util_idle (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_util_idle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_util_idle() directly.

    YANG Description: CPU utlization % at idle state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-idle", rest_name="cpu-util-idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_util_idle must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-idle", rest_name="cpu-util-idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)""",
        })

    self.__cpu_util_idle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_util_idle(self):
    self.__cpu_util_idle = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-idle", rest_name="cpu-util-idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)


  def _get_cpu_util_iowait(self):
    """
    Getter method for cpu_util_iowait, mapped from YANG variable /cpu_state/top/cpu_util_iowait (decimal64)

    YANG Description: CPU utlization % waiting for I/O
    """
    return self.__cpu_util_iowait
      
  def _set_cpu_util_iowait(self, v, load=False):
    """
    Setter method for cpu_util_iowait, mapped from YANG variable /cpu_state/top/cpu_util_iowait (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_util_iowait is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_util_iowait() directly.

    YANG Description: CPU utlization % waiting for I/O
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-iowait", rest_name="cpu-util-iowait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_util_iowait must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-iowait", rest_name="cpu-util-iowait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)""",
        })

    self.__cpu_util_iowait = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_util_iowait(self):
    self.__cpu_util_iowait = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-iowait", rest_name="cpu-util-iowait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)


  def _get_cpu_util_hi(self):
    """
    Getter method for cpu_util_hi, mapped from YANG variable /cpu_state/top/cpu_util_hi (decimal64)

    YANG Description: CPU utlization % for hardware interrupt
    """
    return self.__cpu_util_hi
      
  def _set_cpu_util_hi(self, v, load=False):
    """
    Setter method for cpu_util_hi, mapped from YANG variable /cpu_state/top/cpu_util_hi (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_util_hi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_util_hi() directly.

    YANG Description: CPU utlization % for hardware interrupt
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-hi", rest_name="cpu-util-hi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_util_hi must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-hi", rest_name="cpu-util-hi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)""",
        })

    self.__cpu_util_hi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_util_hi(self):
    self.__cpu_util_hi = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-hi", rest_name="cpu-util-hi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)


  def _get_cpu_util_si(self):
    """
    Getter method for cpu_util_si, mapped from YANG variable /cpu_state/top/cpu_util_si (decimal64)

    YANG Description: CPU utlization % for software interrupt
    """
    return self.__cpu_util_si
      
  def _set_cpu_util_si(self, v, load=False):
    """
    Setter method for cpu_util_si, mapped from YANG variable /cpu_state/top/cpu_util_si (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_util_si is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_util_si() directly.

    YANG Description: CPU utlization % for software interrupt
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-si", rest_name="cpu-util-si", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_util_si must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-si", rest_name="cpu-util-si", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)""",
        })

    self.__cpu_util_si = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_util_si(self):
    self.__cpu_util_si = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-si", rest_name="cpu-util-si", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)


  def _get_cpu_util_st(self):
    """
    Getter method for cpu_util_st, mapped from YANG variable /cpu_state/top/cpu_util_st (decimal64)

    YANG Description: CPU utlization % for steal time
    """
    return self.__cpu_util_st
      
  def _set_cpu_util_st(self, v, load=False):
    """
    Setter method for cpu_util_st, mapped from YANG variable /cpu_state/top/cpu_util_st (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_util_st is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_util_st() directly.

    YANG Description: CPU utlization % for steal time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-st", rest_name="cpu-util-st", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_util_st must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-st", rest_name="cpu-util-st", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)""",
        })

    self.__cpu_util_st = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_util_st(self):
    self.__cpu_util_st = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="cpu-util-st", rest_name="cpu-util-st", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)


  def _get_cpu_total_mem(self):
    """
    Getter method for cpu_total_mem, mapped from YANG variable /cpu_state/top/cpu_total_mem (string)

    YANG Description: Total memory
    """
    return self.__cpu_total_mem
      
  def _set_cpu_total_mem(self, v, load=False):
    """
    Setter method for cpu_total_mem, mapped from YANG variable /cpu_state/top/cpu_total_mem (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_total_mem is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_total_mem() directly.

    YANG Description: Total memory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cpu-total-mem", rest_name="cpu-total-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_total_mem must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-total-mem", rest_name="cpu-total-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)""",
        })

    self.__cpu_total_mem = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_total_mem(self):
    self.__cpu_total_mem = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-total-mem", rest_name="cpu-total-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)


  def _get_cpu_used_mem(self):
    """
    Getter method for cpu_used_mem, mapped from YANG variable /cpu_state/top/cpu_used_mem (string)

    YANG Description: Total used memory
    """
    return self.__cpu_used_mem
      
  def _set_cpu_used_mem(self, v, load=False):
    """
    Setter method for cpu_used_mem, mapped from YANG variable /cpu_state/top/cpu_used_mem (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_used_mem is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_used_mem() directly.

    YANG Description: Total used memory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cpu-used-mem", rest_name="cpu-used-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_used_mem must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-used-mem", rest_name="cpu-used-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)""",
        })

    self.__cpu_used_mem = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_used_mem(self):
    self.__cpu_used_mem = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-used-mem", rest_name="cpu-used-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)


  def _get_cpu_free_mem(self):
    """
    Getter method for cpu_free_mem, mapped from YANG variable /cpu_state/top/cpu_free_mem (string)

    YANG Description: Total Free memory
    """
    return self.__cpu_free_mem
      
  def _set_cpu_free_mem(self, v, load=False):
    """
    Setter method for cpu_free_mem, mapped from YANG variable /cpu_state/top/cpu_free_mem (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_free_mem is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_free_mem() directly.

    YANG Description: Total Free memory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cpu-free-mem", rest_name="cpu-free-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_free_mem must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-free-mem", rest_name="cpu-free-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)""",
        })

    self.__cpu_free_mem = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_free_mem(self):
    self.__cpu_free_mem = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-free-mem", rest_name="cpu-free-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)


  def _get_cpu_buffer_mem(self):
    """
    Getter method for cpu_buffer_mem, mapped from YANG variable /cpu_state/top/cpu_buffer_mem (string)

    YANG Description: Total memory used for buffers
    """
    return self.__cpu_buffer_mem
      
  def _set_cpu_buffer_mem(self, v, load=False):
    """
    Setter method for cpu_buffer_mem, mapped from YANG variable /cpu_state/top/cpu_buffer_mem (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_buffer_mem is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_buffer_mem() directly.

    YANG Description: Total memory used for buffers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cpu-buffer-mem", rest_name="cpu-buffer-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_buffer_mem must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-buffer-mem", rest_name="cpu-buffer-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)""",
        })

    self.__cpu_buffer_mem = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_buffer_mem(self):
    self.__cpu_buffer_mem = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-buffer-mem", rest_name="cpu-buffer-mem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)


  def _get_cpu_total_mem_swap(self):
    """
    Getter method for cpu_total_mem_swap, mapped from YANG variable /cpu_state/top/cpu_total_mem_swap (string)

    YANG Description: Total swap memory
    """
    return self.__cpu_total_mem_swap
      
  def _set_cpu_total_mem_swap(self, v, load=False):
    """
    Setter method for cpu_total_mem_swap, mapped from YANG variable /cpu_state/top/cpu_total_mem_swap (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_total_mem_swap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_total_mem_swap() directly.

    YANG Description: Total swap memory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cpu-total-mem-swap", rest_name="cpu-total-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_total_mem_swap must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-total-mem-swap", rest_name="cpu-total-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)""",
        })

    self.__cpu_total_mem_swap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_total_mem_swap(self):
    self.__cpu_total_mem_swap = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-total-mem-swap", rest_name="cpu-total-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)


  def _get_cpu_used_mem_swap(self):
    """
    Getter method for cpu_used_mem_swap, mapped from YANG variable /cpu_state/top/cpu_used_mem_swap (string)

    YANG Description: Total used swap memory
    """
    return self.__cpu_used_mem_swap
      
  def _set_cpu_used_mem_swap(self, v, load=False):
    """
    Setter method for cpu_used_mem_swap, mapped from YANG variable /cpu_state/top/cpu_used_mem_swap (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_used_mem_swap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_used_mem_swap() directly.

    YANG Description: Total used swap memory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cpu-used-mem-swap", rest_name="cpu-used-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_used_mem_swap must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-used-mem-swap", rest_name="cpu-used-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)""",
        })

    self.__cpu_used_mem_swap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_used_mem_swap(self):
    self.__cpu_used_mem_swap = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-used-mem-swap", rest_name="cpu-used-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)


  def _get_cpu_free_mem_swap(self):
    """
    Getter method for cpu_free_mem_swap, mapped from YANG variable /cpu_state/top/cpu_free_mem_swap (string)

    YANG Description: Total Free swap memory
    """
    return self.__cpu_free_mem_swap
      
  def _set_cpu_free_mem_swap(self, v, load=False):
    """
    Setter method for cpu_free_mem_swap, mapped from YANG variable /cpu_state/top/cpu_free_mem_swap (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_free_mem_swap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_free_mem_swap() directly.

    YANG Description: Total Free swap memory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cpu-free-mem-swap", rest_name="cpu-free-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_free_mem_swap must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-free-mem-swap", rest_name="cpu-free-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)""",
        })

    self.__cpu_free_mem_swap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_free_mem_swap(self):
    self.__cpu_free_mem_swap = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-free-mem-swap", rest_name="cpu-free-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)


  def _get_cpu_cache_mem_swap(self):
    """
    Getter method for cpu_cache_mem_swap, mapped from YANG variable /cpu_state/top/cpu_cache_mem_swap (string)

    YANG Description: Total memory used by cache
    """
    return self.__cpu_cache_mem_swap
      
  def _set_cpu_cache_mem_swap(self, v, load=False):
    """
    Setter method for cpu_cache_mem_swap, mapped from YANG variable /cpu_state/top/cpu_cache_mem_swap (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_cache_mem_swap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_cache_mem_swap() directly.

    YANG Description: Total memory used by cache
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cpu-cache-mem-swap", rest_name="cpu-cache-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_cache_mem_swap must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-cache-mem-swap", rest_name="cpu-cache-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)""",
        })

    self.__cpu_cache_mem_swap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_cache_mem_swap(self):
    self.__cpu_cache_mem_swap = YANGDynClass(base=unicode, is_leaf=True, yang_name="cpu-cache-mem-swap", rest_name="cpu-cache-mem-swap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='string', is_config=False)


  def _get_cpu_top_process_information(self):
    """
    Getter method for cpu_top_process_information, mapped from YANG variable /cpu_state/top/cpu_top_process_information (list)

    YANG Description:  Process information list from the top 
    """
    return self.__cpu_top_process_information
      
  def _set_cpu_top_process_information(self, v, load=False):
    """
    Setter method for cpu_top_process_information, mapped from YANG variable /cpu_state/top/cpu_top_process_information (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_top_process_information is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_top_process_information() directly.

    YANG Description:  Process information list from the top 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("cpu_process_id",cpu_top_process_information.cpu_top_process_information, yang_name="cpu-top-process-information", rest_name="cpu-top-process-information", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cpu-process-id', extensions={u'tailf-common': {u'callpoint': u'RAS-cpu-top-process-information', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-top-process-information", rest_name="cpu-top-process-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'RAS-cpu-top-process-information', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_top_process_information must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("cpu_process_id",cpu_top_process_information.cpu_top_process_information, yang_name="cpu-top-process-information", rest_name="cpu-top-process-information", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cpu-process-id', extensions={u'tailf-common': {u'callpoint': u'RAS-cpu-top-process-information', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-top-process-information", rest_name="cpu-top-process-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'RAS-cpu-top-process-information', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='list', is_config=False)""",
        })

    self.__cpu_top_process_information = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_top_process_information(self):
    self.__cpu_top_process_information = YANGDynClass(base=YANGListType("cpu_process_id",cpu_top_process_information.cpu_top_process_information, yang_name="cpu-top-process-information", rest_name="cpu-top-process-information", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cpu-process-id', extensions={u'tailf-common': {u'callpoint': u'RAS-cpu-top-process-information', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-top-process-information", rest_name="cpu-top-process-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'RAS-cpu-top-process-information', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='list', is_config=False)

  cpu_curr_time = __builtin__.property(_get_cpu_curr_time)
  cpu_system_uptime = __builtin__.property(_get_cpu_system_uptime)
  cpu_no_of_users = __builtin__.property(_get_cpu_no_of_users)
  cpu_load_average_one_min = __builtin__.property(_get_cpu_load_average_one_min)
  cpu_load_average_five_min = __builtin__.property(_get_cpu_load_average_five_min)
  cpu_load_average_fifteen_min = __builtin__.property(_get_cpu_load_average_fifteen_min)
  cpu_total_task = __builtin__.property(_get_cpu_total_task)
  cpu_running_task = __builtin__.property(_get_cpu_running_task)
  cpu_sleeping_task = __builtin__.property(_get_cpu_sleeping_task)
  cpu_stopped_task = __builtin__.property(_get_cpu_stopped_task)
  cpu_zombie_task = __builtin__.property(_get_cpu_zombie_task)
  cpu_util_user = __builtin__.property(_get_cpu_util_user)
  cpu_util_kernel = __builtin__.property(_get_cpu_util_kernel)
  cpu_util_nice = __builtin__.property(_get_cpu_util_nice)
  cpu_util_idle = __builtin__.property(_get_cpu_util_idle)
  cpu_util_iowait = __builtin__.property(_get_cpu_util_iowait)
  cpu_util_hi = __builtin__.property(_get_cpu_util_hi)
  cpu_util_si = __builtin__.property(_get_cpu_util_si)
  cpu_util_st = __builtin__.property(_get_cpu_util_st)
  cpu_total_mem = __builtin__.property(_get_cpu_total_mem)
  cpu_used_mem = __builtin__.property(_get_cpu_used_mem)
  cpu_free_mem = __builtin__.property(_get_cpu_free_mem)
  cpu_buffer_mem = __builtin__.property(_get_cpu_buffer_mem)
  cpu_total_mem_swap = __builtin__.property(_get_cpu_total_mem_swap)
  cpu_used_mem_swap = __builtin__.property(_get_cpu_used_mem_swap)
  cpu_free_mem_swap = __builtin__.property(_get_cpu_free_mem_swap)
  cpu_cache_mem_swap = __builtin__.property(_get_cpu_cache_mem_swap)
  cpu_top_process_information = __builtin__.property(_get_cpu_top_process_information)


  _pyangbind_elements = {'cpu_curr_time': cpu_curr_time, 'cpu_system_uptime': cpu_system_uptime, 'cpu_no_of_users': cpu_no_of_users, 'cpu_load_average_one_min': cpu_load_average_one_min, 'cpu_load_average_five_min': cpu_load_average_five_min, 'cpu_load_average_fifteen_min': cpu_load_average_fifteen_min, 'cpu_total_task': cpu_total_task, 'cpu_running_task': cpu_running_task, 'cpu_sleeping_task': cpu_sleeping_task, 'cpu_stopped_task': cpu_stopped_task, 'cpu_zombie_task': cpu_zombie_task, 'cpu_util_user': cpu_util_user, 'cpu_util_kernel': cpu_util_kernel, 'cpu_util_nice': cpu_util_nice, 'cpu_util_idle': cpu_util_idle, 'cpu_util_iowait': cpu_util_iowait, 'cpu_util_hi': cpu_util_hi, 'cpu_util_si': cpu_util_si, 'cpu_util_st': cpu_util_st, 'cpu_total_mem': cpu_total_mem, 'cpu_used_mem': cpu_used_mem, 'cpu_free_mem': cpu_free_mem, 'cpu_buffer_mem': cpu_buffer_mem, 'cpu_total_mem_swap': cpu_total_mem_swap, 'cpu_used_mem_swap': cpu_used_mem_swap, 'cpu_free_mem_swap': cpu_free_mem_swap, 'cpu_cache_mem_swap': cpu_cache_mem_swap, 'cpu_top_process_information': cpu_top_process_information, }


