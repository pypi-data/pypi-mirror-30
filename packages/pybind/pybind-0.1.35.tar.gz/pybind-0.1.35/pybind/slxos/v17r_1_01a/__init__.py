
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import http_sa
class brocade_http_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-http-config - based on the path /brocade-http-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Instrument to configure HTTP Server
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__http_sa',)

  _yang_name = 'brocade-http-config'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__http_sa = YANGDynClass(base=http_sa.http_sa, is_container='container', presence=False, yang_name="http-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-http', defining_module='brocade-http-config', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_http_sa(self):
    """
    Getter method for http_sa, mapped from YANG variable /http_sa (container)
    """
    return self.__http_sa
      
  def _set_http_sa(self, v, load=False):
    """
    Setter method for http_sa, mapped from YANG variable /http_sa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_http_sa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_http_sa() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=http_sa.http_sa, is_container='container', presence=False, yang_name="http-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-http', defining_module='brocade-http-config', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """http_sa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=http_sa.http_sa, is_container='container', presence=False, yang_name="http-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-http', defining_module='brocade-http-config', yang_type='container', is_config=True)""",
        })

    self.__http_sa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_http_sa(self):
    self.__http_sa = YANGDynClass(base=http_sa.http_sa, is_container='container', presence=False, yang_name="http-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-http', defining_module='brocade-http-config', yang_type='container', is_config=True)

  http_sa = __builtin__.property(_get_http_sa, _set_http_sa)


  _pyangbind_elements = {'http_sa': http_sa, }


import snmp_server
class brocade_snmp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-snmp - based on the path /brocade-snmp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data Model for SNMP Server and related configuration CLIs
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__snmp_server',)

  _yang_name = 'brocade-snmp'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__snmp_server = YANGDynClass(base=snmp_server.snmp_server, is_container='container', presence=False, yang_name="snmp-server", rest_name="snmp-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Snmp server configurations.', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-snmp', defining_module='brocade-snmp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_snmp_server(self):
    """
    Getter method for snmp_server, mapped from YANG variable /snmp_server (container)
    """
    return self.__snmp_server
      
  def _set_snmp_server(self, v, load=False):
    """
    Setter method for snmp_server, mapped from YANG variable /snmp_server (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snmp_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snmp_server() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=snmp_server.snmp_server, is_container='container', presence=False, yang_name="snmp-server", rest_name="snmp-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Snmp server configurations.', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-snmp', defining_module='brocade-snmp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snmp_server must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=snmp_server.snmp_server, is_container='container', presence=False, yang_name="snmp-server", rest_name="snmp-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Snmp server configurations.', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-snmp', defining_module='brocade-snmp', yang_type='container', is_config=True)""",
        })

    self.__snmp_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snmp_server(self):
    self.__snmp_server = YANGDynClass(base=snmp_server.snmp_server, is_container='container', presence=False, yang_name="snmp-server", rest_name="snmp-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Snmp server configurations.', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-snmp', defining_module='brocade-snmp', yang_type='container', is_config=True)

  snmp_server = __builtin__.property(_get_snmp_server, _set_snmp_server)


  _pyangbind_elements = {'snmp_server': snmp_server, }


class brocade_nameserver(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-nameserver - based on the path /brocade-nameserver. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The management module is an instrumentation to manage the
Fibre Channel (FC) Name Server, which realizes the FC-GS-6
requirements.

This module provides the means for monitoring the operation
of, and configuring some parameters of, one or more instances
of Fibre Channel Name Server functionality.

The Fibre Channel Name Server provides a way for N_Ports and
NL_Ports to register and discover Fibre Channel attributes.
Such attributes include names, addresses, types, features,
etc., at various protocol layers, including upper layer
protocols specific to Fibre Channel (which are sometimes
called 'FC-4s').

Physically, Fibre Channel is an interconnection of multiple
communication points, called N_Ports, interconnected either by
a switching network, called a Fabric, or by a point-to-point
link. A Fibre Channel 'node' consists of one or more N_Ports.
A Fabric may consist of multiple Interconnect Elements, some
of which are switches.  An N_Port connects to the Fabric via a
port on a switch called an F_Port.  When multiple FC nodes are
connected to a single port on a switch via an 'Arbitrated Loop'
topology, the switch port is called an FL_Port, and the nodes'
ports are called NL_Ports.  The term Nx_Port is used to refer
to either an N_Port or an NL_Port.

Glossary of the terms used:
---------------------------
F_Port              -   Port that connects to a node point-to-point.

FL_Port             -   Port that connects to a FC-AL loop.

Frame Redirection   -   A Brocade-proprietary feature that uses
                       zoning to define a redirected path for
                       Initiator and Target traffic. Traffic is
                       redirected to a network appliance via a
                       virtual initiator and virtual target.

iSCSI               -   Internet Small Computer System
                       Interface.

N_Port              -   Port on a node used with both FC-P2P
                       or FC-SW topologies.

NL_Port             -   Port on a node used with an FC-AL
                       topology.

NPIV                -   N_Port ID Virtualization.

Nx_Port             -   A generic port that can become an N_port
                       or NL_Port.

Port ID (PID)       -   The Fibre Channel address ID in DDAAPP
                       hexadecimal format.

SCR                 -   State Change Registration.

Shared Area         -   A Brocade-proprietary method of
                       addressing where the area address uses
                       the traditional 8-bits of the FCID
                       'AREA' field, plus an additional 2-bits
                       from the FCID 'AL_PA' field.

Translate Domain    -   FOS FC routing (FCR) creates an
                       translate domain in the local edge
                       fabric and this represents the
                       remote edge fabric
                       (also, 'Xlate Domain')

Access Gateway (AG) -   The Access Gateway feature, a software 
                       feature that allows a Brocade switch 
                       to act as transparent 'port expander', 
                       connecting multiple FC devices
                       (typically host HBA ports) to a single 
                       FC fabric port (F_Port). The Access 
                       Gateway connects to the fabric using 
                       the FC N_Port protocol rather than the 
                       E_Port protocol normally used by a 
                       switch, and uses the FC-FS N_Port ID 
                       Virtualization (NPIV) facility to 
                       allow its client devices to connect to 
                       the FC fabric. Although it uses its 
                       switching logic to allow the attached 
                       devices to send and receive FC traffic 
                       to the fabric, it is not recognized by 
                       the fabric as a 'switch' and therefore
                       doesn't consume a domain ID and doesn't
                       participate in the switch-to-switch 
                       traffic normal to an FC fabric.

  """
  _pyangbind_elements = {}

  

import ha
import ha_action
class brocade_ha(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ha - based on the path /brocade-ha. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to ha
level commands
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__ha','__ha_action',)

  _yang_name = 'brocade-ha'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__ha = YANGDynClass(base=ha.ha, is_container='container', presence=False, yang_name="ha", rest_name="ha", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'High availability Configuration', u'cli-add-mode': None, u'cli-suppress-no': None, u'cli-full-command': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='container', is_config=True)
    self.__ha_action = YANGDynClass(base=ha_action.ha_action, is_container='container', presence=False, yang_name="ha-action", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_ha(self):
    """
    Getter method for ha, mapped from YANG variable /ha (container)

    YANG Description: Configuration related to high availability functionalities.
    """
    return self.__ha
      
  def _set_ha(self, v, load=False):
    """
    Setter method for ha, mapped from YANG variable /ha (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha() directly.

    YANG Description: Configuration related to high availability functionalities.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ha.ha, is_container='container', presence=False, yang_name="ha", rest_name="ha", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'High availability Configuration', u'cli-add-mode': None, u'cli-suppress-no': None, u'cli-full-command': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ha.ha, is_container='container', presence=False, yang_name="ha", rest_name="ha", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'High availability Configuration', u'cli-add-mode': None, u'cli-suppress-no': None, u'cli-full-command': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='container', is_config=True)""",
        })

    self.__ha = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha(self):
    self.__ha = YANGDynClass(base=ha.ha, is_container='container', presence=False, yang_name="ha", rest_name="ha", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'High availability Configuration', u'cli-add-mode': None, u'cli-suppress-no': None, u'cli-full-command': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='container', is_config=True)


  def _get_ha_action(self):
    """
    Getter method for ha_action, mapped from YANG variable /ha_action (container)
    """
    return self.__ha_action
      
  def _set_ha_action(self, v, load=False):
    """
    Setter method for ha_action, mapped from YANG variable /ha_action (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_action() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ha_action.ha_action, is_container='container', presence=False, yang_name="ha-action", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_action must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ha_action.ha_action, is_container='container', presence=False, yang_name="ha-action", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='container', is_config=True)""",
        })

    self.__ha_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_action(self):
    self.__ha_action = YANGDynClass(base=ha_action.ha_action, is_container='container', presence=False, yang_name="ha-action", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='container', is_config=True)

  ha = __builtin__.property(_get_ha, _set_ha)
  ha_action = __builtin__.property(_get_ha_action, _set_ha_action)


  _pyangbind_elements = {'ha': ha, 'ha_action': ha_action, }


import interface_statistics_state
class brocade_interface_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-interface-operational - based on the path /brocade-interface-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage interface
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__interface_statistics_state',)

  _yang_name = 'brocade-interface-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__interface_statistics_state = YANGDynClass(base=interface_statistics_state.interface_statistics_state, is_container='container', presence=False, yang_name="interface-statistics-state", rest_name="interface-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'interface-interface-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-interface-operational', defining_module='brocade-interface-operational', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_interface_statistics_state(self):
    """
    Getter method for interface_statistics_state, mapped from YANG variable /interface_statistics_state (container)

    YANG Description: Interafce Statistics
    """
    return self.__interface_statistics_state
      
  def _set_interface_statistics_state(self, v, load=False):
    """
    Setter method for interface_statistics_state, mapped from YANG variable /interface_statistics_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_statistics_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_statistics_state() directly.

    YANG Description: Interafce Statistics
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_statistics_state.interface_statistics_state, is_container='container', presence=False, yang_name="interface-statistics-state", rest_name="interface-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'interface-interface-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-interface-operational', defining_module='brocade-interface-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_statistics_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_statistics_state.interface_statistics_state, is_container='container', presence=False, yang_name="interface-statistics-state", rest_name="interface-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'interface-interface-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-interface-operational', defining_module='brocade-interface-operational', yang_type='container', is_config=True)""",
        })

    self.__interface_statistics_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_statistics_state(self):
    self.__interface_statistics_state = YANGDynClass(base=interface_statistics_state.interface_statistics_state, is_container='container', presence=False, yang_name="interface-statistics-state", rest_name="interface-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'interface-interface-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-interface-operational', defining_module='brocade-interface-operational', yang_type='container', is_config=True)

  interface_statistics_state = __builtin__.property(_get_interface_statistics_state, _set_interface_statistics_state)


  _pyangbind_elements = {'interface_statistics_state': interface_statistics_state, }


import firmware
import dhcp
class brocade_firmware(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-firmware - based on the path /brocade-firmware. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to firmware level
level commands
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__firmware','__dhcp',)

  _yang_name = 'brocade-firmware'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__dhcp = YANGDynClass(base=dhcp.dhcp, is_container='container', presence=False, yang_name="dhcp", rest_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Commands to manage DHCP auto-deployment'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)
    self.__firmware = YANGDynClass(base=firmware.firmware, is_container='container', presence=False, yang_name="firmware", rest_name="firmware", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'firmware operations', u'action': u'recover'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_firmware(self):
    """
    Getter method for firmware, mapped from YANG variable /firmware (container)
    """
    return self.__firmware
      
  def _set_firmware(self, v, load=False):
    """
    Setter method for firmware, mapped from YANG variable /firmware (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_firmware is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_firmware() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=firmware.firmware, is_container='container', presence=False, yang_name="firmware", rest_name="firmware", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'firmware operations', u'action': u'recover'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """firmware must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=firmware.firmware, is_container='container', presence=False, yang_name="firmware", rest_name="firmware", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'firmware operations', u'action': u'recover'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)""",
        })

    self.__firmware = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_firmware(self):
    self.__firmware = YANGDynClass(base=firmware.firmware, is_container='container', presence=False, yang_name="firmware", rest_name="firmware", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'firmware operations', u'action': u'recover'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)


  def _get_dhcp(self):
    """
    Getter method for dhcp, mapped from YANG variable /dhcp (container)
    """
    return self.__dhcp
      
  def _set_dhcp(self, v, load=False):
    """
    Setter method for dhcp, mapped from YANG variable /dhcp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=dhcp.dhcp, is_container='container', presence=False, yang_name="dhcp", rest_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Commands to manage DHCP auto-deployment'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dhcp.dhcp, is_container='container', presence=False, yang_name="dhcp", rest_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Commands to manage DHCP auto-deployment'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)""",
        })

    self.__dhcp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp(self):
    self.__dhcp = YANGDynClass(base=dhcp.dhcp, is_container='container', presence=False, yang_name="dhcp", rest_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Commands to manage DHCP auto-deployment'}}, namespace='urn:brocade.com:mgmt:brocade-firmware', defining_module='brocade-firmware', yang_type='container', is_config=True)

  firmware = __builtin__.property(_get_firmware, _set_firmware)
  dhcp = __builtin__.property(_get_dhcp, _set_dhcp)


  _pyangbind_elements = {'firmware': firmware, 'dhcp': dhcp, }


class brocade_cdp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-cdp - based on the path /brocade-cdp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage the 
'Cisco Discovery Protocol (CDP)'.
  """
  _pyangbind_elements = {}

  

class brocade_lldp_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-lldp-ext - based on the path /brocade-lldp-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module is an extension to lldp model for 
 - Defining RPCs to retrieve lldp neighbors 
   in the managed device.
  """
  _pyangbind_elements = {}

  

class brocade_firmware_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-firmware-ext - based on the path /brocade-firmware-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub module defines Firmware information.
Copyright (c) 2010-2011 by Brocade Communications Systems, Inc.
All rights reserved.
  """
  _pyangbind_elements = {}

  

import ipv6_acl
class brocade_ipv6_access_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ipv6-access-list - based on the path /brocade-ipv6-access-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management sub-module contains the configuration
and rpc implementaion for IP Access-list.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__ipv6_acl',)

  _yang_name = 'brocade-ipv6-access-list'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__ipv6_acl = YANGDynClass(base=ipv6_acl.ipv6_acl, is_container='container', presence=False, yang_name="ipv6-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_IP6_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-ipv6-access-list', defining_module='brocade-ipv6-access-list', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_ipv6_acl(self):
    """
    Getter method for ipv6_acl, mapped from YANG variable /ipv6_acl (container)
    """
    return self.__ipv6_acl
      
  def _set_ipv6_acl(self, v, load=False):
    """
    Setter method for ipv6_acl, mapped from YANG variable /ipv6_acl (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_acl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_acl() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ipv6_acl.ipv6_acl, is_container='container', presence=False, yang_name="ipv6-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_IP6_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-ipv6-access-list', defining_module='brocade-ipv6-access-list', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_acl must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ipv6_acl.ipv6_acl, is_container='container', presence=False, yang_name="ipv6-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_IP6_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-ipv6-access-list', defining_module='brocade-ipv6-access-list', yang_type='container', is_config=True)""",
        })

    self.__ipv6_acl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_acl(self):
    self.__ipv6_acl = YANGDynClass(base=ipv6_acl.ipv6_acl, is_container='container', presence=False, yang_name="ipv6-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_IP6_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-ipv6-access-list', defining_module='brocade-ipv6-access-list', yang_type='container', is_config=True)

  ipv6_acl = __builtin__.property(_get_ipv6_acl, _set_ipv6_acl)


  _pyangbind_elements = {'ipv6_acl': ipv6_acl, }


import igmp_snooping_state
class brocade_mc_hms_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mc-hms-operational - based on the path /brocade-mc-hms-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage mc-hms
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__igmp_snooping_state',)

  _yang_name = 'brocade-mc-hms-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__igmp_snooping_state = YANGDynClass(base=igmp_snooping_state.igmp_snooping_state, is_container='container', presence=False, yang_name="igmp-snooping-state", rest_name="igmp-snooping-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mc-hms-igmp-snooping', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mc-hms-operational', defining_module='brocade-mc-hms-operational', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_igmp_snooping_state(self):
    """
    Getter method for igmp_snooping_state, mapped from YANG variable /igmp_snooping_state (container)

    YANG Description: IGMP Snooping Root MO
    """
    return self.__igmp_snooping_state
      
  def _set_igmp_snooping_state(self, v, load=False):
    """
    Setter method for igmp_snooping_state, mapped from YANG variable /igmp_snooping_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_igmp_snooping_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_igmp_snooping_state() directly.

    YANG Description: IGMP Snooping Root MO
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=igmp_snooping_state.igmp_snooping_state, is_container='container', presence=False, yang_name="igmp-snooping-state", rest_name="igmp-snooping-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mc-hms-igmp-snooping', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mc-hms-operational', defining_module='brocade-mc-hms-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """igmp_snooping_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=igmp_snooping_state.igmp_snooping_state, is_container='container', presence=False, yang_name="igmp-snooping-state", rest_name="igmp-snooping-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mc-hms-igmp-snooping', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mc-hms-operational', defining_module='brocade-mc-hms-operational', yang_type='container', is_config=True)""",
        })

    self.__igmp_snooping_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_igmp_snooping_state(self):
    self.__igmp_snooping_state = YANGDynClass(base=igmp_snooping_state.igmp_snooping_state, is_container='container', presence=False, yang_name="igmp-snooping-state", rest_name="igmp-snooping-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mc-hms-igmp-snooping', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mc-hms-operational', defining_module='brocade-mc-hms-operational', yang_type='container', is_config=True)

  igmp_snooping_state = __builtin__.property(_get_igmp_snooping_state, _set_igmp_snooping_state)


  _pyangbind_elements = {'igmp_snooping_state': igmp_snooping_state, }


class brocade_netconf_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-netconf-ext - based on the path /brocade-netconf-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub module defines NETCONF information.
 Copyright(c) 2010-2011 by Brocade Communications Systems, Inc.
 All rights reserved.
  """
  _pyangbind_elements = {}

  

class brocade_fcoe_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-fcoe-ext - based on the path /brocade-fcoe-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an extension to FCOE model for
    - Defining RPCs to retrieve operational information of 
      the FCoE.
        
Glossary of the terms used:
---------------------------
ACC frame - Accept frame

FCoE -      Fibre Channel over Ethernet (FCoE) is an 
           encapsulation of Fibre Channel frames over Ethernet
           networks. 

FIP -       FCoE Intialization Protocol is the standard for 
           intilization of FCoE network.

FCF -       Fibre Channel Forwarder is a network entity 
           responsible for forwarding the FCoE traffic.

FLOGI -     Fabric Login is a frame used by the end devices to 
           login to a Fibre Channel or FCoE Fabric.

FDISC -     Fabric Discovery is a frame used by the end devices 
           to perform logins of all the loop attached ports.

LOGO -      Logout is a frame used by the end devices to logout 
           of the Fibre Channel or FCoE Fabric.

ENODE -     End Node is the term used to refer End devices in 
           the FCoE network.

VN-Port -   Virtual N-Port is the FCoE equivalent of the Fibre 
           Channel N-Port.

CVL -       Clear Virtual Links is the frame to tear the Virtual
           Links in the FCoE Network.

  """
  _pyangbind_elements = {}

  

class brocade_threshold_monitor_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-threshold-monitor-ext - based on the path /brocade-threshold-monitor-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub module defines show threshold-monitor data model
Copyright (c) 2011 by Brocade Communications Systems, Inc.
All rights reserved.
  """
  _pyangbind_elements = {}

  

import class_map
import policy_map
import system_qos
class brocade_qos_mqc(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-qos-mqc - based on the path /brocade-qos-mqc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes the data model for Modular Quality of Service
(Modular QoS)
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__class_map','__policy_map','__system_qos',)

  _yang_name = 'brocade-qos-mqc'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__class_map = YANGDynClass(base=YANGListType("name",class_map.class_map, yang_name="class-map", rest_name="class-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}), is_container='list', yang_name="class-map", rest_name="class-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)
    self.__system_qos = YANGDynClass(base=system_qos.system_qos, is_container='container', presence=False, yang_name="system-qos", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'74'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='container', is_config=True)
    self.__policy_map = YANGDynClass(base=YANGListType("name",policy_map.policy_map, yang_name="policy-map", rest_name="policy-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}), is_container='list', yang_name="policy-map", rest_name="policy-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_class_map(self):
    """
    Getter method for class_map, mapped from YANG variable /class_map (list)
    """
    return self.__class_map
      
  def _set_class_map(self, v, load=False):
    """
    Setter method for class_map, mapped from YANG variable /class_map (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_class_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_class_map() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",class_map.class_map, yang_name="class-map", rest_name="class-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}), is_container='list', yang_name="class-map", rest_name="class-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """class_map must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",class_map.class_map, yang_name="class-map", rest_name="class-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}), is_container='list', yang_name="class-map", rest_name="class-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)""",
        })

    self.__class_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_class_map(self):
    self.__class_map = YANGDynClass(base=YANGListType("name",class_map.class_map, yang_name="class-map", rest_name="class-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}), is_container='list', yang_name="class-map", rest_name="class-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Class Map Configuration', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'policer-class-map', u'cli-mode-name': u'config-classmap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)


  def _get_policy_map(self):
    """
    Getter method for policy_map, mapped from YANG variable /policy_map (list)
    """
    return self.__policy_map
      
  def _set_policy_map(self, v, load=False):
    """
    Setter method for policy_map, mapped from YANG variable /policy_map (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_map() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",policy_map.policy_map, yang_name="policy-map", rest_name="policy-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}), is_container='list', yang_name="policy-map", rest_name="policy-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_map must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",policy_map.policy_map, yang_name="policy-map", rest_name="policy-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}), is_container='list', yang_name="policy-map", rest_name="policy-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)""",
        })

    self.__policy_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_map(self):
    self.__policy_map = YANGDynClass(base=YANGListType("name",policy_map.policy_map, yang_name="policy-map", rest_name="policy-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}), is_container='list', yang_name="policy-map", rest_name="policy-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Policy Map Configuration', u'cli-no-key-completion': None, u'callpoint': u'policer-policy-map', u'sort-priority': u'73', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-policymap'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='list', is_config=True)


  def _get_system_qos(self):
    """
    Getter method for system_qos, mapped from YANG variable /system_qos (container)
    """
    return self.__system_qos
      
  def _set_system_qos(self, v, load=False):
    """
    Setter method for system_qos, mapped from YANG variable /system_qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_qos() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=system_qos.system_qos, is_container='container', presence=False, yang_name="system-qos", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'74'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=system_qos.system_qos, is_container='container', presence=False, yang_name="system-qos", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'74'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='container', is_config=True)""",
        })

    self.__system_qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_qos(self):
    self.__system_qos = YANGDynClass(base=system_qos.system_qos, is_container='container', presence=False, yang_name="system-qos", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'74'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mqc', defining_module='brocade-qos-mqc', yang_type='container', is_config=True)

  class_map = __builtin__.property(_get_class_map, _set_class_map)
  policy_map = __builtin__.property(_get_policy_map, _set_policy_map)
  system_qos = __builtin__.property(_get_system_qos, _set_system_qos)


  _pyangbind_elements = {'class_map': class_map, 'policy_map': policy_map, 'system_qos': system_qos, }


import clock_sa
class brocade_clock(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-clock - based on the path /brocade-clock. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An instrumentation to configure local clock.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__clock_sa',)

  _yang_name = 'brocade-clock'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__clock_sa = YANGDynClass(base=clock_sa.clock_sa, is_container='container', presence=False, yang_name="clock-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-clock', defining_module='brocade-clock', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_clock_sa(self):
    """
    Getter method for clock_sa, mapped from YANG variable /clock_sa (container)
    """
    return self.__clock_sa
      
  def _set_clock_sa(self, v, load=False):
    """
    Setter method for clock_sa, mapped from YANG variable /clock_sa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock_sa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock_sa() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=clock_sa.clock_sa, is_container='container', presence=False, yang_name="clock-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-clock', defining_module='brocade-clock', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock_sa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=clock_sa.clock_sa, is_container='container', presence=False, yang_name="clock-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-clock', defining_module='brocade-clock', yang_type='container', is_config=True)""",
        })

    self.__clock_sa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock_sa(self):
    self.__clock_sa = YANGDynClass(base=clock_sa.clock_sa, is_container='container', presence=False, yang_name="clock-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-clock', defining_module='brocade-clock', yang_type='container', is_config=True)

  clock_sa = __builtin__.property(_get_clock_sa, _set_clock_sa)


  _pyangbind_elements = {'clock_sa': clock_sa, }


import hardware
class brocade_hardware(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-hardware - based on the path /brocade-hardware. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This hardware management module is used to manage HW connectors,
portgroup and profile.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__hardware',)

  _yang_name = 'brocade-hardware'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__hardware = YANGDynClass(base=hardware.hardware, is_container='container', presence=False, yang_name="hardware", rest_name="hardware", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Hardware Management configuration', u'cli-add-mode': None, u'cli-suppress-show-path': None, u'cli-suppress-no': None, u'cli-full-command': None}}, namespace='urn:brocade.com:mgmt:brocade-hardware', defining_module='brocade-hardware', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_hardware(self):
    """
    Getter method for hardware, mapped from YANG variable /hardware (container)

    YANG Description: This specifies the group of configuration/operational 
elements to manage the hardware chracteristics of this
managed entity.
    """
    return self.__hardware
      
  def _set_hardware(self, v, load=False):
    """
    Setter method for hardware, mapped from YANG variable /hardware (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hardware is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hardware() directly.

    YANG Description: This specifies the group of configuration/operational 
elements to manage the hardware chracteristics of this
managed entity.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=hardware.hardware, is_container='container', presence=False, yang_name="hardware", rest_name="hardware", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Hardware Management configuration', u'cli-add-mode': None, u'cli-suppress-show-path': None, u'cli-suppress-no': None, u'cli-full-command': None}}, namespace='urn:brocade.com:mgmt:brocade-hardware', defining_module='brocade-hardware', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hardware must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=hardware.hardware, is_container='container', presence=False, yang_name="hardware", rest_name="hardware", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Hardware Management configuration', u'cli-add-mode': None, u'cli-suppress-show-path': None, u'cli-suppress-no': None, u'cli-full-command': None}}, namespace='urn:brocade.com:mgmt:brocade-hardware', defining_module='brocade-hardware', yang_type='container', is_config=True)""",
        })

    self.__hardware = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hardware(self):
    self.__hardware = YANGDynClass(base=hardware.hardware, is_container='container', presence=False, yang_name="hardware", rest_name="hardware", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Hardware Management configuration', u'cli-add-mode': None, u'cli-suppress-show-path': None, u'cli-suppress-no': None, u'cli-full-command': None}}, namespace='urn:brocade.com:mgmt:brocade-hardware', defining_module='brocade-hardware', yang_type='container', is_config=True)

  hardware = __builtin__.property(_get_hardware, _set_hardware)


  _pyangbind_elements = {'hardware': hardware, }


import vlan
class brocade_vlan(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-vlan - based on the path /brocade-vlan. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule manages VLAN related CLIs.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__vlan',)

  _yang_name = 'brocade-vlan'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__vlan = YANGDynClass(base=vlan.vlan, is_container='container', presence=False, yang_name="vlan", rest_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Vlan commands', u'cli-incomplete-no': None, u'sort-priority': u'54', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-vlan', defining_module='brocade-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_vlan(self):
    """
    Getter method for vlan, mapped from YANG variable /vlan (container)
    """
    return self.__vlan
      
  def _set_vlan(self, v, load=False):
    """
    Setter method for vlan, mapped from YANG variable /vlan (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=vlan.vlan, is_container='container', presence=False, yang_name="vlan", rest_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Vlan commands', u'cli-incomplete-no': None, u'sort-priority': u'54', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-vlan', defining_module='brocade-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vlan.vlan, is_container='container', presence=False, yang_name="vlan", rest_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Vlan commands', u'cli-incomplete-no': None, u'sort-priority': u'54', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-vlan', defining_module='brocade-vlan', yang_type='container', is_config=True)""",
        })

    self.__vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan(self):
    self.__vlan = YANGDynClass(base=vlan.vlan, is_container='container', presence=False, yang_name="vlan", rest_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Vlan commands', u'cli-incomplete-no': None, u'sort-priority': u'54', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-vlan', defining_module='brocade-vlan', yang_type='container', is_config=True)

  vlan = __builtin__.property(_get_vlan, _set_vlan)


  _pyangbind_elements = {'vlan': vlan, }


import zoning
class brocade_zone(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-zone - based on the path /brocade-zone. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__zoning',)

  _yang_name = 'brocade-zone'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__zoning = YANGDynClass(base=zoning.zoning, is_container='container', presence=False, yang_name="zoning", rest_name="zoning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Zoning commands', u'display-when': u'/vcsmode/vcs-mode = "true"', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-zone', defining_module='brocade-zone', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_zoning(self):
    """
    Getter method for zoning, mapped from YANG variable /zoning (container)
    """
    return self.__zoning
      
  def _set_zoning(self, v, load=False):
    """
    Setter method for zoning, mapped from YANG variable /zoning (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_zoning is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_zoning() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=zoning.zoning, is_container='container', presence=False, yang_name="zoning", rest_name="zoning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Zoning commands', u'display-when': u'/vcsmode/vcs-mode = "true"', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-zone', defining_module='brocade-zone', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """zoning must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=zoning.zoning, is_container='container', presence=False, yang_name="zoning", rest_name="zoning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Zoning commands', u'display-when': u'/vcsmode/vcs-mode = "true"', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-zone', defining_module='brocade-zone', yang_type='container', is_config=True)""",
        })

    self.__zoning = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_zoning(self):
    self.__zoning = YANGDynClass(base=zoning.zoning, is_container='container', presence=False, yang_name="zoning", rest_name="zoning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Zoning commands', u'display-when': u'/vcsmode/vcs-mode = "true"', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-zone', defining_module='brocade-zone', yang_type='container', is_config=True)

  zoning = __builtin__.property(_get_zoning, _set_zoning)


  _pyangbind_elements = {'zoning': zoning, }


import port_channel_redundancy_group
class brocade_lag(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-lag - based on the path /brocade-lag. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management sub-module is an instrumentation to manage Link
aggregation or IEEE 802.1AX-2008 feature.

Glossary of the terms used:
--------------------------
LAG - Link Aggregation.
LACP - Link Aggregation Control Protocol
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__port_channel_redundancy_group',)

  _yang_name = 'brocade-lag'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__port_channel_redundancy_group = YANGDynClass(base=YANGListType("group_id",port_channel_redundancy_group.port_channel_redundancy_group, yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='group-id', extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'99', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}), is_container='list', yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'99', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}, namespace='urn:brocade.com:mgmt:brocade-lag', defining_module='brocade-lag', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_port_channel_redundancy_group(self):
    """
    Getter method for port_channel_redundancy_group, mapped from YANG variable /port_channel_redundancy_group (list)

    YANG Description: The list of port-channel redundancy groups in a managed device.
Each entry represents a port-channel-redundancy-group.
    """
    return self.__port_channel_redundancy_group
      
  def _set_port_channel_redundancy_group(self, v, load=False):
    """
    Setter method for port_channel_redundancy_group, mapped from YANG variable /port_channel_redundancy_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_channel_redundancy_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_channel_redundancy_group() directly.

    YANG Description: The list of port-channel redundancy groups in a managed device.
Each entry represents a port-channel-redundancy-group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("group_id",port_channel_redundancy_group.port_channel_redundancy_group, yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='group-id', extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'99', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}), is_container='list', yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'99', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}, namespace='urn:brocade.com:mgmt:brocade-lag', defining_module='brocade-lag', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_channel_redundancy_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("group_id",port_channel_redundancy_group.port_channel_redundancy_group, yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='group-id', extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'99', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}), is_container='list', yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'99', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}, namespace='urn:brocade.com:mgmt:brocade-lag', defining_module='brocade-lag', yang_type='list', is_config=True)""",
        })

    self.__port_channel_redundancy_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_channel_redundancy_group(self):
    self.__port_channel_redundancy_group = YANGDynClass(base=YANGListType("group_id",port_channel_redundancy_group.port_channel_redundancy_group, yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='group-id', extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'99', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}), is_container='list', yang_name="port-channel-redundancy-group", rest_name="port-channel-redundancy-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The list of port-channel redundancy groups.', u'cli-no-key-completion': None, u'sort-priority': u'99', u'cli-suppress-show-path': None, u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'po_redundant_grp_cp'}}, namespace='urn:brocade.com:mgmt:brocade-lag', defining_module='brocade-lag', yang_type='list', is_config=True)

  port_channel_redundancy_group = __builtin__.property(_get_port_channel_redundancy_group, _set_port_channel_redundancy_group)


  _pyangbind_elements = {'port_channel_redundancy_group': port_channel_redundancy_group, }


import system_config
class brocade_system_watermark(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-system-watermark - based on the path /brocade-system-watermark. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines SYSTEM related information.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__system_config',)

  _yang_name = 'brocade-system-watermark'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__system_config = YANGDynClass(base=system_config.system_config, is_container='container', presence=False, yang_name="system-config", rest_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'system enable/disable commands', u'alt-name': u'system'}}, namespace='urn:brocade.com:mgmt:brocade-system-watermark', defining_module='brocade-system-watermark', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_system_config(self):
    """
    Getter method for system_config, mapped from YANG variable /system_config (container)
    """
    return self.__system_config
      
  def _set_system_config(self, v, load=False):
    """
    Setter method for system_config, mapped from YANG variable /system_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=system_config.system_config, is_container='container', presence=False, yang_name="system-config", rest_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'system enable/disable commands', u'alt-name': u'system'}}, namespace='urn:brocade.com:mgmt:brocade-system-watermark', defining_module='brocade-system-watermark', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=system_config.system_config, is_container='container', presence=False, yang_name="system-config", rest_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'system enable/disable commands', u'alt-name': u'system'}}, namespace='urn:brocade.com:mgmt:brocade-system-watermark', defining_module='brocade-system-watermark', yang_type='container', is_config=True)""",
        })

    self.__system_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_config(self):
    self.__system_config = YANGDynClass(base=system_config.system_config, is_container='container', presence=False, yang_name="system-config", rest_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'system enable/disable commands', u'alt-name': u'system'}}, namespace='urn:brocade.com:mgmt:brocade-system-watermark', defining_module='brocade-system-watermark', yang_type='container', is_config=True)

  system_config = __builtin__.property(_get_system_config, _set_system_config)


  _pyangbind_elements = {'system_config': system_config, }


class brocade_anycast_gateway(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-anycast-gateway - based on the path /brocade-anycast-gateway. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes the data model for anycast gateway
  """
  _pyangbind_elements = {}

  

class brocade_port_profile_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-port-profile-ext - based on the path /brocade-port-profile-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an extension to the port-profile
model for 
   - Defining RPCs to retrieve port-profile related operational
     data in the managed device.
  """
  _pyangbind_elements = {}

  

class brocade_ras_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ras-ext - based on the path /brocade-ras-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines RASLOG related information.
Copyright (c) 2010-11 by Brocade Communications Systems, Inc.
All rights reserved.
  """
  _pyangbind_elements = {}

  

class brocade_default_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-default-config - based on the path /brocade-default-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Module for enabling default configuration CLIs
  """
  _pyangbind_elements = {}

  

import lacp
class brocade_lacp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-lacp - based on the path /brocade-lacp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes the data model for Link Aggregation 
Control Protocol
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__lacp',)

  _yang_name = 'brocade-lacp'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__lacp = YANGDynClass(base=lacp.lacp, is_container='container', presence=False, yang_name="lacp", rest_name="lacp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'LACP commands', u'cli-incomplete-no': None, u'callpoint': u'lacp_systempriority', u'sort-priority': u'58'}}, namespace='urn:brocade.com:mgmt:brocade-lacp', defining_module='brocade-lacp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_lacp(self):
    """
    Getter method for lacp, mapped from YANG variable /lacp (container)
    """
    return self.__lacp
      
  def _set_lacp(self, v, load=False):
    """
    Setter method for lacp, mapped from YANG variable /lacp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lacp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lacp() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=lacp.lacp, is_container='container', presence=False, yang_name="lacp", rest_name="lacp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'LACP commands', u'cli-incomplete-no': None, u'callpoint': u'lacp_systempriority', u'sort-priority': u'58'}}, namespace='urn:brocade.com:mgmt:brocade-lacp', defining_module='brocade-lacp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lacp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=lacp.lacp, is_container='container', presence=False, yang_name="lacp", rest_name="lacp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'LACP commands', u'cli-incomplete-no': None, u'callpoint': u'lacp_systempriority', u'sort-priority': u'58'}}, namespace='urn:brocade.com:mgmt:brocade-lacp', defining_module='brocade-lacp', yang_type='container', is_config=True)""",
        })

    self.__lacp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lacp(self):
    self.__lacp = YANGDynClass(base=lacp.lacp, is_container='container', presence=False, yang_name="lacp", rest_name="lacp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'LACP commands', u'cli-incomplete-no': None, u'callpoint': u'lacp_systempriority', u'sort-priority': u'58'}}, namespace='urn:brocade.com:mgmt:brocade-lacp', defining_module='brocade-lacp', yang_type='container', is_config=True)

  lacp = __builtin__.property(_get_lacp, _set_lacp)


  _pyangbind_elements = {'lacp': lacp, }


class brocade_ag(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ag - based on the path /brocade-ag. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage AG 
feature.
  """
  _pyangbind_elements = {}

  

import fabric
class brocade_fabric_service(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-fabric-service - based on the path /brocade-fabric-service. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module gives Virtual Cluster Switching (VCS)
FABRIC related information. VCS refers to the ability of
a group of physical Ethernet switches, inter-connected
in arbitrary fashion via the regular front-end
data ports, to present themselves as one unified and
transparent Ethernet switching service to the external network.
The inter-connecting network that glues all these individual
switches is refered as 'fabric', and the group of physical
Ethernet switches in the fabric is refered to as 'cluster'.

Glossary of the terms used:
---------------------------
RBridge     - A Routing Bridge or RBridge is a network device
              that implements the TRILL protocol, as defined
              by the IETF.

RBridge-ID  - RBridge-ID is the unique identifier of a node
              in the fabric. It can take values from 1 - 239.

ISL         - A inter switch link (ISL) is the link directly
              connecting a fabric port of one switch to fabric
              port of another switch. For an ISL to come up
              both side of the link need to have
              compatible configurations.

Trunk       - Brocade trunk is a hardware based LAG (link
              aggregation group) that is formed dynamically.
              It is a technology that allows to combine up to
              8 ISLs into a single logical trunk that provides
              up to 80 Gigabits per second (Gbps) data
              transfers.
              Trunking uses a simple algorithm to optimally
              distribute frames across a set of available paths
              that link two adjacent switches. Such a set of
              links is called trunking group.
              In a trunk group one of the trunk ports is
              used to set up all routing paths for the entire
              trunk group. This port is called the 'trunk
              master'.

WWN         - World Wide Name (WWN) is a unique 64 bit
              identifier that is assigned to a manufacturer
              by the Institute of Electrical and Electronic
              Engineers(IEEE) and hard-coded into a Fibre
              Channel (FC) device.

Principle   - In a fabric one switch is elected to manage
Switch        RBridge-ID assignments within the fabric.
              This switch is called the Principal Switch.
              Each fabric has its own Principal Switch. If the
              fabric configuration changes, a different switch
              could become principal.
              Note: In case of a single switch fabric, the same
              switch acts as the Principal Switch.

ECMP        - Equal cost multiple path (ECMP) is a routing
              strategy where next-hop packet forwarding to a
              single destination can occur over multiple
              'best paths' which tie for top place in routing
              metric calculations.

BUM         - Broadcast, Unknown Unicast & Multicast (BUM)
              traffic.

FSPF        - Fabric Shortest Path First (FSPF) is a routing
              protocol used in Fibre Channel networks.
              It calculates the best path between switches,
              establishes routes across the fabric and
              calculates alternate routes in event of a
              failure or topology change. FSPF guarantees
              in-order delivery of frames, even if the
              routing topology has changed during a failure,
              by enforcing a 'hold down' time before a new
              path is activated.

Port ID(PID)- The Fibre Channel address ID in DDAAPP
              hexadecimal format.

VID         - VLAN identifier (VID).

PISL        - Physical inter switch link (PISL).

Note:
The terms node and switch have been used interchangeably
in this document. Both refer to the same.

  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__fabric',)

  _yang_name = 'brocade-fabric-service'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__fabric = YANGDynClass(base=fabric.fabric, is_container='container', presence=False, yang_name="fabric", rest_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Allows to configure fabric related parameters', u'display-when': u'/vcsmode/vcs-mode = "true"', u'sort-priority': u'51', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fabric-service', defining_module='brocade-fabric-service', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_fabric(self):
    """
    Getter method for fabric, mapped from YANG variable /fabric (container)

    YANG Description: This function is used to configure fabric
parameters such as multicast priority.
    """
    return self.__fabric
      
  def _set_fabric(self, v, load=False):
    """
    Setter method for fabric, mapped from YANG variable /fabric (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fabric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fabric() directly.

    YANG Description: This function is used to configure fabric
parameters such as multicast priority.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=fabric.fabric, is_container='container', presence=False, yang_name="fabric", rest_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Allows to configure fabric related parameters', u'display-when': u'/vcsmode/vcs-mode = "true"', u'sort-priority': u'51', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fabric-service', defining_module='brocade-fabric-service', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fabric must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=fabric.fabric, is_container='container', presence=False, yang_name="fabric", rest_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Allows to configure fabric related parameters', u'display-when': u'/vcsmode/vcs-mode = "true"', u'sort-priority': u'51', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fabric-service', defining_module='brocade-fabric-service', yang_type='container', is_config=True)""",
        })

    self.__fabric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fabric(self):
    self.__fabric = YANGDynClass(base=fabric.fabric, is_container='container', presence=False, yang_name="fabric", rest_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Allows to configure fabric related parameters', u'display-when': u'/vcsmode/vcs-mode = "true"', u'sort-priority': u'51', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fabric-service', defining_module='brocade-fabric-service', yang_type='container', is_config=True)

  fabric = __builtin__.property(_get_fabric, _set_fabric)


  _pyangbind_elements = {'fabric': fabric, }


class brocade_tunnels_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-tunnels-ext - based on the path /brocade-tunnels-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage the IP
tunnels. It is a extension of brocade-tunnels module.

Glossary of the terms used:
---------------------------
VXLAN       Virtual eXtensible Local Area Network (RFC 7348)
VXLAN Gateway
           Software module in Brocade VCS switch which forwards
           traffic between VXLAN and non-VXLAN environments.
NSX         NSX is a network virtualization platform solution
           by Vmware. Refer - www.vmware.com/in/products/nsx
NSX Controller
           NSX Controller is the cluster of x86 systems which
           manage the virtual networks.
TCP         Transmission Control Protocol (RFC 793)
SSL         Secure Sockets Layer Protocol (RFC 6101)
BFD         Bidirectional Forwarding Detection (RFC 5880)
BGP-EVPN    Border Gateway Protocol, Ethernet VPN (RFC 7432)


  """
  _pyangbind_elements = {}

  

class brocade_dot1ag(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-dot1ag - based on the path /brocade-dot1ag. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage
CFM Protocol.
  """
  _pyangbind_elements = {}

  

class brocade_maps_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-maps-ext - based on the path /brocade-maps-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub module defines show system-monitor data model
Copyright (c) 2011 by Brocade Communications Systems, Inc.
All rights reserved.
  """
  _pyangbind_elements = {}

  

class brocade_lif(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-lif - based on the path /brocade-lif. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
This module defines configuration commands related for creating logical interfaces for
physical and port channel interfaces.

Configuration examples:
interface e 1/1.1
interface e 2/2.23
interface port-channel 2.1
interface port-channel 2.23

  """
  _pyangbind_elements = {}

  

class brocade_distributedlog(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-distributedlog - based on the path /brocade-distributedlog. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Vcs log related information
  """
  _pyangbind_elements = {}

  

import arp_entry
class brocade_arp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-arp - based on the path /brocade-arp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage
ARPD Daemon
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__arp_entry',)

  _yang_name = 'brocade-arp'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__arp_entry = YANGDynClass(base=YANGListType("arp_ip_address",arp_entry.arp_entry, yang_name="arp-entry", rest_name="arp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='arp-ip-address', extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}), is_container='list', yang_name="arp-entry", rest_name="arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_arp_entry(self):
    """
    Getter method for arp_entry, mapped from YANG variable /arp_entry (list)
    """
    return self.__arp_entry
      
  def _set_arp_entry(self, v, load=False):
    """
    Setter method for arp_entry, mapped from YANG variable /arp_entry (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_arp_entry is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_arp_entry() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("arp_ip_address",arp_entry.arp_entry, yang_name="arp-entry", rest_name="arp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='arp-ip-address', extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}), is_container='list', yang_name="arp-entry", rest_name="arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """arp_entry must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("arp_ip_address",arp_entry.arp_entry, yang_name="arp-entry", rest_name="arp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='arp-ip-address', extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}), is_container='list', yang_name="arp-entry", rest_name="arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='list', is_config=True)""",
        })

    self.__arp_entry = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_arp_entry(self):
    self.__arp_entry = YANGDynClass(base=YANGListType("arp_ip_address",arp_entry.arp_entry, yang_name="arp-entry", rest_name="arp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='arp-ip-address', extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}), is_container='list', yang_name="arp-entry", rest_name="arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Address Resolution Protocol (ARP)', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'alt-name': u'arp', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'ArpStaticConfigCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='list', is_config=True)

  arp_entry = __builtin__.property(_get_arp_entry, _set_arp_entry)


  _pyangbind_elements = {'arp_entry': arp_entry, }


import show
import clear
import no
import ip
import ipv6
import router
import routing_system
class brocade_common_def(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-common-def - based on the path /brocade-common-def. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module contains collection of most commonly 
used derived YANG data types within the 'Broacde' name-space.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__show','__clear','__no','__ip','__ipv6','__router','__routing_system',)

  _yang_name = 'brocade-common-def'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__no = YANGDynClass(base=no.no, is_container='container', presence=False, yang_name="no", rest_name="no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    self.__ip = YANGDynClass(base=ip.ip, is_container='container', presence=False, yang_name="ip", rest_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IP).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L3_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    self.__clear = YANGDynClass(base=clear.clear, is_container='container', presence=False, yang_name="clear", rest_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    self.__show = YANGDynClass(base=show.show, is_container='container', presence=False, yang_name="show", rest_name="show", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    self.__ipv6 = YANGDynClass(base=ipv6.ipv6, is_container='container', presence=False, yang_name="ipv6", rest_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IPv6).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_IPV6_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    self.__routing_system = YANGDynClass(base=routing_system.routing_system, is_container='container', presence=False, yang_name="routing-system", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE'}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    self.__router = YANGDynClass(base=router.router, is_container='container', presence=False, yang_name="router", rest_name="router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Router', u'cli-incomplete-no': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_show(self):
    """
    Getter method for show, mapped from YANG variable /show (container)
    """
    return self.__show
      
  def _set_show(self, v, load=False):
    """
    Setter method for show, mapped from YANG variable /show (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_show is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_show() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=show.show, is_container='container', presence=False, yang_name="show", rest_name="show", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """show must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=show.show, is_container='container', presence=False, yang_name="show", rest_name="show", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)""",
        })

    self.__show = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_show(self):
    self.__show = YANGDynClass(base=show.show, is_container='container', presence=False, yang_name="show", rest_name="show", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)


  def _get_clear(self):
    """
    Getter method for clear, mapped from YANG variable /clear (container)
    """
    return self.__clear
      
  def _set_clear(self, v, load=False):
    """
    Setter method for clear, mapped from YANG variable /clear (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=clear.clear, is_container='container', presence=False, yang_name="clear", rest_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=clear.clear, is_container='container', presence=False, yang_name="clear", rest_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)""",
        })

    self.__clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear(self):
    self.__clear = YANGDynClass(base=clear.clear, is_container='container', presence=False, yang_name="clear", rest_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)


  def _get_no(self):
    """
    Getter method for no, mapped from YANG variable /no (container)
    """
    return self.__no
      
  def _set_no(self, v, load=False):
    """
    Setter method for no, mapped from YANG variable /no (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=no.no, is_container='container', presence=False, yang_name="no", rest_name="no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=no.no, is_container='container', presence=False, yang_name="no", rest_name="no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)""",
        })

    self.__no = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no(self):
    self.__no = YANGDynClass(base=no.no, is_container='container', presence=False, yang_name="no", rest_name="no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)


  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /ip (container)
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /ip (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ip.ip, is_container='container', presence=False, yang_name="ip", rest_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IP).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L3_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ip.ip, is_container='container', presence=False, yang_name="ip", rest_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IP).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L3_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=ip.ip, is_container='container', presence=False, yang_name="ip", rest_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IP).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L3_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)


  def _get_ipv6(self):
    """
    Getter method for ipv6, mapped from YANG variable /ipv6 (container)
    """
    return self.__ipv6
      
  def _set_ipv6(self, v, load=False):
    """
    Setter method for ipv6, mapped from YANG variable /ipv6 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ipv6.ipv6, is_container='container', presence=False, yang_name="ipv6", rest_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IPv6).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_IPV6_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ipv6.ipv6, is_container='container', presence=False, yang_name="ipv6", rest_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IPv6).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_IPV6_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)""",
        })

    self.__ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6(self):
    self.__ipv6 = YANGDynClass(base=ipv6.ipv6, is_container='container', presence=False, yang_name="ipv6", rest_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IPv6).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_IPV6_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)


  def _get_router(self):
    """
    Getter method for router, mapped from YANG variable /router (container)

    YANG Description: The routing system.
    """
    return self.__router
      
  def _set_router(self, v, load=False):
    """
    Setter method for router, mapped from YANG variable /router (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router() directly.

    YANG Description: The routing system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=router.router, is_container='container', presence=False, yang_name="router", rest_name="router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Router', u'cli-incomplete-no': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=router.router, is_container='container', presence=False, yang_name="router", rest_name="router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Router', u'cli-incomplete-no': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)""",
        })

    self.__router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router(self):
    self.__router = YANGDynClass(base=router.router, is_container='container', presence=False, yang_name="router", rest_name="router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Router', u'cli-incomplete-no': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)


  def _get_routing_system(self):
    """
    Getter method for routing_system, mapped from YANG variable /routing_system (container)
    """
    return self.__routing_system
      
  def _set_routing_system(self, v, load=False):
    """
    Setter method for routing_system, mapped from YANG variable /routing_system (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_system() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=routing_system.routing_system, is_container='container', presence=False, yang_name="routing-system", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE'}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_system must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=routing_system.routing_system, is_container='container', presence=False, yang_name="routing-system", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE'}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)""",
        })

    self.__routing_system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_system(self):
    self.__routing_system = YANGDynClass(base=routing_system.routing_system, is_container='container', presence=False, yang_name="routing-system", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE'}}, namespace='urn:brocade.com:mgmt:brocade-common-def', defining_module='brocade-common-def', yang_type='container', is_config=True)

  show = __builtin__.property(_get_show, _set_show)
  clear = __builtin__.property(_get_clear, _set_clear)
  no = __builtin__.property(_get_no, _set_no)
  ip = __builtin__.property(_get_ip, _set_ip)
  ipv6 = __builtin__.property(_get_ipv6, _set_ipv6)
  router = __builtin__.property(_get_router, _set_router)
  routing_system = __builtin__.property(_get_routing_system, _set_routing_system)


  _pyangbind_elements = {'show': show, 'clear': clear, 'no': no, 'ip': ip, 'ipv6': ipv6, 'router': router, 'routing_system': routing_system, }


import link_fault_signaling
class brocade_lfs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-lfs - based on the path /brocade-lfs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages link fault signal (LFS)
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__link_fault_signaling',)

  _yang_name = 'brocade-lfs'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__link_fault_signaling = YANGDynClass(base=link_fault_signaling.link_fault_signaling, is_container='container', presence=False, yang_name="link-fault-signaling", rest_name="link-fault-signaling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure a link-fault-signaling', u'cli-full-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'Lfs_global'}}, namespace='urn:brocade.com:mgmt:brocade-lfs', defining_module='brocade-lfs', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_link_fault_signaling(self):
    """
    Getter method for link_fault_signaling, mapped from YANG variable /link_fault_signaling (container)
    """
    return self.__link_fault_signaling
      
  def _set_link_fault_signaling(self, v, load=False):
    """
    Setter method for link_fault_signaling, mapped from YANG variable /link_fault_signaling (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_fault_signaling is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_fault_signaling() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=link_fault_signaling.link_fault_signaling, is_container='container', presence=False, yang_name="link-fault-signaling", rest_name="link-fault-signaling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure a link-fault-signaling', u'cli-full-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'Lfs_global'}}, namespace='urn:brocade.com:mgmt:brocade-lfs', defining_module='brocade-lfs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_fault_signaling must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=link_fault_signaling.link_fault_signaling, is_container='container', presence=False, yang_name="link-fault-signaling", rest_name="link-fault-signaling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure a link-fault-signaling', u'cli-full-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'Lfs_global'}}, namespace='urn:brocade.com:mgmt:brocade-lfs', defining_module='brocade-lfs', yang_type='container', is_config=True)""",
        })

    self.__link_fault_signaling = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_fault_signaling(self):
    self.__link_fault_signaling = YANGDynClass(base=link_fault_signaling.link_fault_signaling, is_container='container', presence=False, yang_name="link-fault-signaling", rest_name="link-fault-signaling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure a link-fault-signaling', u'cli-full-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'callpoint': u'Lfs_global'}}, namespace='urn:brocade.com:mgmt:brocade-lfs', defining_module='brocade-lfs', yang_type='container', is_config=True)

  link_fault_signaling = __builtin__.property(_get_link_fault_signaling, _set_link_fault_signaling)


  _pyangbind_elements = {'link_fault_signaling': link_fault_signaling, }


class brocade_auto_shut_edge_port(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-auto-shut-edge-port - based on the path /brocade-auto-shut-edge-port. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides interface to provision auto-shut on edge ports
  """
  _pyangbind_elements = {}

  

import vc_peer_state
import bd_vc_peer_state
class brocade_pwm_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-pwm-operational - based on the path /brocade-pwm-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage pwm
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__vc_peer_state','__bd_vc_peer_state',)

  _yang_name = 'brocade-pwm-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__bd_vc_peer_state = YANGDynClass(base=YANGListType("vc_id",bd_vc_peer_state.bd_vc_peer_state, yang_name="bd-vc-peer-state", rest_name="bd-vc-peer-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vc-id', extensions={u'tailf-common': {u'callpoint': u'pwm-bd-vc-peer', u'cli-suppress-show-path': None}}), is_container='list', yang_name="bd-vc-peer-state", rest_name="bd-vc-peer-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pwm-bd-vc-peer', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pwm-operational', defining_module='brocade-pwm-operational', yang_type='list', is_config=True)
    self.__vc_peer_state = YANGDynClass(base=vc_peer_state.vc_peer_state, is_container='container', presence=False, yang_name="vc-peer-state", rest_name="vc-peer-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pwm-vc-peer', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pwm-operational', defining_module='brocade-pwm-operational', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_vc_peer_state(self):
    """
    Getter method for vc_peer_state, mapped from YANG variable /vc_peer_state (container)

    YANG Description:  VC peer information
    """
    return self.__vc_peer_state
      
  def _set_vc_peer_state(self, v, load=False):
    """
    Setter method for vc_peer_state, mapped from YANG variable /vc_peer_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vc_peer_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vc_peer_state() directly.

    YANG Description:  VC peer information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=vc_peer_state.vc_peer_state, is_container='container', presence=False, yang_name="vc-peer-state", rest_name="vc-peer-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pwm-vc-peer', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pwm-operational', defining_module='brocade-pwm-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vc_peer_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vc_peer_state.vc_peer_state, is_container='container', presence=False, yang_name="vc-peer-state", rest_name="vc-peer-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pwm-vc-peer', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pwm-operational', defining_module='brocade-pwm-operational', yang_type='container', is_config=True)""",
        })

    self.__vc_peer_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vc_peer_state(self):
    self.__vc_peer_state = YANGDynClass(base=vc_peer_state.vc_peer_state, is_container='container', presence=False, yang_name="vc-peer-state", rest_name="vc-peer-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pwm-vc-peer', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pwm-operational', defining_module='brocade-pwm-operational', yang_type='container', is_config=True)


  def _get_bd_vc_peer_state(self):
    """
    Getter method for bd_vc_peer_state, mapped from YANG variable /bd_vc_peer_state (list)

    YANG Description:  VC peer information
    """
    return self.__bd_vc_peer_state
      
  def _set_bd_vc_peer_state(self, v, load=False):
    """
    Setter method for bd_vc_peer_state, mapped from YANG variable /bd_vc_peer_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bd_vc_peer_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bd_vc_peer_state() directly.

    YANG Description:  VC peer information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vc_id",bd_vc_peer_state.bd_vc_peer_state, yang_name="bd-vc-peer-state", rest_name="bd-vc-peer-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vc-id', extensions={u'tailf-common': {u'callpoint': u'pwm-bd-vc-peer', u'cli-suppress-show-path': None}}), is_container='list', yang_name="bd-vc-peer-state", rest_name="bd-vc-peer-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pwm-bd-vc-peer', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pwm-operational', defining_module='brocade-pwm-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bd_vc_peer_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vc_id",bd_vc_peer_state.bd_vc_peer_state, yang_name="bd-vc-peer-state", rest_name="bd-vc-peer-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vc-id', extensions={u'tailf-common': {u'callpoint': u'pwm-bd-vc-peer', u'cli-suppress-show-path': None}}), is_container='list', yang_name="bd-vc-peer-state", rest_name="bd-vc-peer-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pwm-bd-vc-peer', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pwm-operational', defining_module='brocade-pwm-operational', yang_type='list', is_config=True)""",
        })

    self.__bd_vc_peer_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bd_vc_peer_state(self):
    self.__bd_vc_peer_state = YANGDynClass(base=YANGListType("vc_id",bd_vc_peer_state.bd_vc_peer_state, yang_name="bd-vc-peer-state", rest_name="bd-vc-peer-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vc-id', extensions={u'tailf-common': {u'callpoint': u'pwm-bd-vc-peer', u'cli-suppress-show-path': None}}), is_container='list', yang_name="bd-vc-peer-state", rest_name="bd-vc-peer-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pwm-bd-vc-peer', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pwm-operational', defining_module='brocade-pwm-operational', yang_type='list', is_config=True)

  vc_peer_state = __builtin__.property(_get_vc_peer_state, _set_vc_peer_state)
  bd_vc_peer_state = __builtin__.property(_get_bd_vc_peer_state, _set_bd_vc_peer_state)


  _pyangbind_elements = {'vc_peer_state': vc_peer_state, 'bd_vc_peer_state': bd_vc_peer_state, }


import dot1x
class brocade_dot1x(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-dot1x - based on the path /brocade-dot1x. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage dot1x 
feature. 
        
IEEE 802.1X is an IEEE Standard for port-based Network Access 
Control(PNAC). It is a networking protocol which provides an 
authentication mechanism to devices wishing to attach to a
LAN or WLAN.IEEE 802.1X defines the encapsulation of the 
Extensible Authentication Protocol (EAP) over IEEE 802
which is known as EAP over LAN or EAPoL.
802.1x involves 3 parties
    Supplicant - Device which connects to network
    Authenticator - Network device such as ethernet switch
    Authentication server - A host running software that
                            supports Radius and EAP Protocols
This module defines the parameters used for the Port based 
Network access control. Here authentication server is termed
as dot1x server.

Glossary of the terms used:
---------------------------
EAPoL- Extensible Authentication Protocol over LAN

  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__dot1x',)

  _yang_name = 'brocade-dot1x'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__dot1x = YANGDynClass(base=dot1x.dot1x, is_container='container', presence=False, yang_name="dot1x", rest_name="dot1x", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'IEEE 802.1X Port-Based Access Control', u'cli-incomplete-no': None, u'callpoint': u'lacp_systempriority', u'sort-priority': u'59'}}, namespace='urn:brocade.com:mgmt:brocade-dot1x', defining_module='brocade-dot1x', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_dot1x(self):
    """
    Getter method for dot1x, mapped from YANG variable /dot1x (container)

    YANG Description: This provides grouping of all the dot1x configuration
elements.
    """
    return self.__dot1x
      
  def _set_dot1x(self, v, load=False):
    """
    Setter method for dot1x, mapped from YANG variable /dot1x (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot1x is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot1x() directly.

    YANG Description: This provides grouping of all the dot1x configuration
elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=dot1x.dot1x, is_container='container', presence=False, yang_name="dot1x", rest_name="dot1x", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'IEEE 802.1X Port-Based Access Control', u'cli-incomplete-no': None, u'callpoint': u'lacp_systempriority', u'sort-priority': u'59'}}, namespace='urn:brocade.com:mgmt:brocade-dot1x', defining_module='brocade-dot1x', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot1x must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dot1x.dot1x, is_container='container', presence=False, yang_name="dot1x", rest_name="dot1x", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'IEEE 802.1X Port-Based Access Control', u'cli-incomplete-no': None, u'callpoint': u'lacp_systempriority', u'sort-priority': u'59'}}, namespace='urn:brocade.com:mgmt:brocade-dot1x', defining_module='brocade-dot1x', yang_type='container', is_config=True)""",
        })

    self.__dot1x = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot1x(self):
    self.__dot1x = YANGDynClass(base=dot1x.dot1x, is_container='container', presence=False, yang_name="dot1x", rest_name="dot1x", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'IEEE 802.1X Port-Based Access Control', u'cli-incomplete-no': None, u'callpoint': u'lacp_systempriority', u'sort-priority': u'59'}}, namespace='urn:brocade.com:mgmt:brocade-dot1x', defining_module='brocade-dot1x', yang_type='container', is_config=True)

  dot1x = __builtin__.property(_get_dot1x, _set_dot1x)


  _pyangbind_elements = {'dot1x': dot1x, }


class brocade_dhcp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-dhcp - based on the path /brocade-dhcp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage 
DHCP functionality.
  """
  _pyangbind_elements = {}

  

import openflow_state
import queues_state
class brocade_openflow_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-openflow-operational - based on the path /brocade-openflow-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage openflow
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__openflow_state','__queues_state',)

  _yang_name = 'brocade-openflow-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__queues_state = YANGDynClass(base=queues_state.queues_state, is_container='container', presence=False, yang_name="queues-state", rest_name="queues-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-queues', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=True)
    self.__openflow_state = YANGDynClass(base=openflow_state.openflow_state, is_container='container', presence=False, yang_name="openflow-state", rest_name="openflow-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-openflow', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_openflow_state(self):
    """
    Getter method for openflow_state, mapped from YANG variable /openflow_state (container)

    YANG Description: OPENFLOW Operational Information
    """
    return self.__openflow_state
      
  def _set_openflow_state(self, v, load=False):
    """
    Setter method for openflow_state, mapped from YANG variable /openflow_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_openflow_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_openflow_state() directly.

    YANG Description: OPENFLOW Operational Information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=openflow_state.openflow_state, is_container='container', presence=False, yang_name="openflow-state", rest_name="openflow-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-openflow', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """openflow_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=openflow_state.openflow_state, is_container='container', presence=False, yang_name="openflow-state", rest_name="openflow-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-openflow', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=True)""",
        })

    self.__openflow_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_openflow_state(self):
    self.__openflow_state = YANGDynClass(base=openflow_state.openflow_state, is_container='container', presence=False, yang_name="openflow-state", rest_name="openflow-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-openflow', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=True)


  def _get_queues_state(self):
    """
    Getter method for queues_state, mapped from YANG variable /queues_state (container)

    YANG Description: Queues
    """
    return self.__queues_state
      
  def _set_queues_state(self, v, load=False):
    """
    Setter method for queues_state, mapped from YANG variable /queues_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_queues_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_queues_state() directly.

    YANG Description: Queues
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=queues_state.queues_state, is_container='container', presence=False, yang_name="queues-state", rest_name="queues-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-queues', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """queues_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=queues_state.queues_state, is_container='container', presence=False, yang_name="queues-state", rest_name="queues-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-queues', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=True)""",
        })

    self.__queues_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_queues_state(self):
    self.__queues_state = YANGDynClass(base=queues_state.queues_state, is_container='container', presence=False, yang_name="queues-state", rest_name="queues-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-queues', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=True)

  openflow_state = __builtin__.property(_get_openflow_state, _set_openflow_state)
  queues_state = __builtin__.property(_get_queues_state, _set_queues_state)


  _pyangbind_elements = {'openflow_state': openflow_state, 'queues_state': queues_state, }


import beacon
class brocade_beacon(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-beacon - based on the path /brocade-beacon. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__beacon',)

  _yang_name = 'brocade-beacon'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__beacon = YANGDynClass(base=beacon.beacon, is_container='container', presence=False, yang_name="beacon", rest_name="beacon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable/Disable beacon'}}, namespace='urn:brocade.com:mgmt:brocade-beacon', defining_module='brocade-beacon', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_beacon(self):
    """
    Getter method for beacon, mapped from YANG variable /beacon (container)
    """
    return self.__beacon
      
  def _set_beacon(self, v, load=False):
    """
    Setter method for beacon, mapped from YANG variable /beacon (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_beacon is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_beacon() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=beacon.beacon, is_container='container', presence=False, yang_name="beacon", rest_name="beacon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable/Disable beacon'}}, namespace='urn:brocade.com:mgmt:brocade-beacon', defining_module='brocade-beacon', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """beacon must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=beacon.beacon, is_container='container', presence=False, yang_name="beacon", rest_name="beacon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable/Disable beacon'}}, namespace='urn:brocade.com:mgmt:brocade-beacon', defining_module='brocade-beacon', yang_type='container', is_config=True)""",
        })

    self.__beacon = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_beacon(self):
    self.__beacon = YANGDynClass(base=beacon.beacon, is_container='container', presence=False, yang_name="beacon", rest_name="beacon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable/Disable beacon'}}, namespace='urn:brocade.com:mgmt:brocade-beacon', defining_module='brocade-beacon', yang_type='container', is_config=True)

  beacon = __builtin__.property(_get_beacon, _set_beacon)


  _pyangbind_elements = {'beacon': beacon, }


class brocade_qos_cpu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-qos-cpu - based on the path /brocade-qos-cpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages CPU Quality Of Service (QOS)
  """
  _pyangbind_elements = {}

  

class brocade_dhcpv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-dhcpv6 - based on the path /brocade-dhcpv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage 
DHCPv6 functionality.
  """
  _pyangbind_elements = {}

  

import mctd_client_state_state
import show_client_id_df_info_state
import show_cluster_mem_bd_mct_state
class brocade_mct_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mct-operational - based on the path /brocade-mct-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage mct
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__mctd_client_state_state','__show_client_id_df_info_state','__show_cluster_mem_bd_mct_state',)

  _yang_name = 'brocade-mct-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__show_client_id_df_info_state = YANGDynClass(base=YANGListType("cluster_id client_id",show_client_id_df_info_state.show_client_id_df_info_state, yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='list', is_config=True)
    self.__mctd_client_state_state = YANGDynClass(base=mctd_client_state_state.mctd_client_state_state, is_container='container', presence=False, yang_name="mctd-client-state-state", rest_name="mctd-client-state-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-mctd-client-state', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='container', is_config=True)
    self.__show_cluster_mem_bd_mct_state = YANGDynClass(base=YANGListType("cluster_id",show_cluster_mem_bd_mct_state.show_cluster_mem_bd_mct_state, yang_name="show-cluster-mem-bd-mct-state", rest_name="show-cluster-mem-bd-mct-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id', extensions={u'tailf-common': {u'callpoint': u'mct-show-cluster-mem-bd-mct', u'cli-suppress-show-path': None}}), is_container='list', yang_name="show-cluster-mem-bd-mct-state", rest_name="show-cluster-mem-bd-mct-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-show-cluster-mem-bd-mct', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_mctd_client_state_state(self):
    """
    Getter method for mctd_client_state_state, mapped from YANG variable /mctd_client_state_state (container)

    YANG Description: MCT Client Operational Information
    """
    return self.__mctd_client_state_state
      
  def _set_mctd_client_state_state(self, v, load=False):
    """
    Setter method for mctd_client_state_state, mapped from YANG variable /mctd_client_state_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mctd_client_state_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mctd_client_state_state() directly.

    YANG Description: MCT Client Operational Information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mctd_client_state_state.mctd_client_state_state, is_container='container', presence=False, yang_name="mctd-client-state-state", rest_name="mctd-client-state-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-mctd-client-state', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mctd_client_state_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mctd_client_state_state.mctd_client_state_state, is_container='container', presence=False, yang_name="mctd-client-state-state", rest_name="mctd-client-state-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-mctd-client-state', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='container', is_config=True)""",
        })

    self.__mctd_client_state_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mctd_client_state_state(self):
    self.__mctd_client_state_state = YANGDynClass(base=mctd_client_state_state.mctd_client_state_state, is_container='container', presence=False, yang_name="mctd-client-state-state", rest_name="mctd-client-state-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-mctd-client-state', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='container', is_config=True)


  def _get_show_client_id_df_info_state(self):
    """
    Getter method for show_client_id_df_info_state, mapped from YANG variable /show_client_id_df_info_state (list)

    YANG Description: VLANs elected as designated forwarder
    """
    return self.__show_client_id_df_info_state
      
  def _set_show_client_id_df_info_state(self, v, load=False):
    """
    Setter method for show_client_id_df_info_state, mapped from YANG variable /show_client_id_df_info_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_show_client_id_df_info_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_show_client_id_df_info_state() directly.

    YANG Description: VLANs elected as designated forwarder
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("cluster_id client_id",show_client_id_df_info_state.show_client_id_df_info_state, yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """show_client_id_df_info_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("cluster_id client_id",show_client_id_df_info_state.show_client_id_df_info_state, yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='list', is_config=True)""",
        })

    self.__show_client_id_df_info_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_show_client_id_df_info_state(self):
    self.__show_client_id_df_info_state = YANGDynClass(base=YANGListType("cluster_id client_id",show_client_id_df_info_state.show_client_id_df_info_state, yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="show-client-id-df-info-state", rest_name="show-client-id-df-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-show-client-id-df-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='list', is_config=True)


  def _get_show_cluster_mem_bd_mct_state(self):
    """
    Getter method for show_cluster_mem_bd_mct_state, mapped from YANG variable /show_cluster_mem_bd_mct_state (list)

    YANG Description: Vlan Label Info for show cluster member BD
    """
    return self.__show_cluster_mem_bd_mct_state
      
  def _set_show_cluster_mem_bd_mct_state(self, v, load=False):
    """
    Setter method for show_cluster_mem_bd_mct_state, mapped from YANG variable /show_cluster_mem_bd_mct_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_show_cluster_mem_bd_mct_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_show_cluster_mem_bd_mct_state() directly.

    YANG Description: Vlan Label Info for show cluster member BD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("cluster_id",show_cluster_mem_bd_mct_state.show_cluster_mem_bd_mct_state, yang_name="show-cluster-mem-bd-mct-state", rest_name="show-cluster-mem-bd-mct-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id', extensions={u'tailf-common': {u'callpoint': u'mct-show-cluster-mem-bd-mct', u'cli-suppress-show-path': None}}), is_container='list', yang_name="show-cluster-mem-bd-mct-state", rest_name="show-cluster-mem-bd-mct-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-show-cluster-mem-bd-mct', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """show_cluster_mem_bd_mct_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("cluster_id",show_cluster_mem_bd_mct_state.show_cluster_mem_bd_mct_state, yang_name="show-cluster-mem-bd-mct-state", rest_name="show-cluster-mem-bd-mct-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id', extensions={u'tailf-common': {u'callpoint': u'mct-show-cluster-mem-bd-mct', u'cli-suppress-show-path': None}}), is_container='list', yang_name="show-cluster-mem-bd-mct-state", rest_name="show-cluster-mem-bd-mct-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-show-cluster-mem-bd-mct', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='list', is_config=True)""",
        })

    self.__show_cluster_mem_bd_mct_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_show_cluster_mem_bd_mct_state(self):
    self.__show_cluster_mem_bd_mct_state = YANGDynClass(base=YANGListType("cluster_id",show_cluster_mem_bd_mct_state.show_cluster_mem_bd_mct_state, yang_name="show-cluster-mem-bd-mct-state", rest_name="show-cluster-mem-bd-mct-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id', extensions={u'tailf-common': {u'callpoint': u'mct-show-cluster-mem-bd-mct', u'cli-suppress-show-path': None}}), is_container='list', yang_name="show-cluster-mem-bd-mct-state", rest_name="show-cluster-mem-bd-mct-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mct-show-cluster-mem-bd-mct', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mct-operational', defining_module='brocade-mct-operational', yang_type='list', is_config=True)

  mctd_client_state_state = __builtin__.property(_get_mctd_client_state_state, _set_mctd_client_state_state)
  show_client_id_df_info_state = __builtin__.property(_get_show_client_id_df_info_state, _set_show_client_id_df_info_state)
  show_cluster_mem_bd_mct_state = __builtin__.property(_get_show_cluster_mem_bd_mct_state, _set_show_cluster_mem_bd_mct_state)


  _pyangbind_elements = {'mctd_client_state_state': mctd_client_state_state, 'show_client_id_df_info_state': show_client_id_df_info_state, 'show_cluster_mem_bd_mct_state': show_cluster_mem_bd_mct_state, }


import rmon
class brocade_rmon(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-rmon - based on the path /brocade-rmon. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__rmon',)

  _yang_name = 'brocade-rmon'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__rmon = YANGDynClass(base=rmon.rmon, is_container='container', presence=False, yang_name="rmon", rest_name="rmon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Remote Monitoring Protocol (RMON)', u'cli-incomplete-no': None, u'sort-priority': u'88'}}, namespace='urn:brocade.com:mgmt:brocade-rmon', defining_module='brocade-rmon', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_rmon(self):
    """
    Getter method for rmon, mapped from YANG variable /rmon (container)
    """
    return self.__rmon
      
  def _set_rmon(self, v, load=False):
    """
    Setter method for rmon, mapped from YANG variable /rmon (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rmon is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rmon() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=rmon.rmon, is_container='container', presence=False, yang_name="rmon", rest_name="rmon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Remote Monitoring Protocol (RMON)', u'cli-incomplete-no': None, u'sort-priority': u'88'}}, namespace='urn:brocade.com:mgmt:brocade-rmon', defining_module='brocade-rmon', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rmon must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=rmon.rmon, is_container='container', presence=False, yang_name="rmon", rest_name="rmon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Remote Monitoring Protocol (RMON)', u'cli-incomplete-no': None, u'sort-priority': u'88'}}, namespace='urn:brocade.com:mgmt:brocade-rmon', defining_module='brocade-rmon', yang_type='container', is_config=True)""",
        })

    self.__rmon = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rmon(self):
    self.__rmon = YANGDynClass(base=rmon.rmon, is_container='container', presence=False, yang_name="rmon", rest_name="rmon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Remote Monitoring Protocol (RMON)', u'cli-incomplete-no': None, u'sort-priority': u'88'}}, namespace='urn:brocade.com:mgmt:brocade-rmon', defining_module='brocade-rmon', yang_type='container', is_config=True)

  rmon = __builtin__.property(_get_rmon, _set_rmon)


  _pyangbind_elements = {'rmon': rmon, }


import sysmon
class brocade_sysmon(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-sysmon - based on the path /brocade-sysmon. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages TM/SFM Error Monitoring
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__sysmon',)

  _yang_name = 'brocade-sysmon'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__sysmon = YANGDynClass(base=sysmon.sysmon, is_container='container', presence=False, yang_name="sysmon", rest_name="sysmon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'System Error Monitoring', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-sysmon', defining_module='brocade-sysmon', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_sysmon(self):
    """
    Getter method for sysmon, mapped from YANG variable /sysmon (container)
    """
    return self.__sysmon
      
  def _set_sysmon(self, v, load=False):
    """
    Setter method for sysmon, mapped from YANG variable /sysmon (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sysmon is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sysmon() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=sysmon.sysmon, is_container='container', presence=False, yang_name="sysmon", rest_name="sysmon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'System Error Monitoring', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-sysmon', defining_module='brocade-sysmon', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sysmon must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=sysmon.sysmon, is_container='container', presence=False, yang_name="sysmon", rest_name="sysmon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'System Error Monitoring', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-sysmon', defining_module='brocade-sysmon', yang_type='container', is_config=True)""",
        })

    self.__sysmon = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sysmon(self):
    self.__sysmon = YANGDynClass(base=sysmon.sysmon, is_container='container', presence=False, yang_name="sysmon", rest_name="sysmon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'System Error Monitoring', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-sysmon', defining_module='brocade-sysmon', yang_type='container', is_config=True)

  sysmon = __builtin__.property(_get_sysmon, _set_sysmon)


  _pyangbind_elements = {'sysmon': sysmon, }


class brocade_ipv6_nd_ra(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ipv6-nd-ra - based on the path /brocade-ipv6-nd-ra. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management sub-module contains the configuration
for Neighbor Discovery and Router Advertisement.
  """
  _pyangbind_elements = {}

  

import crypto_sa
class brocade_crypto(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-crypto - based on the path /brocade-crypto. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Instrument to configure Crypto services for HTTPS Certificate Management
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__crypto_sa',)

  _yang_name = 'brocade-crypto'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__crypto_sa = YANGDynClass(base=crypto_sa.crypto_sa, is_container='container', presence=False, yang_name="crypto-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-crypto', defining_module='brocade-crypto', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_crypto_sa(self):
    """
    Getter method for crypto_sa, mapped from YANG variable /crypto_sa (container)
    """
    return self.__crypto_sa
      
  def _set_crypto_sa(self, v, load=False):
    """
    Setter method for crypto_sa, mapped from YANG variable /crypto_sa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_crypto_sa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_crypto_sa() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=crypto_sa.crypto_sa, is_container='container', presence=False, yang_name="crypto-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-crypto', defining_module='brocade-crypto', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """crypto_sa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=crypto_sa.crypto_sa, is_container='container', presence=False, yang_name="crypto-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-crypto', defining_module='brocade-crypto', yang_type='container', is_config=True)""",
        })

    self.__crypto_sa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_crypto_sa(self):
    self.__crypto_sa = YANGDynClass(base=crypto_sa.crypto_sa, is_container='container', presence=False, yang_name="crypto-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-crypto', defining_module='brocade-crypto', yang_type='container', is_config=True)

  crypto_sa = __builtin__.property(_get_crypto_sa, _set_crypto_sa)


  _pyangbind_elements = {'crypto_sa': crypto_sa, }


class brocade_bfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-bfd - based on the path /brocade-bfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage BFD.
  """
  _pyangbind_elements = {}

  

class brocade_ipv6_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ipv6-config - based on the path /brocade-ipv6-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management sub-module contains the configuration
and rpc implementaion for IP Access-list.
  """
  _pyangbind_elements = {}

  

import vxlan_acl_state
import overlay_transit_state
class brocade_ssm_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ssm-operational - based on the path /brocade-ssm-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage ssm
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__vxlan_acl_state','__overlay_transit_state',)

  _yang_name = 'brocade-ssm-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__vxlan_acl_state = YANGDynClass(base=vxlan_acl_state.vxlan_acl_state, is_container='container', presence=False, yang_name="vxlan-acl-state", rest_name="vxlan-acl-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'ssm-vxlan-acl', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='container', is_config=True)
    self.__overlay_transit_state = YANGDynClass(base=YANGListType("overlay_transit_name",overlay_transit_state.overlay_transit_state, yang_name="overlay-transit-state", rest_name="overlay-transit-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='overlay-transit-name', extensions={u'tailf-common': {u'callpoint': u'ssm-overlay-transit', u'cli-suppress-show-path': None}}), is_container='list', yang_name="overlay-transit-state", rest_name="overlay-transit-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'ssm-overlay-transit', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_vxlan_acl_state(self):
    """
    Getter method for vxlan_acl_state, mapped from YANG variable /vxlan_acl_state (container)

    YANG Description:  Vxlan ACL information
    """
    return self.__vxlan_acl_state
      
  def _set_vxlan_acl_state(self, v, load=False):
    """
    Setter method for vxlan_acl_state, mapped from YANG variable /vxlan_acl_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vxlan_acl_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vxlan_acl_state() directly.

    YANG Description:  Vxlan ACL information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=vxlan_acl_state.vxlan_acl_state, is_container='container', presence=False, yang_name="vxlan-acl-state", rest_name="vxlan-acl-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'ssm-vxlan-acl', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vxlan_acl_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vxlan_acl_state.vxlan_acl_state, is_container='container', presence=False, yang_name="vxlan-acl-state", rest_name="vxlan-acl-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'ssm-vxlan-acl', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='container', is_config=True)""",
        })

    self.__vxlan_acl_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vxlan_acl_state(self):
    self.__vxlan_acl_state = YANGDynClass(base=vxlan_acl_state.vxlan_acl_state, is_container='container', presence=False, yang_name="vxlan-acl-state", rest_name="vxlan-acl-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'ssm-vxlan-acl', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='container', is_config=True)


  def _get_overlay_transit_state(self):
    """
    Getter method for overlay_transit_state, mapped from YANG variable /overlay_transit_state (list)

    YANG Description:  Vxlan Transit information
    """
    return self.__overlay_transit_state
      
  def _set_overlay_transit_state(self, v, load=False):
    """
    Setter method for overlay_transit_state, mapped from YANG variable /overlay_transit_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overlay_transit_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overlay_transit_state() directly.

    YANG Description:  Vxlan Transit information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("overlay_transit_name",overlay_transit_state.overlay_transit_state, yang_name="overlay-transit-state", rest_name="overlay-transit-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='overlay-transit-name', extensions={u'tailf-common': {u'callpoint': u'ssm-overlay-transit', u'cli-suppress-show-path': None}}), is_container='list', yang_name="overlay-transit-state", rest_name="overlay-transit-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'ssm-overlay-transit', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overlay_transit_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("overlay_transit_name",overlay_transit_state.overlay_transit_state, yang_name="overlay-transit-state", rest_name="overlay-transit-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='overlay-transit-name', extensions={u'tailf-common': {u'callpoint': u'ssm-overlay-transit', u'cli-suppress-show-path': None}}), is_container='list', yang_name="overlay-transit-state", rest_name="overlay-transit-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'ssm-overlay-transit', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='list', is_config=True)""",
        })

    self.__overlay_transit_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overlay_transit_state(self):
    self.__overlay_transit_state = YANGDynClass(base=YANGListType("overlay_transit_name",overlay_transit_state.overlay_transit_state, yang_name="overlay-transit-state", rest_name="overlay-transit-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='overlay-transit-name', extensions={u'tailf-common': {u'callpoint': u'ssm-overlay-transit', u'cli-suppress-show-path': None}}), is_container='list', yang_name="overlay-transit-state", rest_name="overlay-transit-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'ssm-overlay-transit', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='list', is_config=True)

  vxlan_acl_state = __builtin__.property(_get_vxlan_acl_state, _set_vxlan_acl_state)
  overlay_transit_state = __builtin__.property(_get_overlay_transit_state, _set_overlay_transit_state)


  _pyangbind_elements = {'vxlan_acl_state': vxlan_acl_state, 'overlay_transit_state': overlay_transit_state, }


class brocade_ipv6_rtm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ipv6-rtm - based on the path /brocade-ipv6-rtm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is for IP Routes.
  """
  _pyangbind_elements = {}

  

import monitor
class brocade_span(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-span - based on the path /brocade-span. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages Port Mirroring (SPAN)
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__monitor',)

  _yang_name = 'brocade-span'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__monitor = YANGDynClass(base=monitor.monitor, is_container='container', presence=False, yang_name="monitor", rest_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Entering span sessions', u'cli-incomplete-no': None, u'callpoint': u'Span', u'sort-priority': u'RUNNCFG_LEVEL_SPAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-span', defining_module='brocade-span', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_monitor(self):
    """
    Getter method for monitor, mapped from YANG variable /monitor (container)
    """
    return self.__monitor
      
  def _set_monitor(self, v, load=False):
    """
    Setter method for monitor, mapped from YANG variable /monitor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitor() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=monitor.monitor, is_container='container', presence=False, yang_name="monitor", rest_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Entering span sessions', u'cli-incomplete-no': None, u'callpoint': u'Span', u'sort-priority': u'RUNNCFG_LEVEL_SPAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-span', defining_module='brocade-span', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """monitor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=monitor.monitor, is_container='container', presence=False, yang_name="monitor", rest_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Entering span sessions', u'cli-incomplete-no': None, u'callpoint': u'Span', u'sort-priority': u'RUNNCFG_LEVEL_SPAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-span', defining_module='brocade-span', yang_type='container', is_config=True)""",
        })

    self.__monitor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_monitor(self):
    self.__monitor = YANGDynClass(base=monitor.monitor, is_container='container', presence=False, yang_name="monitor", rest_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Entering span sessions', u'cli-incomplete-no': None, u'callpoint': u'Span', u'sort-priority': u'RUNNCFG_LEVEL_SPAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-span', defining_module='brocade-span', yang_type='container', is_config=True)

  monitor = __builtin__.property(_get_monitor, _set_monitor)


  _pyangbind_elements = {'monitor': monitor, }


class brocade_sysmgr(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-sysmgr - based on the path /brocade-sysmgr. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This system manager  module is used to display the bpswitch statistics
for the switch
  """
  _pyangbind_elements = {}

  

import mac
class brocade_mac_access_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mac-access-list - based on the path /brocade-mac-access-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management sub-module contains the configuration
and rpc implementaion for MAC Access-list.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__mac',)

  _yang_name = 'brocade-mac-access-list'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__mac = YANGDynClass(base=mac.mac, is_container='container', presence=False, yang_name="mac", rest_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC access list', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_MAC_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-mac-access-list', defining_module='brocade-mac-access-list', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_mac(self):
    """
    Getter method for mac, mapped from YANG variable /mac (container)
    """
    return self.__mac
      
  def _set_mac(self, v, load=False):
    """
    Setter method for mac, mapped from YANG variable /mac (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mac.mac, is_container='container', presence=False, yang_name="mac", rest_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC access list', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_MAC_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-mac-access-list', defining_module='brocade-mac-access-list', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mac.mac, is_container='container', presence=False, yang_name="mac", rest_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC access list', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_MAC_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-mac-access-list', defining_module='brocade-mac-access-list', yang_type='container', is_config=True)""",
        })

    self.__mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac(self):
    self.__mac = YANGDynClass(base=mac.mac, is_container='container', presence=False, yang_name="mac", rest_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC access list', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_GLOBAL_MAC_ACL'}}, namespace='urn:brocade.com:mgmt:brocade-mac-access-list', defining_module='brocade-mac-access-list', yang_type='container', is_config=True)

  mac = __builtin__.property(_get_mac, _set_mac)


  _pyangbind_elements = {'mac': mac, }


class brocade_igmp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-igmp - based on the path /brocade-igmp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This file defines the data model for the IGMP (Internet
Group Management Protocol) configuration commands.
  """
  _pyangbind_elements = {}

  

class brocade_http_redirect(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-http-redirect - based on the path /brocade-http-redirect. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data Model for HTTP Server configuration
  """
  _pyangbind_elements = {}

  

import terminal_cfg
class brocade_terminal(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-terminal - based on the path /brocade-terminal. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management submodule is an instrumentation to 
manage CLI terminal related features.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__terminal_cfg',)

  _yang_name = 'brocade-terminal'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__terminal_cfg = YANGDynClass(base=terminal_cfg.terminal_cfg, is_container='container', presence=False, yang_name="terminal-cfg", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'CLI terminal configuration', u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-terminal', defining_module='brocade-terminal', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_terminal_cfg(self):
    """
    Getter method for terminal_cfg, mapped from YANG variable /terminal_cfg (container)
    """
    return self.__terminal_cfg
      
  def _set_terminal_cfg(self, v, load=False):
    """
    Setter method for terminal_cfg, mapped from YANG variable /terminal_cfg (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminal_cfg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminal_cfg() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=terminal_cfg.terminal_cfg, is_container='container', presence=False, yang_name="terminal-cfg", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'CLI terminal configuration', u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-terminal', defining_module='brocade-terminal', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """terminal_cfg must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=terminal_cfg.terminal_cfg, is_container='container', presence=False, yang_name="terminal-cfg", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'CLI terminal configuration', u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-terminal', defining_module='brocade-terminal', yang_type='container', is_config=True)""",
        })

    self.__terminal_cfg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_terminal_cfg(self):
    self.__terminal_cfg = YANGDynClass(base=terminal_cfg.terminal_cfg, is_container='container', presence=False, yang_name="terminal-cfg", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'CLI terminal configuration', u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-terminal', defining_module='brocade-terminal', yang_type='container', is_config=True)

  terminal_cfg = __builtin__.property(_get_terminal_cfg, _set_terminal_cfg)


  _pyangbind_elements = {'terminal_cfg': terminal_cfg, }


class brocade_Enclosure_show(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-Enclosure-show - based on the path /brocade-Enclosure-show. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub module provides interface to Get 
Enclosure Related information on Embedded paltforms.
Copyright (c) 2010-2011 by Brocade Communications Systems, Inc.
All rights reserved.
  """
  _pyangbind_elements = {}

  

import port_profile
import port_profile_global
import port_profile_domain
class brocade_port_profile(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-port-profile - based on the path /brocade-port-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage  
Automatic Port Profiles in the device.
        
Glossary of the terms used:
--------------------------- 
APPM - Automatic Port Profile Management.
AMPP - Automatic Migration of Port Profile.
VM   - Virtual Machine.
VAL  - Virtual Access Layer, provided by VCS.
VCS  - Virtual Cluster Switching.
        
        
A port-profile is a collection of network policies to be 
applied on a network traffic on a given port.
        
Automatic Migration of Port Profile (AMPP) functionality 
provides fabric wide configuration of Ethernet policies and 
achieves per port-profile forwarding and enables network level 
features to support VM mobility.
        
With Server Virtualization infrastructure, a VM can move from 
one physical server to another. When such move occurs, it is 
ideal for access-layer to apply the network policies on the 
VM transparently. The Brocade VAL service provides such 
automatic migration of the port-profile on a given VMAC 
transparently. 
   
                                          [Hypervisor2]
                                           _____
                                          |     |
                                         /|VMAC |
                     '*************'    / |_____|
                     '             '   /     ^
                     '             '  /      |
                     '             '_/       ^
                     ' [VCS Fabric]'_        |
                     ' VMAC-PP map ' \     VM mobility
                     '             '  \      |
                     '             '   \     ^
                     '*************'    \  __|__
                                         \|     |
                                          |VMAC |
                                          |_____|
                                          [Hypervisor1]
                                          
This management module provides instrumentation to 
   - create/activate port-profile
   - map port-profile to MAC

A Port-profile typically comprises of:
+--------------------------------------------------------------+
| sub-profile         Description                              |
+--------------------------------------------------------------+
| Vlan profile        Vlan membership and filtering rules.     |
| QoS profile         Qos policies.                            |
| FCoE profile        The attributes needed for the port to    |
|                     support FCoE: FCoE VLAN, FCMAP, FCoE     |
|                     Priority, Virtual Fabric ID etc.         |
| Security profile    Security rules needed for the server     |
|                     port, typically enabling 802.1x with EAP |
|                     TLV extensions for VM Mobility, MAC based|
|                     standard and extended ACLs.              |
+--------------------------------------------------------------+
        
VM MAC addresses are added to a port-profile to specify all the 
network attributes for a server port. A port-profile is 
activated on a server port when as part of regular MAC learning. 
VM MAC to port-profile association is specified using this 
management module. The actual association in hardware is applied
when the MAC address is learned.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__port_profile','__port_profile_global','__port_profile_domain',)

  _yang_name = 'brocade-port-profile'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__port_profile_domain = YANGDynClass(base=YANGListType("port_profile_domain_name",port_profile_domain.port_profile_domain, yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-profile-domain-name', extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'71', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}), is_container='list', yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'71', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)
    self.__port_profile_global = YANGDynClass(base=port_profile_global.port_profile_global, is_container='container', presence=False, yang_name="port-profile-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'70'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='container', is_config=True)
    self.__port_profile = YANGDynClass(base=YANGListType("name",port_profile.port_profile, yang_name="port-profile", rest_name="port-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'70'}}), is_container='list', yang_name="port-profile", rest_name="port-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'70'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_port_profile(self):
    """
    Getter method for port_profile, mapped from YANG variable /port_profile (list)

    YANG Description: The list of port-profiles in the managed device. Each row
represents port profile name and its subprofiles.
    """
    return self.__port_profile
      
  def _set_port_profile(self, v, load=False):
    """
    Setter method for port_profile, mapped from YANG variable /port_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_profile() directly.

    YANG Description: The list of port-profiles in the managed device. Each row
represents port profile name and its subprofiles.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",port_profile.port_profile, yang_name="port-profile", rest_name="port-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'70'}}), is_container='list', yang_name="port-profile", rest_name="port-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'70'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_profile must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",port_profile.port_profile, yang_name="port-profile", rest_name="port-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'70'}}), is_container='list', yang_name="port-profile", rest_name="port-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'70'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)""",
        })

    self.__port_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_profile(self):
    self.__port_profile = YANGDynClass(base=YANGListType("name",port_profile.port_profile, yang_name="port-profile", rest_name="port-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'70'}}), is_container='list', yang_name="port-profile", rest_name="port-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Automatic port profile', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'callpoint': u'port-profile-config', u'sort-priority': u'70'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)


  def _get_port_profile_global(self):
    """
    Getter method for port_profile_global, mapped from YANG variable /port_profile_global (container)

    YANG Description: This provides the grouping for configuration parameters
to activate and MAC for a port profile.
    """
    return self.__port_profile_global
      
  def _set_port_profile_global(self, v, load=False):
    """
    Setter method for port_profile_global, mapped from YANG variable /port_profile_global (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_profile_global is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_profile_global() directly.

    YANG Description: This provides the grouping for configuration parameters
to activate and MAC for a port profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=port_profile_global.port_profile_global, is_container='container', presence=False, yang_name="port-profile-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'70'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_profile_global must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=port_profile_global.port_profile_global, is_container='container', presence=False, yang_name="port-profile-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'70'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='container', is_config=True)""",
        })

    self.__port_profile_global = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_profile_global(self):
    self.__port_profile_global = YANGDynClass(base=port_profile_global.port_profile_global, is_container='container', presence=False, yang_name="port-profile-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'70'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='container', is_config=True)


  def _get_port_profile_domain(self):
    """
    Getter method for port_profile_domain, mapped from YANG variable /port_profile_domain (list)
    """
    return self.__port_profile_domain
      
  def _set_port_profile_domain(self, v, load=False):
    """
    Setter method for port_profile_domain, mapped from YANG variable /port_profile_domain (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_profile_domain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_profile_domain() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("port_profile_domain_name",port_profile_domain.port_profile_domain, yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-profile-domain-name', extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'71', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}), is_container='list', yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'71', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_profile_domain must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("port_profile_domain_name",port_profile_domain.port_profile_domain, yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-profile-domain-name', extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'71', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}), is_container='list', yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'71', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)""",
        })

    self.__port_profile_domain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_profile_domain(self):
    self.__port_profile_domain = YANGDynClass(base=YANGListType("port_profile_domain_name",port_profile_domain.port_profile_domain, yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-profile-domain-name', extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'71', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}), is_container='list', yang_name="port-profile-domain", rest_name="port-profile-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Define a port-profile-domain', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'71', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'port-profile-domain-callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-port-profile', defining_module='brocade-port-profile', yang_type='list', is_config=True)

  port_profile = __builtin__.property(_get_port_profile, _set_port_profile)
  port_profile_global = __builtin__.property(_get_port_profile_global, _set_port_profile_global)
  port_profile_domain = __builtin__.property(_get_port_profile_domain, _set_port_profile_domain)


  _pyangbind_elements = {'port_profile': port_profile, 'port_profile_global': port_profile_global, 'port_profile_domain': port_profile_domain, }


import cpu_state
import mem_state
class brocade_RAS_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-RAS-operational - based on the path /brocade-RAS-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage RAS
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__cpu_state','__mem_state',)

  _yang_name = 'brocade-RAS-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__cpu_state = YANGDynClass(base=cpu_state.cpu_state, is_container='container', presence=False, yang_name="cpu-state", rest_name="cpu-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'RAS-cpu', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='container', is_config=True)
    self.__mem_state = YANGDynClass(base=mem_state.mem_state, is_container='container', presence=False, yang_name="mem-state", rest_name="mem-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'RAS-mem', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_cpu_state(self):
    """
    Getter method for cpu_state, mapped from YANG variable /cpu_state (container)

    YANG Description: CPU information
    """
    return self.__cpu_state
      
  def _set_cpu_state(self, v, load=False):
    """
    Setter method for cpu_state, mapped from YANG variable /cpu_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_state() directly.

    YANG Description: CPU information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=cpu_state.cpu_state, is_container='container', presence=False, yang_name="cpu-state", rest_name="cpu-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'RAS-cpu', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=cpu_state.cpu_state, is_container='container', presence=False, yang_name="cpu-state", rest_name="cpu-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'RAS-cpu', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='container', is_config=True)""",
        })

    self.__cpu_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_state(self):
    self.__cpu_state = YANGDynClass(base=cpu_state.cpu_state, is_container='container', presence=False, yang_name="cpu-state", rest_name="cpu-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'RAS-cpu', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='container', is_config=True)


  def _get_mem_state(self):
    """
    Getter method for mem_state, mapped from YANG variable /mem_state (container)

    YANG Description: Memory information
    """
    return self.__mem_state
      
  def _set_mem_state(self, v, load=False):
    """
    Setter method for mem_state, mapped from YANG variable /mem_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mem_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mem_state() directly.

    YANG Description: Memory information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mem_state.mem_state, is_container='container', presence=False, yang_name="mem-state", rest_name="mem-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'RAS-mem', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mem_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mem_state.mem_state, is_container='container', presence=False, yang_name="mem-state", rest_name="mem-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'RAS-mem', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='container', is_config=True)""",
        })

    self.__mem_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mem_state(self):
    self.__mem_state = YANGDynClass(base=mem_state.mem_state, is_container='container', presence=False, yang_name="mem-state", rest_name="mem-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'RAS-mem', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='container', is_config=True)

  cpu_state = __builtin__.property(_get_cpu_state, _set_cpu_state)
  mem_state = __builtin__.property(_get_mem_state, _set_mem_state)


  _pyangbind_elements = {'cpu_state': cpu_state, 'mem_state': mem_state, }


class brocade_lacp_pdu_forward(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-lacp-pdu-forward - based on the path /brocade-lacp-pdu-forward. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
Configuration command to enable LACP PDU Forward on an interface

  """
  _pyangbind_elements = {}

  

import event_handler
class brocade_event_handler(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-event-handler - based on the path /brocade-event-handler. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: event handler related information
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__event_handler',)

  _yang_name = 'brocade-event-handler'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__event_handler = YANGDynClass(base=event_handler.event_handler, is_container='container', presence=False, yang_name="event-handler", rest_name="event-handler", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Event Handler Commands', u'callpoint': u'event-handler-callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-event-handler', defining_module='brocade-event-handler', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_event_handler(self):
    """
    Getter method for event_handler, mapped from YANG variable /event_handler (container)

    YANG Description: Event Handler Commands
    """
    return self.__event_handler
      
  def _set_event_handler(self, v, load=False):
    """
    Setter method for event_handler, mapped from YANG variable /event_handler (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event_handler is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event_handler() directly.

    YANG Description: Event Handler Commands
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=event_handler.event_handler, is_container='container', presence=False, yang_name="event-handler", rest_name="event-handler", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Event Handler Commands', u'callpoint': u'event-handler-callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-event-handler', defining_module='brocade-event-handler', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """event_handler must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=event_handler.event_handler, is_container='container', presence=False, yang_name="event-handler", rest_name="event-handler", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Event Handler Commands', u'callpoint': u'event-handler-callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-event-handler', defining_module='brocade-event-handler', yang_type='container', is_config=True)""",
        })

    self.__event_handler = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_event_handler(self):
    self.__event_handler = YANGDynClass(base=event_handler.event_handler, is_container='container', presence=False, yang_name="event-handler", rest_name="event-handler", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Event Handler Commands', u'callpoint': u'event-handler-callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-event-handler', defining_module='brocade-event-handler', yang_type='container', is_config=True)

  event_handler = __builtin__.property(_get_event_handler, _set_event_handler)


  _pyangbind_elements = {'event_handler': event_handler, }


import opstest_state
class brocade_opstest(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-opstest - based on the path /brocade-opstest. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__opstest_state',)

  _yang_name = 'brocade-opstest'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__opstest_state = YANGDynClass(base=opstest_state.opstest_state, is_container='container', presence=False, yang_name="opstest-state", rest_name="opstest-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-opstest', defining_module='brocade-opstest', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_opstest_state(self):
    """
    Getter method for opstest_state, mapped from YANG variable /opstest_state (container)
    """
    return self.__opstest_state
      
  def _set_opstest_state(self, v, load=False):
    """
    Setter method for opstest_state, mapped from YANG variable /opstest_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opstest_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opstest_state() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=opstest_state.opstest_state, is_container='container', presence=False, yang_name="opstest-state", rest_name="opstest-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-opstest', defining_module='brocade-opstest', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opstest_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=opstest_state.opstest_state, is_container='container', presence=False, yang_name="opstest-state", rest_name="opstest-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-opstest', defining_module='brocade-opstest', yang_type='container', is_config=True)""",
        })

    self.__opstest_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opstest_state(self):
    self.__opstest_state = YANGDynClass(base=opstest_state.opstest_state, is_container='container', presence=False, yang_name="opstest-state", rest_name="opstest-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-opstest', defining_module='brocade-opstest', yang_type='container', is_config=True)

  opstest_state = __builtin__.property(_get_opstest_state, _set_opstest_state)


  _pyangbind_elements = {'opstest_state': opstest_state, }


class brocade_bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-bgp - based on the path /brocade-bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage
BGP Protocol.
  """
  _pyangbind_elements = {}

  

import load_balance_lag
class brocade_rbridge_lag(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-rbridge-lag - based on the path /brocade-rbridge-lag. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage
LAG protocol.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__load_balance_lag',)

  _yang_name = 'brocade-rbridge-lag'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__load_balance_lag = YANGDynClass(base=load_balance_lag.load_balance_lag, is_container='container', presence=False, yang_name="load-balance-lag", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'RbridgeLagCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-rbridge-lag', defining_module='brocade-rbridge-lag', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_load_balance_lag(self):
    """
    Getter method for load_balance_lag, mapped from YANG variable /load_balance_lag (container)
    """
    return self.__load_balance_lag
      
  def _set_load_balance_lag(self, v, load=False):
    """
    Setter method for load_balance_lag, mapped from YANG variable /load_balance_lag (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_load_balance_lag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_load_balance_lag() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=load_balance_lag.load_balance_lag, is_container='container', presence=False, yang_name="load-balance-lag", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'RbridgeLagCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-rbridge-lag', defining_module='brocade-rbridge-lag', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """load_balance_lag must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=load_balance_lag.load_balance_lag, is_container='container', presence=False, yang_name="load-balance-lag", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'RbridgeLagCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-rbridge-lag', defining_module='brocade-rbridge-lag', yang_type='container', is_config=True)""",
        })

    self.__load_balance_lag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_load_balance_lag(self):
    self.__load_balance_lag = YANGDynClass(base=load_balance_lag.load_balance_lag, is_container='container', presence=False, yang_name="load-balance-lag", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'RbridgeLagCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-rbridge-lag', defining_module='brocade-rbridge-lag', yang_type='container', is_config=True)

  load_balance_lag = __builtin__.property(_get_load_balance_lag, _set_load_balance_lag)


  _pyangbind_elements = {'load_balance_lag': load_balance_lag, }


import mac_address_table
import mac_group
class brocade_mac_address_table(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mac-address-table - based on the path /brocade-mac-address-table. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Mac forwarding table
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__mac_address_table','__mac_group',)

  _yang_name = 'brocade-mac-address-table'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__mac_address_table = YANGDynClass(base=mac_address_table.mac_address_table, is_container='container', presence=False, yang_name="mac-address-table", rest_name="mac-address-table", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC forwarding table information', u'cli-incomplete-no': None, u'sort-priority': u'85'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='container', is_config=True)
    self.__mac_group = YANGDynClass(base=YANGListType("mac_group_id",mac_group.mac_group, yang_name="mac-group", rest_name="mac-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac-group-id', extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'54', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}), is_container='list', yang_name="mac-group", rest_name="mac-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'54', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_mac_address_table(self):
    """
    Getter method for mac_address_table, mapped from YANG variable /mac_address_table (container)
    """
    return self.__mac_address_table
      
  def _set_mac_address_table(self, v, load=False):
    """
    Setter method for mac_address_table, mapped from YANG variable /mac_address_table (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address_table is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address_table() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mac_address_table.mac_address_table, is_container='container', presence=False, yang_name="mac-address-table", rest_name="mac-address-table", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC forwarding table information', u'cli-incomplete-no': None, u'sort-priority': u'85'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address_table must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mac_address_table.mac_address_table, is_container='container', presence=False, yang_name="mac-address-table", rest_name="mac-address-table", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC forwarding table information', u'cli-incomplete-no': None, u'sort-priority': u'85'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='container', is_config=True)""",
        })

    self.__mac_address_table = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address_table(self):
    self.__mac_address_table = YANGDynClass(base=mac_address_table.mac_address_table, is_container='container', presence=False, yang_name="mac-address-table", rest_name="mac-address-table", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC forwarding table information', u'cli-incomplete-no': None, u'sort-priority': u'85'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='container', is_config=True)


  def _get_mac_group(self):
    """
    Getter method for mac_group, mapped from YANG variable /mac_group (list)
    """
    return self.__mac_group
      
  def _set_mac_group(self, v, load=False):
    """
    Setter method for mac_group, mapped from YANG variable /mac_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_group() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("mac_group_id",mac_group.mac_group, yang_name="mac-group", rest_name="mac-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac-group-id', extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'54', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}), is_container='list', yang_name="mac-group", rest_name="mac-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'54', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("mac_group_id",mac_group.mac_group, yang_name="mac-group", rest_name="mac-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac-group-id', extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'54', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}), is_container='list', yang_name="mac-group", rest_name="mac-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'54', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='list', is_config=True)""",
        })

    self.__mac_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_group(self):
    self.__mac_group = YANGDynClass(base=YANGListType("mac_group_id",mac_group.mac_group, yang_name="mac-group", rest_name="mac-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac-group-id', extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'54', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}), is_container='list', yang_name="mac-group", rest_name="mac-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC Group Configuration', u'cli-no-key-completion': None, u'sort-priority': u'54', u'cli-suppress-list-no': None, u'hidden': u'full', u'callpoint': u'mac-group-config'}}, namespace='urn:brocade.com:mgmt:brocade-mac-address-table', defining_module='brocade-mac-address-table', yang_type='list', is_config=True)

  mac_address_table = __builtin__.property(_get_mac_address_table, _set_mac_address_table)
  mac_group = __builtin__.property(_get_mac_group, _set_mac_group)


  _pyangbind_elements = {'mac_address_table': mac_address_table, 'mac_group': mac_group, }


import mpls_state
class brocade_mpls_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls-operational - based on the path /brocade-mpls-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage mpls
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__mpls_state',)

  _yang_name = 'brocade-mpls-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__mpls_state = YANGDynClass(base=mpls_state.mpls_state, is_container='container', presence=False, yang_name="mpls-state", rest_name="mpls-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-mpls', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_mpls_state(self):
    """
    Getter method for mpls_state, mapped from YANG variable /mpls_state (container)

    YANG Description: MPLS Operational Information
    """
    return self.__mpls_state
      
  def _set_mpls_state(self, v, load=False):
    """
    Setter method for mpls_state, mapped from YANG variable /mpls_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_state() directly.

    YANG Description: MPLS Operational Information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mpls_state.mpls_state, is_container='container', presence=False, yang_name="mpls-state", rest_name="mpls-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-mpls', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mpls_state.mpls_state, is_container='container', presence=False, yang_name="mpls-state", rest_name="mpls-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-mpls', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=True)""",
        })

    self.__mpls_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_state(self):
    self.__mpls_state = YANGDynClass(base=mpls_state.mpls_state, is_container='container', presence=False, yang_name="mpls-state", rest_name="mpls-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-mpls', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=True)

  mpls_state = __builtin__.property(_get_mpls_state, _set_mpls_state)


  _pyangbind_elements = {'mpls_state': mpls_state, }


class brocade_ip_administration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ip-administration - based on the path /brocade-ip-administration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to ipadm
level commands
  """
  _pyangbind_elements = {}

  

import mld_snooping
class brocade_mld_snooping(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mld-snooping - based on the path /brocade-mld-snooping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage the 
'Multicast Listener Discovery (MLD) Snooping'.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__mld_snooping',)

  _yang_name = 'brocade-mld-snooping'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__mld_snooping = YANGDynClass(base=mld_snooping.mld_snooping, is_container='container', presence=False, yang_name="mld-snooping", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-mld-snooping', defining_module='brocade-mld-snooping', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_mld_snooping(self):
    """
    Getter method for mld_snooping, mapped from YANG variable /mld_snooping (container)
    """
    return self.__mld_snooping
      
  def _set_mld_snooping(self, v, load=False):
    """
    Setter method for mld_snooping, mapped from YANG variable /mld_snooping (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mld_snooping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mld_snooping() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mld_snooping.mld_snooping, is_container='container', presence=False, yang_name="mld-snooping", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-mld-snooping', defining_module='brocade-mld-snooping', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mld_snooping must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mld_snooping.mld_snooping, is_container='container', presence=False, yang_name="mld-snooping", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-mld-snooping', defining_module='brocade-mld-snooping', yang_type='container', is_config=True)""",
        })

    self.__mld_snooping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mld_snooping(self):
    self.__mld_snooping = YANGDynClass(base=mld_snooping.mld_snooping, is_container='container', presence=False, yang_name="mld-snooping", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-mld-snooping', defining_module='brocade-mld-snooping', yang_type='container', is_config=True)

  mld_snooping = __builtin__.property(_get_mld_snooping, _set_mld_snooping)


  _pyangbind_elements = {'mld_snooping': mld_snooping, }


import tm_state
import cpu_interface_state
class brocade_sysdiag_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-sysdiag-operational - based on the path /brocade-sysdiag-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage sysdiag
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__tm_state','__cpu_interface_state',)

  _yang_name = 'brocade-sysdiag-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__tm_state = YANGDynClass(base=tm_state.tm_state, is_container='container', presence=False, yang_name="tm-state", rest_name="tm-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'sysdiag-tm', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-sysdiag-operational', defining_module='brocade-sysdiag-operational', yang_type='container', is_config=True)
    self.__cpu_interface_state = YANGDynClass(base=YANGListType("ifname",cpu_interface_state.cpu_interface_state, yang_name="cpu-interface-state", rest_name="cpu-interface-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifname', extensions={u'tailf-common': {u'callpoint': u'sysdiag-cpu-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-interface-state", rest_name="cpu-interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'sysdiag-cpu-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-sysdiag-operational', defining_module='brocade-sysdiag-operational', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_tm_state(self):
    """
    Getter method for tm_state, mapped from YANG variable /tm_state (container)

    YANG Description: TM statistics
    """
    return self.__tm_state
      
  def _set_tm_state(self, v, load=False):
    """
    Setter method for tm_state, mapped from YANG variable /tm_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tm_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tm_state() directly.

    YANG Description: TM statistics
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=tm_state.tm_state, is_container='container', presence=False, yang_name="tm-state", rest_name="tm-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'sysdiag-tm', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-sysdiag-operational', defining_module='brocade-sysdiag-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tm_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tm_state.tm_state, is_container='container', presence=False, yang_name="tm-state", rest_name="tm-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'sysdiag-tm', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-sysdiag-operational', defining_module='brocade-sysdiag-operational', yang_type='container', is_config=True)""",
        })

    self.__tm_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tm_state(self):
    self.__tm_state = YANGDynClass(base=tm_state.tm_state, is_container='container', presence=False, yang_name="tm-state", rest_name="tm-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'sysdiag-tm', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-sysdiag-operational', defining_module='brocade-sysdiag-operational', yang_type='container', is_config=True)


  def _get_cpu_interface_state(self):
    """
    Getter method for cpu_interface_state, mapped from YANG variable /cpu_interface_state (list)

    YANG Description: CPU ethernet interface stats
    """
    return self.__cpu_interface_state
      
  def _set_cpu_interface_state(self, v, load=False):
    """
    Setter method for cpu_interface_state, mapped from YANG variable /cpu_interface_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_interface_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_interface_state() directly.

    YANG Description: CPU ethernet interface stats
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ifname",cpu_interface_state.cpu_interface_state, yang_name="cpu-interface-state", rest_name="cpu-interface-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifname', extensions={u'tailf-common': {u'callpoint': u'sysdiag-cpu-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-interface-state", rest_name="cpu-interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'sysdiag-cpu-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-sysdiag-operational', defining_module='brocade-sysdiag-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_interface_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ifname",cpu_interface_state.cpu_interface_state, yang_name="cpu-interface-state", rest_name="cpu-interface-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifname', extensions={u'tailf-common': {u'callpoint': u'sysdiag-cpu-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-interface-state", rest_name="cpu-interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'sysdiag-cpu-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-sysdiag-operational', defining_module='brocade-sysdiag-operational', yang_type='list', is_config=True)""",
        })

    self.__cpu_interface_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_interface_state(self):
    self.__cpu_interface_state = YANGDynClass(base=YANGListType("ifname",cpu_interface_state.cpu_interface_state, yang_name="cpu-interface-state", rest_name="cpu-interface-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifname', extensions={u'tailf-common': {u'callpoint': u'sysdiag-cpu-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-interface-state", rest_name="cpu-interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'sysdiag-cpu-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-sysdiag-operational', defining_module='brocade-sysdiag-operational', yang_type='list', is_config=True)

  tm_state = __builtin__.property(_get_tm_state, _set_tm_state)
  cpu_interface_state = __builtin__.property(_get_cpu_interface_state, _set_cpu_interface_state)


  _pyangbind_elements = {'tm_state': tm_state, 'cpu_interface_state': cpu_interface_state, }


import vrf
class brocade_vrf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-vrf - based on the path /brocade-vrf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages Virtual Routing and Forwarding (VRF)
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__vrf',)

  _yang_name = 'brocade-vrf'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__vrf = YANGDynClass(base=YANGListType("vrf_name",vrf.vrf, yang_name="vrf", rest_name="vrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}), is_container='list', yang_name="vrf", rest_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-vrf', defining_module='brocade-vrf', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_vrf(self):
    """
    Getter method for vrf, mapped from YANG variable /vrf (list)
    """
    return self.__vrf
      
  def _set_vrf(self, v, load=False):
    """
    Setter method for vrf, mapped from YANG variable /vrf (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vrf_name",vrf.vrf, yang_name="vrf", rest_name="vrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}), is_container='list', yang_name="vrf", rest_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-vrf', defining_module='brocade-vrf', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vrf_name",vrf.vrf, yang_name="vrf", rest_name="vrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}), is_container='list', yang_name="vrf", rest_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-vrf', defining_module='brocade-vrf', yang_type='list', is_config=True)""",
        })

    self.__vrf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf(self):
    self.__vrf = YANGDynClass(base=YANGListType("vrf_name",vrf.vrf, yang_name="vrf", rest_name="vrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}), is_container='list', yang_name="vrf", rest_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VRF configurations', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_VRF_NAME', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-full-command': None, u'callpoint': u'vrfCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-vrf', defining_module='brocade-vrf', yang_type='list', is_config=True)

  vrf = __builtin__.property(_get_vrf, _set_vrf)


  _pyangbind_elements = {'vrf': vrf, }


import global_lc_holder
import latch_detection_config
class brocade_linecard_management(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-linecard-management - based on the path /brocade-linecard-management. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This linecard management module is used to manage linecards.
It can be used to configure, show, or turn on/off a linecard.n
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__global_lc_holder','__latch_detection_config',)

  _yang_name = 'brocade-linecard-management'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__global_lc_holder = YANGDynClass(base=global_lc_holder.global_lc_holder, is_container='container', presence=False, yang_name="global-lc-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-linecard-management', defining_module='brocade-linecard-management', yang_type='container', is_config=True)
    self.__latch_detection_config = YANGDynClass(base=latch_detection_config.latch_detection_config, is_container='container', presence=False, yang_name="latch-detection-config", rest_name="latch-detection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'linecard latch screw detection', u'alt-name': u'latch-detection', u'display-when': u'((/local-node/swbd-number = "2000") or (/local-node/swbd-number = "2001"))'}}, namespace='urn:brocade.com:mgmt:brocade-linecard-management', defining_module='brocade-linecard-management', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_global_lc_holder(self):
    """
    Getter method for global_lc_holder, mapped from YANG variable /global_lc_holder (container)
    """
    return self.__global_lc_holder
      
  def _set_global_lc_holder(self, v, load=False):
    """
    Setter method for global_lc_holder, mapped from YANG variable /global_lc_holder (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_lc_holder is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_lc_holder() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=global_lc_holder.global_lc_holder, is_container='container', presence=False, yang_name="global-lc-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-linecard-management', defining_module='brocade-linecard-management', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_lc_holder must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=global_lc_holder.global_lc_holder, is_container='container', presence=False, yang_name="global-lc-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-linecard-management', defining_module='brocade-linecard-management', yang_type='container', is_config=True)""",
        })

    self.__global_lc_holder = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_lc_holder(self):
    self.__global_lc_holder = YANGDynClass(base=global_lc_holder.global_lc_holder, is_container='container', presence=False, yang_name="global-lc-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-linecard-management', defining_module='brocade-linecard-management', yang_type='container', is_config=True)


  def _get_latch_detection_config(self):
    """
    Getter method for latch_detection_config, mapped from YANG variable /latch_detection_config (container)
    """
    return self.__latch_detection_config
      
  def _set_latch_detection_config(self, v, load=False):
    """
    Setter method for latch_detection_config, mapped from YANG variable /latch_detection_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_latch_detection_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_latch_detection_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=latch_detection_config.latch_detection_config, is_container='container', presence=False, yang_name="latch-detection-config", rest_name="latch-detection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'linecard latch screw detection', u'alt-name': u'latch-detection', u'display-when': u'((/local-node/swbd-number = "2000") or (/local-node/swbd-number = "2001"))'}}, namespace='urn:brocade.com:mgmt:brocade-linecard-management', defining_module='brocade-linecard-management', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """latch_detection_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=latch_detection_config.latch_detection_config, is_container='container', presence=False, yang_name="latch-detection-config", rest_name="latch-detection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'linecard latch screw detection', u'alt-name': u'latch-detection', u'display-when': u'((/local-node/swbd-number = "2000") or (/local-node/swbd-number = "2001"))'}}, namespace='urn:brocade.com:mgmt:brocade-linecard-management', defining_module='brocade-linecard-management', yang_type='container', is_config=True)""",
        })

    self.__latch_detection_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_latch_detection_config(self):
    self.__latch_detection_config = YANGDynClass(base=latch_detection_config.latch_detection_config, is_container='container', presence=False, yang_name="latch-detection-config", rest_name="latch-detection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'linecard latch screw detection', u'alt-name': u'latch-detection', u'display-when': u'((/local-node/swbd-number = "2000") or (/local-node/swbd-number = "2001"))'}}, namespace='urn:brocade.com:mgmt:brocade-linecard-management', defining_module='brocade-linecard-management', yang_type='container', is_config=True)

  global_lc_holder = __builtin__.property(_get_global_lc_holder, _set_global_lc_holder)
  latch_detection_config = __builtin__.property(_get_latch_detection_config, _set_latch_detection_config)


  _pyangbind_elements = {'global_lc_holder': global_lc_holder, 'latch_detection_config': latch_detection_config, }


import threshold_monitor_hidden
class brocade_threshold_monitor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-threshold-monitor - based on the path /brocade-threshold-monitor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data Model for Brocade's System Monitor configuration CLIs
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__threshold_monitor_hidden',)

  _yang_name = 'brocade-threshold-monitor'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__threshold_monitor_hidden = YANGDynClass(base=threshold_monitor_hidden.threshold_monitor_hidden, is_container='container', presence=False, yang_name="threshold-monitor-hidden", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-threshold-monitor', defining_module='brocade-threshold-monitor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_threshold_monitor_hidden(self):
    """
    Getter method for threshold_monitor_hidden, mapped from YANG variable /threshold_monitor_hidden (container)
    """
    return self.__threshold_monitor_hidden
      
  def _set_threshold_monitor_hidden(self, v, load=False):
    """
    Setter method for threshold_monitor_hidden, mapped from YANG variable /threshold_monitor_hidden (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold_monitor_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold_monitor_hidden() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=threshold_monitor_hidden.threshold_monitor_hidden, is_container='container', presence=False, yang_name="threshold-monitor-hidden", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-threshold-monitor', defining_module='brocade-threshold-monitor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold_monitor_hidden must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=threshold_monitor_hidden.threshold_monitor_hidden, is_container='container', presence=False, yang_name="threshold-monitor-hidden", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-threshold-monitor', defining_module='brocade-threshold-monitor', yang_type='container', is_config=True)""",
        })

    self.__threshold_monitor_hidden = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold_monitor_hidden(self):
    self.__threshold_monitor_hidden = YANGDynClass(base=threshold_monitor_hidden.threshold_monitor_hidden, is_container='container', presence=False, yang_name="threshold-monitor-hidden", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-threshold-monitor', defining_module='brocade-threshold-monitor', yang_type='container', is_config=True)

  threshold_monitor_hidden = __builtin__.property(_get_threshold_monitor_hidden, _set_threshold_monitor_hidden)


  _pyangbind_elements = {'threshold_monitor_hidden': threshold_monitor_hidden, }


import pim_anycast_state
import pim_ecmp_state
import pim_global_state
import pim_mcache_state
class brocade_pim_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-pim-operational - based on the path /brocade-pim-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage pim
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__pim_anycast_state','__pim_ecmp_state','__pim_global_state','__pim_mcache_state',)

  _yang_name = 'brocade-pim-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__pim_anycast_state = YANGDynClass(base=YANGListType("vrf_name anycast_rp",pim_anycast_state.pim_anycast_state, yang_name="pim-anycast-state", rest_name="pim-anycast-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name anycast-rp', extensions={u'tailf-common': {u'callpoint': u'pim-pim-anycast', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-anycast-state", rest_name="pim-anycast-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-anycast', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)
    self.__pim_mcache_state = YANGDynClass(base=YANGListType("vrf_name src_addr grp_addr",pim_mcache_state.pim_mcache_state, yang_name="pim-mcache-state", rest_name="pim-mcache-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name src-addr grp-addr', extensions={u'tailf-common': {u'callpoint': u'pim-pim-mcache', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-mcache-state", rest_name="pim-mcache-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-mcache', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)
    self.__pim_global_state = YANGDynClass(base=YANGListType("vrf_name",pim_global_state.pim_global_state, yang_name="pim-global-state", rest_name="pim-global-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'callpoint': u'pim-pim-global', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-global-state", rest_name="pim-global-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-global', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)
    self.__pim_ecmp_state = YANGDynClass(base=YANGListType("vrf_name addr_filter",pim_ecmp_state.pim_ecmp_state, yang_name="pim-ecmp-state", rest_name="pim-ecmp-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name addr-filter', extensions={u'tailf-common': {u'callpoint': u'pim-pim-ecmp', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-ecmp-state", rest_name="pim-ecmp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-ecmp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_pim_anycast_state(self):
    """
    Getter method for pim_anycast_state, mapped from YANG variable /pim_anycast_state (list)

    YANG Description: Pim Anycast Rp information
    """
    return self.__pim_anycast_state
      
  def _set_pim_anycast_state(self, v, load=False):
    """
    Setter method for pim_anycast_state, mapped from YANG variable /pim_anycast_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pim_anycast_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pim_anycast_state() directly.

    YANG Description: Pim Anycast Rp information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vrf_name anycast_rp",pim_anycast_state.pim_anycast_state, yang_name="pim-anycast-state", rest_name="pim-anycast-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name anycast-rp', extensions={u'tailf-common': {u'callpoint': u'pim-pim-anycast', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-anycast-state", rest_name="pim-anycast-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-anycast', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pim_anycast_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vrf_name anycast_rp",pim_anycast_state.pim_anycast_state, yang_name="pim-anycast-state", rest_name="pim-anycast-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name anycast-rp', extensions={u'tailf-common': {u'callpoint': u'pim-pim-anycast', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-anycast-state", rest_name="pim-anycast-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-anycast', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)""",
        })

    self.__pim_anycast_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pim_anycast_state(self):
    self.__pim_anycast_state = YANGDynClass(base=YANGListType("vrf_name anycast_rp",pim_anycast_state.pim_anycast_state, yang_name="pim-anycast-state", rest_name="pim-anycast-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name anycast-rp', extensions={u'tailf-common': {u'callpoint': u'pim-pim-anycast', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-anycast-state", rest_name="pim-anycast-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-anycast', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)


  def _get_pim_ecmp_state(self):
    """
    Getter method for pim_ecmp_state, mapped from YANG variable /pim_ecmp_state (list)

    YANG Description: Pim Load Sharing
    """
    return self.__pim_ecmp_state
      
  def _set_pim_ecmp_state(self, v, load=False):
    """
    Setter method for pim_ecmp_state, mapped from YANG variable /pim_ecmp_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pim_ecmp_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pim_ecmp_state() directly.

    YANG Description: Pim Load Sharing
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vrf_name addr_filter",pim_ecmp_state.pim_ecmp_state, yang_name="pim-ecmp-state", rest_name="pim-ecmp-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name addr-filter', extensions={u'tailf-common': {u'callpoint': u'pim-pim-ecmp', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-ecmp-state", rest_name="pim-ecmp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-ecmp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pim_ecmp_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vrf_name addr_filter",pim_ecmp_state.pim_ecmp_state, yang_name="pim-ecmp-state", rest_name="pim-ecmp-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name addr-filter', extensions={u'tailf-common': {u'callpoint': u'pim-pim-ecmp', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-ecmp-state", rest_name="pim-ecmp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-ecmp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)""",
        })

    self.__pim_ecmp_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pim_ecmp_state(self):
    self.__pim_ecmp_state = YANGDynClass(base=YANGListType("vrf_name addr_filter",pim_ecmp_state.pim_ecmp_state, yang_name="pim-ecmp-state", rest_name="pim-ecmp-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name addr-filter', extensions={u'tailf-common': {u'callpoint': u'pim-pim-ecmp', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-ecmp-state", rest_name="pim-ecmp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-ecmp', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)


  def _get_pim_global_state(self):
    """
    Getter method for pim_global_state, mapped from YANG variable /pim_global_state (list)

    YANG Description: PIMSM Global Configuration Parameters
    """
    return self.__pim_global_state
      
  def _set_pim_global_state(self, v, load=False):
    """
    Setter method for pim_global_state, mapped from YANG variable /pim_global_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pim_global_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pim_global_state() directly.

    YANG Description: PIMSM Global Configuration Parameters
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vrf_name",pim_global_state.pim_global_state, yang_name="pim-global-state", rest_name="pim-global-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'callpoint': u'pim-pim-global', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-global-state", rest_name="pim-global-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-global', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pim_global_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vrf_name",pim_global_state.pim_global_state, yang_name="pim-global-state", rest_name="pim-global-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'callpoint': u'pim-pim-global', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-global-state", rest_name="pim-global-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-global', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)""",
        })

    self.__pim_global_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pim_global_state(self):
    self.__pim_global_state = YANGDynClass(base=YANGListType("vrf_name",pim_global_state.pim_global_state, yang_name="pim-global-state", rest_name="pim-global-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'callpoint': u'pim-pim-global', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-global-state", rest_name="pim-global-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-global', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)


  def _get_pim_mcache_state(self):
    """
    Getter method for pim_mcache_state, mapped from YANG variable /pim_mcache_state (list)

    YANG Description: mcache table
    """
    return self.__pim_mcache_state
      
  def _set_pim_mcache_state(self, v, load=False):
    """
    Setter method for pim_mcache_state, mapped from YANG variable /pim_mcache_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pim_mcache_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pim_mcache_state() directly.

    YANG Description: mcache table
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vrf_name src_addr grp_addr",pim_mcache_state.pim_mcache_state, yang_name="pim-mcache-state", rest_name="pim-mcache-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name src-addr grp-addr', extensions={u'tailf-common': {u'callpoint': u'pim-pim-mcache', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-mcache-state", rest_name="pim-mcache-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-mcache', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pim_mcache_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vrf_name src_addr grp_addr",pim_mcache_state.pim_mcache_state, yang_name="pim-mcache-state", rest_name="pim-mcache-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name src-addr grp-addr', extensions={u'tailf-common': {u'callpoint': u'pim-pim-mcache', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-mcache-state", rest_name="pim-mcache-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-mcache', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)""",
        })

    self.__pim_mcache_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pim_mcache_state(self):
    self.__pim_mcache_state = YANGDynClass(base=YANGListType("vrf_name src_addr grp_addr",pim_mcache_state.pim_mcache_state, yang_name="pim-mcache-state", rest_name="pim-mcache-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name src-addr grp-addr', extensions={u'tailf-common': {u'callpoint': u'pim-pim-mcache', u'cli-suppress-show-path': None}}), is_container='list', yang_name="pim-mcache-state", rest_name="pim-mcache-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-mcache', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=True)

  pim_anycast_state = __builtin__.property(_get_pim_anycast_state, _set_pim_anycast_state)
  pim_ecmp_state = __builtin__.property(_get_pim_ecmp_state, _set_pim_ecmp_state)
  pim_global_state = __builtin__.property(_get_pim_global_state, _set_pim_global_state)
  pim_mcache_state = __builtin__.property(_get_pim_mcache_state, _set_pim_mcache_state)


  _pyangbind_elements = {'pim_anycast_state': pim_anycast_state, 'pim_ecmp_state': pim_ecmp_state, 'pim_global_state': pim_global_state, 'pim_mcache_state': pim_mcache_state, }


import ntp
class brocade_ntp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ntp - based on the path /brocade-ntp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Instrument to configure ntp servers and monitoring active server
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__ntp',)

  _yang_name = 'brocade-ntp'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__ntp = YANGDynClass(base=ntp.ntp, is_container='container', presence=False, yang_name="ntp", rest_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'NTP commands', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ntp', defining_module='brocade-ntp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_ntp(self):
    """
    Getter method for ntp, mapped from YANG variable /ntp (container)
    """
    return self.__ntp
      
  def _set_ntp(self, v, load=False):
    """
    Setter method for ntp, mapped from YANG variable /ntp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ntp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ntp() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ntp.ntp, is_container='container', presence=False, yang_name="ntp", rest_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'NTP commands', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ntp', defining_module='brocade-ntp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ntp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ntp.ntp, is_container='container', presence=False, yang_name="ntp", rest_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'NTP commands', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ntp', defining_module='brocade-ntp', yang_type='container', is_config=True)""",
        })

    self.__ntp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ntp(self):
    self.__ntp = YANGDynClass(base=ntp.ntp, is_container='container', presence=False, yang_name="ntp", rest_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'NTP commands', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ntp', defining_module='brocade-ntp', yang_type='container', is_config=True)

  ntp = __builtin__.property(_get_ntp, _set_ntp)


  _pyangbind_elements = {'ntp': ntp, }


import fcoe_fsb
import fcoe
class brocade_fcoe(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-fcoe - based on the path /brocade-fcoe. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage fcoe  
feature.

Fiber Channel over Ethernet (FCoE) is an
encapsulation of Fiber Channel frames over Ethernet networks. 
This allows Fiber Channel to use 10 Gigabit Ethernet networks
(or higher speeds) while preserving the Fiber Channel protocol.

The FCoE interface can be managed using this module.

This module provides a mechanism to configure FCoE maps and
FCoE interface.
 
Glossary of the terms used
--------------------------  
FIP -      FCoE Initialization Protocol is the standard for
           initialization of FCoE network.   
VFID -     Virtual Fabric Identifier

  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__fcoe_fsb','__fcoe',)

  _yang_name = 'brocade-fcoe'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__fcoe_fsb = YANGDynClass(base=fcoe_fsb.fcoe_fsb, is_container='container', presence=False, yang_name="fcoe-fsb", rest_name="fsb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'fcoe_fsb_cp', u'info': u'Enable/Disable the fsb mode', u'hidden': u'debug', u'alt-name': u'fsb', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fcoe', defining_module='brocade-fcoe', yang_type='container', is_config=True)
    self.__fcoe = YANGDynClass(base=fcoe.fcoe, is_container='container', presence=False, yang_name="fcoe", rest_name="fcoe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'FCoE configuration commands', u'sort-priority': u'RUNNCFG_LEVEL_FEATURE_FCOE', u'cli-suppress-no': None, u'cli-full-command': None, u'cli-add-mode': None, u'display-when': u'(/vcsmode/vcs-mode = "true")'}}, namespace='urn:brocade.com:mgmt:brocade-fcoe', defining_module='brocade-fcoe', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_fcoe_fsb(self):
    """
    Getter method for fcoe_fsb, mapped from YANG variable /fcoe_fsb (container)

    YANG Description: This CLI will disable/enable fsb mode
    """
    return self.__fcoe_fsb
      
  def _set_fcoe_fsb(self, v, load=False):
    """
    Setter method for fcoe_fsb, mapped from YANG variable /fcoe_fsb (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fcoe_fsb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fcoe_fsb() directly.

    YANG Description: This CLI will disable/enable fsb mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=fcoe_fsb.fcoe_fsb, is_container='container', presence=False, yang_name="fcoe-fsb", rest_name="fsb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'fcoe_fsb_cp', u'info': u'Enable/Disable the fsb mode', u'hidden': u'debug', u'alt-name': u'fsb', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fcoe', defining_module='brocade-fcoe', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fcoe_fsb must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=fcoe_fsb.fcoe_fsb, is_container='container', presence=False, yang_name="fcoe-fsb", rest_name="fsb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'fcoe_fsb_cp', u'info': u'Enable/Disable the fsb mode', u'hidden': u'debug', u'alt-name': u'fsb', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fcoe', defining_module='brocade-fcoe', yang_type='container', is_config=True)""",
        })

    self.__fcoe_fsb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fcoe_fsb(self):
    self.__fcoe_fsb = YANGDynClass(base=fcoe_fsb.fcoe_fsb, is_container='container', presence=False, yang_name="fcoe-fsb", rest_name="fsb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'fcoe_fsb_cp', u'info': u'Enable/Disable the fsb mode', u'hidden': u'debug', u'alt-name': u'fsb', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fcoe', defining_module='brocade-fcoe', yang_type='container', is_config=True)


  def _get_fcoe(self):
    """
    Getter method for fcoe, mapped from YANG variable /fcoe (container)

    YANG Description: This provides the grouping of all FCoE map configuration
elements.
    """
    return self.__fcoe
      
  def _set_fcoe(self, v, load=False):
    """
    Setter method for fcoe, mapped from YANG variable /fcoe (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fcoe is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fcoe() directly.

    YANG Description: This provides the grouping of all FCoE map configuration
elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=fcoe.fcoe, is_container='container', presence=False, yang_name="fcoe", rest_name="fcoe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'FCoE configuration commands', u'sort-priority': u'RUNNCFG_LEVEL_FEATURE_FCOE', u'cli-suppress-no': None, u'cli-full-command': None, u'cli-add-mode': None, u'display-when': u'(/vcsmode/vcs-mode = "true")'}}, namespace='urn:brocade.com:mgmt:brocade-fcoe', defining_module='brocade-fcoe', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fcoe must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=fcoe.fcoe, is_container='container', presence=False, yang_name="fcoe", rest_name="fcoe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'FCoE configuration commands', u'sort-priority': u'RUNNCFG_LEVEL_FEATURE_FCOE', u'cli-suppress-no': None, u'cli-full-command': None, u'cli-add-mode': None, u'display-when': u'(/vcsmode/vcs-mode = "true")'}}, namespace='urn:brocade.com:mgmt:brocade-fcoe', defining_module='brocade-fcoe', yang_type='container', is_config=True)""",
        })

    self.__fcoe = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fcoe(self):
    self.__fcoe = YANGDynClass(base=fcoe.fcoe, is_container='container', presence=False, yang_name="fcoe", rest_name="fcoe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'FCoE configuration commands', u'sort-priority': u'RUNNCFG_LEVEL_FEATURE_FCOE', u'cli-suppress-no': None, u'cli-full-command': None, u'cli-add-mode': None, u'display-when': u'(/vcsmode/vcs-mode = "true")'}}, namespace='urn:brocade.com:mgmt:brocade-fcoe', defining_module='brocade-fcoe', yang_type='container', is_config=True)

  fcoe_fsb = __builtin__.property(_get_fcoe_fsb, _set_fcoe_fsb)
  fcoe = __builtin__.property(_get_fcoe, _set_fcoe)


  _pyangbind_elements = {'fcoe_fsb': fcoe_fsb, 'fcoe': fcoe, }


import protocol_vrrp
class brocade_vrrp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-vrrp - based on the path /brocade-vrrp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes the data model for Virtual Router Redundancy Protocol
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__protocol_vrrp',)

  _yang_name = 'brocade-vrrp'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__protocol_vrrp = YANGDynClass(base=protocol_vrrp.protocol_vrrp, is_container='container', presence=False, yang_name="protocol-vrrp", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-vrrp', defining_module='brocade-vrrp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_protocol_vrrp(self):
    """
    Getter method for protocol_vrrp, mapped from YANG variable /protocol_vrrp (container)

    YANG Description: An intermediary node that separates the protocol vrrp from other protocols.
    """
    return self.__protocol_vrrp
      
  def _set_protocol_vrrp(self, v, load=False):
    """
    Setter method for protocol_vrrp, mapped from YANG variable /protocol_vrrp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_vrrp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_vrrp() directly.

    YANG Description: An intermediary node that separates the protocol vrrp from other protocols.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=protocol_vrrp.protocol_vrrp, is_container='container', presence=False, yang_name="protocol-vrrp", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-vrrp', defining_module='brocade-vrrp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_vrrp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=protocol_vrrp.protocol_vrrp, is_container='container', presence=False, yang_name="protocol-vrrp", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-vrrp', defining_module='brocade-vrrp', yang_type='container', is_config=True)""",
        })

    self.__protocol_vrrp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_vrrp(self):
    self.__protocol_vrrp = YANGDynClass(base=protocol_vrrp.protocol_vrrp, is_container='container', presence=False, yang_name="protocol-vrrp", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_ROUTER_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-vrrp', defining_module='brocade-vrrp', yang_type='container', is_config=True)

  protocol_vrrp = __builtin__.property(_get_protocol_vrrp, _set_protocol_vrrp)


  _pyangbind_elements = {'protocol_vrrp': protocol_vrrp, }


import topology_group
class brocade_topology_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-topology-group - based on the path /brocade-topology-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule Manages Topology Group related CLI.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__topology_group',)

  _yang_name = 'brocade-topology-group'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__topology_group = YANGDynClass(base=YANGListType("topology_group_id",topology_group.topology_group, yang_name="topology-group", rest_name="topology-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='topology-group-id', extensions={u'tailf-common': {u'info': u'Configure topology vlan group for L2 protocols', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'145', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'TopologyGroupCallpoint', u'cli-mode-name': u'config-topo-group-$(topology-group-id)'}}), is_container='list', yang_name="topology-group", rest_name="topology-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure topology vlan group for L2 protocols', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'145', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'TopologyGroupCallpoint', u'cli-mode-name': u'config-topo-group-$(topology-group-id)'}}, namespace='urn:brocade.com:mgmt:brocade-topology-group', defining_module='brocade-topology-group', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_topology_group(self):
    """
    Getter method for topology_group, mapped from YANG variable /topology_group (list)
    """
    return self.__topology_group
      
  def _set_topology_group(self, v, load=False):
    """
    Setter method for topology_group, mapped from YANG variable /topology_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_topology_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_topology_group() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("topology_group_id",topology_group.topology_group, yang_name="topology-group", rest_name="topology-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='topology-group-id', extensions={u'tailf-common': {u'info': u'Configure topology vlan group for L2 protocols', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'145', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'TopologyGroupCallpoint', u'cli-mode-name': u'config-topo-group-$(topology-group-id)'}}), is_container='list', yang_name="topology-group", rest_name="topology-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure topology vlan group for L2 protocols', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'145', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'TopologyGroupCallpoint', u'cli-mode-name': u'config-topo-group-$(topology-group-id)'}}, namespace='urn:brocade.com:mgmt:brocade-topology-group', defining_module='brocade-topology-group', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """topology_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("topology_group_id",topology_group.topology_group, yang_name="topology-group", rest_name="topology-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='topology-group-id', extensions={u'tailf-common': {u'info': u'Configure topology vlan group for L2 protocols', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'145', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'TopologyGroupCallpoint', u'cli-mode-name': u'config-topo-group-$(topology-group-id)'}}), is_container='list', yang_name="topology-group", rest_name="topology-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure topology vlan group for L2 protocols', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'145', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'TopologyGroupCallpoint', u'cli-mode-name': u'config-topo-group-$(topology-group-id)'}}, namespace='urn:brocade.com:mgmt:brocade-topology-group', defining_module='brocade-topology-group', yang_type='list', is_config=True)""",
        })

    self.__topology_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_topology_group(self):
    self.__topology_group = YANGDynClass(base=YANGListType("topology_group_id",topology_group.topology_group, yang_name="topology-group", rest_name="topology-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='topology-group-id', extensions={u'tailf-common': {u'info': u'Configure topology vlan group for L2 protocols', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'145', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'TopologyGroupCallpoint', u'cli-mode-name': u'config-topo-group-$(topology-group-id)'}}), is_container='list', yang_name="topology-group", rest_name="topology-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure topology vlan group for L2 protocols', u'cli-no-key-completion': None, u'cli-full-no': None, u'sort-priority': u'145', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'TopologyGroupCallpoint', u'cli-mode-name': u'config-topo-group-$(topology-group-id)'}}, namespace='urn:brocade.com:mgmt:brocade-topology-group', defining_module='brocade-topology-group', yang_type='list', is_config=True)

  topology_group = __builtin__.property(_get_topology_group, _set_topology_group)


  _pyangbind_elements = {'topology_group': topology_group, }


class brocade_dle(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-dle - based on the path /brocade-dle. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages delay link event (DLE)
  """
  _pyangbind_elements = {}

  

import acl_policy
class brocade_acl_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-acl-policy - based on the path /brocade-acl-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage                 
ACL Policy Configuration.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__acl_policy',)

  _yang_name = 'brocade-acl-policy'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__acl_policy = YANGDynClass(base=acl_policy.acl_policy, is_container='container', presence=False, yang_name="acl-policy", rest_name="acl-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-add-mode': None, u'cli-full-command': None, u'info': u'ACL related Global commands', u'callpoint': u'GlobalAclPolicyConfig'}}, namespace='urn:brocade.com:mgmt:brocade-acl-policy', defining_module='brocade-acl-policy', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_acl_policy(self):
    """
    Getter method for acl_policy, mapped from YANG variable /acl_policy (container)
    """
    return self.__acl_policy
      
  def _set_acl_policy(self, v, load=False):
    """
    Setter method for acl_policy, mapped from YANG variable /acl_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acl_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acl_policy() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=acl_policy.acl_policy, is_container='container', presence=False, yang_name="acl-policy", rest_name="acl-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-add-mode': None, u'cli-full-command': None, u'info': u'ACL related Global commands', u'callpoint': u'GlobalAclPolicyConfig'}}, namespace='urn:brocade.com:mgmt:brocade-acl-policy', defining_module='brocade-acl-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acl_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=acl_policy.acl_policy, is_container='container', presence=False, yang_name="acl-policy", rest_name="acl-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-add-mode': None, u'cli-full-command': None, u'info': u'ACL related Global commands', u'callpoint': u'GlobalAclPolicyConfig'}}, namespace='urn:brocade.com:mgmt:brocade-acl-policy', defining_module='brocade-acl-policy', yang_type='container', is_config=True)""",
        })

    self.__acl_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acl_policy(self):
    self.__acl_policy = YANGDynClass(base=acl_policy.acl_policy, is_container='container', presence=False, yang_name="acl-policy", rest_name="acl-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-add-mode': None, u'cli-full-command': None, u'info': u'ACL related Global commands', u'callpoint': u'GlobalAclPolicyConfig'}}, namespace='urn:brocade.com:mgmt:brocade-acl-policy', defining_module='brocade-acl-policy', yang_type='container', is_config=True)

  acl_policy = __builtin__.property(_get_acl_policy, _set_acl_policy)


  _pyangbind_elements = {'acl_policy': acl_policy, }


import bd_mac_br_state
import mct_l2ys_state
import bridge_domain_mac_state
class brocade_l2sys_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-l2sys-operational - based on the path /brocade-l2sys-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage l2sys
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__bd_mac_br_state','__mct_l2ys_state','__bridge_domain_mac_state',)

  _yang_name = 'brocade-l2sys-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__mct_l2ys_state = YANGDynClass(base=mct_l2ys_state.mct_l2ys_state, is_container='container', presence=False, yang_name="mct-l2ys-state", rest_name="mct-l2ys-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'l2sys-mct-l2ys', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-l2sys-operational', defining_module='brocade-l2sys-operational', yang_type='container', is_config=True)
    self.__bd_mac_br_state = YANGDynClass(base=bd_mac_br_state.bd_mac_br_state, is_container='container', presence=False, yang_name="bd-mac-br-state", rest_name="bd-mac-br-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'l2sys-bd-mac-br', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-l2sys-operational', defining_module='brocade-l2sys-operational', yang_type='container', is_config=True)
    self.__bridge_domain_mac_state = YANGDynClass(base=YANGListType("bd_id",bridge_domain_mac_state.bridge_domain_mac_state, yang_name="bridge-domain-mac-state", rest_name="bridge-domain-mac-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'l2sys-bridge-domain-mac', u'cli-suppress-show-path': None}}), is_container='list', yang_name="bridge-domain-mac-state", rest_name="bridge-domain-mac-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'l2sys-bridge-domain-mac', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-l2sys-operational', defining_module='brocade-l2sys-operational', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_bd_mac_br_state(self):
    """
    Getter method for bd_mac_br_state, mapped from YANG variable /bd_mac_br_state (container)

    YANG Description: Bridge-domain mac brief info
    """
    return self.__bd_mac_br_state
      
  def _set_bd_mac_br_state(self, v, load=False):
    """
    Setter method for bd_mac_br_state, mapped from YANG variable /bd_mac_br_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bd_mac_br_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bd_mac_br_state() directly.

    YANG Description: Bridge-domain mac brief info
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bd_mac_br_state.bd_mac_br_state, is_container='container', presence=False, yang_name="bd-mac-br-state", rest_name="bd-mac-br-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'l2sys-bd-mac-br', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-l2sys-operational', defining_module='brocade-l2sys-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bd_mac_br_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bd_mac_br_state.bd_mac_br_state, is_container='container', presence=False, yang_name="bd-mac-br-state", rest_name="bd-mac-br-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'l2sys-bd-mac-br', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-l2sys-operational', defining_module='brocade-l2sys-operational', yang_type='container', is_config=True)""",
        })

    self.__bd_mac_br_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bd_mac_br_state(self):
    self.__bd_mac_br_state = YANGDynClass(base=bd_mac_br_state.bd_mac_br_state, is_container='container', presence=False, yang_name="bd-mac-br-state", rest_name="bd-mac-br-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'l2sys-bd-mac-br', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-l2sys-operational', defining_module='brocade-l2sys-operational', yang_type='container', is_config=True)


  def _get_mct_l2ys_state(self):
    """
    Getter method for mct_l2ys_state, mapped from YANG variable /mct_l2ys_state (container)

    YANG Description: MCT L2sys Operational Information
    """
    return self.__mct_l2ys_state
      
  def _set_mct_l2ys_state(self, v, load=False):
    """
    Setter method for mct_l2ys_state, mapped from YANG variable /mct_l2ys_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mct_l2ys_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mct_l2ys_state() directly.

    YANG Description: MCT L2sys Operational Information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mct_l2ys_state.mct_l2ys_state, is_container='container', presence=False, yang_name="mct-l2ys-state", rest_name="mct-l2ys-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'l2sys-mct-l2ys', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-l2sys-operational', defining_module='brocade-l2sys-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mct_l2ys_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mct_l2ys_state.mct_l2ys_state, is_container='container', presence=False, yang_name="mct-l2ys-state", rest_name="mct-l2ys-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'l2sys-mct-l2ys', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-l2sys-operational', defining_module='brocade-l2sys-operational', yang_type='container', is_config=True)""",
        })

    self.__mct_l2ys_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mct_l2ys_state(self):
    self.__mct_l2ys_state = YANGDynClass(base=mct_l2ys_state.mct_l2ys_state, is_container='container', presence=False, yang_name="mct-l2ys-state", rest_name="mct-l2ys-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'l2sys-mct-l2ys', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-l2sys-operational', defining_module='brocade-l2sys-operational', yang_type='container', is_config=True)


  def _get_bridge_domain_mac_state(self):
    """
    Getter method for bridge_domain_mac_state, mapped from YANG variable /bridge_domain_mac_state (list)

    YANG Description:  brief mac Bridge-domain information
    """
    return self.__bridge_domain_mac_state
      
  def _set_bridge_domain_mac_state(self, v, load=False):
    """
    Setter method for bridge_domain_mac_state, mapped from YANG variable /bridge_domain_mac_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bridge_domain_mac_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bridge_domain_mac_state() directly.

    YANG Description:  brief mac Bridge-domain information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("bd_id",bridge_domain_mac_state.bridge_domain_mac_state, yang_name="bridge-domain-mac-state", rest_name="bridge-domain-mac-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'l2sys-bridge-domain-mac', u'cli-suppress-show-path': None}}), is_container='list', yang_name="bridge-domain-mac-state", rest_name="bridge-domain-mac-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'l2sys-bridge-domain-mac', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-l2sys-operational', defining_module='brocade-l2sys-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bridge_domain_mac_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("bd_id",bridge_domain_mac_state.bridge_domain_mac_state, yang_name="bridge-domain-mac-state", rest_name="bridge-domain-mac-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'l2sys-bridge-domain-mac', u'cli-suppress-show-path': None}}), is_container='list', yang_name="bridge-domain-mac-state", rest_name="bridge-domain-mac-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'l2sys-bridge-domain-mac', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-l2sys-operational', defining_module='brocade-l2sys-operational', yang_type='list', is_config=True)""",
        })

    self.__bridge_domain_mac_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bridge_domain_mac_state(self):
    self.__bridge_domain_mac_state = YANGDynClass(base=YANGListType("bd_id",bridge_domain_mac_state.bridge_domain_mac_state, yang_name="bridge-domain-mac-state", rest_name="bridge-domain-mac-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'l2sys-bridge-domain-mac', u'cli-suppress-show-path': None}}), is_container='list', yang_name="bridge-domain-mac-state", rest_name="bridge-domain-mac-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'l2sys-bridge-domain-mac', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-l2sys-operational', defining_module='brocade-l2sys-operational', yang_type='list', is_config=True)

  bd_mac_br_state = __builtin__.property(_get_bd_mac_br_state, _set_bd_mac_br_state)
  mct_l2ys_state = __builtin__.property(_get_mct_l2ys_state, _set_mct_l2ys_state)
  bridge_domain_mac_state = __builtin__.property(_get_bridge_domain_mac_state, _set_bridge_domain_mac_state)


  _pyangbind_elements = {'bd_mac_br_state': bd_mac_br_state, 'mct_l2ys_state': mct_l2ys_state, 'bridge_domain_mac_state': bridge_domain_mac_state, }


class brocade_eld(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-eld - based on the path /brocade-eld. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  _pyangbind_elements = {}

  

import maps
class brocade_maps(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-maps - based on the path /brocade-maps. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage MAPS 
feature.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__maps',)

  _yang_name = 'brocade-maps'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__maps = YANGDynClass(base=maps.maps, is_container='container', presence=False, yang_name="maps", rest_name="maps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-add-mode': None, u'cli-full-command': None, u'info': u'All MAPS mode related commands.', u'cli-suppress-no': None, u'cli-mode-name': u'config-maps'}}, namespace='urn:brocade.com:mgmt:brocade-maps', defining_module='brocade-maps', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_maps(self):
    """
    Getter method for maps, mapped from YANG variable /maps (container)
    """
    return self.__maps
      
  def _set_maps(self, v, load=False):
    """
    Setter method for maps, mapped from YANG variable /maps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maps() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=maps.maps, is_container='container', presence=False, yang_name="maps", rest_name="maps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-add-mode': None, u'cli-full-command': None, u'info': u'All MAPS mode related commands.', u'cli-suppress-no': None, u'cli-mode-name': u'config-maps'}}, namespace='urn:brocade.com:mgmt:brocade-maps', defining_module='brocade-maps', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=maps.maps, is_container='container', presence=False, yang_name="maps", rest_name="maps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-add-mode': None, u'cli-full-command': None, u'info': u'All MAPS mode related commands.', u'cli-suppress-no': None, u'cli-mode-name': u'config-maps'}}, namespace='urn:brocade.com:mgmt:brocade-maps', defining_module='brocade-maps', yang_type='container', is_config=True)""",
        })

    self.__maps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maps(self):
    self.__maps = YANGDynClass(base=maps.maps, is_container='container', presence=False, yang_name="maps", rest_name="maps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-add-mode': None, u'cli-full-command': None, u'info': u'All MAPS mode related commands.', u'cli-suppress-no': None, u'cli-mode-name': u'config-maps'}}, namespace='urn:brocade.com:mgmt:brocade-maps', defining_module='brocade-maps', yang_type='container', is_config=True)

  maps = __builtin__.property(_get_maps, _set_maps)


  _pyangbind_elements = {'maps': maps, }


import adj_neighbor_entries_state
import counts_state
import isis_state
import traffic_state
import spf_log_state
class brocade_isis_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-isis-operational - based on the path /brocade-isis-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage isis
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__adj_neighbor_entries_state','__counts_state','__isis_state','__traffic_state','__spf_log_state',)

  _yang_name = 'brocade-isis-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__isis_state = YANGDynClass(base=isis_state.isis_state, is_container='container', presence=False, yang_name="isis-state", rest_name="isis-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-isis', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    self.__traffic_state = YANGDynClass(base=traffic_state.traffic_state, is_container='container', presence=False, yang_name="traffic-state", rest_name="traffic-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-traffic', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    self.__counts_state = YANGDynClass(base=counts_state.counts_state, is_container='container', presence=False, yang_name="counts-state", rest_name="counts-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-counts', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    self.__adj_neighbor_entries_state = YANGDynClass(base=adj_neighbor_entries_state.adj_neighbor_entries_state, is_container='container', presence=False, yang_name="adj-neighbor-entries-state", rest_name="adj-neighbor-entries-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-adj-neighbor-entries', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    self.__spf_log_state = YANGDynClass(base=YANGListType("spf_log_version",spf_log_state.spf_log_state, yang_name="spf-log-state", rest_name="spf-log-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='spf-log-version', extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}), is_container='list', yang_name="spf-log-state", rest_name="spf-log-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_adj_neighbor_entries_state(self):
    """
    Getter method for adj_neighbor_entries_state, mapped from YANG variable /adj_neighbor_entries_state (container)

    YANG Description: ISIS Adjacency Neighbor Entries
    """
    return self.__adj_neighbor_entries_state
      
  def _set_adj_neighbor_entries_state(self, v, load=False):
    """
    Setter method for adj_neighbor_entries_state, mapped from YANG variable /adj_neighbor_entries_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adj_neighbor_entries_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adj_neighbor_entries_state() directly.

    YANG Description: ISIS Adjacency Neighbor Entries
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=adj_neighbor_entries_state.adj_neighbor_entries_state, is_container='container', presence=False, yang_name="adj-neighbor-entries-state", rest_name="adj-neighbor-entries-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-adj-neighbor-entries', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adj_neighbor_entries_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=adj_neighbor_entries_state.adj_neighbor_entries_state, is_container='container', presence=False, yang_name="adj-neighbor-entries-state", rest_name="adj-neighbor-entries-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-adj-neighbor-entries', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)""",
        })

    self.__adj_neighbor_entries_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adj_neighbor_entries_state(self):
    self.__adj_neighbor_entries_state = YANGDynClass(base=adj_neighbor_entries_state.adj_neighbor_entries_state, is_container='container', presence=False, yang_name="adj-neighbor-entries-state", rest_name="adj-neighbor-entries-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-adj-neighbor-entries', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)


  def _get_counts_state(self):
    """
    Getter method for counts_state, mapped from YANG variable /counts_state (container)

    YANG Description: IS-IS Counters
    """
    return self.__counts_state
      
  def _set_counts_state(self, v, load=False):
    """
    Setter method for counts_state, mapped from YANG variable /counts_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counts_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counts_state() directly.

    YANG Description: IS-IS Counters
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=counts_state.counts_state, is_container='container', presence=False, yang_name="counts-state", rest_name="counts-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-counts', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counts_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=counts_state.counts_state, is_container='container', presence=False, yang_name="counts-state", rest_name="counts-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-counts', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)""",
        })

    self.__counts_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counts_state(self):
    self.__counts_state = YANGDynClass(base=counts_state.counts_state, is_container='container', presence=False, yang_name="counts-state", rest_name="counts-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-counts', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)


  def _get_isis_state(self):
    """
    Getter method for isis_state, mapped from YANG variable /isis_state (container)

    YANG Description: ISIS Operational Information
    """
    return self.__isis_state
      
  def _set_isis_state(self, v, load=False):
    """
    Setter method for isis_state, mapped from YANG variable /isis_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isis_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isis_state() directly.

    YANG Description: ISIS Operational Information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=isis_state.isis_state, is_container='container', presence=False, yang_name="isis-state", rest_name="isis-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-isis', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isis_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=isis_state.isis_state, is_container='container', presence=False, yang_name="isis-state", rest_name="isis-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-isis', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)""",
        })

    self.__isis_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isis_state(self):
    self.__isis_state = YANGDynClass(base=isis_state.isis_state, is_container='container', presence=False, yang_name="isis-state", rest_name="isis-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-isis', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)


  def _get_traffic_state(self):
    """
    Getter method for traffic_state, mapped from YANG variable /traffic_state (container)

    YANG Description: IS-IS packet counts
    """
    return self.__traffic_state
      
  def _set_traffic_state(self, v, load=False):
    """
    Setter method for traffic_state, mapped from YANG variable /traffic_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_state() directly.

    YANG Description: IS-IS packet counts
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=traffic_state.traffic_state, is_container='container', presence=False, yang_name="traffic-state", rest_name="traffic-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-traffic', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=traffic_state.traffic_state, is_container='container', presence=False, yang_name="traffic-state", rest_name="traffic-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-traffic', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)""",
        })

    self.__traffic_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_state(self):
    self.__traffic_state = YANGDynClass(base=traffic_state.traffic_state, is_container='container', presence=False, yang_name="traffic-state", rest_name="traffic-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-traffic', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='container', is_config=True)


  def _get_spf_log_state(self):
    """
    Getter method for spf_log_state, mapped from YANG variable /spf_log_state (list)

    YANG Description: ISIS IPv4 or IPv6 SPF LOG information
    """
    return self.__spf_log_state
      
  def _set_spf_log_state(self, v, load=False):
    """
    Setter method for spf_log_state, mapped from YANG variable /spf_log_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spf_log_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spf_log_state() directly.

    YANG Description: ISIS IPv4 or IPv6 SPF LOG information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("spf_log_version",spf_log_state.spf_log_state, yang_name="spf-log-state", rest_name="spf-log-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='spf-log-version', extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}), is_container='list', yang_name="spf-log-state", rest_name="spf-log-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spf_log_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("spf_log_version",spf_log_state.spf_log_state, yang_name="spf-log-state", rest_name="spf-log-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='spf-log-version', extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}), is_container='list', yang_name="spf-log-state", rest_name="spf-log-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='list', is_config=True)""",
        })

    self.__spf_log_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spf_log_state(self):
    self.__spf_log_state = YANGDynClass(base=YANGListType("spf_log_version",spf_log_state.spf_log_state, yang_name="spf-log-state", rest_name="spf-log-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='spf-log-version', extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}), is_container='list', yang_name="spf-log-state", rest_name="spf-log-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'isis-spf-log', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='list', is_config=True)

  adj_neighbor_entries_state = __builtin__.property(_get_adj_neighbor_entries_state, _set_adj_neighbor_entries_state)
  counts_state = __builtin__.property(_get_counts_state, _set_counts_state)
  isis_state = __builtin__.property(_get_isis_state, _set_isis_state)
  traffic_state = __builtin__.property(_get_traffic_state, _set_traffic_state)
  spf_log_state = __builtin__.property(_get_spf_log_state, _set_spf_log_state)


  _pyangbind_elements = {'adj_neighbor_entries_state': adj_neighbor_entries_state, 'counts_state': counts_state, 'isis_state': isis_state, 'traffic_state': traffic_state, 'spf_log_state': spf_log_state, }


import vcsmode
import local_node
import vcs
class brocade_vcs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-vcs - based on the path /brocade-vcs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage  
Virtual Cluster Switching (VCS).
        
Glossary of the terms used:
--------------------------- 
VAL  - Virtual Access Layer, provided by VCS.
VCS  - Virtual Cluster Switching.
TRILL - Transparent Interconnection of Lot of Links.
TLS - Transparent LAN Services.
        
        
VCS refers to the ability of a group of physical Ethernet 
switches, inter-connected in arbitrary fashion via the regular 
front-end data ports, to present themselves as one unified and
transparent Ethernet switching service to the external network. 
The inter-connecting network that glues all these individual 
switches is refered as 'fabric', and the group of physical 
Ethernet switches in the fabric is refered to as 'cluster'. 
        
+--------+                                   +--------+
|External|                                   |External| 
|Non-VCS |                                   |Non-VCS |
|Switch  |                                   |Switch  |
+--------+                                   +--------+          
  |                                              |
  |                                              |
  |                                              |
+---+                                            |          
|   |                                            | 
|S1 |                                      ******************
+---+                                      * Logical Switch *  
  |<------ Fabric Port    \---->           *                *  
  |                       /---->           * (VCS Cluster)  *
+---+                                      ******************
|   |                                            |
|S2 |                                            |
+---+                                            |
  |<----- Edge Port                              |
  |                                              |
+-------+                                   +-------+
|Server |                                   |Server |
+-------+                                   +-------+

[Physical View]                            [Logical View]

As shown in the figure above, the fabric ports are transparent 
as far as the external devices connected to the VCS are 
concerned. In this sense the whole of the cluster behaves like 
a logical switch to the external network.         

  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__vcsmode','__local_node','__vcs',)

  _yang_name = 'brocade-vcs'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__local_node = YANGDynClass(base=local_node.local_node, is_container='container', presence=False, yang_name="local-node", rest_name="local-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)
    self.__vcs = YANGDynClass(base=vcs.vcs, is_container='container', presence=False, yang_name="vcs", rest_name="vcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Virtual Cluster Switching Configuration', u'hidden': u'full', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)
    self.__vcsmode = YANGDynClass(base=vcsmode.vcsmode, is_container='container', presence=False, yang_name="vcsmode", rest_name="vcsmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_vcsmode(self):
    """
    Getter method for vcsmode, mapped from YANG variable /vcsmode (container)
    """
    return self.__vcsmode
      
  def _set_vcsmode(self, v, load=False):
    """
    Setter method for vcsmode, mapped from YANG variable /vcsmode (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcsmode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcsmode() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=vcsmode.vcsmode, is_container='container', presence=False, yang_name="vcsmode", rest_name="vcsmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vcsmode must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vcsmode.vcsmode, is_container='container', presence=False, yang_name="vcsmode", rest_name="vcsmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)""",
        })

    self.__vcsmode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vcsmode(self):
    self.__vcsmode = YANGDynClass(base=vcsmode.vcsmode, is_container='container', presence=False, yang_name="vcsmode", rest_name="vcsmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)


  def _get_local_node(self):
    """
    Getter method for local_node, mapped from YANG variable /local_node (container)
    """
    return self.__local_node
      
  def _set_local_node(self, v, load=False):
    """
    Setter method for local_node, mapped from YANG variable /local_node (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_node() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=local_node.local_node, is_container='container', presence=False, yang_name="local-node", rest_name="local-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_node must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=local_node.local_node, is_container='container', presence=False, yang_name="local-node", rest_name="local-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)""",
        })

    self.__local_node = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_node(self):
    self.__local_node = YANGDynClass(base=local_node.local_node, is_container='container', presence=False, yang_name="local-node", rest_name="local-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'VcsModeCallpoint', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)


  def _get_vcs(self):
    """
    Getter method for vcs, mapped from YANG variable /vcs (container)
    """
    return self.__vcs
      
  def _set_vcs(self, v, load=False):
    """
    Setter method for vcs, mapped from YANG variable /vcs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcs() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=vcs.vcs, is_container='container', presence=False, yang_name="vcs", rest_name="vcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Virtual Cluster Switching Configuration', u'hidden': u'full', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vcs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vcs.vcs, is_container='container', presence=False, yang_name="vcs", rest_name="vcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Virtual Cluster Switching Configuration', u'hidden': u'full', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)""",
        })

    self.__vcs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vcs(self):
    self.__vcs = YANGDynClass(base=vcs.vcs, is_container='container', presence=False, yang_name="vcs", rest_name="vcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Virtual Cluster Switching Configuration', u'hidden': u'full', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vcs', defining_module='brocade-vcs', yang_type='container', is_config=True)

  vcsmode = __builtin__.property(_get_vcsmode, _set_vcsmode)
  local_node = __builtin__.property(_get_local_node, _set_local_node)
  vcs = __builtin__.property(_get_vcs, _set_vcs)


  _pyangbind_elements = {'vcsmode': vcsmode, 'local_node': local_node, 'vcs': vcs, }


class brocade_ip_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ip-config - based on the path /brocade-ip-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  _pyangbind_elements = {}

  

class brocade_lldp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-lldp - based on the path /brocade-lldp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage the 
'Link Layer Discovery Protocol (LLDP)'. LLDP is a data-link 
layer protocol, operating above the MAC service layer, that
performs basic neighbor discovery. The discovering process 
involves advertising of network device identity, capabilities,
and interconnections on a IEEE 802 LAN network.
        
The protocol is formally referred to by the IEEE as Station and 
Media Access Control Connectivity Discovery specified in 
standards document 802.1AB.
        
Glossary of the terms used:
--------------------------- 
FCoE - Fibre Channel over Ethernet.
DCBX - Data Center Bridging Exchange Protocol.
CEE - Converged Enhanced Ethernet.
TLV - Type Length Value.
  """
  _pyangbind_elements = {}

  

import telnet_sa
import ssh_sa
class brocade_sec_services(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-sec-services - based on the path /brocade-sec-services. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Instrument to configure Telnet Server and SSH Server
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__telnet_sa','__ssh_sa',)

  _yang_name = 'brocade-sec-services'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__telnet_sa = YANGDynClass(base=telnet_sa.telnet_sa, is_container='container', presence=False, yang_name="telnet-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_TELNET_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)
    self.__ssh_sa = YANGDynClass(base=ssh_sa.ssh_sa, is_container='container', presence=False, yang_name="ssh-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_SSH_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_telnet_sa(self):
    """
    Getter method for telnet_sa, mapped from YANG variable /telnet_sa (container)
    """
    return self.__telnet_sa
      
  def _set_telnet_sa(self, v, load=False):
    """
    Setter method for telnet_sa, mapped from YANG variable /telnet_sa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_telnet_sa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_telnet_sa() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=telnet_sa.telnet_sa, is_container='container', presence=False, yang_name="telnet-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_TELNET_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """telnet_sa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=telnet_sa.telnet_sa, is_container='container', presence=False, yang_name="telnet-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_TELNET_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)""",
        })

    self.__telnet_sa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_telnet_sa(self):
    self.__telnet_sa = YANGDynClass(base=telnet_sa.telnet_sa, is_container='container', presence=False, yang_name="telnet-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_TELNET_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)


  def _get_ssh_sa(self):
    """
    Getter method for ssh_sa, mapped from YANG variable /ssh_sa (container)
    """
    return self.__ssh_sa
      
  def _set_ssh_sa(self, v, load=False):
    """
    Setter method for ssh_sa, mapped from YANG variable /ssh_sa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh_sa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh_sa() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ssh_sa.ssh_sa, is_container='container', presence=False, yang_name="ssh-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_SSH_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh_sa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ssh_sa.ssh_sa, is_container='container', presence=False, yang_name="ssh-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_SSH_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)""",
        })

    self.__ssh_sa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh_sa(self):
    self.__ssh_sa = YANGDynClass(base=ssh_sa.ssh_sa, is_container='container', presence=False, yang_name="ssh-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_SSH_VRF'}}, namespace='urn:brocade.com:mgmt:brocade-sec-services', defining_module='brocade-sec-services', yang_type='container', is_config=True)

  telnet_sa = __builtin__.property(_get_telnet_sa, _set_telnet_sa)
  ssh_sa = __builtin__.property(_get_ssh_sa, _set_ssh_sa)


  _pyangbind_elements = {'telnet_sa': telnet_sa, 'ssh_sa': ssh_sa, }


class brocade_xstp_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-xstp-ext - based on the path /brocade-xstp-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes the data model for Spanning Tree
Protocol

Glossary of the terms used:
---------------------------
CIST   Common and Internal Spanning Tree (IEEE 802.1Q)

  """
  _pyangbind_elements = {}

  

import vcenter
class brocade_vswitch(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-vswitch - based on the path /brocade-vswitch. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management submodule is an instrumentation to 
manage Virtual switch features.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__vcenter',)

  _yang_name = 'brocade-vswitch'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__vcenter = YANGDynClass(base=YANGListType("id",vcenter.vcenter, yang_name="vcenter", rest_name="vcenter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions={u'tailf-common': {u'info': u'vCenter Configuration', u'cli-suppress-mode': None, u'sort-priority': u'95', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'vcenter_callpoint'}}), is_container='list', yang_name="vcenter", rest_name="vcenter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'vCenter Configuration', u'cli-suppress-mode': None, u'sort-priority': u'95', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'vcenter_callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-vswitch', defining_module='brocade-vswitch', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_vcenter(self):
    """
    Getter method for vcenter, mapped from YANG variable /vcenter (list)

    YANG Description: vCenter
    """
    return self.__vcenter
      
  def _set_vcenter(self, v, load=False):
    """
    Setter method for vcenter, mapped from YANG variable /vcenter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcenter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcenter() directly.

    YANG Description: vCenter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",vcenter.vcenter, yang_name="vcenter", rest_name="vcenter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions={u'tailf-common': {u'info': u'vCenter Configuration', u'cli-suppress-mode': None, u'sort-priority': u'95', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'vcenter_callpoint'}}), is_container='list', yang_name="vcenter", rest_name="vcenter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'vCenter Configuration', u'cli-suppress-mode': None, u'sort-priority': u'95', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'vcenter_callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-vswitch', defining_module='brocade-vswitch', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vcenter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",vcenter.vcenter, yang_name="vcenter", rest_name="vcenter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions={u'tailf-common': {u'info': u'vCenter Configuration', u'cli-suppress-mode': None, u'sort-priority': u'95', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'vcenter_callpoint'}}), is_container='list', yang_name="vcenter", rest_name="vcenter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'vCenter Configuration', u'cli-suppress-mode': None, u'sort-priority': u'95', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'vcenter_callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-vswitch', defining_module='brocade-vswitch', yang_type='list', is_config=True)""",
        })

    self.__vcenter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vcenter(self):
    self.__vcenter = YANGDynClass(base=YANGListType("id",vcenter.vcenter, yang_name="vcenter", rest_name="vcenter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions={u'tailf-common': {u'info': u'vCenter Configuration', u'cli-suppress-mode': None, u'sort-priority': u'95', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'vcenter_callpoint'}}), is_container='list', yang_name="vcenter", rest_name="vcenter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'vCenter Configuration', u'cli-suppress-mode': None, u'sort-priority': u'95', u'cli-suppress-list-no': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'vcenter_callpoint'}}, namespace='urn:brocade.com:mgmt:brocade-vswitch', defining_module='brocade-vswitch', yang_type='list', is_config=True)

  vcenter = __builtin__.property(_get_vcenter, _set_vcenter)


  _pyangbind_elements = {'vcenter': vcenter, }


import bridge_domain
class brocade_bridge_domain(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-bridge-domain - based on the path /brocade-bridge-domain. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage Bridge-Domain .
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__bridge_domain',)

  _yang_name = 'brocade-bridge-domain'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__bridge_domain = YANGDynClass(base=YANGListType("bridge_domain_id bridge_domain_type",bridge_domain.bridge_domain, yang_name="bridge-domain", rest_name="bridge-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bridge-domain-id bridge-domain-type', extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'sort-priority': u'106', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}), is_container='list', yang_name="bridge-domain", rest_name="bridge-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'sort-priority': u'106', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_bridge_domain(self):
    """
    Getter method for bridge_domain, mapped from YANG variable /bridge_domain (list)
    """
    return self.__bridge_domain
      
  def _set_bridge_domain(self, v, load=False):
    """
    Setter method for bridge_domain, mapped from YANG variable /bridge_domain (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bridge_domain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bridge_domain() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("bridge_domain_id bridge_domain_type",bridge_domain.bridge_domain, yang_name="bridge-domain", rest_name="bridge-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bridge-domain-id bridge-domain-type', extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'sort-priority': u'106', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}), is_container='list', yang_name="bridge-domain", rest_name="bridge-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'sort-priority': u'106', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bridge_domain must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("bridge_domain_id bridge_domain_type",bridge_domain.bridge_domain, yang_name="bridge-domain", rest_name="bridge-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bridge-domain-id bridge-domain-type', extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'sort-priority': u'106', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}), is_container='list', yang_name="bridge-domain", rest_name="bridge-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'sort-priority': u'106', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)""",
        })

    self.__bridge_domain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bridge_domain(self):
    self.__bridge_domain = YANGDynClass(base=YANGListType("bridge_domain_id bridge_domain_type",bridge_domain.bridge_domain, yang_name="bridge-domain", rest_name="bridge-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bridge-domain-id bridge-domain-type', extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'sort-priority': u'106', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}), is_container='list', yang_name="bridge-domain", rest_name="bridge-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'bridge-domain name for Node Specific configuration', u'cli-no-key-completion': None, u'sort-priority': u'106', u'cli-suppress-list-no': None, u'cli-no-match-completion': None, u'cli-full-command': None, u'callpoint': u'BridgeDomainBasicCallpoint', u'cli-mode-name': u'config-bridge-domain-$(bridge-domain-id)'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)

  bridge_domain = __builtin__.property(_get_bridge_domain, _set_bridge_domain)


  _pyangbind_elements = {'bridge_domain': bridge_domain, }


class brocade_interface_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-interface-ext - based on the path /brocade-interface-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module is an extension to interface model for 
 - Defining RPCs to retrieve interface related operational data
   in the managed device.
 
Glossary of the terms used:
--------------------------- 
HDLC - High-Level Data Link Control.
PPP  - Point-to-Point Protocol.
ATM  - Asynchronous Transfer Mode.
GBIC - Gigabit Interface Converter.
SFP  - small form-factor.
XFP  - 10 Gigabit Small Form Factor Pluggable.
xFF  -
XFP-E - XFP Extended.
ISL   - Inter switch Link.

  """
  _pyangbind_elements = {}

  

class brocade_apply_qos_mpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-apply-qos-mpls - based on the path /brocade-apply-qos-mpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages apply MPLS Quality Of Service (QOS)
  """
  _pyangbind_elements = {}

  

import bp_rate_limit
class brocade_bprate_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-bprate-limit - based on the path /brocade-bprate-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage
Bp Ratelimit module
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__bp_rate_limit',)

  _yang_name = 'brocade-bprate-limit'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__bp_rate_limit = YANGDynClass(base=bp_rate_limit.bp_rate_limit, is_container='container', presence=False, yang_name="bp-rate-limit", rest_name="bp-rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure BP Rate Limit Mode', u'hidden': u'full', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-bprate-limit', defining_module='brocade-bprate-limit', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_bp_rate_limit(self):
    """
    Getter method for bp_rate_limit, mapped from YANG variable /bp_rate_limit (container)
    """
    return self.__bp_rate_limit
      
  def _set_bp_rate_limit(self, v, load=False):
    """
    Setter method for bp_rate_limit, mapped from YANG variable /bp_rate_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bp_rate_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bp_rate_limit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bp_rate_limit.bp_rate_limit, is_container='container', presence=False, yang_name="bp-rate-limit", rest_name="bp-rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure BP Rate Limit Mode', u'hidden': u'full', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-bprate-limit', defining_module='brocade-bprate-limit', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bp_rate_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bp_rate_limit.bp_rate_limit, is_container='container', presence=False, yang_name="bp-rate-limit", rest_name="bp-rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure BP Rate Limit Mode', u'hidden': u'full', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-bprate-limit', defining_module='brocade-bprate-limit', yang_type='container', is_config=True)""",
        })

    self.__bp_rate_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bp_rate_limit(self):
    self.__bp_rate_limit = YANGDynClass(base=bp_rate_limit.bp_rate_limit, is_container='container', presence=False, yang_name="bp-rate-limit", rest_name="bp-rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure BP Rate Limit Mode', u'hidden': u'full', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-bprate-limit', defining_module='brocade-bprate-limit', yang_type='container', is_config=True)

  bp_rate_limit = __builtin__.property(_get_bp_rate_limit, _set_bp_rate_limit)


  _pyangbind_elements = {'bp_rate_limit': bp_rate_limit, }


import cluster
class brocade_mct(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mct - based on the path /brocade-mct. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage Mct .
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__cluster',)

  _yang_name = 'brocade-mct'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__cluster = YANGDynClass(base=YANGListType("cluster_name cluster_id",cluster.cluster, yang_name="cluster", rest_name="cluster", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-name cluster-id', extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'sort-priority': u'RUNNCFG_MCT_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}), is_container='list', yang_name="cluster", rest_name="cluster", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'sort-priority': u'RUNNCFG_MCT_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}, namespace='urn:brocade.com:mgmt:brocade-mct', defining_module='brocade-mct', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_cluster(self):
    """
    Getter method for cluster, mapped from YANG variable /cluster (list)
    """
    return self.__cluster
      
  def _set_cluster(self, v, load=False):
    """
    Setter method for cluster, mapped from YANG variable /cluster (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cluster is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cluster() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("cluster_name cluster_id",cluster.cluster, yang_name="cluster", rest_name="cluster", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-name cluster-id', extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'sort-priority': u'RUNNCFG_MCT_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}), is_container='list', yang_name="cluster", rest_name="cluster", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'sort-priority': u'RUNNCFG_MCT_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}, namespace='urn:brocade.com:mgmt:brocade-mct', defining_module='brocade-mct', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cluster must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("cluster_name cluster_id",cluster.cluster, yang_name="cluster", rest_name="cluster", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-name cluster-id', extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'sort-priority': u'RUNNCFG_MCT_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}), is_container='list', yang_name="cluster", rest_name="cluster", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'sort-priority': u'RUNNCFG_MCT_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}, namespace='urn:brocade.com:mgmt:brocade-mct', defining_module='brocade-mct', yang_type='list', is_config=True)""",
        })

    self.__cluster = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cluster(self):
    self.__cluster = YANGDynClass(base=YANGListType("cluster_name cluster_id",cluster.cluster, yang_name="cluster", rest_name="cluster", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-name cluster-id', extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'sort-priority': u'RUNNCFG_MCT_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}), is_container='list', yang_name="cluster", rest_name="cluster", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u' MCT Cluster Specific configuration', u'sort-priority': u'RUNNCFG_MCT_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'callpoint': u'MctBasicCallpoint', u'cli-mode-name': u'config-cluster-$(cluster-id)'}}, namespace='urn:brocade.com:mgmt:brocade-mct', defining_module='brocade-mct', yang_type='list', is_config=True)

  cluster = __builtin__.property(_get_cluster, _set_cluster)


  _pyangbind_elements = {'cluster': cluster, }


class brocade_entity(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-entity - based on the path /brocade-entity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage 
all physical and logical entities in the managed device.
  """
  _pyangbind_elements = {}

  

class brocade_intf_loopback(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-intf-loopback - based on the path /brocade-intf-loopback. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Module for implementing Interface Loopback CLIs
  """
  _pyangbind_elements = {}

  

import copy
import logging
import destination_console
import system_ras
import support
import logtest
class brocade_ras(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ras - based on the path /brocade-ras. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to log collection 
 like supportsave,copy support and USB management
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__copy','__logging','__destination_console','__system_ras','__support','__logtest',)

  _yang_name = 'brocade-ras'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__logging = YANGDynClass(base=logging.logging, is_container='container', presence=False, yang_name="logging", rest_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Logging configuration: raslog/syslog'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)
    self.__support = YANGDynClass(base=support.support, is_container='container', presence=False, yang_name="support", rest_name="support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Support configuration', u'callpoint': u'RASGlobalConfigCallPoint'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)
    self.__logtest = YANGDynClass(base=logtest.logtest, is_container='container', presence=False, yang_name="logtest", rest_name="logtest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'hidden': u'debug'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)
    self.__system_ras = YANGDynClass(base=system_ras.system_ras, is_container='container', presence=False, yang_name="system-ras", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)
    self.__destination_console = YANGDynClass(base=destination_console.destination_console, is_container='container', presence=False, yang_name="destination_console", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)
    self.__copy = YANGDynClass(base=copy.copy, is_container='container', presence=False, yang_name="copy", rest_name="copy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'RAS copy operation', u'action': u'support-interactive'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_copy(self):
    """
    Getter method for copy, mapped from YANG variable /copy (container)
    """
    return self.__copy
      
  def _set_copy(self, v, load=False):
    """
    Setter method for copy, mapped from YANG variable /copy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_copy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_copy() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=copy.copy, is_container='container', presence=False, yang_name="copy", rest_name="copy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'RAS copy operation', u'action': u'support-interactive'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """copy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=copy.copy, is_container='container', presence=False, yang_name="copy", rest_name="copy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'RAS copy operation', u'action': u'support-interactive'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)""",
        })

    self.__copy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_copy(self):
    self.__copy = YANGDynClass(base=copy.copy, is_container='container', presence=False, yang_name="copy", rest_name="copy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'RAS copy operation', u'action': u'support-interactive'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)


  def _get_logging(self):
    """
    Getter method for logging, mapped from YANG variable /logging (container)
    """
    return self.__logging
      
  def _set_logging(self, v, load=False):
    """
    Setter method for logging, mapped from YANG variable /logging (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=logging.logging, is_container='container', presence=False, yang_name="logging", rest_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Logging configuration: raslog/syslog'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logging.logging, is_container='container', presence=False, yang_name="logging", rest_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Logging configuration: raslog/syslog'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)""",
        })

    self.__logging = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging(self):
    self.__logging = YANGDynClass(base=logging.logging, is_container='container', presence=False, yang_name="logging", rest_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Logging configuration: raslog/syslog'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)


  def _get_destination_console(self):
    """
    Getter method for destination_console, mapped from YANG variable /destination_console (container)
    """
    return self.__destination_console
      
  def _set_destination_console(self, v, load=False):
    """
    Setter method for destination_console, mapped from YANG variable /destination_console (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_console is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_console() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=destination_console.destination_console, is_container='container', presence=False, yang_name="destination_console", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_console must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=destination_console.destination_console, is_container='container', presence=False, yang_name="destination_console", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)""",
        })

    self.__destination_console = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_console(self):
    self.__destination_console = YANGDynClass(base=destination_console.destination_console, is_container='container', presence=False, yang_name="destination_console", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)


  def _get_system_ras(self):
    """
    Getter method for system_ras, mapped from YANG variable /system_ras (container)
    """
    return self.__system_ras
      
  def _set_system_ras(self, v, load=False):
    """
    Setter method for system_ras, mapped from YANG variable /system_ras (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_ras is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_ras() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=system_ras.system_ras, is_container='container', presence=False, yang_name="system-ras", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_ras must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=system_ras.system_ras, is_container='container', presence=False, yang_name="system-ras", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)""",
        })

    self.__system_ras = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_ras(self):
    self.__system_ras = YANGDynClass(base=system_ras.system_ras, is_container='container', presence=False, yang_name="system-ras", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)


  def _get_support(self):
    """
    Getter method for support, mapped from YANG variable /support (container)
    """
    return self.__support
      
  def _set_support(self, v, load=False):
    """
    Setter method for support, mapped from YANG variable /support (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_support is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_support() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=support.support, is_container='container', presence=False, yang_name="support", rest_name="support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Support configuration', u'callpoint': u'RASGlobalConfigCallPoint'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """support must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=support.support, is_container='container', presence=False, yang_name="support", rest_name="support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Support configuration', u'callpoint': u'RASGlobalConfigCallPoint'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)""",
        })

    self.__support = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_support(self):
    self.__support = YANGDynClass(base=support.support, is_container='container', presence=False, yang_name="support", rest_name="support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Support configuration', u'callpoint': u'RASGlobalConfigCallPoint'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)


  def _get_logtest(self):
    """
    Getter method for logtest, mapped from YANG variable /logtest (container)
    """
    return self.__logtest
      
  def _set_logtest(self, v, load=False):
    """
    Setter method for logtest, mapped from YANG variable /logtest (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logtest is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logtest() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=logtest.logtest, is_container='container', presence=False, yang_name="logtest", rest_name="logtest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'hidden': u'debug'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logtest must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logtest.logtest, is_container='container', presence=False, yang_name="logtest", rest_name="logtest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'hidden': u'debug'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)""",
        })

    self.__logtest = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logtest(self):
    self.__logtest = YANGDynClass(base=logtest.logtest, is_container='container', presence=False, yang_name="logtest", rest_name="logtest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'hidden': u'debug'}}, namespace='urn:brocade.com:mgmt:brocade-ras', defining_module='brocade-ras', yang_type='container', is_config=True)

  copy = __builtin__.property(_get_copy, _set_copy)
  logging = __builtin__.property(_get_logging, _set_logging)
  destination_console = __builtin__.property(_get_destination_console, _set_destination_console)
  system_ras = __builtin__.property(_get_system_ras, _set_system_ras)
  support = __builtin__.property(_get_support, _set_support)
  logtest = __builtin__.property(_get_logtest, _set_logtest)


  _pyangbind_elements = {'copy': copy, 'logging': logging, 'destination_console': destination_console, 'system_ras': system_ras, 'support': support, 'logtest': logtest, }


import qos_mpls
class brocade_qos_mpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-qos-mpls - based on the path /brocade-qos-mpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages MPLS Quality Of Service (QOS)
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__qos_mpls',)

  _yang_name = 'brocade-qos-mpls'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__qos_mpls = YANGDynClass(base=qos_mpls.qos_mpls, is_container='container', presence=False, yang_name="qos-mpls", rest_name="qos-mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MPLS Quality of Service (QoS)', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_MPLS_QOS'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mpls', defining_module='brocade-qos-mpls', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_qos_mpls(self):
    """
    Getter method for qos_mpls, mapped from YANG variable /qos_mpls (container)
    """
    return self.__qos_mpls
      
  def _set_qos_mpls(self, v, load=False):
    """
    Setter method for qos_mpls, mapped from YANG variable /qos_mpls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos_mpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos_mpls() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=qos_mpls.qos_mpls, is_container='container', presence=False, yang_name="qos-mpls", rest_name="qos-mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MPLS Quality of Service (QoS)', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_MPLS_QOS'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mpls', defining_module='brocade-qos-mpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos_mpls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=qos_mpls.qos_mpls, is_container='container', presence=False, yang_name="qos-mpls", rest_name="qos-mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MPLS Quality of Service (QoS)', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_MPLS_QOS'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mpls', defining_module='brocade-qos-mpls', yang_type='container', is_config=True)""",
        })

    self.__qos_mpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos_mpls(self):
    self.__qos_mpls = YANGDynClass(base=qos_mpls.qos_mpls, is_container='container', presence=False, yang_name="qos-mpls", rest_name="qos-mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MPLS Quality of Service (QoS)', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_MPLS_QOS'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mpls', defining_module='brocade-qos-mpls', yang_type='container', is_config=True)

  qos_mpls = __builtin__.property(_get_qos_mpls, _set_qos_mpls)


  _pyangbind_elements = {'qos_mpls': qos_mpls, }


import diag
class brocade_diagnostics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-diagnostics - based on the path /brocade-diagnostics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Modules for entities implementing FOS Diagnostics
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__diag',)

  _yang_name = 'brocade-diagnostics'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__diag = YANGDynClass(base=diag.diag, is_container='container', presence=False, yang_name="diag", rest_name="diag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Commands to manage diagnostic activities', u'action': u'setdbg', u'display-when': u'((/local-node/swbd-number = "131"))'}}, namespace='urn:brocade.com:mgmt:brocade-diagnostics', defining_module='brocade-diagnostics', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_diag(self):
    """
    Getter method for diag, mapped from YANG variable /diag (container)
    """
    return self.__diag
      
  def _set_diag(self, v, load=False):
    """
    Setter method for diag, mapped from YANG variable /diag (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_diag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_diag() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=diag.diag, is_container='container', presence=False, yang_name="diag", rest_name="diag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Commands to manage diagnostic activities', u'action': u'setdbg', u'display-when': u'((/local-node/swbd-number = "131"))'}}, namespace='urn:brocade.com:mgmt:brocade-diagnostics', defining_module='brocade-diagnostics', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """diag must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=diag.diag, is_container='container', presence=False, yang_name="diag", rest_name="diag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Commands to manage diagnostic activities', u'action': u'setdbg', u'display-when': u'((/local-node/swbd-number = "131"))'}}, namespace='urn:brocade.com:mgmt:brocade-diagnostics', defining_module='brocade-diagnostics', yang_type='container', is_config=True)""",
        })

    self.__diag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_diag(self):
    self.__diag = YANGDynClass(base=diag.diag, is_container='container', presence=False, yang_name="diag", rest_name="diag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Commands to manage diagnostic activities', u'action': u'setdbg', u'display-when': u'((/local-node/swbd-number = "131"))'}}, namespace='urn:brocade.com:mgmt:brocade-diagnostics', defining_module='brocade-diagnostics', yang_type='container', is_config=True)

  diag = __builtin__.property(_get_diag, _set_diag)


  _pyangbind_elements = {'diag': diag, }


import preprovision
class brocade_preprovision(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-preprovision - based on the path /brocade-preprovision. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage preprovision
feature.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__preprovision',)

  _yang_name = 'brocade-preprovision'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__preprovision = YANGDynClass(base=preprovision.preprovision, is_container='container', presence=False, yang_name="preprovision", rest_name="preprovision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Preprovision profile', u'hidden': u'full', u'display-when': u'((/vcsmode/vcs-mode = "true") and (/vcsmode/vcs-cluster-mode = "true"))', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-preprovision', defining_module='brocade-preprovision', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_preprovision(self):
    """
    Getter method for preprovision, mapped from YANG variable /preprovision (container)

    YANG Description: Preprovision profile
    """
    return self.__preprovision
      
  def _set_preprovision(self, v, load=False):
    """
    Setter method for preprovision, mapped from YANG variable /preprovision (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preprovision is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preprovision() directly.

    YANG Description: Preprovision profile
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=preprovision.preprovision, is_container='container', presence=False, yang_name="preprovision", rest_name="preprovision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Preprovision profile', u'hidden': u'full', u'display-when': u'((/vcsmode/vcs-mode = "true") and (/vcsmode/vcs-cluster-mode = "true"))', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-preprovision', defining_module='brocade-preprovision', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preprovision must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=preprovision.preprovision, is_container='container', presence=False, yang_name="preprovision", rest_name="preprovision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Preprovision profile', u'hidden': u'full', u'display-when': u'((/vcsmode/vcs-mode = "true") and (/vcsmode/vcs-cluster-mode = "true"))', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-preprovision', defining_module='brocade-preprovision', yang_type='container', is_config=True)""",
        })

    self.__preprovision = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preprovision(self):
    self.__preprovision = YANGDynClass(base=preprovision.preprovision, is_container='container', presence=False, yang_name="preprovision", rest_name="preprovision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Preprovision profile', u'hidden': u'full', u'display-when': u'((/vcsmode/vcs-mode = "true") and (/vcsmode/vcs-cluster-mode = "true"))', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-preprovision', defining_module='brocade-preprovision', yang_type='container', is_config=True)

  preprovision = __builtin__.property(_get_preprovision, _set_preprovision)


  _pyangbind_elements = {'preprovision': preprovision, }


import interface
import interface_vlan
import protocol
class brocade_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-interface - based on the path /brocade-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage  
ethernet network interfaces sub-layers.
        
The following ethernet interfaces can be managed using this 
management module:
        
+--------------------------------------------------------------+
| List name                  Description                       |
+--------------------------------------------------------------+
| ethernet                   Physical Ethernet interfaces      |
| port-channel               Port-channel/LAG interfaces       |
| management                 Management port/interfaces        |
| vlan                       L2 Vlan interface.                |
+--------------------------------------------------------------+
        
This module provides mechanism:
   - to discover and characterize the interface sub-layers.
   - to configure various attributes of these interfaces.
   - to structure the interfaces such that various L2/L3 
   access/security policies, network discovery policies, QoS 
   policies and Link aggregation policies can be applied using 
   other modules supported by the managed entity.
        
Glossary of the terms used:
--------------------------- 
TRILL   - Transparent Interconnection of Lots of Links.
VLAN    - Virtual Local Area Network.
ISL     - Inter switch Link.
MTU     - Maximum transmission unit. The size of the largest 
         packet which can be sent/received on an interface.
LAG     - IEEE Link Aggregation (IEEE 802.1AX).
vLAG    - virtual LAG.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__interface','__interface_vlan','__protocol',)

  _yang_name = 'brocade-interface'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__interface = YANGDynClass(base=interface.interface, is_container='container', presence=False, yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'All the interface related configurations/data.', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)
    self.__protocol = YANGDynClass(base=protocol.protocol, is_container='container', presence=False, yang_name="protocol", rest_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Protocol Configuration', u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L2_CONFIG', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)
    self.__interface_vlan = YANGDynClass(base=interface_vlan.interface_vlan, is_container='container', presence=False, yang_name="interface-vlan", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_VLAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interface (container)

    YANG Description: All the interface related elements of this managed device
grouped under this container.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interface (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: All the interface related elements of this managed device
grouped under this container.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface.interface, is_container='container', presence=False, yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'All the interface related configurations/data.', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface.interface, is_container='container', presence=False, yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'All the interface related configurations/data.', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=interface.interface, is_container='container', presence=False, yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'All the interface related configurations/data.', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)


  def _get_interface_vlan(self):
    """
    Getter method for interface_vlan, mapped from YANG variable /interface_vlan (container)

    YANG Description: An intermediary node that separates the vlan related 
elements of this managed device.
    """
    return self.__interface_vlan
      
  def _set_interface_vlan(self, v, load=False):
    """
    Setter method for interface_vlan, mapped from YANG variable /interface_vlan (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_vlan() directly.

    YANG Description: An intermediary node that separates the vlan related 
elements of this managed device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_vlan.interface_vlan, is_container='container', presence=False, yang_name="interface-vlan", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_VLAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_vlan must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_vlan.interface_vlan, is_container='container', presence=False, yang_name="interface-vlan", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_VLAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)""",
        })

    self.__interface_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_vlan(self):
    self.__interface_vlan = YANGDynClass(base=interface_vlan.interface_vlan, is_container='container', presence=False, yang_name="interface-vlan", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'RUNNCFG_LEVEL_INTERFACE_VLAN_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /protocol (container)
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /protocol (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=protocol.protocol, is_container='container', presence=False, yang_name="protocol", rest_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Protocol Configuration', u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L2_CONFIG', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=protocol.protocol, is_container='container', presence=False, yang_name="protocol", rest_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Protocol Configuration', u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L2_CONFIG', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=protocol.protocol, is_container='container', presence=False, yang_name="protocol", rest_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Protocol Configuration', u'sort-priority': u'RUNNCFG_LEVEL_PROTOCOL_L2_CONFIG', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-interface', defining_module='brocade-interface', yang_type='container', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)
  interface_vlan = __builtin__.property(_get_interface_vlan, _set_interface_vlan)
  protocol = __builtin__.property(_get_protocol, _set_protocol)


  _pyangbind_elements = {'interface': interface, 'interface_vlan': interface_vlan, 'protocol': protocol, }


import qos
class brocade_qos_mls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-qos-mls - based on the path /brocade-qos-mls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages Multi Layer Switching(MLS) Quality Of Service (QOS)
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__qos',)

  _yang_name = 'brocade-qos-mls'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', presence=False, yang_name="qos", rest_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Quality of Service (QoS)', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_QOS'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mls', defining_module='brocade-qos-mls', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_qos(self):
    """
    Getter method for qos, mapped from YANG variable /qos (container)
    """
    return self.__qos
      
  def _set_qos(self, v, load=False):
    """
    Setter method for qos, mapped from YANG variable /qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=qos.qos, is_container='container', presence=False, yang_name="qos", rest_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Quality of Service (QoS)', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_QOS'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mls', defining_module='brocade-qos-mls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=qos.qos, is_container='container', presence=False, yang_name="qos", rest_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Quality of Service (QoS)', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_QOS'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mls', defining_module='brocade-qos-mls', yang_type='container', is_config=True)""",
        })

    self.__qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos(self):
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', presence=False, yang_name="qos", rest_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Quality of Service (QoS)', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_QOS'}}, namespace='urn:brocade.com:mgmt:brocade-qos-mls', defining_module='brocade-qos-mls', yang_type='container', is_config=True)

  qos = __builtin__.property(_get_qos, _set_qos)


  _pyangbind_elements = {'qos': qos, }


import rbridge_id
class brocade_rbridge(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-rbridge - based on the path /brocade-rbridge. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage 
rbridge-id feature.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__rbridge_id',)

  _yang_name = 'brocade-rbridge'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__rbridge_id = YANGDynClass(base=YANGListType("rbridge_id",rbridge_id.rbridge_id, yang_name="rbridge-id", rest_name="rbridge-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='rbridge-id', extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}), is_container='list', yang_name="rbridge-id", rest_name="rbridge-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}, namespace='urn:brocade.com:mgmt:brocade-rbridge', defining_module='brocade-rbridge', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_rbridge_id(self):
    """
    Getter method for rbridge_id, mapped from YANG variable /rbridge_id (list)
    """
    return self.__rbridge_id
      
  def _set_rbridge_id(self, v, load=False):
    """
    Setter method for rbridge_id, mapped from YANG variable /rbridge_id (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rbridge_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rbridge_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("rbridge_id",rbridge_id.rbridge_id, yang_name="rbridge-id", rest_name="rbridge-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='rbridge-id', extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}), is_container='list', yang_name="rbridge-id", rest_name="rbridge-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}, namespace='urn:brocade.com:mgmt:brocade-rbridge', defining_module='brocade-rbridge', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rbridge_id must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("rbridge_id",rbridge_id.rbridge_id, yang_name="rbridge-id", rest_name="rbridge-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='rbridge-id', extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}), is_container='list', yang_name="rbridge-id", rest_name="rbridge-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}, namespace='urn:brocade.com:mgmt:brocade-rbridge', defining_module='brocade-rbridge', yang_type='list', is_config=True)""",
        })

    self.__rbridge_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rbridge_id(self):
    self.__rbridge_id = YANGDynClass(base=YANGListType("rbridge_id",rbridge_id.rbridge_id, yang_name="rbridge-id", rest_name="rbridge-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='rbridge-id', extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}), is_container='list', yang_name="rbridge-id", rest_name="rbridge-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Rbridge Id for Node Specific configuration', u'callpoint': u'vcsnodespecificcallpoint', u'sort-priority': u'RUNNCFG_LEVEL_RBRIDGE', u'cli-suppress-no': None, u'display-when': u'/vcsmode/vcs-mode = "true"'}}, namespace='urn:brocade.com:mgmt:brocade-rbridge', defining_module='brocade-rbridge', yang_type='list', is_config=True)

  rbridge_id = __builtin__.property(_get_rbridge_id, _set_rbridge_id)


  _pyangbind_elements = {'rbridge_id': rbridge_id, }


import dpod
class brocade_license(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-license - based on the path /brocade-license. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management sub-module is an instrumentation to manage
the licenses in the VCS fabric.

Glossary of the terms used:
---------------------------
DPOD        -   Dynamic ports on demand
licStr      -   License string (i.e., license key)
POD         -   Ports on demand


  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__dpod',)

  _yang_name = 'brocade-license'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__dpod = YANGDynClass(base=dpod.dpod, is_container='container', presence=False, yang_name="dpod", rest_name="dpod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Manage and display DPOD license assignments.\nUsage: dpod [slot/port] [reserve|release]', u'display-when': u'(/c:capabilities/c:license/c:dpod_display = "true")'}}, namespace='urn:brocade.com:mgmt:brocade-license', defining_module='brocade-license', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_dpod(self):
    """
    Getter method for dpod, mapped from YANG variable /dpod (container)
    """
    return self.__dpod
      
  def _set_dpod(self, v, load=False):
    """
    Setter method for dpod, mapped from YANG variable /dpod (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dpod is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dpod() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=dpod.dpod, is_container='container', presence=False, yang_name="dpod", rest_name="dpod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Manage and display DPOD license assignments.\nUsage: dpod [slot/port] [reserve|release]', u'display-when': u'(/c:capabilities/c:license/c:dpod_display = "true")'}}, namespace='urn:brocade.com:mgmt:brocade-license', defining_module='brocade-license', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dpod must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dpod.dpod, is_container='container', presence=False, yang_name="dpod", rest_name="dpod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Manage and display DPOD license assignments.\nUsage: dpod [slot/port] [reserve|release]', u'display-when': u'(/c:capabilities/c:license/c:dpod_display = "true")'}}, namespace='urn:brocade.com:mgmt:brocade-license', defining_module='brocade-license', yang_type='container', is_config=True)""",
        })

    self.__dpod = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dpod(self):
    self.__dpod = YANGDynClass(base=dpod.dpod, is_container='container', presence=False, yang_name="dpod", rest_name="dpod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Manage and display DPOD license assignments.\nUsage: dpod [slot/port] [reserve|release]', u'display-when': u'(/c:capabilities/c:license/c:dpod_display = "true")'}}, namespace='urn:brocade.com:mgmt:brocade-license', defining_module='brocade-license', yang_type='container', is_config=True)

  dpod = __builtin__.property(_get_dpod, _set_dpod)


  _pyangbind_elements = {'dpod': dpod, }


class brocade_icmp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-icmp - based on the path /brocade-icmp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides interface to provision icmp configuration on interfaces
  """
  _pyangbind_elements = {}

  

import vrrp_global
import protocol_vrrpv3
class brocade_vrrpv3(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-vrrpv3 - based on the path /brocade-vrrpv3. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes the data model for Virtual Router Redundancy Protocol
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__vrrp_global','__protocol_vrrpv3',)

  _yang_name = 'brocade-vrrpv3'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__protocol_vrrpv3 = YANGDynClass(base=protocol_vrrpv3.protocol_vrrpv3, is_container='container', presence=False, yang_name="protocol-vrrpv3", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'40'}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)
    self.__vrrp_global = YANGDynClass(base=vrrp_global.vrrp_global, is_container='container', presence=False, yang_name="vrrp-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'vrrpv3GlobalConf', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_vrrp_global(self):
    """
    Getter method for vrrp_global, mapped from YANG variable /vrrp_global (container)
    """
    return self.__vrrp_global
      
  def _set_vrrp_global(self, v, load=False):
    """
    Setter method for vrrp_global, mapped from YANG variable /vrrp_global (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrrp_global is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrrp_global() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=vrrp_global.vrrp_global, is_container='container', presence=False, yang_name="vrrp-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'vrrpv3GlobalConf', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrrp_global must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vrrp_global.vrrp_global, is_container='container', presence=False, yang_name="vrrp-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'vrrpv3GlobalConf', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)""",
        })

    self.__vrrp_global = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrrp_global(self):
    self.__vrrp_global = YANGDynClass(base=vrrp_global.vrrp_global, is_container='container', presence=False, yang_name="vrrp-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'callpoint': u'vrrpv3GlobalConf', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)


  def _get_protocol_vrrpv3(self):
    """
    Getter method for protocol_vrrpv3, mapped from YANG variable /protocol_vrrpv3 (container)

    YANG Description: An intermediary node that separates the protocol vrrpv3 from other protocols.
    """
    return self.__protocol_vrrpv3
      
  def _set_protocol_vrrpv3(self, v, load=False):
    """
    Setter method for protocol_vrrpv3, mapped from YANG variable /protocol_vrrpv3 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_vrrpv3 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_vrrpv3() directly.

    YANG Description: An intermediary node that separates the protocol vrrpv3 from other protocols.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=protocol_vrrpv3.protocol_vrrpv3, is_container='container', presence=False, yang_name="protocol-vrrpv3", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'40'}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_vrrpv3 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=protocol_vrrpv3.protocol_vrrpv3, is_container='container', presence=False, yang_name="protocol-vrrpv3", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'40'}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)""",
        })

    self.__protocol_vrrpv3 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_vrrpv3(self):
    self.__protocol_vrrpv3 = YANGDynClass(base=protocol_vrrpv3.protocol_vrrpv3, is_container='container', presence=False, yang_name="protocol-vrrpv3", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'40'}}, namespace='urn:brocade.com:mgmt:brocade-vrrpv3', defining_module='brocade-vrrpv3', yang_type='container', is_config=True)

  vrrp_global = __builtin__.property(_get_vrrp_global, _set_vrrp_global)
  protocol_vrrpv3 = __builtin__.property(_get_protocol_vrrpv3, _set_protocol_vrrpv3)


  _pyangbind_elements = {'vrrp_global': vrrp_global, 'protocol_vrrpv3': protocol_vrrpv3, }


class brocade_isis(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-isis - based on the path /brocade-isis. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage
ISIS Protocol.
  """
  _pyangbind_elements = {}

  

class brocade_dot3ah(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-dot3ah - based on the path /brocade-dot3ah. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage
Link OAM Protocol.
  """
  _pyangbind_elements = {}

  

class brocade_ospfv3(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ospfv3 - based on the path /brocade-ospfv3. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage OSPF Version 3 Protocol.
  """
  _pyangbind_elements = {}

  

class brocade_system_monitor_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-system-monitor-ext - based on the path /brocade-system-monitor-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub module defines show system-monitor data model
Copyright (c) 2011 by Brocade Communications Systems, Inc.
All rights reserved.
  """
  _pyangbind_elements = {}

  

import pw_profile
class brocade_pw_profile(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-pw-profile - based on the path /brocade-pw-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage PW-Profile .
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__pw_profile',)

  _yang_name = 'brocade-pw-profile'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__pw_profile = YANGDynClass(base=YANGListType("pw_profile_name",pw_profile.pw_profile, yang_name="pw-profile", rest_name="pw-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='pw-profile-name', extensions={u'tailf-common': {u'info': u'pw-profile for Node Specific configuration', u'callpoint': u'PWProfileBasicCallpoint', u'cli-mode-name': u'config-pw-profile-$(pw-profile-name)'}}), is_container='list', yang_name="pw-profile", rest_name="pw-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'pw-profile for Node Specific configuration', u'callpoint': u'PWProfileBasicCallpoint', u'cli-mode-name': u'config-pw-profile-$(pw-profile-name)'}}, namespace='urn:brocade.com:mgmt:brocade-pw-profile', defining_module='brocade-pw-profile', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_pw_profile(self):
    """
    Getter method for pw_profile, mapped from YANG variable /pw_profile (list)
    """
    return self.__pw_profile
      
  def _set_pw_profile(self, v, load=False):
    """
    Setter method for pw_profile, mapped from YANG variable /pw_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pw_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pw_profile() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("pw_profile_name",pw_profile.pw_profile, yang_name="pw-profile", rest_name="pw-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='pw-profile-name', extensions={u'tailf-common': {u'info': u'pw-profile for Node Specific configuration', u'callpoint': u'PWProfileBasicCallpoint', u'cli-mode-name': u'config-pw-profile-$(pw-profile-name)'}}), is_container='list', yang_name="pw-profile", rest_name="pw-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'pw-profile for Node Specific configuration', u'callpoint': u'PWProfileBasicCallpoint', u'cli-mode-name': u'config-pw-profile-$(pw-profile-name)'}}, namespace='urn:brocade.com:mgmt:brocade-pw-profile', defining_module='brocade-pw-profile', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pw_profile must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("pw_profile_name",pw_profile.pw_profile, yang_name="pw-profile", rest_name="pw-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='pw-profile-name', extensions={u'tailf-common': {u'info': u'pw-profile for Node Specific configuration', u'callpoint': u'PWProfileBasicCallpoint', u'cli-mode-name': u'config-pw-profile-$(pw-profile-name)'}}), is_container='list', yang_name="pw-profile", rest_name="pw-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'pw-profile for Node Specific configuration', u'callpoint': u'PWProfileBasicCallpoint', u'cli-mode-name': u'config-pw-profile-$(pw-profile-name)'}}, namespace='urn:brocade.com:mgmt:brocade-pw-profile', defining_module='brocade-pw-profile', yang_type='list', is_config=True)""",
        })

    self.__pw_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pw_profile(self):
    self.__pw_profile = YANGDynClass(base=YANGListType("pw_profile_name",pw_profile.pw_profile, yang_name="pw-profile", rest_name="pw-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='pw-profile-name', extensions={u'tailf-common': {u'info': u'pw-profile for Node Specific configuration', u'callpoint': u'PWProfileBasicCallpoint', u'cli-mode-name': u'config-pw-profile-$(pw-profile-name)'}}), is_container='list', yang_name="pw-profile", rest_name="pw-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'pw-profile for Node Specific configuration', u'callpoint': u'PWProfileBasicCallpoint', u'cli-mode-name': u'config-pw-profile-$(pw-profile-name)'}}, namespace='urn:brocade.com:mgmt:brocade-pw-profile', defining_module='brocade-pw-profile', yang_type='list', is_config=True)

  pw_profile = __builtin__.property(_get_pw_profile, _set_pw_profile)


  _pyangbind_elements = {'pw_profile': pw_profile, }


import mpls_config
class brocade_mpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls - based on the path /brocade-mpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage
mpls protocol.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__mpls_config',)

  _yang_name = 'brocade-mpls'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__mpls_config = YANGDynClass(base=mpls_config.mpls_config, is_container='container', presence=False, yang_name="mpls-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'146'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_mpls_config(self):
    """
    Getter method for mpls_config, mapped from YANG variable /mpls_config (container)
    """
    return self.__mpls_config
      
  def _set_mpls_config(self, v, load=False):
    """
    Setter method for mpls_config, mapped from YANG variable /mpls_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mpls_config.mpls_config, is_container='container', presence=False, yang_name="mpls-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'146'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mpls_config.mpls_config, is_container='container', presence=False, yang_name="mpls-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'146'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)""",
        })

    self.__mpls_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_config(self):
    self.__mpls_config = YANGDynClass(base=mpls_config.mpls_config, is_container='container', presence=False, yang_name="mpls-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'146'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)

  mpls_config = __builtin__.property(_get_mpls_config, _set_mpls_config)


  _pyangbind_elements = {'mpls_config': mpls_config, }


import dai_config
class brocade_dai(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-dai - based on the path /brocade-dai. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management sub-module contains the configuration
and rpc implementaion for IP Access-list.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__dai_config',)

  _yang_name = 'brocade-dai'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__dai_config = YANGDynClass(base=dai_config.dai_config, is_container='container', presence=False, yang_name="dai-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-dai', defining_module='brocade-dai', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_dai_config(self):
    """
    Getter method for dai_config, mapped from YANG variable /dai_config (container)
    """
    return self.__dai_config
      
  def _set_dai_config(self, v, load=False):
    """
    Setter method for dai_config, mapped from YANG variable /dai_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dai_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dai_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=dai_config.dai_config, is_container='container', presence=False, yang_name="dai-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-dai', defining_module='brocade-dai', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dai_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dai_config.dai_config, is_container='container', presence=False, yang_name="dai-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-dai', defining_module='brocade-dai', yang_type='container', is_config=True)""",
        })

    self.__dai_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dai_config(self):
    self.__dai_config = YANGDynClass(base=dai_config.dai_config, is_container='container', presence=False, yang_name="dai-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-dai', defining_module='brocade-dai', yang_type='container', is_config=True)

  dai_config = __builtin__.property(_get_dai_config, _set_dai_config)


  _pyangbind_elements = {'dai_config': dai_config, }


class brocade_pld(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-pld - based on the path /brocade-pld. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages port link dampening (PLD)
  """
  _pyangbind_elements = {}

  

import hide_filter_change_update_delay_holder
class brocade_ip_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ip-policy - based on the path /brocade-ip-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage 
different IP routing protocols.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__hide_filter_change_update_delay_holder',)

  _yang_name = 'brocade-ip-policy'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__hide_filter_change_update_delay_holder = YANGDynClass(base=hide_filter_change_update_delay_holder.hide_filter_change_update_delay_holder, is_container='container', presence=False, yang_name="hide-filter-change-update-delay-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-ip-policy', defining_module='brocade-ip-policy', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_hide_filter_change_update_delay_holder(self):
    """
    Getter method for hide_filter_change_update_delay_holder, mapped from YANG variable /hide_filter_change_update_delay_holder (container)
    """
    return self.__hide_filter_change_update_delay_holder
      
  def _set_hide_filter_change_update_delay_holder(self, v, load=False):
    """
    Setter method for hide_filter_change_update_delay_holder, mapped from YANG variable /hide_filter_change_update_delay_holder (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hide_filter_change_update_delay_holder is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hide_filter_change_update_delay_holder() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=hide_filter_change_update_delay_holder.hide_filter_change_update_delay_holder, is_container='container', presence=False, yang_name="hide-filter-change-update-delay-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-ip-policy', defining_module='brocade-ip-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hide_filter_change_update_delay_holder must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=hide_filter_change_update_delay_holder.hide_filter_change_update_delay_holder, is_container='container', presence=False, yang_name="hide-filter-change-update-delay-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-ip-policy', defining_module='brocade-ip-policy', yang_type='container', is_config=True)""",
        })

    self.__hide_filter_change_update_delay_holder = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hide_filter_change_update_delay_holder(self):
    self.__hide_filter_change_update_delay_holder = YANGDynClass(base=hide_filter_change_update_delay_holder.hide_filter_change_update_delay_holder, is_container='container', presence=False, yang_name="hide-filter-change-update-delay-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-ip-policy', defining_module='brocade-ip-policy', yang_type='container', is_config=True)

  hide_filter_change_update_delay_holder = __builtin__.property(_get_hide_filter_change_update_delay_holder, _set_hide_filter_change_update_delay_holder)


  _pyangbind_elements = {'hide_filter_change_update_delay_holder': hide_filter_change_update_delay_holder, }


import hide_virtual_ip_holder
import chassis
class brocade_chassis(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-chassis - based on the path /brocade-chassis. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Module for implementing switch configurable
enable/disable CLIs
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__hide_virtual_ip_holder','__chassis',)

  _yang_name = 'brocade-chassis'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__hide_virtual_ip_holder = YANGDynClass(base=hide_virtual_ip_holder.hide_virtual_ip_holder, is_container='container', presence=False, yang_name="hide-virtual-ip-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-chassis', defining_module='brocade-chassis', yang_type='container', is_config=True)
    self.__chassis = YANGDynClass(base=chassis.chassis, is_container='container', presence=False, yang_name="chassis", rest_name="chassis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable/Disable Chassis', u'action': u'disable', u'display-when': u'((/local-node/swbd-number = "131"))', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-chassis', defining_module='brocade-chassis', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_hide_virtual_ip_holder(self):
    """
    Getter method for hide_virtual_ip_holder, mapped from YANG variable /hide_virtual_ip_holder (container)
    """
    return self.__hide_virtual_ip_holder
      
  def _set_hide_virtual_ip_holder(self, v, load=False):
    """
    Setter method for hide_virtual_ip_holder, mapped from YANG variable /hide_virtual_ip_holder (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hide_virtual_ip_holder is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hide_virtual_ip_holder() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=hide_virtual_ip_holder.hide_virtual_ip_holder, is_container='container', presence=False, yang_name="hide-virtual-ip-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-chassis', defining_module='brocade-chassis', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hide_virtual_ip_holder must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=hide_virtual_ip_holder.hide_virtual_ip_holder, is_container='container', presence=False, yang_name="hide-virtual-ip-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-chassis', defining_module='brocade-chassis', yang_type='container', is_config=True)""",
        })

    self.__hide_virtual_ip_holder = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hide_virtual_ip_holder(self):
    self.__hide_virtual_ip_holder = YANGDynClass(base=hide_virtual_ip_holder.hide_virtual_ip_holder, is_container='container', presence=False, yang_name="hide-virtual-ip-holder", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-chassis', defining_module='brocade-chassis', yang_type='container', is_config=True)


  def _get_chassis(self):
    """
    Getter method for chassis, mapped from YANG variable /chassis (container)
    """
    return self.__chassis
      
  def _set_chassis(self, v, load=False):
    """
    Setter method for chassis, mapped from YANG variable /chassis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chassis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chassis() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=chassis.chassis, is_container='container', presence=False, yang_name="chassis", rest_name="chassis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable/Disable Chassis', u'action': u'disable', u'display-when': u'((/local-node/swbd-number = "131"))', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-chassis', defining_module='brocade-chassis', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chassis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=chassis.chassis, is_container='container', presence=False, yang_name="chassis", rest_name="chassis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable/Disable Chassis', u'action': u'disable', u'display-when': u'((/local-node/swbd-number = "131"))', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-chassis', defining_module='brocade-chassis', yang_type='container', is_config=True)""",
        })

    self.__chassis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chassis(self):
    self.__chassis = YANGDynClass(base=chassis.chassis, is_container='container', presence=False, yang_name="chassis", rest_name="chassis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable/Disable Chassis', u'action': u'disable', u'display-when': u'((/local-node/swbd-number = "131"))', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-chassis', defining_module='brocade-chassis', yang_type='container', is_config=True)

  hide_virtual_ip_holder = __builtin__.property(_get_hide_virtual_ip_holder, _set_hide_virtual_ip_holder)
  chassis = __builtin__.property(_get_chassis, _set_chassis)


  _pyangbind_elements = {'hide_virtual_ip_holder': hide_virtual_ip_holder, 'chassis': chassis, }


import cee_map
import nas
class brocade_qos_cee(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-qos-cee - based on the path /brocade-qos-cee. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management submodule is an instrumentation to 
manage cee-map feature.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__cee_map','__nas',)

  _yang_name = 'brocade-qos-cee'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__cee_map = YANGDynClass(base=YANGListType("name",cee_map.cee_map, yang_name="cee-map", rest_name="cee-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}), is_container='list', yang_name="cee-map", rest_name="cee-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='list', is_config=True)
    self.__nas = YANGDynClass(base=nas.nas, is_container='container', presence=False, yang_name="nas", rest_name="nas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Network Attached Storage', u'sort-priority': u'37', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_cee_map(self):
    """
    Getter method for cee_map, mapped from YANG variable /cee_map (list)
    """
    return self.__cee_map
      
  def _set_cee_map(self, v, load=False):
    """
    Setter method for cee_map, mapped from YANG variable /cee_map (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cee_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cee_map() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",cee_map.cee_map, yang_name="cee-map", rest_name="cee-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}), is_container='list', yang_name="cee-map", rest_name="cee-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cee_map must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",cee_map.cee_map, yang_name="cee-map", rest_name="cee-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}), is_container='list', yang_name="cee-map", rest_name="cee-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='list', is_config=True)""",
        })

    self.__cee_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cee_map(self):
    self.__cee_map = YANGDynClass(base=YANGListType("name",cee_map.cee_map, yang_name="cee-map", rest_name="cee-map", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}), is_container='list', yang_name="cee-map", rest_name="cee-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'CEE map command', u'callpoint': u'qos_cee_map', u'sort-priority': u'36'}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='list', is_config=True)


  def _get_nas(self):
    """
    Getter method for nas, mapped from YANG variable /nas (container)
    """
    return self.__nas
      
  def _set_nas(self, v, load=False):
    """
    Setter method for nas, mapped from YANG variable /nas (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nas() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=nas.nas, is_container='container', presence=False, yang_name="nas", rest_name="nas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Network Attached Storage', u'sort-priority': u'37', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nas must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=nas.nas, is_container='container', presence=False, yang_name="nas", rest_name="nas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Network Attached Storage', u'sort-priority': u'37', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='container', is_config=True)""",
        })

    self.__nas = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nas(self):
    self.__nas = YANGDynClass(base=nas.nas, is_container='container', presence=False, yang_name="nas", rest_name="nas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Network Attached Storage', u'sort-priority': u'37', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-cee', defining_module='brocade-qos-cee', yang_type='container', is_config=True)

  cee_map = __builtin__.property(_get_cee_map, _set_cee_map)
  nas = __builtin__.property(_get_nas, _set_nas)


  _pyangbind_elements = {'cee_map': cee_map, 'nas': nas, }


class brocade_gre_vxlan(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-gre-vxlan - based on the path /brocade-gre-vxlan. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages GRE Vxlan commands
  """
  _pyangbind_elements = {}

  

import aaa_config
import username
import service
import role
import radius_server
import tacacs_server
import ldap_server
import password_attributes
import banner
import rule
import root_sa
import alias_config
class brocade_aaa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-aaa - based on the path /brocade-aaa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data Model for AAA CLIs
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__aaa_config','__username','__service','__role','__radius_server','__tacacs_server','__ldap_server','__password_attributes','__banner','__rule','__root_sa','__alias_config',)

  _yang_name = 'brocade-aaa'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__username = YANGDynClass(base=YANGListType("name",username.username, yang_name="username", rest_name="username", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configuration of local Users', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'19', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'user_cp'}}), is_container='list', yang_name="username", rest_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configuration of local Users', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'19', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'user_cp'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='list', is_config=True)
    self.__root_sa = YANGDynClass(base=root_sa.root_sa, is_container='container', presence=False, yang_name="root-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__tacacs_server = YANGDynClass(base=tacacs_server.tacacs_server, is_container='container', presence=False, yang_name="tacacs-server", rest_name="tacacs-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'TACACS+ server configuration', u'cli-incomplete-no': None, u'sort-priority': u'14'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__service = YANGDynClass(base=service.service, is_container='container', presence=False, yang_name="service", rest_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Perform services', u'sort-priority': u'18'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__ldap_server = YANGDynClass(base=ldap_server.ldap_server, is_container='container', presence=False, yang_name="ldap-server", rest_name="ldap-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'LDAP server configuration', u'cli-incomplete-no': None, u'sort-priority': u'15'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__rule = YANGDynClass(base=YANGListType("index",rule.rule, yang_name="rule", rest_name="rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions={u'tailf-common': {u'info': u'Rule Configuration', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'17', u'cli-suppress-list-no': None, u'cli-full-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'rule_cp'}}), is_container='list', yang_name="rule", rest_name="rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Rule Configuration', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'17', u'cli-suppress-list-no': None, u'cli-full-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'rule_cp'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='list', is_config=True)
    self.__aaa_config = YANGDynClass(base=aaa_config.aaa_config, is_container='container', presence=False, yang_name="aaa-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'16'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__role = YANGDynClass(base=role.role, is_container='container', presence=False, yang_name="role", rest_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Role configuration', u'cli-incomplete-no': None, u'sort-priority': u'12'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__radius_server = YANGDynClass(base=radius_server.radius_server, is_container='container', presence=False, yang_name="radius-server", rest_name="radius-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'RADIUS server configuration', u'cli-incomplete-no': None, u'sort-priority': u'13'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__banner = YANGDynClass(base=banner.banner, is_container='container', presence=False, yang_name="banner", rest_name="banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Banner message', u'callpoint': u'banner_cp', u'sort-priority': u'10'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__password_attributes = YANGDynClass(base=password_attributes.password_attributes, is_container='container', presence=False, yang_name="password-attributes", rest_name="password-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure system wide user password attributes', u'callpoint': u'password_attributes_cp', u'sort-priority': u'11'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__alias_config = YANGDynClass(base=alias_config.alias_config, is_container='container', presence=False, yang_name="alias-config", rest_name="alias-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-add-mode': None, u'cli-full-command': None, u'info': u'Command Alias'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_aaa_config(self):
    """
    Getter method for aaa_config, mapped from YANG variable /aaa_config (container)
    """
    return self.__aaa_config
      
  def _set_aaa_config(self, v, load=False):
    """
    Setter method for aaa_config, mapped from YANG variable /aaa_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aaa_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aaa_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=aaa_config.aaa_config, is_container='container', presence=False, yang_name="aaa-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'16'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aaa_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=aaa_config.aaa_config, is_container='container', presence=False, yang_name="aaa-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'16'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__aaa_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aaa_config(self):
    self.__aaa_config = YANGDynClass(base=aaa_config.aaa_config, is_container='container', presence=False, yang_name="aaa-config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'16'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_username(self):
    """
    Getter method for username, mapped from YANG variable /username (list)
    """
    return self.__username
      
  def _set_username(self, v, load=False):
    """
    Setter method for username, mapped from YANG variable /username (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_username is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_username() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",username.username, yang_name="username", rest_name="username", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configuration of local Users', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'19', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'user_cp'}}), is_container='list', yang_name="username", rest_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configuration of local Users', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'19', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'user_cp'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """username must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",username.username, yang_name="username", rest_name="username", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configuration of local Users', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'19', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'user_cp'}}), is_container='list', yang_name="username", rest_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configuration of local Users', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'19', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'user_cp'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='list', is_config=True)""",
        })

    self.__username = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_username(self):
    self.__username = YANGDynClass(base=YANGListType("name",username.username, yang_name="username", rest_name="username", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configuration of local Users', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'19', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'user_cp'}}), is_container='list', yang_name="username", rest_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configuration of local Users', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'19', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'user_cp'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='list', is_config=True)


  def _get_service(self):
    """
    Getter method for service, mapped from YANG variable /service (container)
    """
    return self.__service
      
  def _set_service(self, v, load=False):
    """
    Setter method for service, mapped from YANG variable /service (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=service.service, is_container='container', presence=False, yang_name="service", rest_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Perform services', u'sort-priority': u'18'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=service.service, is_container='container', presence=False, yang_name="service", rest_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Perform services', u'sort-priority': u'18'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service(self):
    self.__service = YANGDynClass(base=service.service, is_container='container', presence=False, yang_name="service", rest_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Perform services', u'sort-priority': u'18'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_role(self):
    """
    Getter method for role, mapped from YANG variable /role (container)
    """
    return self.__role
      
  def _set_role(self, v, load=False):
    """
    Setter method for role, mapped from YANG variable /role (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=role.role, is_container='container', presence=False, yang_name="role", rest_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Role configuration', u'cli-incomplete-no': None, u'sort-priority': u'12'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """role must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=role.role, is_container='container', presence=False, yang_name="role", rest_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Role configuration', u'cli-incomplete-no': None, u'sort-priority': u'12'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_role(self):
    self.__role = YANGDynClass(base=role.role, is_container='container', presence=False, yang_name="role", rest_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Role configuration', u'cli-incomplete-no': None, u'sort-priority': u'12'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_radius_server(self):
    """
    Getter method for radius_server, mapped from YANG variable /radius_server (container)
    """
    return self.__radius_server
      
  def _set_radius_server(self, v, load=False):
    """
    Setter method for radius_server, mapped from YANG variable /radius_server (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_radius_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_radius_server() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=radius_server.radius_server, is_container='container', presence=False, yang_name="radius-server", rest_name="radius-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'RADIUS server configuration', u'cli-incomplete-no': None, u'sort-priority': u'13'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """radius_server must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=radius_server.radius_server, is_container='container', presence=False, yang_name="radius-server", rest_name="radius-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'RADIUS server configuration', u'cli-incomplete-no': None, u'sort-priority': u'13'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__radius_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_radius_server(self):
    self.__radius_server = YANGDynClass(base=radius_server.radius_server, is_container='container', presence=False, yang_name="radius-server", rest_name="radius-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'RADIUS server configuration', u'cli-incomplete-no': None, u'sort-priority': u'13'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_tacacs_server(self):
    """
    Getter method for tacacs_server, mapped from YANG variable /tacacs_server (container)
    """
    return self.__tacacs_server
      
  def _set_tacacs_server(self, v, load=False):
    """
    Setter method for tacacs_server, mapped from YANG variable /tacacs_server (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tacacs_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tacacs_server() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=tacacs_server.tacacs_server, is_container='container', presence=False, yang_name="tacacs-server", rest_name="tacacs-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'TACACS+ server configuration', u'cli-incomplete-no': None, u'sort-priority': u'14'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tacacs_server must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tacacs_server.tacacs_server, is_container='container', presence=False, yang_name="tacacs-server", rest_name="tacacs-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'TACACS+ server configuration', u'cli-incomplete-no': None, u'sort-priority': u'14'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__tacacs_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tacacs_server(self):
    self.__tacacs_server = YANGDynClass(base=tacacs_server.tacacs_server, is_container='container', presence=False, yang_name="tacacs-server", rest_name="tacacs-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'TACACS+ server configuration', u'cli-incomplete-no': None, u'sort-priority': u'14'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_ldap_server(self):
    """
    Getter method for ldap_server, mapped from YANG variable /ldap_server (container)
    """
    return self.__ldap_server
      
  def _set_ldap_server(self, v, load=False):
    """
    Setter method for ldap_server, mapped from YANG variable /ldap_server (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldap_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldap_server() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ldap_server.ldap_server, is_container='container', presence=False, yang_name="ldap-server", rest_name="ldap-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'LDAP server configuration', u'cli-incomplete-no': None, u'sort-priority': u'15'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldap_server must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ldap_server.ldap_server, is_container='container', presence=False, yang_name="ldap-server", rest_name="ldap-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'LDAP server configuration', u'cli-incomplete-no': None, u'sort-priority': u'15'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__ldap_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldap_server(self):
    self.__ldap_server = YANGDynClass(base=ldap_server.ldap_server, is_container='container', presence=False, yang_name="ldap-server", rest_name="ldap-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'LDAP server configuration', u'cli-incomplete-no': None, u'sort-priority': u'15'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_password_attributes(self):
    """
    Getter method for password_attributes, mapped from YANG variable /password_attributes (container)
    """
    return self.__password_attributes
      
  def _set_password_attributes(self, v, load=False):
    """
    Setter method for password_attributes, mapped from YANG variable /password_attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_password_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_password_attributes() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=password_attributes.password_attributes, is_container='container', presence=False, yang_name="password-attributes", rest_name="password-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure system wide user password attributes', u'callpoint': u'password_attributes_cp', u'sort-priority': u'11'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """password_attributes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=password_attributes.password_attributes, is_container='container', presence=False, yang_name="password-attributes", rest_name="password-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure system wide user password attributes', u'callpoint': u'password_attributes_cp', u'sort-priority': u'11'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__password_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_password_attributes(self):
    self.__password_attributes = YANGDynClass(base=password_attributes.password_attributes, is_container='container', presence=False, yang_name="password-attributes", rest_name="password-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure system wide user password attributes', u'callpoint': u'password_attributes_cp', u'sort-priority': u'11'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_banner(self):
    """
    Getter method for banner, mapped from YANG variable /banner (container)
    """
    return self.__banner
      
  def _set_banner(self, v, load=False):
    """
    Setter method for banner, mapped from YANG variable /banner (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_banner is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_banner() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=banner.banner, is_container='container', presence=False, yang_name="banner", rest_name="banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Banner message', u'callpoint': u'banner_cp', u'sort-priority': u'10'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """banner must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=banner.banner, is_container='container', presence=False, yang_name="banner", rest_name="banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Banner message', u'callpoint': u'banner_cp', u'sort-priority': u'10'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__banner = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_banner(self):
    self.__banner = YANGDynClass(base=banner.banner, is_container='container', presence=False, yang_name="banner", rest_name="banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Banner message', u'callpoint': u'banner_cp', u'sort-priority': u'10'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_rule(self):
    """
    Getter method for rule, mapped from YANG variable /rule (list)
    """
    return self.__rule
      
  def _set_rule(self, v, load=False):
    """
    Setter method for rule, mapped from YANG variable /rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",rule.rule, yang_name="rule", rest_name="rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions={u'tailf-common': {u'info': u'Rule Configuration', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'17', u'cli-suppress-list-no': None, u'cli-full-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'rule_cp'}}), is_container='list', yang_name="rule", rest_name="rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Rule Configuration', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'17', u'cli-suppress-list-no': None, u'cli-full-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'rule_cp'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rule must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",rule.rule, yang_name="rule", rest_name="rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions={u'tailf-common': {u'info': u'Rule Configuration', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'17', u'cli-suppress-list-no': None, u'cli-full-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'rule_cp'}}), is_container='list', yang_name="rule", rest_name="rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Rule Configuration', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'17', u'cli-suppress-list-no': None, u'cli-full-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'rule_cp'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='list', is_config=True)""",
        })

    self.__rule = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rule(self):
    self.__rule = YANGDynClass(base=YANGListType("index",rule.rule, yang_name="rule", rest_name="rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions={u'tailf-common': {u'info': u'Rule Configuration', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'17', u'cli-suppress-list-no': None, u'cli-full-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'rule_cp'}}), is_container='list', yang_name="rule", rest_name="rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Rule Configuration', u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'sort-priority': u'17', u'cli-suppress-list-no': None, u'cli-full-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-key-abbreviation': None, u'cli-incomplete-command': None, u'callpoint': u'rule_cp'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='list', is_config=True)


  def _get_root_sa(self):
    """
    Getter method for root_sa, mapped from YANG variable /root_sa (container)
    """
    return self.__root_sa
      
  def _set_root_sa(self, v, load=False):
    """
    Setter method for root_sa, mapped from YANG variable /root_sa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root_sa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root_sa() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=root_sa.root_sa, is_container='container', presence=False, yang_name="root-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """root_sa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=root_sa.root_sa, is_container='container', presence=False, yang_name="root-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__root_sa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_root_sa(self):
    self.__root_sa = YANGDynClass(base=root_sa.root_sa, is_container='container', presence=False, yang_name="root-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_alias_config(self):
    """
    Getter method for alias_config, mapped from YANG variable /alias_config (container)
    """
    return self.__alias_config
      
  def _set_alias_config(self, v, load=False):
    """
    Setter method for alias_config, mapped from YANG variable /alias_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alias_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alias_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=alias_config.alias_config, is_container='container', presence=False, yang_name="alias-config", rest_name="alias-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-add-mode': None, u'cli-full-command': None, u'info': u'Command Alias'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alias_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=alias_config.alias_config, is_container='container', presence=False, yang_name="alias-config", rest_name="alias-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-add-mode': None, u'cli-full-command': None, u'info': u'Command Alias'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__alias_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alias_config(self):
    self.__alias_config = YANGDynClass(base=alias_config.alias_config, is_container='container', presence=False, yang_name="alias-config", rest_name="alias-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-add-mode': None, u'cli-full-command': None, u'info': u'Command Alias'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)

  aaa_config = __builtin__.property(_get_aaa_config, _set_aaa_config)
  username = __builtin__.property(_get_username, _set_username)
  service = __builtin__.property(_get_service, _set_service)
  role = __builtin__.property(_get_role, _set_role)
  radius_server = __builtin__.property(_get_radius_server, _set_radius_server)
  tacacs_server = __builtin__.property(_get_tacacs_server, _set_tacacs_server)
  ldap_server = __builtin__.property(_get_ldap_server, _set_ldap_server)
  password_attributes = __builtin__.property(_get_password_attributes, _set_password_attributes)
  banner = __builtin__.property(_get_banner, _set_banner)
  rule = __builtin__.property(_get_rule, _set_rule)
  root_sa = __builtin__.property(_get_root_sa, _set_root_sa)
  alias_config = __builtin__.property(_get_alias_config, _set_alias_config)


  _pyangbind_elements = {'aaa_config': aaa_config, 'username': username, 'service': service, 'role': role, 'radius_server': radius_server, 'tacacs_server': tacacs_server, 'ldap_server': ldap_server, 'password_attributes': password_attributes, 'banner': banner, 'rule': rule, 'root_sa': root_sa, 'alias_config': alias_config, }


class brocade_tm_stats(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-tm-stats - based on the path /brocade-tm-stats. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages Traffic Manager stats
  """
  _pyangbind_elements = {}

  

import sfm_state
class brocade_sysmgr_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-sysmgr-operational - based on the path /brocade-sysmgr-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage sysmgr
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__sfm_state',)

  _yang_name = 'brocade-sysmgr-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__sfm_state = YANGDynClass(base=sfm_state.sfm_state, is_container='container', presence=False, yang_name="sfm-state", rest_name="sfm-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'sysmgr-sfm', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-sysmgr-operational', defining_module='brocade-sysmgr-operational', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_sfm_state(self):
    """
    Getter method for sfm_state, mapped from YANG variable /sfm_state (container)

    YANG Description: SFM Operational Information
    """
    return self.__sfm_state
      
  def _set_sfm_state(self, v, load=False):
    """
    Setter method for sfm_state, mapped from YANG variable /sfm_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sfm_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sfm_state() directly.

    YANG Description: SFM Operational Information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=sfm_state.sfm_state, is_container='container', presence=False, yang_name="sfm-state", rest_name="sfm-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'sysmgr-sfm', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-sysmgr-operational', defining_module='brocade-sysmgr-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sfm_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=sfm_state.sfm_state, is_container='container', presence=False, yang_name="sfm-state", rest_name="sfm-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'sysmgr-sfm', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-sysmgr-operational', defining_module='brocade-sysmgr-operational', yang_type='container', is_config=True)""",
        })

    self.__sfm_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sfm_state(self):
    self.__sfm_state = YANGDynClass(base=sfm_state.sfm_state, is_container='container', presence=False, yang_name="sfm-state", rest_name="sfm-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'sysmgr-sfm', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-sysmgr-operational', defining_module='brocade-sysmgr-operational', yang_type='container', is_config=True)

  sfm_state = __builtin__.property(_get_sfm_state, _set_sfm_state)


  _pyangbind_elements = {'sfm_state': sfm_state, }


class brocade_ip_forward(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ip-forward - based on the path /brocade-ip-forward. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentationfor the management
of CIDR multipath IP Routes. Multipath IP routes have the
same network  number but differing network masks.
  """
  _pyangbind_elements = {}

  

import capabilities
class brocade_system_capabilities(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-system-capabilities - based on the path /brocade-system-capabilities. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes the System Capabilities of the platform.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__capabilities',)

  _yang_name = 'brocade-system-capabilities'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__capabilities = YANGDynClass(base=capabilities.capabilities, is_container='container', presence=False, yang_name="capabilities", rest_name="capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'CapabilitiesCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-system-capabilities', defining_module='brocade-system-capabilities', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_capabilities(self):
    """
    Getter method for capabilities, mapped from YANG variable /capabilities (container)
    """
    return self.__capabilities
      
  def _set_capabilities(self, v, load=False):
    """
    Setter method for capabilities, mapped from YANG variable /capabilities (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_capabilities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_capabilities() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=capabilities.capabilities, is_container='container', presence=False, yang_name="capabilities", rest_name="capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'CapabilitiesCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-system-capabilities', defining_module='brocade-system-capabilities', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """capabilities must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=capabilities.capabilities, is_container='container', presence=False, yang_name="capabilities", rest_name="capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'CapabilitiesCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-system-capabilities', defining_module='brocade-system-capabilities', yang_type='container', is_config=True)""",
        })

    self.__capabilities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_capabilities(self):
    self.__capabilities = YANGDynClass(base=capabilities.capabilities, is_container='container', presence=False, yang_name="capabilities", rest_name="capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'CapabilitiesCallpoint'}}, namespace='urn:brocade.com:mgmt:brocade-system-capabilities', defining_module='brocade-system-capabilities', yang_type='container', is_config=True)

  capabilities = __builtin__.property(_get_capabilities, _set_capabilities)


  _pyangbind_elements = {'capabilities': capabilities, }


import openflow_global
class brocade_openflow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-openflow - based on the path /brocade-openflow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
This module defines configuration commands related for enableing openflow  

Configuration examples:
openflow enable ver13
openflow enable ver10
openflow controller passive

  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__openflow_global',)

  _yang_name = 'brocade-openflow'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__openflow_global = YANGDynClass(base=openflow_global.openflow_global, is_container='container', presence=False, yang_name="openflow-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'enables openflow and version ', u'cli-drop-node-name': None, u'callpoint': u'OpenflowBasicConfigCallPoint'}}, namespace='urn:brocade.com:mgmt:brocade-openflow', defining_module='brocade-openflow', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_openflow_global(self):
    """
    Getter method for openflow_global, mapped from YANG variable /openflow_global (container)
    """
    return self.__openflow_global
      
  def _set_openflow_global(self, v, load=False):
    """
    Setter method for openflow_global, mapped from YANG variable /openflow_global (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_openflow_global is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_openflow_global() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=openflow_global.openflow_global, is_container='container', presence=False, yang_name="openflow-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'enables openflow and version ', u'cli-drop-node-name': None, u'callpoint': u'OpenflowBasicConfigCallPoint'}}, namespace='urn:brocade.com:mgmt:brocade-openflow', defining_module='brocade-openflow', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """openflow_global must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=openflow_global.openflow_global, is_container='container', presence=False, yang_name="openflow-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'enables openflow and version ', u'cli-drop-node-name': None, u'callpoint': u'OpenflowBasicConfigCallPoint'}}, namespace='urn:brocade.com:mgmt:brocade-openflow', defining_module='brocade-openflow', yang_type='container', is_config=True)""",
        })

    self.__openflow_global = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_openflow_global(self):
    self.__openflow_global = YANGDynClass(base=openflow_global.openflow_global, is_container='container', presence=False, yang_name="openflow-global", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'enables openflow and version ', u'cli-drop-node-name': None, u'callpoint': u'OpenflowBasicConfigCallPoint'}}, namespace='urn:brocade.com:mgmt:brocade-openflow', defining_module='brocade-openflow', yang_type='container', is_config=True)

  openflow_global = __builtin__.property(_get_openflow_global, _set_openflow_global)


  _pyangbind_elements = {'openflow_global': openflow_global, }


class brocade_pim(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-pim - based on the path /brocade-pim. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This file describes the data modeliing of all
the configuration commands for the multicast 
protocol, Protocol Independent Multicast (PIM).
  """
  _pyangbind_elements = {}

  

import system_monitor
import system_monitor_mail
class brocade_system_monitor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-system-monitor - based on the path /brocade-system-monitor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data Model for Brocade's System Monitor configuration CLIs
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__system_monitor','__system_monitor_mail',)

  _yang_name = 'brocade-system-monitor'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__system_monitor = YANGDynClass(base=system_monitor.system_monitor, is_container='container', presence=False, yang_name="system-monitor", rest_name="system-monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure FRU threshold and alert setting', u'display-when': u'/vcsmode/vcs-mode = "false"', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-system-monitor', defining_module='brocade-system-monitor', yang_type='container', is_config=True)
    self.__system_monitor_mail = YANGDynClass(base=system_monitor_mail.system_monitor_mail, is_container='container', presence=False, yang_name="system-monitor-mail", rest_name="system-monitor-mail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure FRU mail setting', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-system-monitor', defining_module='brocade-system-monitor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_system_monitor(self):
    """
    Getter method for system_monitor, mapped from YANG variable /system_monitor (container)
    """
    return self.__system_monitor
      
  def _set_system_monitor(self, v, load=False):
    """
    Setter method for system_monitor, mapped from YANG variable /system_monitor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_monitor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_monitor() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=system_monitor.system_monitor, is_container='container', presence=False, yang_name="system-monitor", rest_name="system-monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure FRU threshold and alert setting', u'display-when': u'/vcsmode/vcs-mode = "false"', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-system-monitor', defining_module='brocade-system-monitor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_monitor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=system_monitor.system_monitor, is_container='container', presence=False, yang_name="system-monitor", rest_name="system-monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure FRU threshold and alert setting', u'display-when': u'/vcsmode/vcs-mode = "false"', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-system-monitor', defining_module='brocade-system-monitor', yang_type='container', is_config=True)""",
        })

    self.__system_monitor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_monitor(self):
    self.__system_monitor = YANGDynClass(base=system_monitor.system_monitor, is_container='container', presence=False, yang_name="system-monitor", rest_name="system-monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure FRU threshold and alert setting', u'display-when': u'/vcsmode/vcs-mode = "false"', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-system-monitor', defining_module='brocade-system-monitor', yang_type='container', is_config=True)


  def _get_system_monitor_mail(self):
    """
    Getter method for system_monitor_mail, mapped from YANG variable /system_monitor_mail (container)
    """
    return self.__system_monitor_mail
      
  def _set_system_monitor_mail(self, v, load=False):
    """
    Setter method for system_monitor_mail, mapped from YANG variable /system_monitor_mail (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_monitor_mail is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_monitor_mail() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=system_monitor_mail.system_monitor_mail, is_container='container', presence=False, yang_name="system-monitor-mail", rest_name="system-monitor-mail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure FRU mail setting', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-system-monitor', defining_module='brocade-system-monitor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_monitor_mail must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=system_monitor_mail.system_monitor_mail, is_container='container', presence=False, yang_name="system-monitor-mail", rest_name="system-monitor-mail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure FRU mail setting', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-system-monitor', defining_module='brocade-system-monitor', yang_type='container', is_config=True)""",
        })

    self.__system_monitor_mail = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_monitor_mail(self):
    self.__system_monitor_mail = YANGDynClass(base=system_monitor_mail.system_monitor_mail, is_container='container', presence=False, yang_name="system-monitor-mail", rest_name="system-monitor-mail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure FRU mail setting', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-system-monitor', defining_module='brocade-system-monitor', yang_type='container', is_config=True)

  system_monitor = __builtin__.property(_get_system_monitor, _set_system_monitor)
  system_monitor_mail = __builtin__.property(_get_system_monitor_mail, _set_system_monitor_mail)


  _pyangbind_elements = {'system_monitor': system_monitor, 'system_monitor_mail': system_monitor_mail, }


import tpvm
class brocade_tpvm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-tpvm - based on the path /brocade-tpvm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to TPVM
              administration commands
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__tpvm',)

  _yang_name = 'brocade-tpvm'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__tpvm = YANGDynClass(base=tpvm.tpvm, is_container='container', presence=False, yang_name="tpvm", rest_name="tpvm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'TPVM administration command', u'action': u'stop'}}, namespace='urn:brocade.com:mgmt:brocade-tpvm', defining_module='brocade-tpvm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_tpvm(self):
    """
    Getter method for tpvm, mapped from YANG variable /tpvm (container)
    """
    return self.__tpvm
      
  def _set_tpvm(self, v, load=False):
    """
    Setter method for tpvm, mapped from YANG variable /tpvm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tpvm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tpvm() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=tpvm.tpvm, is_container='container', presence=False, yang_name="tpvm", rest_name="tpvm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'TPVM administration command', u'action': u'stop'}}, namespace='urn:brocade.com:mgmt:brocade-tpvm', defining_module='brocade-tpvm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tpvm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tpvm.tpvm, is_container='container', presence=False, yang_name="tpvm", rest_name="tpvm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'TPVM administration command', u'action': u'stop'}}, namespace='urn:brocade.com:mgmt:brocade-tpvm', defining_module='brocade-tpvm', yang_type='container', is_config=True)""",
        })

    self.__tpvm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tpvm(self):
    self.__tpvm = YANGDynClass(base=tpvm.tpvm, is_container='container', presence=False, yang_name="tpvm", rest_name="tpvm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'TPVM administration command', u'action': u'stop'}}, namespace='urn:brocade.com:mgmt:brocade-tpvm', defining_module='brocade-tpvm', yang_type='container', is_config=True)

  tpvm = __builtin__.property(_get_tpvm, _set_tpvm)


  _pyangbind_elements = {'tpvm': tpvm, }


import cpu_cfg_state
import cpu_info_state
import qos_mpls_state
class brocade_qos_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-qos-operational - based on the path /brocade-qos-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage qos
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__cpu_cfg_state','__cpu_info_state','__qos_mpls_state',)

  _yang_name = 'brocade-qos-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__qos_mpls_state = YANGDynClass(base=YANGListType("map_type",qos_mpls_state.qos_mpls_state, yang_name="qos-mpls-state", rest_name="qos-mpls-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='map-type', extensions={u'tailf-common': {u'callpoint': u'qos-qos-mpls', u'cli-suppress-show-path': None}}), is_container='list', yang_name="qos-mpls-state", rest_name="qos-mpls-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-qos-mpls', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='list', is_config=True)
    self.__cpu_info_state = YANGDynClass(base=YANGListType("group_id",cpu_info_state.cpu_info_state, yang_name="cpu-info-state", rest_name="cpu-info-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='group-id', extensions={u'tailf-common': {u'callpoint': u'qos-cpu-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-info-state", rest_name="cpu-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='list', is_config=True)
    self.__cpu_cfg_state = YANGDynClass(base=YANGListType("slot_id",cpu_cfg_state.cpu_cfg_state, yang_name="cpu-cfg-state", rest_name="cpu-cfg-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='slot-id', extensions={u'tailf-common': {u'callpoint': u'qos-cpu-cfg', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-cfg-state", rest_name="cpu-cfg-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-cfg', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_cpu_cfg_state(self):
    """
    Getter method for cpu_cfg_state, mapped from YANG variable /cpu_cfg_state (list)

    YANG Description: CPU port shaper/burst config
    """
    return self.__cpu_cfg_state
      
  def _set_cpu_cfg_state(self, v, load=False):
    """
    Setter method for cpu_cfg_state, mapped from YANG variable /cpu_cfg_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_cfg_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_cfg_state() directly.

    YANG Description: CPU port shaper/burst config
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("slot_id",cpu_cfg_state.cpu_cfg_state, yang_name="cpu-cfg-state", rest_name="cpu-cfg-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='slot-id', extensions={u'tailf-common': {u'callpoint': u'qos-cpu-cfg', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-cfg-state", rest_name="cpu-cfg-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-cfg', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_cfg_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("slot_id",cpu_cfg_state.cpu_cfg_state, yang_name="cpu-cfg-state", rest_name="cpu-cfg-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='slot-id', extensions={u'tailf-common': {u'callpoint': u'qos-cpu-cfg', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-cfg-state", rest_name="cpu-cfg-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-cfg', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='list', is_config=True)""",
        })

    self.__cpu_cfg_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_cfg_state(self):
    self.__cpu_cfg_state = YANGDynClass(base=YANGListType("slot_id",cpu_cfg_state.cpu_cfg_state, yang_name="cpu-cfg-state", rest_name="cpu-cfg-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='slot-id', extensions={u'tailf-common': {u'callpoint': u'qos-cpu-cfg', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-cfg-state", rest_name="cpu-cfg-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-cfg', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='list', is_config=True)


  def _get_cpu_info_state(self):
    """
    Getter method for cpu_info_state, mapped from YANG variable /cpu_info_state (list)

    YANG Description: CPU EGID and Group ID mapping
    """
    return self.__cpu_info_state
      
  def _set_cpu_info_state(self, v, load=False):
    """
    Setter method for cpu_info_state, mapped from YANG variable /cpu_info_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_info_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_info_state() directly.

    YANG Description: CPU EGID and Group ID mapping
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("group_id",cpu_info_state.cpu_info_state, yang_name="cpu-info-state", rest_name="cpu-info-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='group-id', extensions={u'tailf-common': {u'callpoint': u'qos-cpu-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-info-state", rest_name="cpu-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_info_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("group_id",cpu_info_state.cpu_info_state, yang_name="cpu-info-state", rest_name="cpu-info-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='group-id', extensions={u'tailf-common': {u'callpoint': u'qos-cpu-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-info-state", rest_name="cpu-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='list', is_config=True)""",
        })

    self.__cpu_info_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_info_state(self):
    self.__cpu_info_state = YANGDynClass(base=YANGListType("group_id",cpu_info_state.cpu_info_state, yang_name="cpu-info-state", rest_name="cpu-info-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='group-id', extensions={u'tailf-common': {u'callpoint': u'qos-cpu-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="cpu-info-state", rest_name="cpu-info-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-cpu-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='list', is_config=True)


  def _get_qos_mpls_state(self):
    """
    Getter method for qos_mpls_state, mapped from YANG variable /qos_mpls_state (list)

    YANG Description: qos mpls maps information
    """
    return self.__qos_mpls_state
      
  def _set_qos_mpls_state(self, v, load=False):
    """
    Setter method for qos_mpls_state, mapped from YANG variable /qos_mpls_state (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos_mpls_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos_mpls_state() directly.

    YANG Description: qos mpls maps information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("map_type",qos_mpls_state.qos_mpls_state, yang_name="qos-mpls-state", rest_name="qos-mpls-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='map-type', extensions={u'tailf-common': {u'callpoint': u'qos-qos-mpls', u'cli-suppress-show-path': None}}), is_container='list', yang_name="qos-mpls-state", rest_name="qos-mpls-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-qos-mpls', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos_mpls_state must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("map_type",qos_mpls_state.qos_mpls_state, yang_name="qos-mpls-state", rest_name="qos-mpls-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='map-type', extensions={u'tailf-common': {u'callpoint': u'qos-qos-mpls', u'cli-suppress-show-path': None}}), is_container='list', yang_name="qos-mpls-state", rest_name="qos-mpls-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-qos-mpls', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='list', is_config=True)""",
        })

    self.__qos_mpls_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos_mpls_state(self):
    self.__qos_mpls_state = YANGDynClass(base=YANGListType("map_type",qos_mpls_state.qos_mpls_state, yang_name="qos-mpls-state", rest_name="qos-mpls-state", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='map-type', extensions={u'tailf-common': {u'callpoint': u'qos-qos-mpls', u'cli-suppress-show-path': None}}), is_container='list', yang_name="qos-mpls-state", rest_name="qos-mpls-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'qos-qos-mpls', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-qos-operational', defining_module='brocade-qos-operational', yang_type='list', is_config=True)

  cpu_cfg_state = __builtin__.property(_get_cpu_cfg_state, _set_cpu_cfg_state)
  cpu_info_state = __builtin__.property(_get_cpu_info_state, _set_cpu_info_state)
  qos_mpls_state = __builtin__.property(_get_qos_mpls_state, _set_qos_mpls_state)


  _pyangbind_elements = {'cpu_cfg_state': cpu_cfg_state, 'cpu_info_state': cpu_info_state, 'qos_mpls_state': qos_mpls_state, }


class brocade_system(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-system - based on the path /brocade-system. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines SYSTEM related information.
  """
  _pyangbind_elements = {}

  

import nsx_controller
import overlay_gateway
import ovsdb_server
import tunnel_settings
class brocade_tunnels(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-tunnels - based on the path /brocade-tunnels. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage the IP
tunnels.

Glossary of the terms used:
---------------------------
VXLAN       Virtual eXtensible Local Area Network. See internet
           draft draft-mahalingam-dutt-dcops-vxlan-03.
VXLAN Gateway
           Software module in Brocade VCS switch which forwards
           traffic between VXLAN and non-VXLAN environments.
NSX         NSX is a network virtualization platform solution
           by Vmware. Refer - www.vmware.com/in/products/nsx
NSX Controller
           NSX Controller is the cluster of x86 systems which
           manage the virtual networks.
TCP         Transmission Control Protocol (RFC 793)
SSL         Secure Sockets Layer Protocol (RFC 6101)
BFD         Bidirectional Forwarding Detection (RFC 5880)


  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__nsx_controller','__overlay_gateway','__ovsdb_server','__tunnel_settings',)

  _yang_name = 'brocade-tunnels'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__nsx_controller = YANGDynClass(base=YANGListType("name",nsx_controller.nsx_controller, yang_name="nsx-controller", rest_name="nsx-controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'callpoint': u'nvp-controller-config'}}), is_container='list', yang_name="nsx-controller", rest_name="nsx-controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'callpoint': u'nvp-controller-config'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)
    self.__tunnel_settings = YANGDynClass(base=tunnel_settings.tunnel_settings, is_container='container', presence=False, yang_name="tunnel-settings", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='container', is_config=True)
    self.__overlay_gateway = YANGDynClass(base=YANGListType("name",overlay_gateway.overlay_gateway, yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'callpoint': u'TunnelsGwCallpoint', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-overlay-gw-$(name)'}}), is_container='list', yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'callpoint': u'TunnelsGwCallpoint', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-overlay-gw-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)
    self.__ovsdb_server = YANGDynClass(base=YANGListType("name",ovsdb_server.ovsdb_server, yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}), is_container='list', yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_nsx_controller(self):
    """
    Getter method for nsx_controller, mapped from YANG variable /nsx_controller (list)
    """
    return self.__nsx_controller
      
  def _set_nsx_controller(self, v, load=False):
    """
    Setter method for nsx_controller, mapped from YANG variable /nsx_controller (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsx_controller is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsx_controller() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",nsx_controller.nsx_controller, yang_name="nsx-controller", rest_name="nsx-controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'callpoint': u'nvp-controller-config'}}), is_container='list', yang_name="nsx-controller", rest_name="nsx-controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'callpoint': u'nvp-controller-config'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsx_controller must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",nsx_controller.nsx_controller, yang_name="nsx-controller", rest_name="nsx-controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'callpoint': u'nvp-controller-config'}}), is_container='list', yang_name="nsx-controller", rest_name="nsx-controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'callpoint': u'nvp-controller-config'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)""",
        })

    self.__nsx_controller = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsx_controller(self):
    self.__nsx_controller = YANGDynClass(base=YANGListType("name",nsx_controller.nsx_controller, yang_name="nsx-controller", rest_name="nsx-controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'callpoint': u'nvp-controller-config'}}), is_container='list', yang_name="nsx-controller", rest_name="nsx-controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'NSX controller configuration', u'sort-priority': u'RUNNCFG_LEVEL_NVP_CONTROLLER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'callpoint': u'nvp-controller-config'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)


  def _get_overlay_gateway(self):
    """
    Getter method for overlay_gateway, mapped from YANG variable /overlay_gateway (list)
    """
    return self.__overlay_gateway
      
  def _set_overlay_gateway(self, v, load=False):
    """
    Setter method for overlay_gateway, mapped from YANG variable /overlay_gateway (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overlay_gateway is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overlay_gateway() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",overlay_gateway.overlay_gateway, yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'callpoint': u'TunnelsGwCallpoint', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-overlay-gw-$(name)'}}), is_container='list', yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'callpoint': u'TunnelsGwCallpoint', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-overlay-gw-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overlay_gateway must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",overlay_gateway.overlay_gateway, yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'callpoint': u'TunnelsGwCallpoint', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-overlay-gw-$(name)'}}), is_container='list', yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'callpoint': u'TunnelsGwCallpoint', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-overlay-gw-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)""",
        })

    self.__overlay_gateway = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overlay_gateway(self):
    self.__overlay_gateway = YANGDynClass(base=YANGListType("name",overlay_gateway.overlay_gateway, yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'callpoint': u'TunnelsGwCallpoint', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-overlay-gw-$(name)'}}), is_container='list', yang_name="overlay-gateway", rest_name="overlay-gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Overaly gateway instance', u'callpoint': u'TunnelsGwCallpoint', u'sort-priority': u'RUNNCFG_LEVEL_OVERLAY_GATEWAY_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-full-no': None, u'cli-mode-name': u'config-overlay-gw-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)


  def _get_ovsdb_server(self):
    """
    Getter method for ovsdb_server, mapped from YANG variable /ovsdb_server (list)
    """
    return self.__ovsdb_server
      
  def _set_ovsdb_server(self, v, load=False):
    """
    Setter method for ovsdb_server, mapped from YANG variable /ovsdb_server (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ovsdb_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ovsdb_server() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",ovsdb_server.ovsdb_server, yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}), is_container='list', yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ovsdb_server must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",ovsdb_server.ovsdb_server, yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}), is_container='list', yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)""",
        })

    self.__ovsdb_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ovsdb_server(self):
    self.__ovsdb_server = YANGDynClass(base=YANGListType("name",ovsdb_server.ovsdb_server, yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}), is_container='list', yang_name="ovsdb-server", rest_name="ovsdb-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure OVSDB server.', u'callpoint': u'ovsdbServerConfig', u'sort-priority': u'RUNNCFG_LEVEL_OVSDB_SERVER_CONFIG', u'cli-suppress-list-no': None, u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None, u'cli-mode-name': u'config-server-$(name)'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='list', is_config=True)


  def _get_tunnel_settings(self):
    """
    Getter method for tunnel_settings, mapped from YANG variable /tunnel_settings (container)

    YANG Description: Tunnel related internal settings
    """
    return self.__tunnel_settings
      
  def _set_tunnel_settings(self, v, load=False):
    """
    Setter method for tunnel_settings, mapped from YANG variable /tunnel_settings (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_settings is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_settings() directly.

    YANG Description: Tunnel related internal settings
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=tunnel_settings.tunnel_settings, is_container='container', presence=False, yang_name="tunnel-settings", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_settings must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tunnel_settings.tunnel_settings, is_container='container', presence=False, yang_name="tunnel-settings", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='container', is_config=True)""",
        })

    self.__tunnel_settings = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_settings(self):
    self.__tunnel_settings = YANGDynClass(base=tunnel_settings.tunnel_settings, is_container='container', presence=False, yang_name="tunnel-settings", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'sort-priority': u'RUNNCFG_LEVEL_SYSTEM_GLOBAL'}}, namespace='urn:brocade.com:mgmt:brocade-tunnels', defining_module='brocade-tunnels', yang_type='container', is_config=True)

  nsx_controller = __builtin__.property(_get_nsx_controller, _set_nsx_controller)
  overlay_gateway = __builtin__.property(_get_overlay_gateway, _set_overlay_gateway)
  ovsdb_server = __builtin__.property(_get_ovsdb_server, _set_ovsdb_server)
  tunnel_settings = __builtin__.property(_get_tunnel_settings, _set_tunnel_settings)


  _pyangbind_elements = {'nsx_controller': nsx_controller, 'overlay_gateway': overlay_gateway, 'ovsdb_server': ovsdb_server, 'tunnel_settings': tunnel_settings, }


class brocade_rtm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-rtm - based on the path /brocade-rtm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is for IP Routes.
  """
  _pyangbind_elements = {}

  

class brocade_aaa_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-aaa-ext - based on the path /brocade-aaa-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  _pyangbind_elements = {}

  

class brocade_logical_chassis(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-logical-chassis - based on the path /brocade-logical-chassis. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides interface to provision fabric principal priority
  """
  _pyangbind_elements = {}

  

import ip_acl
import acl_mirror
class brocade_ip_access_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ip-access-list - based on the path /brocade-ip-access-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management sub-module contains the configuration
and rpc implementaion for IP Access-list.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__ip_acl','__acl_mirror',)

  _yang_name = 'brocade-ip-access-list'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__acl_mirror = YANGDynClass(base=acl_mirror.acl_mirror, is_container='container', presence=False, yang_name="acl-mirror", rest_name="acl-mirror", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Interface to be mirrored', u'cli-incomplete-no': None, u'callpoint': u'AclmirrorPort', u'sort-priority': u'147'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)
    self.__ip_acl = YANGDynClass(base=ip_acl.ip_acl, is_container='container', presence=False, yang_name="ip-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'45'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_ip_acl(self):
    """
    Getter method for ip_acl, mapped from YANG variable /ip_acl (container)
    """
    return self.__ip_acl
      
  def _set_ip_acl(self, v, load=False):
    """
    Setter method for ip_acl, mapped from YANG variable /ip_acl (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_acl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_acl() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ip_acl.ip_acl, is_container='container', presence=False, yang_name="ip-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'45'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_acl must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ip_acl.ip_acl, is_container='container', presence=False, yang_name="ip-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'45'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)""",
        })

    self.__ip_acl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_acl(self):
    self.__ip_acl = YANGDynClass(base=ip_acl.ip_acl, is_container='container', presence=False, yang_name="ip-acl", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'sort-priority': u'45'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)


  def _get_acl_mirror(self):
    """
    Getter method for acl_mirror, mapped from YANG variable /acl_mirror (container)
    """
    return self.__acl_mirror
      
  def _set_acl_mirror(self, v, load=False):
    """
    Setter method for acl_mirror, mapped from YANG variable /acl_mirror (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acl_mirror is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acl_mirror() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=acl_mirror.acl_mirror, is_container='container', presence=False, yang_name="acl-mirror", rest_name="acl-mirror", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Interface to be mirrored', u'cli-incomplete-no': None, u'callpoint': u'AclmirrorPort', u'sort-priority': u'147'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acl_mirror must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=acl_mirror.acl_mirror, is_container='container', presence=False, yang_name="acl-mirror", rest_name="acl-mirror", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Interface to be mirrored', u'cli-incomplete-no': None, u'callpoint': u'AclmirrorPort', u'sort-priority': u'147'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)""",
        })

    self.__acl_mirror = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acl_mirror(self):
    self.__acl_mirror = YANGDynClass(base=acl_mirror.acl_mirror, is_container='container', presence=False, yang_name="acl-mirror", rest_name="acl-mirror", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Interface to be mirrored', u'cli-incomplete-no': None, u'callpoint': u'AclmirrorPort', u'sort-priority': u'147'}}, namespace='urn:brocade.com:mgmt:brocade-ip-access-list', defining_module='brocade-ip-access-list', yang_type='container', is_config=True)

  ip_acl = __builtin__.property(_get_ip_acl, _set_ip_acl)
  acl_mirror = __builtin__.property(_get_acl_mirror, _set_acl_mirror)


  _pyangbind_elements = {'ip_acl': ip_acl, 'acl_mirror': acl_mirror, }


import cfm_state
import loam_state
import loam_show_debug_state
class brocade_dot1ag_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-dot1ag-operational - based on the path /brocade-dot1ag-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage dot1ag
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__cfm_state','__loam_state','__loam_show_debug_state',)

  _yang_name = 'brocade-dot1ag-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__cfm_state = YANGDynClass(base=cfm_state.cfm_state, is_container='container', presence=False, yang_name="cfm-state", rest_name="cfm-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'dot1ag-cfm', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-dot1ag-operational', defining_module='brocade-dot1ag-operational', yang_type='container', is_config=True)
    self.__loam_show_debug_state = YANGDynClass(base=loam_show_debug_state.loam_show_debug_state, is_container='container', presence=False, yang_name="loam-show-debug-state", rest_name="loam-show-debug-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'dot1ag-loam-show-debug', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-dot1ag-operational', defining_module='brocade-dot1ag-operational', yang_type='container', is_config=True)
    self.__loam_state = YANGDynClass(base=loam_state.loam_state, is_container='container', presence=False, yang_name="loam-state", rest_name="loam-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'dot1ag-loam', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-dot1ag-operational', defining_module='brocade-dot1ag-operational', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_cfm_state(self):
    """
    Getter method for cfm_state, mapped from YANG variable /cfm_state (container)

    YANG Description: CFM Operational Information
    """
    return self.__cfm_state
      
  def _set_cfm_state(self, v, load=False):
    """
    Setter method for cfm_state, mapped from YANG variable /cfm_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cfm_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cfm_state() directly.

    YANG Description: CFM Operational Information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=cfm_state.cfm_state, is_container='container', presence=False, yang_name="cfm-state", rest_name="cfm-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'dot1ag-cfm', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-dot1ag-operational', defining_module='brocade-dot1ag-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cfm_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=cfm_state.cfm_state, is_container='container', presence=False, yang_name="cfm-state", rest_name="cfm-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'dot1ag-cfm', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-dot1ag-operational', defining_module='brocade-dot1ag-operational', yang_type='container', is_config=True)""",
        })

    self.__cfm_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cfm_state(self):
    self.__cfm_state = YANGDynClass(base=cfm_state.cfm_state, is_container='container', presence=False, yang_name="cfm-state", rest_name="cfm-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'dot1ag-cfm', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-dot1ag-operational', defining_module='brocade-dot1ag-operational', yang_type='container', is_config=True)


  def _get_loam_state(self):
    """
    Getter method for loam_state, mapped from YANG variable /loam_state (container)

    YANG Description: LINK-OAM Operational Information
    """
    return self.__loam_state
      
  def _set_loam_state(self, v, load=False):
    """
    Setter method for loam_state, mapped from YANG variable /loam_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loam_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loam_state() directly.

    YANG Description: LINK-OAM Operational Information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=loam_state.loam_state, is_container='container', presence=False, yang_name="loam-state", rest_name="loam-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'dot1ag-loam', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-dot1ag-operational', defining_module='brocade-dot1ag-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loam_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=loam_state.loam_state, is_container='container', presence=False, yang_name="loam-state", rest_name="loam-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'dot1ag-loam', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-dot1ag-operational', defining_module='brocade-dot1ag-operational', yang_type='container', is_config=True)""",
        })

    self.__loam_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loam_state(self):
    self.__loam_state = YANGDynClass(base=loam_state.loam_state, is_container='container', presence=False, yang_name="loam-state", rest_name="loam-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'dot1ag-loam', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-dot1ag-operational', defining_module='brocade-dot1ag-operational', yang_type='container', is_config=True)


  def _get_loam_show_debug_state(self):
    """
    Getter method for loam_show_debug_state, mapped from YANG variable /loam_show_debug_state (container)

    YANG Description: LINK-OAM debug informaation
    """
    return self.__loam_show_debug_state
      
  def _set_loam_show_debug_state(self, v, load=False):
    """
    Setter method for loam_show_debug_state, mapped from YANG variable /loam_show_debug_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loam_show_debug_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loam_show_debug_state() directly.

    YANG Description: LINK-OAM debug informaation
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=loam_show_debug_state.loam_show_debug_state, is_container='container', presence=False, yang_name="loam-show-debug-state", rest_name="loam-show-debug-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'dot1ag-loam-show-debug', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-dot1ag-operational', defining_module='brocade-dot1ag-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loam_show_debug_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=loam_show_debug_state.loam_show_debug_state, is_container='container', presence=False, yang_name="loam-show-debug-state", rest_name="loam-show-debug-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'dot1ag-loam-show-debug', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-dot1ag-operational', defining_module='brocade-dot1ag-operational', yang_type='container', is_config=True)""",
        })

    self.__loam_show_debug_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loam_show_debug_state(self):
    self.__loam_show_debug_state = YANGDynClass(base=loam_show_debug_state.loam_show_debug_state, is_container='container', presence=False, yang_name="loam-show-debug-state", rest_name="loam-show-debug-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'dot1ag-loam-show-debug', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-dot1ag-operational', defining_module='brocade-dot1ag-operational', yang_type='container', is_config=True)

  cfm_state = __builtin__.property(_get_cfm_state, _set_cfm_state)
  loam_state = __builtin__.property(_get_loam_state, _set_loam_state)
  loam_show_debug_state = __builtin__.property(_get_loam_show_debug_state, _set_loam_show_debug_state)


  _pyangbind_elements = {'cfm_state': cfm_state, 'loam_state': loam_state, 'loam_show_debug_state': loam_show_debug_state, }


import certutil
class brocade_certutil(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-certutil - based on the path /brocade-certutil. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module is used to support certificate management operations
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__certutil',)

  _yang_name = 'brocade-certutil'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__certutil = YANGDynClass(base=certutil.certutil, is_container='container', presence=False, yang_name="certutil", rest_name="certutil", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Security Certificate Management Operations'}}, namespace='urn:brocade.com:mgmt:certutil', defining_module='brocade-certutil', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_certutil(self):
    """
    Getter method for certutil, mapped from YANG variable /certutil (container)

    YANG Description: Security Certificate Management Operations
    """
    return self.__certutil
      
  def _set_certutil(self, v, load=False):
    """
    Setter method for certutil, mapped from YANG variable /certutil (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_certutil is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_certutil() directly.

    YANG Description: Security Certificate Management Operations
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=certutil.certutil, is_container='container', presence=False, yang_name="certutil", rest_name="certutil", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Security Certificate Management Operations'}}, namespace='urn:brocade.com:mgmt:certutil', defining_module='brocade-certutil', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """certutil must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=certutil.certutil, is_container='container', presence=False, yang_name="certutil", rest_name="certutil", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Security Certificate Management Operations'}}, namespace='urn:brocade.com:mgmt:certutil', defining_module='brocade-certutil', yang_type='container', is_config=True)""",
        })

    self.__certutil = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_certutil(self):
    self.__certutil = YANGDynClass(base=certutil.certutil, is_container='container', presence=False, yang_name="certutil", rest_name="certutil", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Security Certificate Management Operations'}}, namespace='urn:brocade.com:mgmt:certutil', defining_module='brocade-certutil', yang_type='container', is_config=True)

  certutil = __builtin__.property(_get_certutil, _set_certutil)


  _pyangbind_elements = {'certutil': certutil, }


import overlay
import overlay_transit
class brocade_vxlan_visibility(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-vxlan-visibility - based on the path /brocade-vxlan-visibility. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module manages VxLan Visibility commands
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__overlay','__overlay_transit',)

  _yang_name = 'brocade-vxlan-visibility'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__overlay_transit = YANGDynClass(base=YANGListType("user_transit_name",overlay_transit.overlay_transit, yang_name="overlay-transit", rest_name="overlay-transit", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='user-transit-name', extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'cli-sequence-commands': None, u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}), is_container='list', yang_name="overlay-transit", rest_name="overlay-transit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'cli-sequence-commands': None, u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='list', is_config=True)
    self.__overlay = YANGDynClass(base=overlay.overlay, is_container='container', presence=False, yang_name="overlay", rest_name="overlay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_overlay(self):
    """
    Getter method for overlay, mapped from YANG variable /overlay (container)
    """
    return self.__overlay
      
  def _set_overlay(self, v, load=False):
    """
    Setter method for overlay, mapped from YANG variable /overlay (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overlay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overlay() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=overlay.overlay, is_container='container', presence=False, yang_name="overlay", rest_name="overlay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overlay must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=overlay.overlay, is_container='container', presence=False, yang_name="overlay", rest_name="overlay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='container', is_config=True)""",
        })

    self.__overlay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overlay(self):
    self.__overlay = YANGDynClass(base=overlay.overlay, is_container='container', presence=False, yang_name="overlay", rest_name="overlay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='container', is_config=True)


  def _get_overlay_transit(self):
    """
    Getter method for overlay_transit, mapped from YANG variable /overlay_transit (list)
    """
    return self.__overlay_transit
      
  def _set_overlay_transit(self, v, load=False):
    """
    Setter method for overlay_transit, mapped from YANG variable /overlay_transit (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overlay_transit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overlay_transit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("user_transit_name",overlay_transit.overlay_transit, yang_name="overlay-transit", rest_name="overlay-transit", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='user-transit-name', extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'cli-sequence-commands': None, u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}), is_container='list', yang_name="overlay-transit", rest_name="overlay-transit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'cli-sequence-commands': None, u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overlay_transit must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("user_transit_name",overlay_transit.overlay_transit, yang_name="overlay-transit", rest_name="overlay-transit", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='user-transit-name', extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'cli-sequence-commands': None, u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}), is_container='list', yang_name="overlay-transit", rest_name="overlay-transit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'cli-sequence-commands': None, u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='list', is_config=True)""",
        })

    self.__overlay_transit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overlay_transit(self):
    self.__overlay_transit = YANGDynClass(base=YANGListType("user_transit_name",overlay_transit.overlay_transit, yang_name="overlay-transit", rest_name="overlay-transit", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='user-transit-name', extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'cli-sequence-commands': None, u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}), is_container='list', yang_name="overlay-transit", rest_name="overlay-transit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'overlay-transit <user-transit-name>', u'cli-sequence-commands': None, u'callpoint': u'VxlanVisibilityTransitCallpoint', u'cli-mode-name': u'config-overlay-transit-$(user-transit-name)'}}, namespace='urn:brocade.com:mgmt:brocade-vxlan-visibility', defining_module='brocade-vxlan-visibility', yang_type='list', is_config=True)

  overlay = __builtin__.property(_get_overlay, _set_overlay)
  overlay_transit = __builtin__.property(_get_overlay_transit, _set_overlay_transit)


  _pyangbind_elements = {'overlay': overlay, 'overlay_transit': overlay_transit, }


import igmp_snooping
class brocade_igmp_snooping(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-igmp-snooping - based on the path /brocade-igmp-snooping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage the 
'Internet Group Management Protocol (IGMP) Snooping'.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__igmp_snooping',)

  _yang_name = 'brocade-igmp-snooping'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__igmp_snooping = YANGDynClass(base=igmp_snooping.igmp_snooping, is_container='container', presence=False, yang_name="igmp-snooping", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-igmp-snooping', defining_module='brocade-igmp-snooping', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_igmp_snooping(self):
    """
    Getter method for igmp_snooping, mapped from YANG variable /igmp_snooping (container)
    """
    return self.__igmp_snooping
      
  def _set_igmp_snooping(self, v, load=False):
    """
    Setter method for igmp_snooping, mapped from YANG variable /igmp_snooping (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_igmp_snooping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_igmp_snooping() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=igmp_snooping.igmp_snooping, is_container='container', presence=False, yang_name="igmp-snooping", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-igmp-snooping', defining_module='brocade-igmp-snooping', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """igmp_snooping must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=igmp_snooping.igmp_snooping, is_container='container', presence=False, yang_name="igmp-snooping", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-igmp-snooping', defining_module='brocade-igmp-snooping', yang_type='container', is_config=True)""",
        })

    self.__igmp_snooping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_igmp_snooping(self):
    self.__igmp_snooping = YANGDynClass(base=igmp_snooping.igmp_snooping, is_container='container', presence=False, yang_name="igmp-snooping", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-igmp-snooping', defining_module='brocade-igmp-snooping', yang_type='container', is_config=True)

  igmp_snooping = __builtin__.property(_get_igmp_snooping, _set_igmp_snooping)


  _pyangbind_elements = {'igmp_snooping': igmp_snooping, }


import control_plane
class brocade_control_plane(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-control-plane - based on the path /brocade-control-plane. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to control-plane
level commands
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__control_plane',)

  _yang_name = 'brocade-control-plane'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__control_plane = YANGDynClass(base=control_plane.control_plane, is_container='container', presence=False, yang_name="control-plane", rest_name="control-plane", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Control Plane configuration', u'cli-add-mode': None, u'cli-suppress-no': None, u'cli-full-command': None}}, namespace='urn:brocade.com:mgmt:brocade-control-plane', defining_module='brocade-control-plane', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_control_plane(self):
    """
    Getter method for control_plane, mapped from YANG variable /control_plane (container)
    """
    return self.__control_plane
      
  def _set_control_plane(self, v, load=False):
    """
    Setter method for control_plane, mapped from YANG variable /control_plane (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=control_plane.control_plane, is_container='container', presence=False, yang_name="control-plane", rest_name="control-plane", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Control Plane configuration', u'cli-add-mode': None, u'cli-suppress-no': None, u'cli-full-command': None}}, namespace='urn:brocade.com:mgmt:brocade-control-plane', defining_module='brocade-control-plane', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=control_plane.control_plane, is_container='container', presence=False, yang_name="control-plane", rest_name="control-plane", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Control Plane configuration', u'cli-add-mode': None, u'cli-suppress-no': None, u'cli-full-command': None}}, namespace='urn:brocade.com:mgmt:brocade-control-plane', defining_module='brocade-control-plane', yang_type='container', is_config=True)""",
        })

    self.__control_plane = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane(self):
    self.__control_plane = YANGDynClass(base=control_plane.control_plane, is_container='container', presence=False, yang_name="control-plane", rest_name="control-plane", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Control Plane configuration', u'cli-add-mode': None, u'cli-suppress-no': None, u'cli-full-command': None}}, namespace='urn:brocade.com:mgmt:brocade-control-plane', defining_module='brocade-control-plane', yang_type='container', is_config=True)

  control_plane = __builtin__.property(_get_control_plane, _set_control_plane)


  _pyangbind_elements = {'control_plane': control_plane, }


import telemetry
class brocade_telemetry(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-telemetry - based on the path /brocade-telemetry. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage
telemetry configuration.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__telemetry',)

  _yang_name = 'brocade-telemetry'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__telemetry = YANGDynClass(base=telemetry.telemetry, is_container='container', presence=False, yang_name="telemetry", rest_name="telemetry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Telemetry configuration', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-telemetry', defining_module='brocade-telemetry', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_telemetry(self):
    """
    Getter method for telemetry, mapped from YANG variable /telemetry (container)
    """
    return self.__telemetry
      
  def _set_telemetry(self, v, load=False):
    """
    Setter method for telemetry, mapped from YANG variable /telemetry (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_telemetry is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_telemetry() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=telemetry.telemetry, is_container='container', presence=False, yang_name="telemetry", rest_name="telemetry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Telemetry configuration', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-telemetry', defining_module='brocade-telemetry', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """telemetry must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=telemetry.telemetry, is_container='container', presence=False, yang_name="telemetry", rest_name="telemetry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Telemetry configuration', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-telemetry', defining_module='brocade-telemetry', yang_type='container', is_config=True)""",
        })

    self.__telemetry = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_telemetry(self):
    self.__telemetry = YANGDynClass(base=telemetry.telemetry, is_container='container', presence=False, yang_name="telemetry", rest_name="telemetry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Telemetry configuration', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-telemetry', defining_module='brocade-telemetry', yang_type='container', is_config=True)

  telemetry = __builtin__.property(_get_telemetry, _set_telemetry)


  _pyangbind_elements = {'telemetry': telemetry, }


class brocade_udld(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-udld - based on the path /brocade-udld. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage UDLD
protocol configuration.

Glossary of the terms used:
---------------------------
PDU    - Protocol Data Unit. In the context of this module PDU
         refers to Layer2 frame transmitted or received by
         UDLD protocol.
UDLD   - UniDirectional Link Detection

  """
  _pyangbind_elements = {}

  

class brocade_ospf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ospf - based on the path /brocade-ospf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage 
OSPF Version 2 Protocol.
  """
  _pyangbind_elements = {}

  

import crypto
class brocade_crypto_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-crypto-ext - based on the path /brocade-crypto-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Instrument to configure Crypto services for HTTPS Certificate Management
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__crypto',)

  _yang_name = 'brocade-crypto-ext'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__crypto = YANGDynClass(base=crypto.crypto, is_container='container', presence=False, yang_name="crypto", rest_name="crypto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Crypto Certificate Management Operations'}}, namespace='urn:brocade.com:mgmt:brocade-crypto-ext', defining_module='brocade-crypto-ext', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_crypto(self):
    """
    Getter method for crypto, mapped from YANG variable /crypto (container)
    """
    return self.__crypto
      
  def _set_crypto(self, v, load=False):
    """
    Setter method for crypto, mapped from YANG variable /crypto (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_crypto is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_crypto() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=crypto.crypto, is_container='container', presence=False, yang_name="crypto", rest_name="crypto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Crypto Certificate Management Operations'}}, namespace='urn:brocade.com:mgmt:brocade-crypto-ext', defining_module='brocade-crypto-ext', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """crypto must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=crypto.crypto, is_container='container', presence=False, yang_name="crypto", rest_name="crypto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Crypto Certificate Management Operations'}}, namespace='urn:brocade.com:mgmt:brocade-crypto-ext', defining_module='brocade-crypto-ext', yang_type='container', is_config=True)""",
        })

    self.__crypto = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_crypto(self):
    self.__crypto = YANGDynClass(base=crypto.crypto, is_container='container', presence=False, yang_name="crypto", rest_name="crypto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Crypto Certificate Management Operations'}}, namespace='urn:brocade.com:mgmt:brocade-crypto-ext', defining_module='brocade-crypto-ext', yang_type='container', is_config=True)

  crypto = __builtin__.property(_get_crypto, _set_crypto)


  _pyangbind_elements = {'crypto': crypto, }


import bridge_domain_state
import logical_interface_state
import mct_state
import sub_interface_statistics_state
import topology_group_state
import vpn_statistics_state
class brocade_nsm_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-nsm-operational - based on the path /brocade-nsm-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage nsm
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__bridge_domain_state','__logical_interface_state','__mct_state','__sub_interface_statistics_state','__topology_group_state','__vpn_statistics_state',)

  _yang_name = 'brocade-nsm-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__logical_interface_state = YANGDynClass(base=logical_interface_state.logical_interface_state, is_container='container', presence=False, yang_name="logical-interface-state", rest_name="logical-interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-logical-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)
    self.__topology_group_state = YANGDynClass(base=topology_group_state.topology_group_state, is_container='container', presence=False, yang_name="topology-group-state", rest_name="topology-group-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-topology-group', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)
    self.__mct_state = YANGDynClass(base=mct_state.mct_state, is_container='container', presence=False, yang_name="mct-state", rest_name="mct-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-mct', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)
    self.__sub_interface_statistics_state = YANGDynClass(base=sub_interface_statistics_state.sub_interface_statistics_state, is_container='container', presence=False, yang_name="sub-interface-statistics-state", rest_name="sub-interface-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-sub-interface-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)
    self.__vpn_statistics_state = YANGDynClass(base=vpn_statistics_state.vpn_statistics_state, is_container='container', presence=False, yang_name="vpn-statistics-state", rest_name="vpn-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-vpn-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)
    self.__bridge_domain_state = YANGDynClass(base=bridge_domain_state.bridge_domain_state, is_container='container', presence=False, yang_name="bridge-domain-state", rest_name="bridge-domain-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-bridge-domain', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_bridge_domain_state(self):
    """
    Getter method for bridge_domain_state, mapped from YANG variable /bridge_domain_state (container)

    YANG Description:  brief Bridge-domain information
    """
    return self.__bridge_domain_state
      
  def _set_bridge_domain_state(self, v, load=False):
    """
    Setter method for bridge_domain_state, mapped from YANG variable /bridge_domain_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bridge_domain_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bridge_domain_state() directly.

    YANG Description:  brief Bridge-domain information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bridge_domain_state.bridge_domain_state, is_container='container', presence=False, yang_name="bridge-domain-state", rest_name="bridge-domain-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-bridge-domain', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bridge_domain_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bridge_domain_state.bridge_domain_state, is_container='container', presence=False, yang_name="bridge-domain-state", rest_name="bridge-domain-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-bridge-domain', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)""",
        })

    self.__bridge_domain_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bridge_domain_state(self):
    self.__bridge_domain_state = YANGDynClass(base=bridge_domain_state.bridge_domain_state, is_container='container', presence=False, yang_name="bridge-domain-state", rest_name="bridge-domain-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-bridge-domain', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)


  def _get_logical_interface_state(self):
    """
    Getter method for logical_interface_state, mapped from YANG variable /logical_interface_state (container)

    YANG Description: Logical interface
    """
    return self.__logical_interface_state
      
  def _set_logical_interface_state(self, v, load=False):
    """
    Setter method for logical_interface_state, mapped from YANG variable /logical_interface_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_interface_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_interface_state() directly.

    YANG Description: Logical interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=logical_interface_state.logical_interface_state, is_container='container', presence=False, yang_name="logical-interface-state", rest_name="logical-interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-logical-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_interface_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logical_interface_state.logical_interface_state, is_container='container', presence=False, yang_name="logical-interface-state", rest_name="logical-interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-logical-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)""",
        })

    self.__logical_interface_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_interface_state(self):
    self.__logical_interface_state = YANGDynClass(base=logical_interface_state.logical_interface_state, is_container='container', presence=False, yang_name="logical-interface-state", rest_name="logical-interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-logical-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)


  def _get_mct_state(self):
    """
    Getter method for mct_state, mapped from YANG variable /mct_state (container)

    YANG Description: MCT Operational Information
    """
    return self.__mct_state
      
  def _set_mct_state(self, v, load=False):
    """
    Setter method for mct_state, mapped from YANG variable /mct_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mct_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mct_state() directly.

    YANG Description: MCT Operational Information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mct_state.mct_state, is_container='container', presence=False, yang_name="mct-state", rest_name="mct-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-mct', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mct_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mct_state.mct_state, is_container='container', presence=False, yang_name="mct-state", rest_name="mct-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-mct', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)""",
        })

    self.__mct_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mct_state(self):
    self.__mct_state = YANGDynClass(base=mct_state.mct_state, is_container='container', presence=False, yang_name="mct-state", rest_name="mct-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-mct', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)


  def _get_sub_interface_statistics_state(self):
    """
    Getter method for sub_interface_statistics_state, mapped from YANG variable /sub_interface_statistics_state (container)

    YANG Description: sub-interface statistics
    """
    return self.__sub_interface_statistics_state
      
  def _set_sub_interface_statistics_state(self, v, load=False):
    """
    Setter method for sub_interface_statistics_state, mapped from YANG variable /sub_interface_statistics_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sub_interface_statistics_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sub_interface_statistics_state() directly.

    YANG Description: sub-interface statistics
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=sub_interface_statistics_state.sub_interface_statistics_state, is_container='container', presence=False, yang_name="sub-interface-statistics-state", rest_name="sub-interface-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-sub-interface-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sub_interface_statistics_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=sub_interface_statistics_state.sub_interface_statistics_state, is_container='container', presence=False, yang_name="sub-interface-statistics-state", rest_name="sub-interface-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-sub-interface-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)""",
        })

    self.__sub_interface_statistics_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sub_interface_statistics_state(self):
    self.__sub_interface_statistics_state = YANGDynClass(base=sub_interface_statistics_state.sub_interface_statistics_state, is_container='container', presence=False, yang_name="sub-interface-statistics-state", rest_name="sub-interface-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-sub-interface-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)


  def _get_topology_group_state(self):
    """
    Getter method for topology_group_state, mapped from YANG variable /topology_group_state (container)

    YANG Description:  Topology Group related information
    """
    return self.__topology_group_state
      
  def _set_topology_group_state(self, v, load=False):
    """
    Setter method for topology_group_state, mapped from YANG variable /topology_group_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_topology_group_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_topology_group_state() directly.

    YANG Description:  Topology Group related information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=topology_group_state.topology_group_state, is_container='container', presence=False, yang_name="topology-group-state", rest_name="topology-group-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-topology-group', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """topology_group_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=topology_group_state.topology_group_state, is_container='container', presence=False, yang_name="topology-group-state", rest_name="topology-group-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-topology-group', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)""",
        })

    self.__topology_group_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_topology_group_state(self):
    self.__topology_group_state = YANGDynClass(base=topology_group_state.topology_group_state, is_container='container', presence=False, yang_name="topology-group-state", rest_name="topology-group-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-topology-group', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)


  def _get_vpn_statistics_state(self):
    """
    Getter method for vpn_statistics_state, mapped from YANG variable /vpn_statistics_state (container)
    """
    return self.__vpn_statistics_state
      
  def _set_vpn_statistics_state(self, v, load=False):
    """
    Setter method for vpn_statistics_state, mapped from YANG variable /vpn_statistics_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_statistics_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_statistics_state() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=vpn_statistics_state.vpn_statistics_state, is_container='container', presence=False, yang_name="vpn-statistics-state", rest_name="vpn-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-vpn-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_statistics_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vpn_statistics_state.vpn_statistics_state, is_container='container', presence=False, yang_name="vpn-statistics-state", rest_name="vpn-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-vpn-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)""",
        })

    self.__vpn_statistics_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_statistics_state(self):
    self.__vpn_statistics_state = YANGDynClass(base=vpn_statistics_state.vpn_statistics_state, is_container='container', presence=False, yang_name="vpn-statistics-state", rest_name="vpn-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-vpn-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='container', is_config=True)

  bridge_domain_state = __builtin__.property(_get_bridge_domain_state, _set_bridge_domain_state)
  logical_interface_state = __builtin__.property(_get_logical_interface_state, _set_logical_interface_state)
  mct_state = __builtin__.property(_get_mct_state, _set_mct_state)
  sub_interface_statistics_state = __builtin__.property(_get_sub_interface_statistics_state, _set_sub_interface_statistics_state)
  topology_group_state = __builtin__.property(_get_topology_group_state, _set_topology_group_state)
  vpn_statistics_state = __builtin__.property(_get_vpn_statistics_state, _set_vpn_statistics_state)


  _pyangbind_elements = {'bridge_domain_state': bridge_domain_state, 'logical_interface_state': logical_interface_state, 'mct_state': mct_state, 'sub_interface_statistics_state': sub_interface_statistics_state, 'topology_group_state': topology_group_state, 'vpn_statistics_state': vpn_statistics_state, }


class brocade_trilloam(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-trilloam - based on the path /brocade-trilloam. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  _pyangbind_elements = {}

  

import fcsp
import fcsp_sa
import secpolicy
import secpolicy_sa
class brocade_fc_auth(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-fc-auth - based on the path /brocade-fc-auth. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data Model for AAA CLIs
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__fcsp','__fcsp_sa','__secpolicy','__secpolicy_sa',)

  _yang_name = 'brocade-fc-auth'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__secpolicy = YANGDynClass(base=secpolicy.secpolicy, is_container='container', presence=False, yang_name="secpolicy", rest_name="secpolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)
    self.__fcsp_sa = YANGDynClass(base=fcsp_sa.fcsp_sa, is_container='container', presence=False, yang_name="fcsp-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)
    self.__fcsp = YANGDynClass(base=fcsp.fcsp, is_container='container', presence=False, yang_name="fcsp", rest_name="fcsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'FCSP operational commands', u'hidden': u'full', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)
    self.__secpolicy_sa = YANGDynClass(base=secpolicy_sa.secpolicy_sa, is_container='container', presence=False, yang_name="secpolicy-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_fcsp(self):
    """
    Getter method for fcsp, mapped from YANG variable /fcsp (container)
    """
    return self.__fcsp
      
  def _set_fcsp(self, v, load=False):
    """
    Setter method for fcsp, mapped from YANG variable /fcsp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fcsp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fcsp() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=fcsp.fcsp, is_container='container', presence=False, yang_name="fcsp", rest_name="fcsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'FCSP operational commands', u'hidden': u'full', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fcsp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=fcsp.fcsp, is_container='container', presence=False, yang_name="fcsp", rest_name="fcsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'FCSP operational commands', u'hidden': u'full', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)""",
        })

    self.__fcsp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fcsp(self):
    self.__fcsp = YANGDynClass(base=fcsp.fcsp, is_container='container', presence=False, yang_name="fcsp", rest_name="fcsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'FCSP operational commands', u'hidden': u'full', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)


  def _get_fcsp_sa(self):
    """
    Getter method for fcsp_sa, mapped from YANG variable /fcsp_sa (container)
    """
    return self.__fcsp_sa
      
  def _set_fcsp_sa(self, v, load=False):
    """
    Setter method for fcsp_sa, mapped from YANG variable /fcsp_sa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fcsp_sa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fcsp_sa() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=fcsp_sa.fcsp_sa, is_container='container', presence=False, yang_name="fcsp-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fcsp_sa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=fcsp_sa.fcsp_sa, is_container='container', presence=False, yang_name="fcsp-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)""",
        })

    self.__fcsp_sa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fcsp_sa(self):
    self.__fcsp_sa = YANGDynClass(base=fcsp_sa.fcsp_sa, is_container='container', presence=False, yang_name="fcsp-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)


  def _get_secpolicy(self):
    """
    Getter method for secpolicy, mapped from YANG variable /secpolicy (container)
    """
    return self.__secpolicy
      
  def _set_secpolicy(self, v, load=False):
    """
    Setter method for secpolicy, mapped from YANG variable /secpolicy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secpolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secpolicy() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=secpolicy.secpolicy, is_container='container', presence=False, yang_name="secpolicy", rest_name="secpolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secpolicy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=secpolicy.secpolicy, is_container='container', presence=False, yang_name="secpolicy", rest_name="secpolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)""",
        })

    self.__secpolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secpolicy(self):
    self.__secpolicy = YANGDynClass(base=secpolicy.secpolicy, is_container='container', presence=False, yang_name="secpolicy", rest_name="secpolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)


  def _get_secpolicy_sa(self):
    """
    Getter method for secpolicy_sa, mapped from YANG variable /secpolicy_sa (container)
    """
    return self.__secpolicy_sa
      
  def _set_secpolicy_sa(self, v, load=False):
    """
    Setter method for secpolicy_sa, mapped from YANG variable /secpolicy_sa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secpolicy_sa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secpolicy_sa() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=secpolicy_sa.secpolicy_sa, is_container='container', presence=False, yang_name="secpolicy-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secpolicy_sa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=secpolicy_sa.secpolicy_sa, is_container='container', presence=False, yang_name="secpolicy-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)""",
        })

    self.__secpolicy_sa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secpolicy_sa(self):
    self.__secpolicy_sa = YANGDynClass(base=secpolicy_sa.secpolicy_sa, is_container='container', presence=False, yang_name="secpolicy-sa", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'display-when': u'/vcsmode/vcs-mode = "false"'}}, namespace='urn:brocade.com:mgmt:brocade-fc-auth', defining_module='brocade-fc-auth', yang_type='container', is_config=True)

  fcsp = __builtin__.property(_get_fcsp, _set_fcsp)
  fcsp_sa = __builtin__.property(_get_fcsp_sa, _set_fcsp_sa)
  secpolicy = __builtin__.property(_get_secpolicy, _set_secpolicy)
  secpolicy_sa = __builtin__.property(_get_secpolicy_sa, _set_secpolicy_sa)


  _pyangbind_elements = {'fcsp': fcsp, 'fcsp_sa': fcsp_sa, 'secpolicy': secpolicy, 'secpolicy_sa': secpolicy_sa, }


import rpf_config
class brocade_rpf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-rpf - based on the path /brocade-rpf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes the data model for Reverse Path Forwarding Protocol
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__rpf_config',)

  _yang_name = 'brocade-rpf'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__rpf_config = YANGDynClass(base=rpf_config.rpf_config, is_container='container', presence=False, yang_name="rpf_config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'callpoint': u'RpfConfig'}}, namespace='urn:brocade.com:mgmt:brocade-rpf', defining_module='brocade-rpf', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_rpf_config(self):
    """
    Getter method for rpf_config, mapped from YANG variable /rpf_config (container)
    """
    return self.__rpf_config
      
  def _set_rpf_config(self, v, load=False):
    """
    Setter method for rpf_config, mapped from YANG variable /rpf_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rpf_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rpf_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=rpf_config.rpf_config, is_container='container', presence=False, yang_name="rpf_config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'callpoint': u'RpfConfig'}}, namespace='urn:brocade.com:mgmt:brocade-rpf', defining_module='brocade-rpf', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rpf_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=rpf_config.rpf_config, is_container='container', presence=False, yang_name="rpf_config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'callpoint': u'RpfConfig'}}, namespace='urn:brocade.com:mgmt:brocade-rpf', defining_module='brocade-rpf', yang_type='container', is_config=True)""",
        })

    self.__rpf_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rpf_config(self):
    self.__rpf_config = YANGDynClass(base=rpf_config.rpf_config, is_container='container', presence=False, yang_name="rpf_config", rest_name="", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full', u'callpoint': u'RpfConfig'}}, namespace='urn:brocade.com:mgmt:brocade-rpf', defining_module='brocade-rpf', yang_type='container', is_config=True)

  rpf_config = __builtin__.property(_get_rpf_config, _set_rpf_config)


  _pyangbind_elements = {'rpf_config': rpf_config, }


class brocade_xstp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-xstp - based on the path /brocade-xstp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage the 
Spanning Tree Protocol (STP).          
        
Glossary of the terms used:
--------------------------- 
        

  """
  _pyangbind_elements = {}

  

import sflow
import sflow_profile
class brocade_sflow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-sflow - based on the path /brocade-sflow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule describes the data model for sFlow
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__sflow','__sflow_profile',)

  _yang_name = 'brocade-sflow'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__sflow_profile = YANGDynClass(base=YANGListType("profile_name",sflow_profile.sflow_profile, yang_name="sflow-profile", rest_name="sflow-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'hidden': u'full', u'callpoint': u'SflowProfile'}}), is_container='list', yang_name="sflow-profile", rest_name="sflow-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'hidden': u'full', u'callpoint': u'SflowProfile'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='list', is_config=True)
    self.__sflow = YANGDynClass(base=sflow.sflow, is_container='container', presence=False, yang_name="sflow", rest_name="sflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Configuration', u'cli-incomplete-no': None, u'callpoint': u'Sflow', u'sort-priority': u'RUNNCFG_LEVEL_SFLOW_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_sflow(self):
    """
    Getter method for sflow, mapped from YANG variable /sflow (container)
    """
    return self.__sflow
      
  def _set_sflow(self, v, load=False):
    """
    Setter method for sflow, mapped from YANG variable /sflow (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sflow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sflow() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=sflow.sflow, is_container='container', presence=False, yang_name="sflow", rest_name="sflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Configuration', u'cli-incomplete-no': None, u'callpoint': u'Sflow', u'sort-priority': u'RUNNCFG_LEVEL_SFLOW_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sflow must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=sflow.sflow, is_container='container', presence=False, yang_name="sflow", rest_name="sflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Configuration', u'cli-incomplete-no': None, u'callpoint': u'Sflow', u'sort-priority': u'RUNNCFG_LEVEL_SFLOW_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='container', is_config=True)""",
        })

    self.__sflow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sflow(self):
    self.__sflow = YANGDynClass(base=sflow.sflow, is_container='container', presence=False, yang_name="sflow", rest_name="sflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Configuration', u'cli-incomplete-no': None, u'callpoint': u'Sflow', u'sort-priority': u'RUNNCFG_LEVEL_SFLOW_CONFIG'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='container', is_config=True)


  def _get_sflow_profile(self):
    """
    Getter method for sflow_profile, mapped from YANG variable /sflow_profile (list)
    """
    return self.__sflow_profile
      
  def _set_sflow_profile(self, v, load=False):
    """
    Setter method for sflow_profile, mapped from YANG variable /sflow_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sflow_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sflow_profile() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("profile_name",sflow_profile.sflow_profile, yang_name="sflow-profile", rest_name="sflow-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'hidden': u'full', u'callpoint': u'SflowProfile'}}), is_container='list', yang_name="sflow-profile", rest_name="sflow-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'hidden': u'full', u'callpoint': u'SflowProfile'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sflow_profile must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("profile_name",sflow_profile.sflow_profile, yang_name="sflow-profile", rest_name="sflow-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'hidden': u'full', u'callpoint': u'SflowProfile'}}), is_container='list', yang_name="sflow-profile", rest_name="sflow-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'hidden': u'full', u'callpoint': u'SflowProfile'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='list', is_config=True)""",
        })

    self.__sflow_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sflow_profile(self):
    self.__sflow_profile = YANGDynClass(base=YANGListType("profile_name",sflow_profile.sflow_profile, yang_name="sflow-profile", rest_name="sflow-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'hidden': u'full', u'callpoint': u'SflowProfile'}}), is_container='list', yang_name="sflow-profile", rest_name="sflow-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Sflow Profile Configuration', u'cli-suppress-mode': None, u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-command': None, u'hidden': u'full', u'callpoint': u'SflowProfile'}}, namespace='urn:brocade.com:mgmt:brocade-sflow', defining_module='brocade-sflow', yang_type='list', is_config=True)

  sflow = __builtin__.property(_get_sflow, _set_sflow)
  sflow_profile = __builtin__.property(_get_sflow_profile, _set_sflow_profile)


  _pyangbind_elements = {'sflow': sflow, 'sflow_profile': sflow_profile, }


import system_utilization_state
class brocade_systemutilization_operational(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-systemutilization-operational - based on the path /brocade-systemutilization-operational. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This management module is an instrumentation to manage systemutilization
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__system_utilization_state',)

  _yang_name = 'brocade-systemutilization-operational'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__system_utilization_state = YANGDynClass(base=system_utilization_state.system_utilization_state, is_container='container', presence=False, yang_name="system-utilization-state", rest_name="system-utilization-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'systemutilization-system-utilization', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_system_utilization_state(self):
    """
    Getter method for system_utilization_state, mapped from YANG variable /system_utilization_state (container)

    YANG Description: System Utilization statistics
    """
    return self.__system_utilization_state
      
  def _set_system_utilization_state(self, v, load=False):
    """
    Setter method for system_utilization_state, mapped from YANG variable /system_utilization_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_utilization_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_utilization_state() directly.

    YANG Description: System Utilization statistics
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=system_utilization_state.system_utilization_state, is_container='container', presence=False, yang_name="system-utilization-state", rest_name="system-utilization-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'systemutilization-system-utilization', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_utilization_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=system_utilization_state.system_utilization_state, is_container='container', presence=False, yang_name="system-utilization-state", rest_name="system-utilization-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'systemutilization-system-utilization', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='container', is_config=True)""",
        })

    self.__system_utilization_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_utilization_state(self):
    self.__system_utilization_state = YANGDynClass(base=system_utilization_state.system_utilization_state, is_container='container', presence=False, yang_name="system-utilization-state", rest_name="system-utilization-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'systemutilization-system-utilization', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-systemutilization-operational', defining_module='brocade-systemutilization-operational', yang_type='container', is_config=True)

  system_utilization_state = __builtin__.property(_get_system_utilization_state, _set_system_utilization_state)


  _pyangbind_elements = {'system_utilization_state': system_utilization_state, }


