
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import detail
import flow
import group
import meter
import resources
import interface
import flow_interface
import controller
import flow_id
import group_id
import meter_id
import queues_interface
class openflow_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-openflow-operational - based on the path /openflow-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: OPENFLOW Operational Information
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__detail','__flow','__group','__meter','__resources','__interface','__flow_interface','__controller','__flow_id','__group_id','__meter_id','__queues_interface',)

  _yang_name = 'openflow-state'
  _rest_name = 'openflow-state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__group = YANGDynClass(base=group.group, is_container='container', presence=False, yang_name="group", rest_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-group', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    self.__flow = YANGDynClass(base=flow.flow, is_container='container', presence=False, yang_name="flow", rest_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    self.__detail = YANGDynClass(base=detail.detail, is_container='container', presence=False, yang_name="detail", rest_name="detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-detail', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    self.__meter = YANGDynClass(base=meter.meter, is_container='container', presence=False, yang_name="meter", rest_name="meter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-meter', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    self.__controller = YANGDynClass(base=YANGListType("name",controller.controller, yang_name="controller", rest_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'callpoint': u'openflow-controller-controller-1'}}), is_container='list', yang_name="controller", rest_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-controller-controller-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)
    self.__flow_interface = YANGDynClass(base=YANGListType("interface_type interface_value",flow_interface.flow_interface, yang_name="flow-interface", rest_name="flow-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-type interface-value', extensions={u'tailf-common': {u'callpoint': u'openflow-flow-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="flow-interface", rest_name="flow-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)
    self.__flow_id = YANGDynClass(base=flow_id.flow_id, is_container='container', presence=False, yang_name="flow-id", rest_name="flow-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow-info-flow-id-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    self.__interface = YANGDynClass(base=YANGListType("port",interface.interface, yang_name="interface", rest_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port', extensions={u'tailf-common': {u'callpoint': u'openflow-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)
    self.__queues_interface = YANGDynClass(base=queues_interface.queues_interface, is_container='container', presence=False, yang_name="queues-interface", rest_name="queues-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-queues-interface-queues-interface-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    self.__group_id = YANGDynClass(base=group_id.group_id, is_container='container', presence=False, yang_name="group-id", rest_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-group-info-group-id-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    self.__resources = YANGDynClass(base=resources.resources, is_container='container', presence=False, yang_name="resources", rest_name="resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-resources', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    self.__meter_id = YANGDynClass(base=meter_id.meter_id, is_container='container', presence=False, yang_name="meter-id", rest_name="meter-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-meter-info-meter-id-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'openflow-state']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'openflow-state']

  def _get_detail(self):
    """
    Getter method for detail, mapped from YANG variable /openflow_state/detail (container)
    """
    return self.__detail
      
  def _set_detail(self, v, load=False):
    """
    Setter method for detail, mapped from YANG variable /openflow_state/detail (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_detail is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_detail() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=detail.detail, is_container='container', presence=False, yang_name="detail", rest_name="detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-detail', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """detail must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=detail.detail, is_container='container', presence=False, yang_name="detail", rest_name="detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-detail', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)""",
        })

    self.__detail = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_detail(self):
    self.__detail = YANGDynClass(base=detail.detail, is_container='container', presence=False, yang_name="detail", rest_name="detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-detail', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)


  def _get_flow(self):
    """
    Getter method for flow, mapped from YANG variable /openflow_state/flow (container)

    YANG Description: Flow details
    """
    return self.__flow
      
  def _set_flow(self, v, load=False):
    """
    Setter method for flow, mapped from YANG variable /openflow_state/flow (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow() directly.

    YANG Description: Flow details
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=flow.flow, is_container='container', presence=False, yang_name="flow", rest_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=flow.flow, is_container='container', presence=False, yang_name="flow", rest_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)""",
        })

    self.__flow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow(self):
    self.__flow = YANGDynClass(base=flow.flow, is_container='container', presence=False, yang_name="flow", rest_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)


  def _get_group(self):
    """
    Getter method for group, mapped from YANG variable /openflow_state/group (container)

    YANG Description: Group details
    """
    return self.__group
      
  def _set_group(self, v, load=False):
    """
    Setter method for group, mapped from YANG variable /openflow_state/group (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group() directly.

    YANG Description: Group details
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=group.group, is_container='container', presence=False, yang_name="group", rest_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-group', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=group.group, is_container='container', presence=False, yang_name="group", rest_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-group', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)""",
        })

    self.__group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group(self):
    self.__group = YANGDynClass(base=group.group, is_container='container', presence=False, yang_name="group", rest_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-group', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)


  def _get_meter(self):
    """
    Getter method for meter, mapped from YANG variable /openflow_state/meter (container)

    YANG Description: Meter
    """
    return self.__meter
      
  def _set_meter(self, v, load=False):
    """
    Setter method for meter, mapped from YANG variable /openflow_state/meter (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_meter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_meter() directly.

    YANG Description: Meter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=meter.meter, is_container='container', presence=False, yang_name="meter", rest_name="meter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-meter', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """meter must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=meter.meter, is_container='container', presence=False, yang_name="meter", rest_name="meter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-meter', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)""",
        })

    self.__meter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_meter(self):
    self.__meter = YANGDynClass(base=meter.meter, is_container='container', presence=False, yang_name="meter", rest_name="meter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-meter', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)


  def _get_resources(self):
    """
    Getter method for resources, mapped from YANG variable /openflow_state/resources (container)

    YANG Description: Openflow Meter Resources
    """
    return self.__resources
      
  def _set_resources(self, v, load=False):
    """
    Setter method for resources, mapped from YANG variable /openflow_state/resources (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resources is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resources() directly.

    YANG Description: Openflow Meter Resources
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=resources.resources, is_container='container', presence=False, yang_name="resources", rest_name="resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-resources', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resources must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=resources.resources, is_container='container', presence=False, yang_name="resources", rest_name="resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-resources', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)""",
        })

    self.__resources = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resources(self):
    self.__resources = YANGDynClass(base=resources.resources, is_container='container', presence=False, yang_name="resources", rest_name="resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-resources', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)


  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /openflow_state/interface (list)

    YANG Description: Openflow enabled interface details
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /openflow_state/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Openflow enabled interface details
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("port",interface.interface, yang_name="interface", rest_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port', extensions={u'tailf-common': {u'callpoint': u'openflow-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("port",interface.interface, yang_name="interface", rest_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port', extensions={u'tailf-common': {u'callpoint': u'openflow-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("port",interface.interface, yang_name="interface", rest_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port', extensions={u'tailf-common': {u'callpoint': u'openflow-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)


  def _get_flow_interface(self):
    """
    Getter method for flow_interface, mapped from YANG variable /openflow_state/flow_interface (list)

    YANG Description: Flow details for an interface
    """
    return self.__flow_interface
      
  def _set_flow_interface(self, v, load=False):
    """
    Setter method for flow_interface, mapped from YANG variable /openflow_state/flow_interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_interface() directly.

    YANG Description: Flow details for an interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("interface_type interface_value",flow_interface.flow_interface, yang_name="flow-interface", rest_name="flow-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-type interface-value', extensions={u'tailf-common': {u'callpoint': u'openflow-flow-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="flow-interface", rest_name="flow-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow_interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("interface_type interface_value",flow_interface.flow_interface, yang_name="flow-interface", rest_name="flow-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-type interface-value', extensions={u'tailf-common': {u'callpoint': u'openflow-flow-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="flow-interface", rest_name="flow-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)""",
        })

    self.__flow_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow_interface(self):
    self.__flow_interface = YANGDynClass(base=YANGListType("interface_type interface_value",flow_interface.flow_interface, yang_name="flow-interface", rest_name="flow-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-type interface-value', extensions={u'tailf-common': {u'callpoint': u'openflow-flow-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="flow-interface", rest_name="flow-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)


  def _get_controller(self):
    """
    Getter method for controller, mapped from YANG variable /openflow_state/controller (list)
    """
    return self.__controller
      
  def _set_controller(self, v, load=False):
    """
    Setter method for controller, mapped from YANG variable /openflow_state/controller (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_controller is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_controller() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",controller.controller, yang_name="controller", rest_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'callpoint': u'openflow-controller-controller-1'}}), is_container='list', yang_name="controller", rest_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-controller-controller-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """controller must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",controller.controller, yang_name="controller", rest_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'callpoint': u'openflow-controller-controller-1'}}), is_container='list', yang_name="controller", rest_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-controller-controller-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)""",
        })

    self.__controller = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_controller(self):
    self.__controller = YANGDynClass(base=YANGListType("name",controller.controller, yang_name="controller", rest_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'callpoint': u'openflow-controller-controller-1'}}), is_container='list', yang_name="controller", rest_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-controller-controller-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)


  def _get_flow_id(self):
    """
    Getter method for flow_id, mapped from YANG variable /openflow_state/flow_id (container)
    """
    return self.__flow_id
      
  def _set_flow_id(self, v, load=False):
    """
    Setter method for flow_id, mapped from YANG variable /openflow_state/flow_id (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=flow_id.flow_id, is_container='container', presence=False, yang_name="flow-id", rest_name="flow-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow-info-flow-id-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow_id must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=flow_id.flow_id, is_container='container', presence=False, yang_name="flow-id", rest_name="flow-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow-info-flow-id-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)""",
        })

    self.__flow_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow_id(self):
    self.__flow_id = YANGDynClass(base=flow_id.flow_id, is_container='container', presence=False, yang_name="flow-id", rest_name="flow-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow-info-flow-id-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)


  def _get_group_id(self):
    """
    Getter method for group_id, mapped from YANG variable /openflow_state/group_id (container)
    """
    return self.__group_id
      
  def _set_group_id(self, v, load=False):
    """
    Setter method for group_id, mapped from YANG variable /openflow_state/group_id (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=group_id.group_id, is_container='container', presence=False, yang_name="group-id", rest_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-group-info-group-id-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_id must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=group_id.group_id, is_container='container', presence=False, yang_name="group-id", rest_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-group-info-group-id-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)""",
        })

    self.__group_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_id(self):
    self.__group_id = YANGDynClass(base=group_id.group_id, is_container='container', presence=False, yang_name="group-id", rest_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-group-info-group-id-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)


  def _get_meter_id(self):
    """
    Getter method for meter_id, mapped from YANG variable /openflow_state/meter_id (container)
    """
    return self.__meter_id
      
  def _set_meter_id(self, v, load=False):
    """
    Setter method for meter_id, mapped from YANG variable /openflow_state/meter_id (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_meter_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_meter_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=meter_id.meter_id, is_container='container', presence=False, yang_name="meter-id", rest_name="meter-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-meter-info-meter-id-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """meter_id must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=meter_id.meter_id, is_container='container', presence=False, yang_name="meter-id", rest_name="meter-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-meter-info-meter-id-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)""",
        })

    self.__meter_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_meter_id(self):
    self.__meter_id = YANGDynClass(base=meter_id.meter_id, is_container='container', presence=False, yang_name="meter-id", rest_name="meter-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-meter-info-meter-id-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)


  def _get_queues_interface(self):
    """
    Getter method for queues_interface, mapped from YANG variable /openflow_state/queues_interface (container)
    """
    return self.__queues_interface
      
  def _set_queues_interface(self, v, load=False):
    """
    Setter method for queues_interface, mapped from YANG variable /openflow_state/queues_interface (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_queues_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_queues_interface() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=queues_interface.queues_interface, is_container='container', presence=False, yang_name="queues-interface", rest_name="queues-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-queues-interface-queues-interface-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """queues_interface must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=queues_interface.queues_interface, is_container='container', presence=False, yang_name="queues-interface", rest_name="queues-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-queues-interface-queues-interface-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)""",
        })

    self.__queues_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_queues_interface(self):
    self.__queues_interface = YANGDynClass(base=queues_interface.queues_interface, is_container='container', presence=False, yang_name="queues-interface", rest_name="queues-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-queues-interface-queues-interface-1'}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='container', is_config=False)

  detail = __builtin__.property(_get_detail)
  flow = __builtin__.property(_get_flow)
  group = __builtin__.property(_get_group)
  meter = __builtin__.property(_get_meter)
  resources = __builtin__.property(_get_resources)
  interface = __builtin__.property(_get_interface)
  flow_interface = __builtin__.property(_get_flow_interface)
  controller = __builtin__.property(_get_controller)
  flow_id = __builtin__.property(_get_flow_id)
  group_id = __builtin__.property(_get_group_id)
  meter_id = __builtin__.property(_get_meter_id)
  queues_interface = __builtin__.property(_get_queues_interface)


  _pyangbind_elements = {'detail': detail, 'flow': flow, 'group': group, 'meter': meter, 'resources': resources, 'interface': interface, 'flow_interface': flow_interface, 'controller': controller, 'flow_id': flow_id, 'group_id': group_id, 'meter_id': meter_id, 'queues_interface': queues_interface, }


