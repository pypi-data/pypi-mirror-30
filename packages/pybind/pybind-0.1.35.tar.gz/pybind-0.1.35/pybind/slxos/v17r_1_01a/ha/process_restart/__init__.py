
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class process_restart(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ha - based on the path /ha/process-restart. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__mpls','__bgp','__isis','__ospfv2','__ospfv3',)

  _yang_name = 'process-restart'
  _rest_name = 'process-restart'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__bgp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bgp", rest_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'BGP protocol (PR takes precedence over GR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)
    self.__isis = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isis", rest_name="isis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'ISIS protocol (PR takes precedence over NSR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)
    self.__mpls = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls", rest_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MPLS protocol', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)
    self.__ospfv2 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ospfv2", rest_name="ospfv2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'OSPF-V2 protocol (PR takes precedence over GR/NSR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)
    self.__ospfv3 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ospfv3", rest_name="ospfv3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'OSPF-V3 protocol (PR takes precedence over GR/NSR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ha', u'process-restart']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'ha', u'process-restart']

  def _get_mpls(self):
    """
    Getter method for mpls, mapped from YANG variable /ha/process_restart/mpls (empty)
    """
    return self.__mpls
      
  def _set_mpls(self, v, load=False):
    """
    Setter method for mpls, mapped from YANG variable /ha/process_restart/mpls (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="mpls", rest_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MPLS protocol', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls", rest_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MPLS protocol', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)""",
        })

    self.__mpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls(self):
    self.__mpls = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls", rest_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MPLS protocol', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)


  def _get_bgp(self):
    """
    Getter method for bgp, mapped from YANG variable /ha/process_restart/bgp (empty)
    """
    return self.__bgp
      
  def _set_bgp(self, v, load=False):
    """
    Setter method for bgp, mapped from YANG variable /ha/process_restart/bgp (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bgp", rest_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'BGP protocol (PR takes precedence over GR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bgp", rest_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'BGP protocol (PR takes precedence over GR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)""",
        })

    self.__bgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp(self):
    self.__bgp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bgp", rest_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'BGP protocol (PR takes precedence over GR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)


  def _get_isis(self):
    """
    Getter method for isis, mapped from YANG variable /ha/process_restart/isis (empty)
    """
    return self.__isis
      
  def _set_isis(self, v, load=False):
    """
    Setter method for isis, mapped from YANG variable /ha/process_restart/isis (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isis() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="isis", rest_name="isis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'ISIS protocol (PR takes precedence over NSR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isis must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isis", rest_name="isis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'ISIS protocol (PR takes precedence over NSR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)""",
        })

    self.__isis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isis(self):
    self.__isis = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isis", rest_name="isis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'ISIS protocol (PR takes precedence over NSR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)


  def _get_ospfv2(self):
    """
    Getter method for ospfv2, mapped from YANG variable /ha/process_restart/ospfv2 (empty)
    """
    return self.__ospfv2
      
  def _set_ospfv2(self, v, load=False):
    """
    Setter method for ospfv2, mapped from YANG variable /ha/process_restart/ospfv2 (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ospfv2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ospfv2() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ospfv2", rest_name="ospfv2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'OSPF-V2 protocol (PR takes precedence over GR/NSR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ospfv2 must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ospfv2", rest_name="ospfv2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'OSPF-V2 protocol (PR takes precedence over GR/NSR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)""",
        })

    self.__ospfv2 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ospfv2(self):
    self.__ospfv2 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ospfv2", rest_name="ospfv2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'OSPF-V2 protocol (PR takes precedence over GR/NSR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)


  def _get_ospfv3(self):
    """
    Getter method for ospfv3, mapped from YANG variable /ha/process_restart/ospfv3 (empty)
    """
    return self.__ospfv3
      
  def _set_ospfv3(self, v, load=False):
    """
    Setter method for ospfv3, mapped from YANG variable /ha/process_restart/ospfv3 (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ospfv3 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ospfv3() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ospfv3", rest_name="ospfv3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'OSPF-V3 protocol (PR takes precedence over GR/NSR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ospfv3 must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ospfv3", rest_name="ospfv3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'OSPF-V3 protocol (PR takes precedence over GR/NSR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)""",
        })

    self.__ospfv3 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ospfv3(self):
    self.__ospfv3 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ospfv3", rest_name="ospfv3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'OSPF-V3 protocol (PR takes precedence over GR/NSR)', u'cli-show-no': None}}, namespace='urn:brocade.com:mgmt:brocade-ha', defining_module='brocade-ha', yang_type='empty', is_config=True)

  mpls = __builtin__.property(_get_mpls, _set_mpls)
  bgp = __builtin__.property(_get_bgp, _set_bgp)
  isis = __builtin__.property(_get_isis, _set_isis)
  ospfv2 = __builtin__.property(_get_ospfv2, _set_ospfv2)
  ospfv3 = __builtin__.property(_get_ospfv3, _set_ospfv3)


  _pyangbind_elements = {'mpls': mpls, 'bgp': bgp, 'isis': isis, 'ospfv2': ospfv2, 'ospfv3': ospfv3, }


