
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class lldp_neighbor_detail(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-lldp-ext - based on the path /brocade_lldp_ext_rpc/get-lldp-neighbor-detail/output/lldp-neighbor-detail. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of lldp neighbor interface entries.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__local_interface_name','__local_interface_mac','__local_interface_ifindex','__remote_interface_name','__remote_interface_mac','__remote_port_description','__remote_chassis_id','__remote_system_name','__remote_system_description','__dead_interval','__remaining_life','__lldp_pdu_transmitted','__lldp_pdu_received',)

  _yang_name = 'lldp-neighbor-detail'
  _rest_name = 'lldp-neighbor-detail'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__remote_port_description = YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-port-description", rest_name="remote-port-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)
    self.__remote_interface_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-interface-name", rest_name="remote-interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)
    self.__local_interface_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-interface-name", rest_name="local-interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)
    self.__lldp_pdu_transmitted = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lldp-pdu-transmitted", rest_name="lldp-pdu-transmitted", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='yang:counter64', is_config=True)
    self.__lldp_pdu_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lldp-pdu-received", rest_name="lldp-pdu-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='yang:counter64', is_config=True)
    self.__remote_interface_mac = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{4}(\\.[0-9a-fA-F]{4}){2}'}), is_leaf=True, yang_name="remote-interface-mac", rest_name="remote-interface-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='interface:mac-address-type', is_config=True)
    self.__remote_system_description = YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-system-description", rest_name="remote-system-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)
    self.__local_interface_mac = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{4}(\\.[0-9a-fA-F]{4}){2}'}), is_leaf=True, yang_name="local-interface-mac", rest_name="local-interface-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='interface:mac-address-type', is_config=True)
    self.__dead_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dead-interval", rest_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='uint64', is_config=True)
    self.__remote_chassis_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-chassis-id", rest_name="remote-chassis-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)
    self.__remaining_life = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="remaining-life", rest_name="remaining-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='uint64', is_config=True)
    self.__local_interface_ifindex = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="local-interface-ifindex", rest_name="local-interface-ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='uint64', is_config=True)
    self.__remote_system_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-system-name", rest_name="remote-system-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'brocade_lldp_ext_rpc', u'get-lldp-neighbor-detail', u'output', u'lldp-neighbor-detail']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'get-lldp-neighbor-detail', u'output', u'lldp-neighbor-detail']

  def _get_local_interface_name(self):
    """
    Getter method for local_interface_name, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/local_interface_name (string)

    YANG Description: This indicates the local interface display name.
    """
    return self.__local_interface_name
      
  def _set_local_interface_name(self, v, load=False):
    """
    Setter method for local_interface_name, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/local_interface_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_interface_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_interface_name() directly.

    YANG Description: This indicates the local interface display name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="local-interface-name", rest_name="local-interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_interface_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="local-interface-name", rest_name="local-interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)""",
        })

    self.__local_interface_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_interface_name(self):
    self.__local_interface_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-interface-name", rest_name="local-interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)


  def _get_local_interface_mac(self):
    """
    Getter method for local_interface_mac, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/local_interface_mac (interface:mac-address-type)

    YANG Description: This indicates the local interface mac.
    """
    return self.__local_interface_mac
      
  def _set_local_interface_mac(self, v, load=False):
    """
    Setter method for local_interface_mac, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/local_interface_mac (interface:mac-address-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_interface_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_interface_mac() directly.

    YANG Description: This indicates the local interface mac.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{4}(\\.[0-9a-fA-F]{4}){2}'}), is_leaf=True, yang_name="local-interface-mac", rest_name="local-interface-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='interface:mac-address-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_interface_mac must be of a type compatible with interface:mac-address-type""",
          'defined-type': "interface:mac-address-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{4}(\\.[0-9a-fA-F]{4}){2}'}), is_leaf=True, yang_name="local-interface-mac", rest_name="local-interface-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='interface:mac-address-type', is_config=True)""",
        })

    self.__local_interface_mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_interface_mac(self):
    self.__local_interface_mac = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{4}(\\.[0-9a-fA-F]{4}){2}'}), is_leaf=True, yang_name="local-interface-mac", rest_name="local-interface-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='interface:mac-address-type', is_config=True)


  def _get_local_interface_ifindex(self):
    """
    Getter method for local_interface_ifindex, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/local_interface_ifindex (uint64)

    YANG Description: This indicates the local interface IfIndex.
    """
    return self.__local_interface_ifindex
      
  def _set_local_interface_ifindex(self, v, load=False):
    """
    Setter method for local_interface_ifindex, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/local_interface_ifindex (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_interface_ifindex is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_interface_ifindex() directly.

    YANG Description: This indicates the local interface IfIndex.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="local-interface-ifindex", rest_name="local-interface-ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_interface_ifindex must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="local-interface-ifindex", rest_name="local-interface-ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='uint64', is_config=True)""",
        })

    self.__local_interface_ifindex = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_interface_ifindex(self):
    self.__local_interface_ifindex = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="local-interface-ifindex", rest_name="local-interface-ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='uint64', is_config=True)


  def _get_remote_interface_name(self):
    """
    Getter method for remote_interface_name, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/remote_interface_name (string)

    YANG Description: This indicates the remote interface display name.
    """
    return self.__remote_interface_name
      
  def _set_remote_interface_name(self, v, load=False):
    """
    Setter method for remote_interface_name, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/remote_interface_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_interface_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_interface_name() directly.

    YANG Description: This indicates the remote interface display name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="remote-interface-name", rest_name="remote-interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_interface_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-interface-name", rest_name="remote-interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)""",
        })

    self.__remote_interface_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_interface_name(self):
    self.__remote_interface_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-interface-name", rest_name="remote-interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)


  def _get_remote_interface_mac(self):
    """
    Getter method for remote_interface_mac, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/remote_interface_mac (interface:mac-address-type)

    YANG Description: This indicates the remote interface mac.
    """
    return self.__remote_interface_mac
      
  def _set_remote_interface_mac(self, v, load=False):
    """
    Setter method for remote_interface_mac, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/remote_interface_mac (interface:mac-address-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_interface_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_interface_mac() directly.

    YANG Description: This indicates the remote interface mac.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{4}(\\.[0-9a-fA-F]{4}){2}'}), is_leaf=True, yang_name="remote-interface-mac", rest_name="remote-interface-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='interface:mac-address-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_interface_mac must be of a type compatible with interface:mac-address-type""",
          'defined-type': "interface:mac-address-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{4}(\\.[0-9a-fA-F]{4}){2}'}), is_leaf=True, yang_name="remote-interface-mac", rest_name="remote-interface-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='interface:mac-address-type', is_config=True)""",
        })

    self.__remote_interface_mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_interface_mac(self):
    self.__remote_interface_mac = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{4}(\\.[0-9a-fA-F]{4}){2}'}), is_leaf=True, yang_name="remote-interface-mac", rest_name="remote-interface-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='interface:mac-address-type', is_config=True)


  def _get_remote_port_description(self):
    """
    Getter method for remote_port_description, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/remote_port_description (string)

    YANG Description: This indicates the remote port description.
    """
    return self.__remote_port_description
      
  def _set_remote_port_description(self, v, load=False):
    """
    Setter method for remote_port_description, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/remote_port_description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_port_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_port_description() directly.

    YANG Description: This indicates the remote port description.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="remote-port-description", rest_name="remote-port-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_port_description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-port-description", rest_name="remote-port-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)""",
        })

    self.__remote_port_description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_port_description(self):
    self.__remote_port_description = YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-port-description", rest_name="remote-port-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)


  def _get_remote_chassis_id(self):
    """
    Getter method for remote_chassis_id, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/remote_chassis_id (string)

    YANG Description: This indicates the remote chassis id.
    """
    return self.__remote_chassis_id
      
  def _set_remote_chassis_id(self, v, load=False):
    """
    Setter method for remote_chassis_id, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/remote_chassis_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_chassis_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_chassis_id() directly.

    YANG Description: This indicates the remote chassis id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="remote-chassis-id", rest_name="remote-chassis-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_chassis_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-chassis-id", rest_name="remote-chassis-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)""",
        })

    self.__remote_chassis_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_chassis_id(self):
    self.__remote_chassis_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-chassis-id", rest_name="remote-chassis-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)


  def _get_remote_system_name(self):
    """
    Getter method for remote_system_name, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/remote_system_name (string)

    YANG Description: This indicates the remote system name.
    """
    return self.__remote_system_name
      
  def _set_remote_system_name(self, v, load=False):
    """
    Setter method for remote_system_name, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/remote_system_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_system_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_system_name() directly.

    YANG Description: This indicates the remote system name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="remote-system-name", rest_name="remote-system-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_system_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-system-name", rest_name="remote-system-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)""",
        })

    self.__remote_system_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_system_name(self):
    self.__remote_system_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-system-name", rest_name="remote-system-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)


  def _get_remote_system_description(self):
    """
    Getter method for remote_system_description, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/remote_system_description (string)

    YANG Description: This indicates the remote system description.
    """
    return self.__remote_system_description
      
  def _set_remote_system_description(self, v, load=False):
    """
    Setter method for remote_system_description, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/remote_system_description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_system_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_system_description() directly.

    YANG Description: This indicates the remote system description.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="remote-system-description", rest_name="remote-system-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_system_description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-system-description", rest_name="remote-system-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)""",
        })

    self.__remote_system_description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_system_description(self):
    self.__remote_system_description = YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-system-description", rest_name="remote-system-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='string', is_config=True)


  def _get_dead_interval(self):
    """
    Getter method for dead_interval, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/dead_interval (uint64)

    YANG Description: This indicates the dead interval
    """
    return self.__dead_interval
      
  def _set_dead_interval(self, v, load=False):
    """
    Setter method for dead_interval, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/dead_interval (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dead_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dead_interval() directly.

    YANG Description: This indicates the dead interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dead-interval", rest_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dead_interval must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dead-interval", rest_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='uint64', is_config=True)""",
        })

    self.__dead_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dead_interval(self):
    self.__dead_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dead-interval", rest_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='uint64', is_config=True)


  def _get_remaining_life(self):
    """
    Getter method for remaining_life, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/remaining_life (uint64)

    YANG Description: This indicates the dead interval
    """
    return self.__remaining_life
      
  def _set_remaining_life(self, v, load=False):
    """
    Setter method for remaining_life, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/remaining_life (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remaining_life is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remaining_life() directly.

    YANG Description: This indicates the dead interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="remaining-life", rest_name="remaining-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remaining_life must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="remaining-life", rest_name="remaining-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='uint64', is_config=True)""",
        })

    self.__remaining_life = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remaining_life(self):
    self.__remaining_life = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="remaining-life", rest_name="remaining-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='uint64', is_config=True)


  def _get_lldp_pdu_transmitted(self):
    """
    Getter method for lldp_pdu_transmitted, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/lldp_pdu_transmitted (yang:counter64)

    YANG Description: The number of Lldp PDUs transmitted from
the interface
    """
    return self.__lldp_pdu_transmitted
      
  def _set_lldp_pdu_transmitted(self, v, load=False):
    """
    Setter method for lldp_pdu_transmitted, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/lldp_pdu_transmitted (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lldp_pdu_transmitted is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lldp_pdu_transmitted() directly.

    YANG Description: The number of Lldp PDUs transmitted from
the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lldp-pdu-transmitted", rest_name="lldp-pdu-transmitted", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='yang:counter64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lldp_pdu_transmitted must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lldp-pdu-transmitted", rest_name="lldp-pdu-transmitted", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='yang:counter64', is_config=True)""",
        })

    self.__lldp_pdu_transmitted = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lldp_pdu_transmitted(self):
    self.__lldp_pdu_transmitted = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lldp-pdu-transmitted", rest_name="lldp-pdu-transmitted", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='yang:counter64', is_config=True)


  def _get_lldp_pdu_received(self):
    """
    Getter method for lldp_pdu_received, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/lldp_pdu_received (yang:counter64)

    YANG Description: The number of Lldp PDUs received by the
interface
    """
    return self.__lldp_pdu_received
      
  def _set_lldp_pdu_received(self, v, load=False):
    """
    Setter method for lldp_pdu_received, mapped from YANG variable /brocade_lldp_ext_rpc/get_lldp_neighbor_detail/output/lldp_neighbor_detail/lldp_pdu_received (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lldp_pdu_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lldp_pdu_received() directly.

    YANG Description: The number of Lldp PDUs received by the
interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lldp-pdu-received", rest_name="lldp-pdu-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='yang:counter64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lldp_pdu_received must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lldp-pdu-received", rest_name="lldp-pdu-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='yang:counter64', is_config=True)""",
        })

    self.__lldp_pdu_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lldp_pdu_received(self):
    self.__lldp_pdu_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lldp-pdu-received", rest_name="lldp-pdu-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-lldp-ext', defining_module='brocade-lldp-ext', yang_type='yang:counter64', is_config=True)

  local_interface_name = __builtin__.property(_get_local_interface_name, _set_local_interface_name)
  local_interface_mac = __builtin__.property(_get_local_interface_mac, _set_local_interface_mac)
  local_interface_ifindex = __builtin__.property(_get_local_interface_ifindex, _set_local_interface_ifindex)
  remote_interface_name = __builtin__.property(_get_remote_interface_name, _set_remote_interface_name)
  remote_interface_mac = __builtin__.property(_get_remote_interface_mac, _set_remote_interface_mac)
  remote_port_description = __builtin__.property(_get_remote_port_description, _set_remote_port_description)
  remote_chassis_id = __builtin__.property(_get_remote_chassis_id, _set_remote_chassis_id)
  remote_system_name = __builtin__.property(_get_remote_system_name, _set_remote_system_name)
  remote_system_description = __builtin__.property(_get_remote_system_description, _set_remote_system_description)
  dead_interval = __builtin__.property(_get_dead_interval, _set_dead_interval)
  remaining_life = __builtin__.property(_get_remaining_life, _set_remaining_life)
  lldp_pdu_transmitted = __builtin__.property(_get_lldp_pdu_transmitted, _set_lldp_pdu_transmitted)
  lldp_pdu_received = __builtin__.property(_get_lldp_pdu_received, _set_lldp_pdu_received)


  _pyangbind_elements = {'local_interface_name': local_interface_name, 'local_interface_mac': local_interface_mac, 'local_interface_ifindex': local_interface_ifindex, 'remote_interface_name': remote_interface_name, 'remote_interface_mac': remote_interface_mac, 'remote_port_description': remote_port_description, 'remote_chassis_id': remote_chassis_id, 'remote_system_name': remote_system_name, 'remote_system_description': remote_system_description, 'dead_interval': dead_interval, 'remaining_life': remaining_life, 'lldp_pdu_transmitted': lldp_pdu_transmitted, 'lldp_pdu_received': lldp_pdu_received, }


