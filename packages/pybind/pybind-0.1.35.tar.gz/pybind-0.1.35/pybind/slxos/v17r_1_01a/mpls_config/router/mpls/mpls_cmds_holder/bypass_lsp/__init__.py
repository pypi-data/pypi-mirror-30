
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import lsp_traffic_engineering
import priority
import exclude_interface
class bypass_lsp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls - based on the path /mpls-config/router/mpls/mpls-cmds-holder/bypass-lsp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__bypass_lsp_name','__bypass_lsp_dest_address','__bypass_lsp_src_address','__bypass_lsp_tie_breaking','__lsp_adaptive','__lsp_reoptimize_timer','__lsp_commit','__lsp_record','__lsp_cos','__lsp_hop_limit','__lsp_cspf_computation_mode','__lsp_traffic_engineering','__priority','__lsp_exclude_any','__lsp_include_any','__lsp_include_all','__exclude_interface','__bypass_lsp_primary_path','__bypass_lsp_enable',)

  _yang_name = 'bypass-lsp'
  _rest_name = 'bypass-lsp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__bypass_lsp_src_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="bypass-lsp-src-address", rest_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Define LSP source address', u'alt-name': u'from'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='inet:ipv4-address', is_config=True)
    self.__priority = YANGDynClass(base=priority.priority, is_container='container', presence=False, yang_name="priority", rest_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'LSP setup and holding priority levels', u'cli-sequence-commands': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    self.__exclude_interface = YANGDynClass(base=YANGListType("bypass_exclude_interface_type bypass_exclude_interface_name",exclude_interface.exclude_interface, yang_name="exclude-interface", rest_name="exclude-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bypass-exclude-interface-type bypass-exclude-interface-name', extensions={u'tailf-common': {u'info': u'choose the interface to avoid as well as to protect', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'callpoint': u'MplsBypassLspExcludeInterface'}}), is_container='list', yang_name="exclude-interface", rest_name="exclude-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'choose the interface to avoid as well as to protect', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'callpoint': u'MplsBypassLspExcludeInterface'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)
    self.__bypass_lsp_name = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..64']}), is_leaf=True, yang_name="bypass-lsp-name", rest_name="bypass-lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'ASCII string;;Name (up to 64 characters)'}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__lsp_cos = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..7']}), is_leaf=True, yang_name="lsp-cos", rest_name="cos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure class of service', u'cli-full-no': None, u'alt-name': u'cos'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__lsp_include_all = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..256']})), is_leaf=False, yang_name="lsp-include-all", rest_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Include all of the administrative groups', u'cli-full-no': None, u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-flat-list-syntax': None, u'alt-name': u'include-all'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__lsp_include_any = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..256']})), is_leaf=False, yang_name="lsp-include-any", rest_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Include any of the administrative groups', u'cli-full-no': None, u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-flat-list-syntax': None, u'alt-name': u'include-any'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__bypass_lsp_tie_breaking = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'most-fill': {'value': 2}, u'random': {'value': 0}, u'least-fill': {'value': 1}},), default=unicode("random"), is_leaf=True, yang_name="bypass-lsp-tie-breaking", rest_name="tie-breaking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Choose the tie breaking mode for cspf', u'cli-full-no': None, u'alt-name': u'tie-breaking'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='tie-breaking', is_config=True)
    self.__lsp_cspf_computation_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'use-igp-metric': {'value': 1}, u'use-te-metric': {'value': 2}},), is_leaf=True, yang_name="lsp-cspf-computation-mode", rest_name="cspf-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Specify cspf-computation-mode', u'cli-full-no': None, u'alt-name': u'cspf-computation-mode'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='cspf-computation-mode', is_config=True)
    self.__lsp_record = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {'value': 1}, u'disable': {'value': 0}},), is_leaf=True, yang_name="lsp-record", rest_name="record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable/disable recording path routes', u'cli-full-no': None, u'alt-name': u'record'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='enable-disable', is_config=True)
    self.__lsp_reoptimize_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'300..65535']}), is_leaf=True, yang_name="lsp-reoptimize-timer", rest_name="reoptimize-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Reoptimization timer', u'cli-full-no': None, u'alt-name': u'reoptimize-timer'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__bypass_lsp_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-enable", rest_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable LSP', u'alt-name': u'enable'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    self.__lsp_traffic_engineering = YANGDynClass(base=lsp_traffic_engineering.lsp_traffic_engineering, is_container='container', presence=False, yang_name="lsp-traffic-engineering", rest_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-compact-syntax': None, u'info': u'LSP traffic engineering parameters', u'alt-name': u'traffic-engineering', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    self.__lsp_commit = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-commit", rest_name="commit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Commit the changes to adaptive LSP', u'alt-name': u'commit', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    self.__bypass_lsp_primary_path = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..64']}), is_leaf=True, yang_name="bypass-lsp-primary-path", rest_name="primary-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set primary explicit path', u'alt-name': u'primary-path'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__lsp_exclude_any = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..256']})), is_leaf=False, yang_name="lsp-exclude-any", rest_name="exclude-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Exclude any of the administrative groups', u'cli-full-no': None, u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-flat-list-syntax': None, u'alt-name': u'exclude-any'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__lsp_hop_limit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..255']}), is_leaf=True, yang_name="lsp-hop-limit", rest_name="hop-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Limit of hops the LSP can traverse', u'cli-full-no': None, u'alt-name': u'hop-limit'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)
    self.__bypass_lsp_dest_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="bypass-lsp-dest-address", rest_name="to", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Define LSP destination address', u'alt-name': u'to'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='inet:ipv4-address', is_config=True)
    self.__lsp_adaptive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-adaptive", rest_name="adaptive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure LSP/secpath to be adaptive', u'cli-full-no': None, u'alt-name': u'adaptive'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mpls-config', u'router', u'mpls', u'mpls-cmds-holder', u'bypass-lsp']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'router', u'mpls', u'bypass-lsp']

  def _get_bypass_lsp_name(self):
    """
    Getter method for bypass_lsp_name, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/bypass_lsp_name (string)
    """
    return self.__bypass_lsp_name
      
  def _set_bypass_lsp_name(self, v, load=False):
    """
    Setter method for bypass_lsp_name, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/bypass_lsp_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..64']}), is_leaf=True, yang_name="bypass-lsp-name", rest_name="bypass-lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'ASCII string;;Name (up to 64 characters)'}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..64']}), is_leaf=True, yang_name="bypass-lsp-name", rest_name="bypass-lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'ASCII string;;Name (up to 64 characters)'}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__bypass_lsp_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_name(self):
    self.__bypass_lsp_name = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..64']}), is_leaf=True, yang_name="bypass-lsp-name", rest_name="bypass-lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'ASCII string;;Name (up to 64 characters)'}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_bypass_lsp_dest_address(self):
    """
    Getter method for bypass_lsp_dest_address, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/bypass_lsp_dest_address (inet:ipv4-address)
    """
    return self.__bypass_lsp_dest_address
      
  def _set_bypass_lsp_dest_address(self, v, load=False):
    """
    Setter method for bypass_lsp_dest_address, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/bypass_lsp_dest_address (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_dest_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_dest_address() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="bypass-lsp-dest-address", rest_name="to", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Define LSP destination address', u'alt-name': u'to'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_dest_address must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="bypass-lsp-dest-address", rest_name="to", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Define LSP destination address', u'alt-name': u'to'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__bypass_lsp_dest_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_dest_address(self):
    self.__bypass_lsp_dest_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="bypass-lsp-dest-address", rest_name="to", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Define LSP destination address', u'alt-name': u'to'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='inet:ipv4-address', is_config=True)


  def _get_bypass_lsp_src_address(self):
    """
    Getter method for bypass_lsp_src_address, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/bypass_lsp_src_address (inet:ipv4-address)
    """
    return self.__bypass_lsp_src_address
      
  def _set_bypass_lsp_src_address(self, v, load=False):
    """
    Setter method for bypass_lsp_src_address, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/bypass_lsp_src_address (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_src_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_src_address() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="bypass-lsp-src-address", rest_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Define LSP source address', u'alt-name': u'from'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_src_address must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="bypass-lsp-src-address", rest_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Define LSP source address', u'alt-name': u'from'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__bypass_lsp_src_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_src_address(self):
    self.__bypass_lsp_src_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="bypass-lsp-src-address", rest_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Define LSP source address', u'alt-name': u'from'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='inet:ipv4-address', is_config=True)


  def _get_bypass_lsp_tie_breaking(self):
    """
    Getter method for bypass_lsp_tie_breaking, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/bypass_lsp_tie_breaking (tie-breaking)
    """
    return self.__bypass_lsp_tie_breaking
      
  def _set_bypass_lsp_tie_breaking(self, v, load=False):
    """
    Setter method for bypass_lsp_tie_breaking, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/bypass_lsp_tie_breaking (tie-breaking)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_tie_breaking is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_tie_breaking() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'most-fill': {'value': 2}, u'random': {'value': 0}, u'least-fill': {'value': 1}},), default=unicode("random"), is_leaf=True, yang_name="bypass-lsp-tie-breaking", rest_name="tie-breaking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Choose the tie breaking mode for cspf', u'cli-full-no': None, u'alt-name': u'tie-breaking'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='tie-breaking', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_tie_breaking must be of a type compatible with tie-breaking""",
          'defined-type': "brocade-mpls:tie-breaking",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'most-fill': {'value': 2}, u'random': {'value': 0}, u'least-fill': {'value': 1}},), default=unicode("random"), is_leaf=True, yang_name="bypass-lsp-tie-breaking", rest_name="tie-breaking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Choose the tie breaking mode for cspf', u'cli-full-no': None, u'alt-name': u'tie-breaking'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='tie-breaking', is_config=True)""",
        })

    self.__bypass_lsp_tie_breaking = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_tie_breaking(self):
    self.__bypass_lsp_tie_breaking = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'most-fill': {'value': 2}, u'random': {'value': 0}, u'least-fill': {'value': 1}},), default=unicode("random"), is_leaf=True, yang_name="bypass-lsp-tie-breaking", rest_name="tie-breaking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Choose the tie breaking mode for cspf', u'cli-full-no': None, u'alt-name': u'tie-breaking'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='tie-breaking', is_config=True)


  def _get_lsp_adaptive(self):
    """
    Getter method for lsp_adaptive, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_adaptive (empty)
    """
    return self.__lsp_adaptive
      
  def _set_lsp_adaptive(self, v, load=False):
    """
    Setter method for lsp_adaptive, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_adaptive (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_adaptive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_adaptive() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-adaptive", rest_name="adaptive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure LSP/secpath to be adaptive', u'cli-full-no': None, u'alt-name': u'adaptive'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_adaptive must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-adaptive", rest_name="adaptive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure LSP/secpath to be adaptive', u'cli-full-no': None, u'alt-name': u'adaptive'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)""",
        })

    self.__lsp_adaptive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_adaptive(self):
    self.__lsp_adaptive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-adaptive", rest_name="adaptive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure LSP/secpath to be adaptive', u'cli-full-no': None, u'alt-name': u'adaptive'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)


  def _get_lsp_reoptimize_timer(self):
    """
    Getter method for lsp_reoptimize_timer, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_reoptimize_timer (uint32)
    """
    return self.__lsp_reoptimize_timer
      
  def _set_lsp_reoptimize_timer(self, v, load=False):
    """
    Setter method for lsp_reoptimize_timer, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_reoptimize_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_reoptimize_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_reoptimize_timer() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'300..65535']}), is_leaf=True, yang_name="lsp-reoptimize-timer", rest_name="reoptimize-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Reoptimization timer', u'cli-full-no': None, u'alt-name': u'reoptimize-timer'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_reoptimize_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'300..65535']}), is_leaf=True, yang_name="lsp-reoptimize-timer", rest_name="reoptimize-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Reoptimization timer', u'cli-full-no': None, u'alt-name': u'reoptimize-timer'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__lsp_reoptimize_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_reoptimize_timer(self):
    self.__lsp_reoptimize_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'300..65535']}), is_leaf=True, yang_name="lsp-reoptimize-timer", rest_name="reoptimize-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Reoptimization timer', u'cli-full-no': None, u'alt-name': u'reoptimize-timer'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_lsp_commit(self):
    """
    Getter method for lsp_commit, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_commit (empty)
    """
    return self.__lsp_commit
      
  def _set_lsp_commit(self, v, load=False):
    """
    Setter method for lsp_commit, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_commit (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_commit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_commit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-commit", rest_name="commit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Commit the changes to adaptive LSP', u'alt-name': u'commit', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_commit must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-commit", rest_name="commit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Commit the changes to adaptive LSP', u'alt-name': u'commit', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)""",
        })

    self.__lsp_commit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_commit(self):
    self.__lsp_commit = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-commit", rest_name="commit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Commit the changes to adaptive LSP', u'alt-name': u'commit', u'cli-suppress-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)


  def _get_lsp_record(self):
    """
    Getter method for lsp_record, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_record (enable-disable)
    """
    return self.__lsp_record
      
  def _set_lsp_record(self, v, load=False):
    """
    Setter method for lsp_record, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_record (enable-disable)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_record is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_record() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {'value': 1}, u'disable': {'value': 0}},), is_leaf=True, yang_name="lsp-record", rest_name="record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable/disable recording path routes', u'cli-full-no': None, u'alt-name': u'record'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='enable-disable', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_record must be of a type compatible with enable-disable""",
          'defined-type': "brocade-mpls:enable-disable",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {'value': 1}, u'disable': {'value': 0}},), is_leaf=True, yang_name="lsp-record", rest_name="record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable/disable recording path routes', u'cli-full-no': None, u'alt-name': u'record'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='enable-disable', is_config=True)""",
        })

    self.__lsp_record = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_record(self):
    self.__lsp_record = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {'value': 1}, u'disable': {'value': 0}},), is_leaf=True, yang_name="lsp-record", rest_name="record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable/disable recording path routes', u'cli-full-no': None, u'alt-name': u'record'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='enable-disable', is_config=True)


  def _get_lsp_cos(self):
    """
    Getter method for lsp_cos, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_cos (uint32)
    """
    return self.__lsp_cos
      
  def _set_lsp_cos(self, v, load=False):
    """
    Setter method for lsp_cos, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_cos (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_cos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_cos() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..7']}), is_leaf=True, yang_name="lsp-cos", rest_name="cos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure class of service', u'cli-full-no': None, u'alt-name': u'cos'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_cos must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..7']}), is_leaf=True, yang_name="lsp-cos", rest_name="cos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure class of service', u'cli-full-no': None, u'alt-name': u'cos'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__lsp_cos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_cos(self):
    self.__lsp_cos = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..7']}), is_leaf=True, yang_name="lsp-cos", rest_name="cos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure class of service', u'cli-full-no': None, u'alt-name': u'cos'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_lsp_hop_limit(self):
    """
    Getter method for lsp_hop_limit, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_hop_limit (uint16)
    """
    return self.__lsp_hop_limit
      
  def _set_lsp_hop_limit(self, v, load=False):
    """
    Setter method for lsp_hop_limit, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_hop_limit (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_hop_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_hop_limit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..255']}), is_leaf=True, yang_name="lsp-hop-limit", rest_name="hop-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Limit of hops the LSP can traverse', u'cli-full-no': None, u'alt-name': u'hop-limit'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_hop_limit must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..255']}), is_leaf=True, yang_name="lsp-hop-limit", rest_name="hop-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Limit of hops the LSP can traverse', u'cli-full-no': None, u'alt-name': u'hop-limit'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)""",
        })

    self.__lsp_hop_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_hop_limit(self):
    self.__lsp_hop_limit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..255']}), is_leaf=True, yang_name="lsp-hop-limit", rest_name="hop-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Limit of hops the LSP can traverse', u'cli-full-no': None, u'alt-name': u'hop-limit'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)


  def _get_lsp_cspf_computation_mode(self):
    """
    Getter method for lsp_cspf_computation_mode, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_cspf_computation_mode (cspf-computation-mode)
    """
    return self.__lsp_cspf_computation_mode
      
  def _set_lsp_cspf_computation_mode(self, v, load=False):
    """
    Setter method for lsp_cspf_computation_mode, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_cspf_computation_mode (cspf-computation-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_cspf_computation_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_cspf_computation_mode() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'use-igp-metric': {'value': 1}, u'use-te-metric': {'value': 2}},), is_leaf=True, yang_name="lsp-cspf-computation-mode", rest_name="cspf-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Specify cspf-computation-mode', u'cli-full-no': None, u'alt-name': u'cspf-computation-mode'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='cspf-computation-mode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_cspf_computation_mode must be of a type compatible with cspf-computation-mode""",
          'defined-type': "brocade-mpls:cspf-computation-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'use-igp-metric': {'value': 1}, u'use-te-metric': {'value': 2}},), is_leaf=True, yang_name="lsp-cspf-computation-mode", rest_name="cspf-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Specify cspf-computation-mode', u'cli-full-no': None, u'alt-name': u'cspf-computation-mode'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='cspf-computation-mode', is_config=True)""",
        })

    self.__lsp_cspf_computation_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_cspf_computation_mode(self):
    self.__lsp_cspf_computation_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'use-igp-metric': {'value': 1}, u'use-te-metric': {'value': 2}},), is_leaf=True, yang_name="lsp-cspf-computation-mode", rest_name="cspf-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Specify cspf-computation-mode', u'cli-full-no': None, u'alt-name': u'cspf-computation-mode'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='cspf-computation-mode', is_config=True)


  def _get_lsp_traffic_engineering(self):
    """
    Getter method for lsp_traffic_engineering, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_traffic_engineering (container)
    """
    return self.__lsp_traffic_engineering
      
  def _set_lsp_traffic_engineering(self, v, load=False):
    """
    Setter method for lsp_traffic_engineering, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_traffic_engineering (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_traffic_engineering is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_traffic_engineering() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=lsp_traffic_engineering.lsp_traffic_engineering, is_container='container', presence=False, yang_name="lsp-traffic-engineering", rest_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-compact-syntax': None, u'info': u'LSP traffic engineering parameters', u'alt-name': u'traffic-engineering', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_traffic_engineering must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=lsp_traffic_engineering.lsp_traffic_engineering, is_container='container', presence=False, yang_name="lsp-traffic-engineering", rest_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-compact-syntax': None, u'info': u'LSP traffic engineering parameters', u'alt-name': u'traffic-engineering', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)""",
        })

    self.__lsp_traffic_engineering = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_traffic_engineering(self):
    self.__lsp_traffic_engineering = YANGDynClass(base=lsp_traffic_engineering.lsp_traffic_engineering, is_container='container', presence=False, yang_name="lsp-traffic-engineering", rest_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-compact-syntax': None, u'info': u'LSP traffic engineering parameters', u'alt-name': u'traffic-engineering', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/priority (container)
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/priority (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=priority.priority, is_container='container', presence=False, yang_name="priority", rest_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'LSP setup and holding priority levels', u'cli-sequence-commands': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=priority.priority, is_container='container', presence=False, yang_name="priority", rest_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'LSP setup and holding priority levels', u'cli-sequence-commands': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=priority.priority, is_container='container', presence=False, yang_name="priority", rest_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'LSP setup and holding priority levels', u'cli-sequence-commands': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)


  def _get_lsp_exclude_any(self):
    """
    Getter method for lsp_exclude_any, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_exclude_any (string)
    """
    return self.__lsp_exclude_any
      
  def _set_lsp_exclude_any(self, v, load=False):
    """
    Setter method for lsp_exclude_any, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_exclude_any (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_exclude_any is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_exclude_any() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..256']})), is_leaf=False, yang_name="lsp-exclude-any", rest_name="exclude-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Exclude any of the administrative groups', u'cli-full-no': None, u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-flat-list-syntax': None, u'alt-name': u'exclude-any'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_exclude_any must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..256']})), is_leaf=False, yang_name="lsp-exclude-any", rest_name="exclude-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Exclude any of the administrative groups', u'cli-full-no': None, u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-flat-list-syntax': None, u'alt-name': u'exclude-any'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__lsp_exclude_any = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_exclude_any(self):
    self.__lsp_exclude_any = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..256']})), is_leaf=False, yang_name="lsp-exclude-any", rest_name="exclude-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Exclude any of the administrative groups', u'cli-full-no': None, u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-flat-list-syntax': None, u'alt-name': u'exclude-any'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_lsp_include_any(self):
    """
    Getter method for lsp_include_any, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_include_any (string)
    """
    return self.__lsp_include_any
      
  def _set_lsp_include_any(self, v, load=False):
    """
    Setter method for lsp_include_any, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_include_any (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_include_any is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_include_any() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..256']})), is_leaf=False, yang_name="lsp-include-any", rest_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Include any of the administrative groups', u'cli-full-no': None, u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-flat-list-syntax': None, u'alt-name': u'include-any'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_include_any must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..256']})), is_leaf=False, yang_name="lsp-include-any", rest_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Include any of the administrative groups', u'cli-full-no': None, u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-flat-list-syntax': None, u'alt-name': u'include-any'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__lsp_include_any = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_include_any(self):
    self.__lsp_include_any = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..256']})), is_leaf=False, yang_name="lsp-include-any", rest_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Include any of the administrative groups', u'cli-full-no': None, u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-flat-list-syntax': None, u'alt-name': u'include-any'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_lsp_include_all(self):
    """
    Getter method for lsp_include_all, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_include_all (string)
    """
    return self.__lsp_include_all
      
  def _set_lsp_include_all(self, v, load=False):
    """
    Setter method for lsp_include_all, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/lsp_include_all (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_include_all is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_include_all() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..256']})), is_leaf=False, yang_name="lsp-include-all", rest_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Include all of the administrative groups', u'cli-full-no': None, u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-flat-list-syntax': None, u'alt-name': u'include-all'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_include_all must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..256']})), is_leaf=False, yang_name="lsp-include-all", rest_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Include all of the administrative groups', u'cli-full-no': None, u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-flat-list-syntax': None, u'alt-name': u'include-all'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__lsp_include_all = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_include_all(self):
    self.__lsp_include_all = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..256']})), is_leaf=False, yang_name="lsp-include-all", rest_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Include all of the administrative groups', u'cli-full-no': None, u'cli-suppress-list-no': None, u'cli-full-command': None, u'cli-flat-list-syntax': None, u'alt-name': u'include-all'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_exclude_interface(self):
    """
    Getter method for exclude_interface, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/exclude_interface (list)
    """
    return self.__exclude_interface
      
  def _set_exclude_interface(self, v, load=False):
    """
    Setter method for exclude_interface, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/exclude_interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exclude_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exclude_interface() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("bypass_exclude_interface_type bypass_exclude_interface_name",exclude_interface.exclude_interface, yang_name="exclude-interface", rest_name="exclude-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bypass-exclude-interface-type bypass-exclude-interface-name', extensions={u'tailf-common': {u'info': u'choose the interface to avoid as well as to protect', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'callpoint': u'MplsBypassLspExcludeInterface'}}), is_container='list', yang_name="exclude-interface", rest_name="exclude-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'choose the interface to avoid as well as to protect', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'callpoint': u'MplsBypassLspExcludeInterface'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exclude_interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("bypass_exclude_interface_type bypass_exclude_interface_name",exclude_interface.exclude_interface, yang_name="exclude-interface", rest_name="exclude-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bypass-exclude-interface-type bypass-exclude-interface-name', extensions={u'tailf-common': {u'info': u'choose the interface to avoid as well as to protect', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'callpoint': u'MplsBypassLspExcludeInterface'}}), is_container='list', yang_name="exclude-interface", rest_name="exclude-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'choose the interface to avoid as well as to protect', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'callpoint': u'MplsBypassLspExcludeInterface'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)""",
        })

    self.__exclude_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exclude_interface(self):
    self.__exclude_interface = YANGDynClass(base=YANGListType("bypass_exclude_interface_type bypass_exclude_interface_name",exclude_interface.exclude_interface, yang_name="exclude-interface", rest_name="exclude-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bypass-exclude-interface-type bypass-exclude-interface-name', extensions={u'tailf-common': {u'info': u'choose the interface to avoid as well as to protect', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'callpoint': u'MplsBypassLspExcludeInterface'}}), is_container='list', yang_name="exclude-interface", rest_name="exclude-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'choose the interface to avoid as well as to protect', u'cli-suppress-list-no': None, u'cli-no-key-completion': None, u'cli-suppress-mode': None, u'callpoint': u'MplsBypassLspExcludeInterface'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)


  def _get_bypass_lsp_primary_path(self):
    """
    Getter method for bypass_lsp_primary_path, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/bypass_lsp_primary_path (string)
    """
    return self.__bypass_lsp_primary_path
      
  def _set_bypass_lsp_primary_path(self, v, load=False):
    """
    Setter method for bypass_lsp_primary_path, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/bypass_lsp_primary_path (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_primary_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_primary_path() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..64']}), is_leaf=True, yang_name="bypass-lsp-primary-path", rest_name="primary-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set primary explicit path', u'alt-name': u'primary-path'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_primary_path must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..64']}), is_leaf=True, yang_name="bypass-lsp-primary-path", rest_name="primary-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set primary explicit path', u'alt-name': u'primary-path'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__bypass_lsp_primary_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_primary_path(self):
    self.__bypass_lsp_primary_path = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..64']}), is_leaf=True, yang_name="bypass-lsp-primary-path", rest_name="primary-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set primary explicit path', u'alt-name': u'primary-path'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_bypass_lsp_enable(self):
    """
    Getter method for bypass_lsp_enable, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/bypass_lsp_enable (empty)
    """
    return self.__bypass_lsp_enable
      
  def _set_bypass_lsp_enable(self, v, load=False):
    """
    Setter method for bypass_lsp_enable, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/bypass_lsp/bypass_lsp_enable (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_enable() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-enable", rest_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable LSP', u'alt-name': u'enable'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_enable must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-enable", rest_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable LSP', u'alt-name': u'enable'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)""",
        })

    self.__bypass_lsp_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_enable(self):
    self.__bypass_lsp_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-enable", rest_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable LSP', u'alt-name': u'enable'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)

  bypass_lsp_name = __builtin__.property(_get_bypass_lsp_name, _set_bypass_lsp_name)
  bypass_lsp_dest_address = __builtin__.property(_get_bypass_lsp_dest_address, _set_bypass_lsp_dest_address)
  bypass_lsp_src_address = __builtin__.property(_get_bypass_lsp_src_address, _set_bypass_lsp_src_address)
  bypass_lsp_tie_breaking = __builtin__.property(_get_bypass_lsp_tie_breaking, _set_bypass_lsp_tie_breaking)
  lsp_adaptive = __builtin__.property(_get_lsp_adaptive, _set_lsp_adaptive)
  lsp_reoptimize_timer = __builtin__.property(_get_lsp_reoptimize_timer, _set_lsp_reoptimize_timer)
  lsp_commit = __builtin__.property(_get_lsp_commit, _set_lsp_commit)
  lsp_record = __builtin__.property(_get_lsp_record, _set_lsp_record)
  lsp_cos = __builtin__.property(_get_lsp_cos, _set_lsp_cos)
  lsp_hop_limit = __builtin__.property(_get_lsp_hop_limit, _set_lsp_hop_limit)
  lsp_cspf_computation_mode = __builtin__.property(_get_lsp_cspf_computation_mode, _set_lsp_cspf_computation_mode)
  lsp_traffic_engineering = __builtin__.property(_get_lsp_traffic_engineering, _set_lsp_traffic_engineering)
  priority = __builtin__.property(_get_priority, _set_priority)
  lsp_exclude_any = __builtin__.property(_get_lsp_exclude_any, _set_lsp_exclude_any)
  lsp_include_any = __builtin__.property(_get_lsp_include_any, _set_lsp_include_any)
  lsp_include_all = __builtin__.property(_get_lsp_include_all, _set_lsp_include_all)
  exclude_interface = __builtin__.property(_get_exclude_interface, _set_exclude_interface)
  bypass_lsp_primary_path = __builtin__.property(_get_bypass_lsp_primary_path, _set_bypass_lsp_primary_path)
  bypass_lsp_enable = __builtin__.property(_get_bypass_lsp_enable, _set_bypass_lsp_enable)


  _pyangbind_elements = {'bypass_lsp_name': bypass_lsp_name, 'bypass_lsp_dest_address': bypass_lsp_dest_address, 'bypass_lsp_src_address': bypass_lsp_src_address, 'bypass_lsp_tie_breaking': bypass_lsp_tie_breaking, 'lsp_adaptive': lsp_adaptive, 'lsp_reoptimize_timer': lsp_reoptimize_timer, 'lsp_commit': lsp_commit, 'lsp_record': lsp_record, 'lsp_cos': lsp_cos, 'lsp_hop_limit': lsp_hop_limit, 'lsp_cspf_computation_mode': lsp_cspf_computation_mode, 'lsp_traffic_engineering': lsp_traffic_engineering, 'priority': priority, 'lsp_exclude_any': lsp_exclude_any, 'lsp_include_any': lsp_include_any, 'lsp_include_all': lsp_include_all, 'exclude_interface': exclude_interface, 'bypass_lsp_primary_path': bypass_lsp_primary_path, 'bypass_lsp_enable': bypass_lsp_enable, }


