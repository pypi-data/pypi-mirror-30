
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import admin_group_lists
class frr(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls-operational - based on the path /mpls-state/lsp/frr. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: MPLS LSP FRR information
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__configured','__one_to_one','__one_to_many','__protection_type','__frr_up','__active','__priority_configured','__setup_priority','__holding_priority','__hop_limit_configured','__hop_limit','__bandwidth_inherited','__bandwidth_configured','__bandwidth','__down_reason','__computation_mode','__group_computation_mode_default','__group_computation_mode_add_penalty','__group_computation_mode_exclude_groups','__group_computation_mode_high_cost','__out_port_id','__out_port_name','__out_label','__path_cost','__bypass_name','__has_secondary_swithover_time','__secondary_swithover_time','__hold_time','__global_revertive','__revertive_timer_expired','__fwdg_state_primary_up','__fwdg_state_primary_active','__fwdg_state_primary_down','__fwdg_state_secondary_up','__fwdg_state_secondary_active','__fwdg_state_secondary_down','__fwdg_state_detour_up','__fwdg_state_detour_active','__fwdg_state_detour_down','__admin_group_configured','__admin_group_lists',)

  _yang_name = 'frr'
  _rest_name = 'frr'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__bandwidth_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bandwidth-configured", rest_name="bandwidth-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__out_port_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-port-id", rest_name="out-port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__path_cost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-cost", rest_name="path-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="configured", rest_name="configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__bandwidth_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bandwidth-inherited", rest_name="bandwidth-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__down_reason = YANGDynClass(base=unicode, is_leaf=True, yang_name="down-reason", rest_name="down-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", rest_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__fwdg_state_primary_active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-primary-active", rest_name="fwdg-state-primary-active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__out_port_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="out-port-name", rest_name="out-port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__global_revertive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="global-revertive", rest_name="global-revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__one_to_one = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="one-to-one", rest_name="one-to-one", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__computation_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'cspf-computation-mode-default': {'value': 1}, u'cspf-computation-mode-use-bypass-metric': {'value': 2}, u'cspf-computation-mode-use-igp-metric-global': {'value': 7}, u'cspf-computation-mode-use-igp-metric': {'value': 5}, u'cspf-computation-mode-use-te-metric': {'value': 4}, u'cspf-computation-mode-use-bypass-liberal': {'value': 3}, u'cspf-computation-mode-use-te-metric-global': {'value': 6}},), is_leaf=True, yang_name="computation-mode", rest_name="computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='lsp-cspf-computation-mode', is_config=False)
    self.__fwdg_state_secondary_active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-secondary-active", rest_name="fwdg-state-secondary-active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__hop_limit_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hop-limit-configured", rest_name="hop-limit-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__group_computation_mode_default = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="group-computation-mode-default", rest_name="group-computation-mode-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__group_computation_mode_high_cost = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="group-computation-mode-high-cost", rest_name="group-computation-mode-high-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__fwdg_state_detour_down = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-detour-down", rest_name="fwdg-state-detour-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__out_label = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-label", rest_name="out-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__frr_up = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="frr-up", rest_name="frr-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__admin_group_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="admin-group-configured", rest_name="admin-group-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__holding_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="holding-priority", rest_name="holding-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__has_secondary_swithover_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="has-secondary-swithover-time", rest_name="has-secondary-swithover-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__fwdg_state_secondary_up = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-secondary-up", rest_name="fwdg-state-secondary-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__secondary_swithover_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="secondary-swithover-time", rest_name="secondary-swithover-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__revertive_timer_expired = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="revertive-timer-expired", rest_name="revertive-timer-expired", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__group_computation_mode_exclude_groups = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="group-computation-mode-exclude-groups", rest_name="group-computation-mode-exclude-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__bypass_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-name", rest_name="bypass-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__protection_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'node-protection': {'value': 2}, u'link-protection': {'value': 1}},), is_leaf=True, yang_name="protection-type", rest_name="protection-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='lsp-frr-protection-type', is_config=False)
    self.__admin_group_lists = YANGDynClass(base=YANGListType("list_type",admin_group_lists.admin_group_lists, yang_name="admin-group-lists", rest_name="admin-group-lists", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='list-type', extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-admin-group-list-admin-group-lists-3'}}), is_container='list', yang_name="admin-group-lists", rest_name="admin-group-lists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-admin-group-list-admin-group-lists-3'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", rest_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__fwdg_state_secondary_down = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-secondary-down", rest_name="fwdg-state-secondary-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__hold_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time", rest_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__setup_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="setup-priority", rest_name="setup-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__fwdg_state_primary_up = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-primary-up", rest_name="fwdg-state-primary-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__one_to_many = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="one-to-many", rest_name="one-to-many", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__group_computation_mode_add_penalty = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="group-computation-mode-add-penalty", rest_name="group-computation-mode-add-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__priority_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="priority-configured", rest_name="priority-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__fwdg_state_detour_up = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-detour-up", rest_name="fwdg-state-detour-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__fwdg_state_detour_active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-detour-active", rest_name="fwdg-state-detour-active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__fwdg_state_primary_down = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-primary-down", rest_name="fwdg-state-primary-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__hop_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="hop-limit", rest_name="hop-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mpls-state', u'lsp', u'frr']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'mpls-state', u'lsp', u'frr']

  def _get_configured(self):
    """
    Getter method for configured, mapped from YANG variable /mpls_state/lsp/frr/configured (boolean)

    YANG Description: lsp_frr_configured
    """
    return self.__configured
      
  def _set_configured(self, v, load=False):
    """
    Setter method for configured, mapped from YANG variable /mpls_state/lsp/frr/configured (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configured is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configured() directly.

    YANG Description: lsp_frr_configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="configured", rest_name="configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configured must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="configured", rest_name="configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__configured = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configured(self):
    self.__configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="configured", rest_name="configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_one_to_one(self):
    """
    Getter method for one_to_one, mapped from YANG variable /mpls_state/lsp/frr/one_to_one (boolean)

    YANG Description: lsp_frr_one_to_one
    """
    return self.__one_to_one
      
  def _set_one_to_one(self, v, load=False):
    """
    Setter method for one_to_one, mapped from YANG variable /mpls_state/lsp/frr/one_to_one (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_one_to_one is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_one_to_one() directly.

    YANG Description: lsp_frr_one_to_one
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="one-to-one", rest_name="one-to-one", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """one_to_one must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="one-to-one", rest_name="one-to-one", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__one_to_one = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_one_to_one(self):
    self.__one_to_one = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="one-to-one", rest_name="one-to-one", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_one_to_many(self):
    """
    Getter method for one_to_many, mapped from YANG variable /mpls_state/lsp/frr/one_to_many (boolean)

    YANG Description: lsp_frr_one_to_many
    """
    return self.__one_to_many
      
  def _set_one_to_many(self, v, load=False):
    """
    Setter method for one_to_many, mapped from YANG variable /mpls_state/lsp/frr/one_to_many (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_one_to_many is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_one_to_many() directly.

    YANG Description: lsp_frr_one_to_many
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="one-to-many", rest_name="one-to-many", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """one_to_many must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="one-to-many", rest_name="one-to-many", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__one_to_many = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_one_to_many(self):
    self.__one_to_many = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="one-to-many", rest_name="one-to-many", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_protection_type(self):
    """
    Getter method for protection_type, mapped from YANG variable /mpls_state/lsp/frr/protection_type (lsp-frr-protection-type)

    YANG Description: FRR desired protection type
    """
    return self.__protection_type
      
  def _set_protection_type(self, v, load=False):
    """
    Setter method for protection_type, mapped from YANG variable /mpls_state/lsp/frr/protection_type (lsp-frr-protection-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protection_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protection_type() directly.

    YANG Description: FRR desired protection type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'node-protection': {'value': 2}, u'link-protection': {'value': 1}},), is_leaf=True, yang_name="protection-type", rest_name="protection-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='lsp-frr-protection-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protection_type must be of a type compatible with lsp-frr-protection-type""",
          'defined-type': "brocade-mpls-operational:lsp-frr-protection-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'node-protection': {'value': 2}, u'link-protection': {'value': 1}},), is_leaf=True, yang_name="protection-type", rest_name="protection-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='lsp-frr-protection-type', is_config=False)""",
        })

    self.__protection_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protection_type(self):
    self.__protection_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'node-protection': {'value': 2}, u'link-protection': {'value': 1}},), is_leaf=True, yang_name="protection-type", rest_name="protection-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='lsp-frr-protection-type', is_config=False)


  def _get_frr_up(self):
    """
    Getter method for frr_up, mapped from YANG variable /mpls_state/lsp/frr/frr_up (boolean)

    YANG Description: lsp_frr_up
    """
    return self.__frr_up
      
  def _set_frr_up(self, v, load=False):
    """
    Setter method for frr_up, mapped from YANG variable /mpls_state/lsp/frr/frr_up (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frr_up is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frr_up() directly.

    YANG Description: lsp_frr_up
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="frr-up", rest_name="frr-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frr_up must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="frr-up", rest_name="frr-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__frr_up = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frr_up(self):
    self.__frr_up = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="frr-up", rest_name="frr-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /mpls_state/lsp/frr/active (boolean)

    YANG Description: lsp_frr_active
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /mpls_state/lsp/frr/active (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: lsp_frr_active
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="active", rest_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", rest_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", rest_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_priority_configured(self):
    """
    Getter method for priority_configured, mapped from YANG variable /mpls_state/lsp/frr/priority_configured (boolean)

    YANG Description: lsp_frr_priority_configured
    """
    return self.__priority_configured
      
  def _set_priority_configured(self, v, load=False):
    """
    Setter method for priority_configured, mapped from YANG variable /mpls_state/lsp/frr/priority_configured (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority_configured is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority_configured() directly.

    YANG Description: lsp_frr_priority_configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="priority-configured", rest_name="priority-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority_configured must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="priority-configured", rest_name="priority-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__priority_configured = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority_configured(self):
    self.__priority_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="priority-configured", rest_name="priority-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_setup_priority(self):
    """
    Getter method for setup_priority, mapped from YANG variable /mpls_state/lsp/frr/setup_priority (uint8)

    YANG Description: lsp_frr_setup_priority
    """
    return self.__setup_priority
      
  def _set_setup_priority(self, v, load=False):
    """
    Setter method for setup_priority, mapped from YANG variable /mpls_state/lsp/frr/setup_priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_setup_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_setup_priority() directly.

    YANG Description: lsp_frr_setup_priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="setup-priority", rest_name="setup-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """setup_priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="setup-priority", rest_name="setup-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__setup_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_setup_priority(self):
    self.__setup_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="setup-priority", rest_name="setup-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_holding_priority(self):
    """
    Getter method for holding_priority, mapped from YANG variable /mpls_state/lsp/frr/holding_priority (uint8)

    YANG Description: lsp_frr_holding_priority
    """
    return self.__holding_priority
      
  def _set_holding_priority(self, v, load=False):
    """
    Setter method for holding_priority, mapped from YANG variable /mpls_state/lsp/frr/holding_priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_holding_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_holding_priority() directly.

    YANG Description: lsp_frr_holding_priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="holding-priority", rest_name="holding-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """holding_priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="holding-priority", rest_name="holding-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__holding_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_holding_priority(self):
    self.__holding_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="holding-priority", rest_name="holding-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_hop_limit_configured(self):
    """
    Getter method for hop_limit_configured, mapped from YANG variable /mpls_state/lsp/frr/hop_limit_configured (boolean)

    YANG Description: lsp_frr_hop_limit_configured
    """
    return self.__hop_limit_configured
      
  def _set_hop_limit_configured(self, v, load=False):
    """
    Setter method for hop_limit_configured, mapped from YANG variable /mpls_state/lsp/frr/hop_limit_configured (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hop_limit_configured is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hop_limit_configured() directly.

    YANG Description: lsp_frr_hop_limit_configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="hop-limit-configured", rest_name="hop-limit-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hop_limit_configured must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hop-limit-configured", rest_name="hop-limit-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__hop_limit_configured = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hop_limit_configured(self):
    self.__hop_limit_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hop-limit-configured", rest_name="hop-limit-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_hop_limit(self):
    """
    Getter method for hop_limit, mapped from YANG variable /mpls_state/lsp/frr/hop_limit (uint8)

    YANG Description: lsp_frr_hop_limit
    """
    return self.__hop_limit
      
  def _set_hop_limit(self, v, load=False):
    """
    Setter method for hop_limit, mapped from YANG variable /mpls_state/lsp/frr/hop_limit (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hop_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hop_limit() directly.

    YANG Description: lsp_frr_hop_limit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="hop-limit", rest_name="hop-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hop_limit must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="hop-limit", rest_name="hop-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__hop_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hop_limit(self):
    self.__hop_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="hop-limit", rest_name="hop-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_bandwidth_inherited(self):
    """
    Getter method for bandwidth_inherited, mapped from YANG variable /mpls_state/lsp/frr/bandwidth_inherited (boolean)

    YANG Description: Frr bandwidth inherited
    """
    return self.__bandwidth_inherited
      
  def _set_bandwidth_inherited(self, v, load=False):
    """
    Setter method for bandwidth_inherited, mapped from YANG variable /mpls_state/lsp/frr/bandwidth_inherited (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth_inherited is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth_inherited() directly.

    YANG Description: Frr bandwidth inherited
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bandwidth-inherited", rest_name="bandwidth-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth_inherited must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bandwidth-inherited", rest_name="bandwidth-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__bandwidth_inherited = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth_inherited(self):
    self.__bandwidth_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bandwidth-inherited", rest_name="bandwidth-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_bandwidth_configured(self):
    """
    Getter method for bandwidth_configured, mapped from YANG variable /mpls_state/lsp/frr/bandwidth_configured (boolean)

    YANG Description: lsp_frr_bandwidth_configured
    """
    return self.__bandwidth_configured
      
  def _set_bandwidth_configured(self, v, load=False):
    """
    Setter method for bandwidth_configured, mapped from YANG variable /mpls_state/lsp/frr/bandwidth_configured (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth_configured is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth_configured() directly.

    YANG Description: lsp_frr_bandwidth_configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bandwidth-configured", rest_name="bandwidth-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth_configured must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bandwidth-configured", rest_name="bandwidth-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__bandwidth_configured = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth_configured(self):
    self.__bandwidth_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bandwidth-configured", rest_name="bandwidth-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /mpls_state/lsp/frr/bandwidth (uint32)

    YANG Description: lsp_frr_bandwidth
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /mpls_state/lsp/frr/bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: lsp_frr_bandwidth
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", rest_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", rest_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", rest_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_down_reason(self):
    """
    Getter method for down_reason, mapped from YANG variable /mpls_state/lsp/frr/down_reason (string)

    YANG Description: lsp_frr_down_reason
    """
    return self.__down_reason
      
  def _set_down_reason(self, v, load=False):
    """
    Setter method for down_reason, mapped from YANG variable /mpls_state/lsp/frr/down_reason (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_down_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_down_reason() directly.

    YANG Description: lsp_frr_down_reason
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="down-reason", rest_name="down-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """down_reason must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="down-reason", rest_name="down-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__down_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_down_reason(self):
    self.__down_reason = YANGDynClass(base=unicode, is_leaf=True, yang_name="down-reason", rest_name="down-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_computation_mode(self):
    """
    Getter method for computation_mode, mapped from YANG variable /mpls_state/lsp/frr/computation_mode (lsp-cspf-computation-mode)

    YANG Description: lsp frr computation mode
    """
    return self.__computation_mode
      
  def _set_computation_mode(self, v, load=False):
    """
    Setter method for computation_mode, mapped from YANG variable /mpls_state/lsp/frr/computation_mode (lsp-cspf-computation-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_computation_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_computation_mode() directly.

    YANG Description: lsp frr computation mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'cspf-computation-mode-default': {'value': 1}, u'cspf-computation-mode-use-bypass-metric': {'value': 2}, u'cspf-computation-mode-use-igp-metric-global': {'value': 7}, u'cspf-computation-mode-use-igp-metric': {'value': 5}, u'cspf-computation-mode-use-te-metric': {'value': 4}, u'cspf-computation-mode-use-bypass-liberal': {'value': 3}, u'cspf-computation-mode-use-te-metric-global': {'value': 6}},), is_leaf=True, yang_name="computation-mode", rest_name="computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='lsp-cspf-computation-mode', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """computation_mode must be of a type compatible with lsp-cspf-computation-mode""",
          'defined-type': "brocade-mpls-operational:lsp-cspf-computation-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'cspf-computation-mode-default': {'value': 1}, u'cspf-computation-mode-use-bypass-metric': {'value': 2}, u'cspf-computation-mode-use-igp-metric-global': {'value': 7}, u'cspf-computation-mode-use-igp-metric': {'value': 5}, u'cspf-computation-mode-use-te-metric': {'value': 4}, u'cspf-computation-mode-use-bypass-liberal': {'value': 3}, u'cspf-computation-mode-use-te-metric-global': {'value': 6}},), is_leaf=True, yang_name="computation-mode", rest_name="computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='lsp-cspf-computation-mode', is_config=False)""",
        })

    self.__computation_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_computation_mode(self):
    self.__computation_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'cspf-computation-mode-default': {'value': 1}, u'cspf-computation-mode-use-bypass-metric': {'value': 2}, u'cspf-computation-mode-use-igp-metric-global': {'value': 7}, u'cspf-computation-mode-use-igp-metric': {'value': 5}, u'cspf-computation-mode-use-te-metric': {'value': 4}, u'cspf-computation-mode-use-bypass-liberal': {'value': 3}, u'cspf-computation-mode-use-te-metric-global': {'value': 6}},), is_leaf=True, yang_name="computation-mode", rest_name="computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='lsp-cspf-computation-mode', is_config=False)


  def _get_group_computation_mode_default(self):
    """
    Getter method for group_computation_mode_default, mapped from YANG variable /mpls_state/lsp/frr/group_computation_mode_default (boolean)

    YANG Description: lsp_frr_group_computation_mode_default
    """
    return self.__group_computation_mode_default
      
  def _set_group_computation_mode_default(self, v, load=False):
    """
    Setter method for group_computation_mode_default, mapped from YANG variable /mpls_state/lsp/frr/group_computation_mode_default (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_computation_mode_default is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_computation_mode_default() directly.

    YANG Description: lsp_frr_group_computation_mode_default
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="group-computation-mode-default", rest_name="group-computation-mode-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_computation_mode_default must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="group-computation-mode-default", rest_name="group-computation-mode-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__group_computation_mode_default = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_computation_mode_default(self):
    self.__group_computation_mode_default = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="group-computation-mode-default", rest_name="group-computation-mode-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_group_computation_mode_add_penalty(self):
    """
    Getter method for group_computation_mode_add_penalty, mapped from YANG variable /mpls_state/lsp/frr/group_computation_mode_add_penalty (boolean)

    YANG Description: lsp_frr_group_computation_mode_add_penalty
    """
    return self.__group_computation_mode_add_penalty
      
  def _set_group_computation_mode_add_penalty(self, v, load=False):
    """
    Setter method for group_computation_mode_add_penalty, mapped from YANG variable /mpls_state/lsp/frr/group_computation_mode_add_penalty (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_computation_mode_add_penalty is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_computation_mode_add_penalty() directly.

    YANG Description: lsp_frr_group_computation_mode_add_penalty
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="group-computation-mode-add-penalty", rest_name="group-computation-mode-add-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_computation_mode_add_penalty must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="group-computation-mode-add-penalty", rest_name="group-computation-mode-add-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__group_computation_mode_add_penalty = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_computation_mode_add_penalty(self):
    self.__group_computation_mode_add_penalty = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="group-computation-mode-add-penalty", rest_name="group-computation-mode-add-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_group_computation_mode_exclude_groups(self):
    """
    Getter method for group_computation_mode_exclude_groups, mapped from YANG variable /mpls_state/lsp/frr/group_computation_mode_exclude_groups (boolean)

    YANG Description: lsp_frr_group_computation_mode_exclude_groups
    """
    return self.__group_computation_mode_exclude_groups
      
  def _set_group_computation_mode_exclude_groups(self, v, load=False):
    """
    Setter method for group_computation_mode_exclude_groups, mapped from YANG variable /mpls_state/lsp/frr/group_computation_mode_exclude_groups (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_computation_mode_exclude_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_computation_mode_exclude_groups() directly.

    YANG Description: lsp_frr_group_computation_mode_exclude_groups
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="group-computation-mode-exclude-groups", rest_name="group-computation-mode-exclude-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_computation_mode_exclude_groups must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="group-computation-mode-exclude-groups", rest_name="group-computation-mode-exclude-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__group_computation_mode_exclude_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_computation_mode_exclude_groups(self):
    self.__group_computation_mode_exclude_groups = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="group-computation-mode-exclude-groups", rest_name="group-computation-mode-exclude-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_group_computation_mode_high_cost(self):
    """
    Getter method for group_computation_mode_high_cost, mapped from YANG variable /mpls_state/lsp/frr/group_computation_mode_high_cost (boolean)

    YANG Description: lsp_frr_group_computation_mode_high_cost
    """
    return self.__group_computation_mode_high_cost
      
  def _set_group_computation_mode_high_cost(self, v, load=False):
    """
    Setter method for group_computation_mode_high_cost, mapped from YANG variable /mpls_state/lsp/frr/group_computation_mode_high_cost (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_computation_mode_high_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_computation_mode_high_cost() directly.

    YANG Description: lsp_frr_group_computation_mode_high_cost
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="group-computation-mode-high-cost", rest_name="group-computation-mode-high-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_computation_mode_high_cost must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="group-computation-mode-high-cost", rest_name="group-computation-mode-high-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__group_computation_mode_high_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_computation_mode_high_cost(self):
    self.__group_computation_mode_high_cost = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="group-computation-mode-high-cost", rest_name="group-computation-mode-high-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_out_port_id(self):
    """
    Getter method for out_port_id, mapped from YANG variable /mpls_state/lsp/frr/out_port_id (uint32)

    YANG Description: lsp_frr_out_port_id
    """
    return self.__out_port_id
      
  def _set_out_port_id(self, v, load=False):
    """
    Setter method for out_port_id, mapped from YANG variable /mpls_state/lsp/frr/out_port_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_port_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_port_id() directly.

    YANG Description: lsp_frr_out_port_id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-port-id", rest_name="out-port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_port_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-port-id", rest_name="out-port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__out_port_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_port_id(self):
    self.__out_port_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-port-id", rest_name="out-port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_out_port_name(self):
    """
    Getter method for out_port_name, mapped from YANG variable /mpls_state/lsp/frr/out_port_name (string)

    YANG Description: lsp_frr_out_port_name
    """
    return self.__out_port_name
      
  def _set_out_port_name(self, v, load=False):
    """
    Setter method for out_port_name, mapped from YANG variable /mpls_state/lsp/frr/out_port_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_port_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_port_name() directly.

    YANG Description: lsp_frr_out_port_name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="out-port-name", rest_name="out-port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_port_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="out-port-name", rest_name="out-port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__out_port_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_port_name(self):
    self.__out_port_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="out-port-name", rest_name="out-port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_out_label(self):
    """
    Getter method for out_label, mapped from YANG variable /mpls_state/lsp/frr/out_label (uint32)

    YANG Description: lsp_frr_out_label
    """
    return self.__out_label
      
  def _set_out_label(self, v, load=False):
    """
    Setter method for out_label, mapped from YANG variable /mpls_state/lsp/frr/out_label (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_label() directly.

    YANG Description: lsp_frr_out_label
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-label", rest_name="out-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_label must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-label", rest_name="out-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__out_label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_label(self):
    self.__out_label = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-label", rest_name="out-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_path_cost(self):
    """
    Getter method for path_cost, mapped from YANG variable /mpls_state/lsp/frr/path_cost (uint32)

    YANG Description: lsp_frr_path_cost
    """
    return self.__path_cost
      
  def _set_path_cost(self, v, load=False):
    """
    Setter method for path_cost, mapped from YANG variable /mpls_state/lsp/frr/path_cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_cost() directly.

    YANG Description: lsp_frr_path_cost
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-cost", rest_name="path-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-cost", rest_name="path-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__path_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_cost(self):
    self.__path_cost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-cost", rest_name="path-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_bypass_name(self):
    """
    Getter method for bypass_name, mapped from YANG variable /mpls_state/lsp/frr/bypass_name (string)

    YANG Description: lsp_frr_bypass_name
    """
    return self.__bypass_name
      
  def _set_bypass_name(self, v, load=False):
    """
    Setter method for bypass_name, mapped from YANG variable /mpls_state/lsp/frr/bypass_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_name() directly.

    YANG Description: lsp_frr_bypass_name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="bypass-name", rest_name="bypass-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-name", rest_name="bypass-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__bypass_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_name(self):
    self.__bypass_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-name", rest_name="bypass-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_has_secondary_swithover_time(self):
    """
    Getter method for has_secondary_swithover_time, mapped from YANG variable /mpls_state/lsp/frr/has_secondary_swithover_time (uint32)

    YANG Description: lsp_frr_has_secondary_swithover_time
    """
    return self.__has_secondary_swithover_time
      
  def _set_has_secondary_swithover_time(self, v, load=False):
    """
    Setter method for has_secondary_swithover_time, mapped from YANG variable /mpls_state/lsp/frr/has_secondary_swithover_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_has_secondary_swithover_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_has_secondary_swithover_time() directly.

    YANG Description: lsp_frr_has_secondary_swithover_time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="has-secondary-swithover-time", rest_name="has-secondary-swithover-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """has_secondary_swithover_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="has-secondary-swithover-time", rest_name="has-secondary-swithover-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__has_secondary_swithover_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_has_secondary_swithover_time(self):
    self.__has_secondary_swithover_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="has-secondary-swithover-time", rest_name="has-secondary-swithover-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_secondary_swithover_time(self):
    """
    Getter method for secondary_swithover_time, mapped from YANG variable /mpls_state/lsp/frr/secondary_swithover_time (uint32)

    YANG Description: lsp_frr_secondary_swithover_time
    """
    return self.__secondary_swithover_time
      
  def _set_secondary_swithover_time(self, v, load=False):
    """
    Setter method for secondary_swithover_time, mapped from YANG variable /mpls_state/lsp/frr/secondary_swithover_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_swithover_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_swithover_time() directly.

    YANG Description: lsp_frr_secondary_swithover_time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="secondary-swithover-time", rest_name="secondary-swithover-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary_swithover_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="secondary-swithover-time", rest_name="secondary-swithover-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__secondary_swithover_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary_swithover_time(self):
    self.__secondary_swithover_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="secondary-swithover-time", rest_name="secondary-swithover-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_hold_time(self):
    """
    Getter method for hold_time, mapped from YANG variable /mpls_state/lsp/frr/hold_time (uint32)

    YANG Description: lsp_frr_hold_time
    """
    return self.__hold_time
      
  def _set_hold_time(self, v, load=False):
    """
    Setter method for hold_time, mapped from YANG variable /mpls_state/lsp/frr/hold_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_time() directly.

    YANG Description: lsp_frr_hold_time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time", rest_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time", rest_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__hold_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_time(self):
    self.__hold_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time", rest_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_global_revertive(self):
    """
    Getter method for global_revertive, mapped from YANG variable /mpls_state/lsp/frr/global_revertive (uint32)

    YANG Description: lsp_frr_global_revertive
    """
    return self.__global_revertive
      
  def _set_global_revertive(self, v, load=False):
    """
    Setter method for global_revertive, mapped from YANG variable /mpls_state/lsp/frr/global_revertive (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_revertive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_revertive() directly.

    YANG Description: lsp_frr_global_revertive
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="global-revertive", rest_name="global-revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_revertive must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="global-revertive", rest_name="global-revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__global_revertive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_revertive(self):
    self.__global_revertive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="global-revertive", rest_name="global-revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_revertive_timer_expired(self):
    """
    Getter method for revertive_timer_expired, mapped from YANG variable /mpls_state/lsp/frr/revertive_timer_expired (uint32)

    YANG Description: lsp_frr_revertive_timer_expired
    """
    return self.__revertive_timer_expired
      
  def _set_revertive_timer_expired(self, v, load=False):
    """
    Setter method for revertive_timer_expired, mapped from YANG variable /mpls_state/lsp/frr/revertive_timer_expired (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revertive_timer_expired is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revertive_timer_expired() directly.

    YANG Description: lsp_frr_revertive_timer_expired
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="revertive-timer-expired", rest_name="revertive-timer-expired", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revertive_timer_expired must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="revertive-timer-expired", rest_name="revertive-timer-expired", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__revertive_timer_expired = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revertive_timer_expired(self):
    self.__revertive_timer_expired = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="revertive-timer-expired", rest_name="revertive-timer-expired", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_fwdg_state_primary_up(self):
    """
    Getter method for fwdg_state_primary_up, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_primary_up (boolean)

    YANG Description: lsp_frr_fwdg_state_primary_up
    """
    return self.__fwdg_state_primary_up
      
  def _set_fwdg_state_primary_up(self, v, load=False):
    """
    Setter method for fwdg_state_primary_up, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_primary_up (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fwdg_state_primary_up is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fwdg_state_primary_up() directly.

    YANG Description: lsp_frr_fwdg_state_primary_up
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fwdg-state-primary-up", rest_name="fwdg-state-primary-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fwdg_state_primary_up must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-primary-up", rest_name="fwdg-state-primary-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__fwdg_state_primary_up = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fwdg_state_primary_up(self):
    self.__fwdg_state_primary_up = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-primary-up", rest_name="fwdg-state-primary-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_fwdg_state_primary_active(self):
    """
    Getter method for fwdg_state_primary_active, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_primary_active (boolean)

    YANG Description: lsp_frr_fwdg_state_primary_active
    """
    return self.__fwdg_state_primary_active
      
  def _set_fwdg_state_primary_active(self, v, load=False):
    """
    Setter method for fwdg_state_primary_active, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_primary_active (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fwdg_state_primary_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fwdg_state_primary_active() directly.

    YANG Description: lsp_frr_fwdg_state_primary_active
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fwdg-state-primary-active", rest_name="fwdg-state-primary-active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fwdg_state_primary_active must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-primary-active", rest_name="fwdg-state-primary-active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__fwdg_state_primary_active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fwdg_state_primary_active(self):
    self.__fwdg_state_primary_active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-primary-active", rest_name="fwdg-state-primary-active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_fwdg_state_primary_down(self):
    """
    Getter method for fwdg_state_primary_down, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_primary_down (boolean)

    YANG Description: lsp_frr_fwdg_state_primary_down
    """
    return self.__fwdg_state_primary_down
      
  def _set_fwdg_state_primary_down(self, v, load=False):
    """
    Setter method for fwdg_state_primary_down, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_primary_down (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fwdg_state_primary_down is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fwdg_state_primary_down() directly.

    YANG Description: lsp_frr_fwdg_state_primary_down
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fwdg-state-primary-down", rest_name="fwdg-state-primary-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fwdg_state_primary_down must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-primary-down", rest_name="fwdg-state-primary-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__fwdg_state_primary_down = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fwdg_state_primary_down(self):
    self.__fwdg_state_primary_down = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-primary-down", rest_name="fwdg-state-primary-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_fwdg_state_secondary_up(self):
    """
    Getter method for fwdg_state_secondary_up, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_secondary_up (boolean)

    YANG Description: lsp_frr_fwdg_state_secondary_up
    """
    return self.__fwdg_state_secondary_up
      
  def _set_fwdg_state_secondary_up(self, v, load=False):
    """
    Setter method for fwdg_state_secondary_up, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_secondary_up (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fwdg_state_secondary_up is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fwdg_state_secondary_up() directly.

    YANG Description: lsp_frr_fwdg_state_secondary_up
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fwdg-state-secondary-up", rest_name="fwdg-state-secondary-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fwdg_state_secondary_up must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-secondary-up", rest_name="fwdg-state-secondary-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__fwdg_state_secondary_up = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fwdg_state_secondary_up(self):
    self.__fwdg_state_secondary_up = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-secondary-up", rest_name="fwdg-state-secondary-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_fwdg_state_secondary_active(self):
    """
    Getter method for fwdg_state_secondary_active, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_secondary_active (boolean)

    YANG Description: lsp_frr_fwdg_state_secondary_active
    """
    return self.__fwdg_state_secondary_active
      
  def _set_fwdg_state_secondary_active(self, v, load=False):
    """
    Setter method for fwdg_state_secondary_active, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_secondary_active (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fwdg_state_secondary_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fwdg_state_secondary_active() directly.

    YANG Description: lsp_frr_fwdg_state_secondary_active
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fwdg-state-secondary-active", rest_name="fwdg-state-secondary-active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fwdg_state_secondary_active must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-secondary-active", rest_name="fwdg-state-secondary-active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__fwdg_state_secondary_active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fwdg_state_secondary_active(self):
    self.__fwdg_state_secondary_active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-secondary-active", rest_name="fwdg-state-secondary-active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_fwdg_state_secondary_down(self):
    """
    Getter method for fwdg_state_secondary_down, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_secondary_down (boolean)

    YANG Description: lsp_frr_fwdg_state_secondary_down
    """
    return self.__fwdg_state_secondary_down
      
  def _set_fwdg_state_secondary_down(self, v, load=False):
    """
    Setter method for fwdg_state_secondary_down, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_secondary_down (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fwdg_state_secondary_down is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fwdg_state_secondary_down() directly.

    YANG Description: lsp_frr_fwdg_state_secondary_down
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fwdg-state-secondary-down", rest_name="fwdg-state-secondary-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fwdg_state_secondary_down must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-secondary-down", rest_name="fwdg-state-secondary-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__fwdg_state_secondary_down = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fwdg_state_secondary_down(self):
    self.__fwdg_state_secondary_down = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-secondary-down", rest_name="fwdg-state-secondary-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_fwdg_state_detour_up(self):
    """
    Getter method for fwdg_state_detour_up, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_detour_up (boolean)

    YANG Description: lsp_frr_fwdg_state_detour_up
    """
    return self.__fwdg_state_detour_up
      
  def _set_fwdg_state_detour_up(self, v, load=False):
    """
    Setter method for fwdg_state_detour_up, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_detour_up (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fwdg_state_detour_up is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fwdg_state_detour_up() directly.

    YANG Description: lsp_frr_fwdg_state_detour_up
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fwdg-state-detour-up", rest_name="fwdg-state-detour-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fwdg_state_detour_up must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-detour-up", rest_name="fwdg-state-detour-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__fwdg_state_detour_up = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fwdg_state_detour_up(self):
    self.__fwdg_state_detour_up = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-detour-up", rest_name="fwdg-state-detour-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_fwdg_state_detour_active(self):
    """
    Getter method for fwdg_state_detour_active, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_detour_active (boolean)

    YANG Description: lsp_frr_fwdg_state_detour_active
    """
    return self.__fwdg_state_detour_active
      
  def _set_fwdg_state_detour_active(self, v, load=False):
    """
    Setter method for fwdg_state_detour_active, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_detour_active (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fwdg_state_detour_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fwdg_state_detour_active() directly.

    YANG Description: lsp_frr_fwdg_state_detour_active
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fwdg-state-detour-active", rest_name="fwdg-state-detour-active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fwdg_state_detour_active must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-detour-active", rest_name="fwdg-state-detour-active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__fwdg_state_detour_active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fwdg_state_detour_active(self):
    self.__fwdg_state_detour_active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-detour-active", rest_name="fwdg-state-detour-active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_fwdg_state_detour_down(self):
    """
    Getter method for fwdg_state_detour_down, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_detour_down (boolean)

    YANG Description: lsp_frr_fwdg_state_detour_active
    """
    return self.__fwdg_state_detour_down
      
  def _set_fwdg_state_detour_down(self, v, load=False):
    """
    Setter method for fwdg_state_detour_down, mapped from YANG variable /mpls_state/lsp/frr/fwdg_state_detour_down (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fwdg_state_detour_down is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fwdg_state_detour_down() directly.

    YANG Description: lsp_frr_fwdg_state_detour_active
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fwdg-state-detour-down", rest_name="fwdg-state-detour-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fwdg_state_detour_down must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-detour-down", rest_name="fwdg-state-detour-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__fwdg_state_detour_down = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fwdg_state_detour_down(self):
    self.__fwdg_state_detour_down = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fwdg-state-detour-down", rest_name="fwdg-state-detour-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_admin_group_configured(self):
    """
    Getter method for admin_group_configured, mapped from YANG variable /mpls_state/lsp/frr/admin_group_configured (boolean)

    YANG Description: lsp_frr_admin_group_configured
    """
    return self.__admin_group_configured
      
  def _set_admin_group_configured(self, v, load=False):
    """
    Setter method for admin_group_configured, mapped from YANG variable /mpls_state/lsp/frr/admin_group_configured (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_group_configured is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_group_configured() directly.

    YANG Description: lsp_frr_admin_group_configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="admin-group-configured", rest_name="admin-group-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_group_configured must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="admin-group-configured", rest_name="admin-group-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__admin_group_configured = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_group_configured(self):
    self.__admin_group_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="admin-group-configured", rest_name="admin-group-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_admin_group_lists(self):
    """
    Getter method for admin_group_lists, mapped from YANG variable /mpls_state/lsp/frr/admin_group_lists (list)
    """
    return self.__admin_group_lists
      
  def _set_admin_group_lists(self, v, load=False):
    """
    Setter method for admin_group_lists, mapped from YANG variable /mpls_state/lsp/frr/admin_group_lists (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_group_lists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_group_lists() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("list_type",admin_group_lists.admin_group_lists, yang_name="admin-group-lists", rest_name="admin-group-lists", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='list-type', extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-admin-group-list-admin-group-lists-3'}}), is_container='list', yang_name="admin-group-lists", rest_name="admin-group-lists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-admin-group-list-admin-group-lists-3'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_group_lists must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("list_type",admin_group_lists.admin_group_lists, yang_name="admin-group-lists", rest_name="admin-group-lists", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='list-type', extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-admin-group-list-admin-group-lists-3'}}), is_container='list', yang_name="admin-group-lists", rest_name="admin-group-lists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-admin-group-list-admin-group-lists-3'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__admin_group_lists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_group_lists(self):
    self.__admin_group_lists = YANGDynClass(base=YANGListType("list_type",admin_group_lists.admin_group_lists, yang_name="admin-group-lists", rest_name="admin-group-lists", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='list-type', extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-admin-group-list-admin-group-lists-3'}}), is_container='list', yang_name="admin-group-lists", rest_name="admin-group-lists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-admin-group-list-admin-group-lists-3'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)

  configured = __builtin__.property(_get_configured)
  one_to_one = __builtin__.property(_get_one_to_one)
  one_to_many = __builtin__.property(_get_one_to_many)
  protection_type = __builtin__.property(_get_protection_type)
  frr_up = __builtin__.property(_get_frr_up)
  active = __builtin__.property(_get_active)
  priority_configured = __builtin__.property(_get_priority_configured)
  setup_priority = __builtin__.property(_get_setup_priority)
  holding_priority = __builtin__.property(_get_holding_priority)
  hop_limit_configured = __builtin__.property(_get_hop_limit_configured)
  hop_limit = __builtin__.property(_get_hop_limit)
  bandwidth_inherited = __builtin__.property(_get_bandwidth_inherited)
  bandwidth_configured = __builtin__.property(_get_bandwidth_configured)
  bandwidth = __builtin__.property(_get_bandwidth)
  down_reason = __builtin__.property(_get_down_reason)
  computation_mode = __builtin__.property(_get_computation_mode)
  group_computation_mode_default = __builtin__.property(_get_group_computation_mode_default)
  group_computation_mode_add_penalty = __builtin__.property(_get_group_computation_mode_add_penalty)
  group_computation_mode_exclude_groups = __builtin__.property(_get_group_computation_mode_exclude_groups)
  group_computation_mode_high_cost = __builtin__.property(_get_group_computation_mode_high_cost)
  out_port_id = __builtin__.property(_get_out_port_id)
  out_port_name = __builtin__.property(_get_out_port_name)
  out_label = __builtin__.property(_get_out_label)
  path_cost = __builtin__.property(_get_path_cost)
  bypass_name = __builtin__.property(_get_bypass_name)
  has_secondary_swithover_time = __builtin__.property(_get_has_secondary_swithover_time)
  secondary_swithover_time = __builtin__.property(_get_secondary_swithover_time)
  hold_time = __builtin__.property(_get_hold_time)
  global_revertive = __builtin__.property(_get_global_revertive)
  revertive_timer_expired = __builtin__.property(_get_revertive_timer_expired)
  fwdg_state_primary_up = __builtin__.property(_get_fwdg_state_primary_up)
  fwdg_state_primary_active = __builtin__.property(_get_fwdg_state_primary_active)
  fwdg_state_primary_down = __builtin__.property(_get_fwdg_state_primary_down)
  fwdg_state_secondary_up = __builtin__.property(_get_fwdg_state_secondary_up)
  fwdg_state_secondary_active = __builtin__.property(_get_fwdg_state_secondary_active)
  fwdg_state_secondary_down = __builtin__.property(_get_fwdg_state_secondary_down)
  fwdg_state_detour_up = __builtin__.property(_get_fwdg_state_detour_up)
  fwdg_state_detour_active = __builtin__.property(_get_fwdg_state_detour_active)
  fwdg_state_detour_down = __builtin__.property(_get_fwdg_state_detour_down)
  admin_group_configured = __builtin__.property(_get_admin_group_configured)
  admin_group_lists = __builtin__.property(_get_admin_group_lists)


  _pyangbind_elements = {'configured': configured, 'one_to_one': one_to_one, 'one_to_many': one_to_many, 'protection_type': protection_type, 'frr_up': frr_up, 'active': active, 'priority_configured': priority_configured, 'setup_priority': setup_priority, 'holding_priority': holding_priority, 'hop_limit_configured': hop_limit_configured, 'hop_limit': hop_limit, 'bandwidth_inherited': bandwidth_inherited, 'bandwidth_configured': bandwidth_configured, 'bandwidth': bandwidth, 'down_reason': down_reason, 'computation_mode': computation_mode, 'group_computation_mode_default': group_computation_mode_default, 'group_computation_mode_add_penalty': group_computation_mode_add_penalty, 'group_computation_mode_exclude_groups': group_computation_mode_exclude_groups, 'group_computation_mode_high_cost': group_computation_mode_high_cost, 'out_port_id': out_port_id, 'out_port_name': out_port_name, 'out_label': out_label, 'path_cost': path_cost, 'bypass_name': bypass_name, 'has_secondary_swithover_time': has_secondary_swithover_time, 'secondary_swithover_time': secondary_swithover_time, 'hold_time': hold_time, 'global_revertive': global_revertive, 'revertive_timer_expired': revertive_timer_expired, 'fwdg_state_primary_up': fwdg_state_primary_up, 'fwdg_state_primary_active': fwdg_state_primary_active, 'fwdg_state_primary_down': fwdg_state_primary_down, 'fwdg_state_secondary_up': fwdg_state_secondary_up, 'fwdg_state_secondary_active': fwdg_state_secondary_active, 'fwdg_state_secondary_down': fwdg_state_secondary_down, 'fwdg_state_detour_up': fwdg_state_detour_up, 'fwdg_state_detour_active': fwdg_state_detour_active, 'fwdg_state_detour_down': fwdg_state_detour_down, 'admin_group_configured': admin_group_configured, 'admin_group_lists': admin_group_lists, }


