
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import admin_groups
import rsvp_flooding_thresholds
class policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls-operational - based on the path /mpls-state/policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: MPLS Policy
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__cspf_intf','__cspf_group_computation_mode','__cspf_comp_mode','__cspf_comp_ignore_overload_bit','__implicit_commit_value','__qos_ttl_mode','__rtm_route_filter_enabled','__rtm_route_filter_all_ibgp_enabled','__ingress_tnnl_actg','__transit_session_actg','__load_interval','__te_policy_protocol','__te_policy_flags','__te_policy_area','__handle_isis_nbr_down','__handle_ospf_nbr_down','__max_lsp_retries','__fast_retry_on','__lsp_retry_interval','__frr_backup_retry_interval','__auto_bandwidth_enabled','__autobw_sample_interval','__autobw_num_sample_record','__soft_preempt_cleanup_timer','__rsvp_periodic_flooding_timer','__admin_groups','__rsvp_flooding_thresholds',)

  _yang_name = 'policy'
  _rest_name = 'policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__rtm_route_filter_all_ibgp_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rtm-route-filter-all-ibgp-enabled", rest_name="rtm-route-filter-all-ibgp-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__te_policy_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'mpls-te-none': {'value': 0}, u'mpls-te-ospf': {'value': 1}, u'mpls-te-isis': {'value': 2}},), is_leaf=True, yang_name="te-policy-protocol", rest_name="te-policy-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='te-protocol', is_config=False)
    self.__autobw_num_sample_record = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="autobw-num-sample-record", rest_name="autobw-num-sample-record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__lsp_retry_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="lsp-retry-interval", rest_name="lsp-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    self.__admin_groups = YANGDynClass(base=YANGListType("name",admin_groups.admin_groups, yang_name="admin-groups", rest_name="admin-groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'callpoint': u'mpls-admin-group', u'cli-suppress-show-path': None}}), is_container='list', yang_name="admin-groups", rest_name="admin-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-admin-group', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__ingress_tnnl_actg = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ingress-tnnl-actg", rest_name="ingress-tnnl-actg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__rsvp_periodic_flooding_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rsvp-periodic-flooding-timer", rest_name="rsvp-periodic-flooding-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    self.__qos_ttl_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'qt-uniform': {'value': 0}, u'qt-pipe': {'value': 1}},), is_leaf=True, yang_name="qos-ttl-mode", rest_name="qos-ttl-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='qos-ttl-mode', is_config=False)
    self.__load_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="load-interval", rest_name="load-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    self.__handle_ospf_nbr_down = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="handle-ospf-nbr-down", rest_name="handle-ospf-nbr-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__te_policy_flags = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="te-policy-flags", rest_name="te-policy-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    self.__auto_bandwidth_enabled = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="auto-bandwidth-enabled", rest_name="auto-bandwidth-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__cspf_group_computation_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'mpls-cspf-grp-comp-mode-default': {'value': 0}, u'mpls-cspf-grp-comp-mode-exclude-groups': {'value': 2}, u'mpls-cspf-grp-comp-mode-max': {'value': 4}, u'mpls-cspf-grp-comp-mode-add-penalty': {'value': 1}, u'mpls-cspf-grp-comp-mode-high-cost': {'value': 3}},), is_leaf=True, yang_name="cspf-group-computation-mode", rest_name="cspf-group-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='mpls-cspf-grp-comp-mode', is_config=False)
    self.__fast_retry_on = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="fast-retry-on", rest_name="fast-retry-on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__soft_preempt_cleanup_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="soft-preempt-cleanup-timer", rest_name="soft-preempt-cleanup-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    self.__max_lsp_retries = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-lsp-retries", rest_name="max-lsp-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    self.__rsvp_flooding_thresholds = YANGDynClass(base=YANGListType("threshold_type",rsvp_flooding_thresholds.rsvp_flooding_thresholds, yang_name="rsvp-flooding-thresholds", rest_name="rsvp-flooding-thresholds", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='threshold-type', extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-flooding-thresholds', u'cli-suppress-show-path': None}}), is_container='list', yang_name="rsvp-flooding-thresholds", rest_name="rsvp-flooding-thresholds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-flooding-thresholds', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__cspf_comp_ignore_overload_bit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cspf-comp-ignore-overload-bit", rest_name="cspf-comp-ignore-overload-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__rtm_route_filter_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rtm-route-filter-enabled", rest_name="rtm-route-filter-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__cspf_comp_mode = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cspf-comp-mode", rest_name="cspf-comp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__implicit_commit_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="implicit-commit-value", rest_name="implicit-commit-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__te_policy_area = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="te-policy-area", rest_name="te-policy-area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__cspf_intf = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cspf-intf", rest_name="cspf-intf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__transit_session_actg = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="transit-session-actg", rest_name="transit-session-actg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__handle_isis_nbr_down = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="handle-isis-nbr-down", rest_name="handle-isis-nbr-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__frr_backup_retry_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frr-backup-retry-interval", rest_name="frr-backup-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__autobw_sample_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="autobw-sample-interval", rest_name="autobw-sample-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mpls-state', u'policy']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'mpls-state', u'policy']

  def _get_cspf_intf(self):
    """
    Getter method for cspf_intf, mapped from YANG variable /mpls_state/policy/cspf_intf (uint8)

    YANG Description: CSPF Interface constraint
    """
    return self.__cspf_intf
      
  def _set_cspf_intf(self, v, load=False):
    """
    Setter method for cspf_intf, mapped from YANG variable /mpls_state/policy/cspf_intf (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cspf_intf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cspf_intf() directly.

    YANG Description: CSPF Interface constraint
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cspf-intf", rest_name="cspf-intf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cspf_intf must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cspf-intf", rest_name="cspf-intf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__cspf_intf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cspf_intf(self):
    self.__cspf_intf = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cspf-intf", rest_name="cspf-intf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_cspf_group_computation_mode(self):
    """
    Getter method for cspf_group_computation_mode, mapped from YANG variable /mpls_state/policy/cspf_group_computation_mode (mpls-cspf-grp-comp-mode)

    YANG Description: CSPF Group Computation Mode
    """
    return self.__cspf_group_computation_mode
      
  def _set_cspf_group_computation_mode(self, v, load=False):
    """
    Setter method for cspf_group_computation_mode, mapped from YANG variable /mpls_state/policy/cspf_group_computation_mode (mpls-cspf-grp-comp-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cspf_group_computation_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cspf_group_computation_mode() directly.

    YANG Description: CSPF Group Computation Mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'mpls-cspf-grp-comp-mode-default': {'value': 0}, u'mpls-cspf-grp-comp-mode-exclude-groups': {'value': 2}, u'mpls-cspf-grp-comp-mode-max': {'value': 4}, u'mpls-cspf-grp-comp-mode-add-penalty': {'value': 1}, u'mpls-cspf-grp-comp-mode-high-cost': {'value': 3}},), is_leaf=True, yang_name="cspf-group-computation-mode", rest_name="cspf-group-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='mpls-cspf-grp-comp-mode', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cspf_group_computation_mode must be of a type compatible with mpls-cspf-grp-comp-mode""",
          'defined-type': "brocade-mpls-operational:mpls-cspf-grp-comp-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'mpls-cspf-grp-comp-mode-default': {'value': 0}, u'mpls-cspf-grp-comp-mode-exclude-groups': {'value': 2}, u'mpls-cspf-grp-comp-mode-max': {'value': 4}, u'mpls-cspf-grp-comp-mode-add-penalty': {'value': 1}, u'mpls-cspf-grp-comp-mode-high-cost': {'value': 3}},), is_leaf=True, yang_name="cspf-group-computation-mode", rest_name="cspf-group-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='mpls-cspf-grp-comp-mode', is_config=False)""",
        })

    self.__cspf_group_computation_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cspf_group_computation_mode(self):
    self.__cspf_group_computation_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'mpls-cspf-grp-comp-mode-default': {'value': 0}, u'mpls-cspf-grp-comp-mode-exclude-groups': {'value': 2}, u'mpls-cspf-grp-comp-mode-max': {'value': 4}, u'mpls-cspf-grp-comp-mode-add-penalty': {'value': 1}, u'mpls-cspf-grp-comp-mode-high-cost': {'value': 3}},), is_leaf=True, yang_name="cspf-group-computation-mode", rest_name="cspf-group-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='mpls-cspf-grp-comp-mode', is_config=False)


  def _get_cspf_comp_mode(self):
    """
    Getter method for cspf_comp_mode, mapped from YANG variable /mpls_state/policy/cspf_comp_mode (uint32)

    YANG Description: CSPF Computation Mode
    """
    return self.__cspf_comp_mode
      
  def _set_cspf_comp_mode(self, v, load=False):
    """
    Setter method for cspf_comp_mode, mapped from YANG variable /mpls_state/policy/cspf_comp_mode (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cspf_comp_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cspf_comp_mode() directly.

    YANG Description: CSPF Computation Mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cspf-comp-mode", rest_name="cspf-comp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cspf_comp_mode must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cspf-comp-mode", rest_name="cspf-comp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__cspf_comp_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cspf_comp_mode(self):
    self.__cspf_comp_mode = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cspf-comp-mode", rest_name="cspf-comp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_cspf_comp_ignore_overload_bit(self):
    """
    Getter method for cspf_comp_ignore_overload_bit, mapped from YANG variable /mpls_state/policy/cspf_comp_ignore_overload_bit (uint8)

    YANG Description: CSPF Computation Ignore Overload Bit
    """
    return self.__cspf_comp_ignore_overload_bit
      
  def _set_cspf_comp_ignore_overload_bit(self, v, load=False):
    """
    Setter method for cspf_comp_ignore_overload_bit, mapped from YANG variable /mpls_state/policy/cspf_comp_ignore_overload_bit (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cspf_comp_ignore_overload_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cspf_comp_ignore_overload_bit() directly.

    YANG Description: CSPF Computation Ignore Overload Bit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cspf-comp-ignore-overload-bit", rest_name="cspf-comp-ignore-overload-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cspf_comp_ignore_overload_bit must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cspf-comp-ignore-overload-bit", rest_name="cspf-comp-ignore-overload-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__cspf_comp_ignore_overload_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cspf_comp_ignore_overload_bit(self):
    self.__cspf_comp_ignore_overload_bit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cspf-comp-ignore-overload-bit", rest_name="cspf-comp-ignore-overload-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_implicit_commit_value(self):
    """
    Getter method for implicit_commit_value, mapped from YANG variable /mpls_state/policy/implicit_commit_value (uint32)

    YANG Description: MPLS Implicit Commit value
    """
    return self.__implicit_commit_value
      
  def _set_implicit_commit_value(self, v, load=False):
    """
    Setter method for implicit_commit_value, mapped from YANG variable /mpls_state/policy/implicit_commit_value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_implicit_commit_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_implicit_commit_value() directly.

    YANG Description: MPLS Implicit Commit value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="implicit-commit-value", rest_name="implicit-commit-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """implicit_commit_value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="implicit-commit-value", rest_name="implicit-commit-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__implicit_commit_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_implicit_commit_value(self):
    self.__implicit_commit_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="implicit-commit-value", rest_name="implicit-commit-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_qos_ttl_mode(self):
    """
    Getter method for qos_ttl_mode, mapped from YANG variable /mpls_state/policy/qos_ttl_mode (qos-ttl-mode)

    YANG Description: MPLS Qos TTL Mode
    """
    return self.__qos_ttl_mode
      
  def _set_qos_ttl_mode(self, v, load=False):
    """
    Setter method for qos_ttl_mode, mapped from YANG variable /mpls_state/policy/qos_ttl_mode (qos-ttl-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos_ttl_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos_ttl_mode() directly.

    YANG Description: MPLS Qos TTL Mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'qt-uniform': {'value': 0}, u'qt-pipe': {'value': 1}},), is_leaf=True, yang_name="qos-ttl-mode", rest_name="qos-ttl-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='qos-ttl-mode', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos_ttl_mode must be of a type compatible with qos-ttl-mode""",
          'defined-type': "brocade-mpls-operational:qos-ttl-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'qt-uniform': {'value': 0}, u'qt-pipe': {'value': 1}},), is_leaf=True, yang_name="qos-ttl-mode", rest_name="qos-ttl-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='qos-ttl-mode', is_config=False)""",
        })

    self.__qos_ttl_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos_ttl_mode(self):
    self.__qos_ttl_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'qt-uniform': {'value': 0}, u'qt-pipe': {'value': 1}},), is_leaf=True, yang_name="qos-ttl-mode", rest_name="qos-ttl-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='qos-ttl-mode', is_config=False)


  def _get_rtm_route_filter_enabled(self):
    """
    Getter method for rtm_route_filter_enabled, mapped from YANG variable /mpls_state/policy/rtm_route_filter_enabled (boolean)

    YANG Description: RTM route filter enabled
    """
    return self.__rtm_route_filter_enabled
      
  def _set_rtm_route_filter_enabled(self, v, load=False):
    """
    Setter method for rtm_route_filter_enabled, mapped from YANG variable /mpls_state/policy/rtm_route_filter_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rtm_route_filter_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rtm_route_filter_enabled() directly.

    YANG Description: RTM route filter enabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="rtm-route-filter-enabled", rest_name="rtm-route-filter-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rtm_route_filter_enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rtm-route-filter-enabled", rest_name="rtm-route-filter-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__rtm_route_filter_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rtm_route_filter_enabled(self):
    self.__rtm_route_filter_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rtm-route-filter-enabled", rest_name="rtm-route-filter-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_rtm_route_filter_all_ibgp_enabled(self):
    """
    Getter method for rtm_route_filter_all_ibgp_enabled, mapped from YANG variable /mpls_state/policy/rtm_route_filter_all_ibgp_enabled (boolean)

    YANG Description: RTM route filter all IBGP enabled
    """
    return self.__rtm_route_filter_all_ibgp_enabled
      
  def _set_rtm_route_filter_all_ibgp_enabled(self, v, load=False):
    """
    Setter method for rtm_route_filter_all_ibgp_enabled, mapped from YANG variable /mpls_state/policy/rtm_route_filter_all_ibgp_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rtm_route_filter_all_ibgp_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rtm_route_filter_all_ibgp_enabled() directly.

    YANG Description: RTM route filter all IBGP enabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="rtm-route-filter-all-ibgp-enabled", rest_name="rtm-route-filter-all-ibgp-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rtm_route_filter_all_ibgp_enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rtm-route-filter-all-ibgp-enabled", rest_name="rtm-route-filter-all-ibgp-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__rtm_route_filter_all_ibgp_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rtm_route_filter_all_ibgp_enabled(self):
    self.__rtm_route_filter_all_ibgp_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rtm-route-filter-all-ibgp-enabled", rest_name="rtm-route-filter-all-ibgp-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_ingress_tnnl_actg(self):
    """
    Getter method for ingress_tnnl_actg, mapped from YANG variable /mpls_state/policy/ingress_tnnl_actg (uint8)

    YANG Description: MPLS Ingress Tunnel Accounting
    """
    return self.__ingress_tnnl_actg
      
  def _set_ingress_tnnl_actg(self, v, load=False):
    """
    Setter method for ingress_tnnl_actg, mapped from YANG variable /mpls_state/policy/ingress_tnnl_actg (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ingress_tnnl_actg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ingress_tnnl_actg() directly.

    YANG Description: MPLS Ingress Tunnel Accounting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ingress-tnnl-actg", rest_name="ingress-tnnl-actg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ingress_tnnl_actg must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ingress-tnnl-actg", rest_name="ingress-tnnl-actg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__ingress_tnnl_actg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ingress_tnnl_actg(self):
    self.__ingress_tnnl_actg = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ingress-tnnl-actg", rest_name="ingress-tnnl-actg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_transit_session_actg(self):
    """
    Getter method for transit_session_actg, mapped from YANG variable /mpls_state/policy/transit_session_actg (uint8)

    YANG Description: MPLS Transit Session Accounting
    """
    return self.__transit_session_actg
      
  def _set_transit_session_actg(self, v, load=False):
    """
    Setter method for transit_session_actg, mapped from YANG variable /mpls_state/policy/transit_session_actg (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transit_session_actg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transit_session_actg() directly.

    YANG Description: MPLS Transit Session Accounting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="transit-session-actg", rest_name="transit-session-actg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transit_session_actg must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="transit-session-actg", rest_name="transit-session-actg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__transit_session_actg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transit_session_actg(self):
    self.__transit_session_actg = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="transit-session-actg", rest_name="transit-session-actg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_load_interval(self):
    """
    Getter method for load_interval, mapped from YANG variable /mpls_state/policy/load_interval (uint16)

    YANG Description: MPLS Load Interval
    """
    return self.__load_interval
      
  def _set_load_interval(self, v, load=False):
    """
    Setter method for load_interval, mapped from YANG variable /mpls_state/policy/load_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_load_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_load_interval() directly.

    YANG Description: MPLS Load Interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="load-interval", rest_name="load-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """load_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="load-interval", rest_name="load-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)""",
        })

    self.__load_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_load_interval(self):
    self.__load_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="load-interval", rest_name="load-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)


  def _get_te_policy_protocol(self):
    """
    Getter method for te_policy_protocol, mapped from YANG variable /mpls_state/policy/te_policy_protocol (te-protocol)

    YANG Description: MPLS TE Protocol
    """
    return self.__te_policy_protocol
      
  def _set_te_policy_protocol(self, v, load=False):
    """
    Setter method for te_policy_protocol, mapped from YANG variable /mpls_state/policy/te_policy_protocol (te-protocol)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_te_policy_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_te_policy_protocol() directly.

    YANG Description: MPLS TE Protocol
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'mpls-te-none': {'value': 0}, u'mpls-te-ospf': {'value': 1}, u'mpls-te-isis': {'value': 2}},), is_leaf=True, yang_name="te-policy-protocol", rest_name="te-policy-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='te-protocol', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """te_policy_protocol must be of a type compatible with te-protocol""",
          'defined-type': "brocade-mpls-operational:te-protocol",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'mpls-te-none': {'value': 0}, u'mpls-te-ospf': {'value': 1}, u'mpls-te-isis': {'value': 2}},), is_leaf=True, yang_name="te-policy-protocol", rest_name="te-policy-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='te-protocol', is_config=False)""",
        })

    self.__te_policy_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_te_policy_protocol(self):
    self.__te_policy_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'mpls-te-none': {'value': 0}, u'mpls-te-ospf': {'value': 1}, u'mpls-te-isis': {'value': 2}},), is_leaf=True, yang_name="te-policy-protocol", rest_name="te-policy-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='te-protocol', is_config=False)


  def _get_te_policy_flags(self):
    """
    Getter method for te_policy_flags, mapped from YANG variable /mpls_state/policy/te_policy_flags (uint16)

    YANG Description: MPLS TE policy flags
    """
    return self.__te_policy_flags
      
  def _set_te_policy_flags(self, v, load=False):
    """
    Setter method for te_policy_flags, mapped from YANG variable /mpls_state/policy/te_policy_flags (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_te_policy_flags is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_te_policy_flags() directly.

    YANG Description: MPLS TE policy flags
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="te-policy-flags", rest_name="te-policy-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """te_policy_flags must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="te-policy-flags", rest_name="te-policy-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)""",
        })

    self.__te_policy_flags = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_te_policy_flags(self):
    self.__te_policy_flags = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="te-policy-flags", rest_name="te-policy-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)


  def _get_te_policy_area(self):
    """
    Getter method for te_policy_area, mapped from YANG variable /mpls_state/policy/te_policy_area (uint32)

    YANG Description: MPLS TE area
    """
    return self.__te_policy_area
      
  def _set_te_policy_area(self, v, load=False):
    """
    Setter method for te_policy_area, mapped from YANG variable /mpls_state/policy/te_policy_area (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_te_policy_area is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_te_policy_area() directly.

    YANG Description: MPLS TE area
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="te-policy-area", rest_name="te-policy-area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """te_policy_area must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="te-policy-area", rest_name="te-policy-area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__te_policy_area = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_te_policy_area(self):
    self.__te_policy_area = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="te-policy-area", rest_name="te-policy-area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_handle_isis_nbr_down(self):
    """
    Getter method for handle_isis_nbr_down, mapped from YANG variable /mpls_state/policy/handle_isis_nbr_down (uint8)

    YANG Description: MPLS Handle ISIS neighbor down
    """
    return self.__handle_isis_nbr_down
      
  def _set_handle_isis_nbr_down(self, v, load=False):
    """
    Setter method for handle_isis_nbr_down, mapped from YANG variable /mpls_state/policy/handle_isis_nbr_down (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_handle_isis_nbr_down is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_handle_isis_nbr_down() directly.

    YANG Description: MPLS Handle ISIS neighbor down
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="handle-isis-nbr-down", rest_name="handle-isis-nbr-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """handle_isis_nbr_down must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="handle-isis-nbr-down", rest_name="handle-isis-nbr-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__handle_isis_nbr_down = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_handle_isis_nbr_down(self):
    self.__handle_isis_nbr_down = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="handle-isis-nbr-down", rest_name="handle-isis-nbr-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_handle_ospf_nbr_down(self):
    """
    Getter method for handle_ospf_nbr_down, mapped from YANG variable /mpls_state/policy/handle_ospf_nbr_down (uint8)

    YANG Description: MPLS Handle OSPF neighbor down
    """
    return self.__handle_ospf_nbr_down
      
  def _set_handle_ospf_nbr_down(self, v, load=False):
    """
    Setter method for handle_ospf_nbr_down, mapped from YANG variable /mpls_state/policy/handle_ospf_nbr_down (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_handle_ospf_nbr_down is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_handle_ospf_nbr_down() directly.

    YANG Description: MPLS Handle OSPF neighbor down
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="handle-ospf-nbr-down", rest_name="handle-ospf-nbr-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """handle_ospf_nbr_down must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="handle-ospf-nbr-down", rest_name="handle-ospf-nbr-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__handle_ospf_nbr_down = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_handle_ospf_nbr_down(self):
    self.__handle_ospf_nbr_down = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="handle-ospf-nbr-down", rest_name="handle-ospf-nbr-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_max_lsp_retries(self):
    """
    Getter method for max_lsp_retries, mapped from YANG variable /mpls_state/policy/max_lsp_retries (uint16)

    YANG Description: MPLS max lsp retries
    """
    return self.__max_lsp_retries
      
  def _set_max_lsp_retries(self, v, load=False):
    """
    Setter method for max_lsp_retries, mapped from YANG variable /mpls_state/policy/max_lsp_retries (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_lsp_retries is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_lsp_retries() directly.

    YANG Description: MPLS max lsp retries
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-lsp-retries", rest_name="max-lsp-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_lsp_retries must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-lsp-retries", rest_name="max-lsp-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)""",
        })

    self.__max_lsp_retries = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_lsp_retries(self):
    self.__max_lsp_retries = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-lsp-retries", rest_name="max-lsp-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)


  def _get_fast_retry_on(self):
    """
    Getter method for fast_retry_on, mapped from YANG variable /mpls_state/policy/fast_retry_on (uint8)

    YANG Description: MPLS fast retry on
    """
    return self.__fast_retry_on
      
  def _set_fast_retry_on(self, v, load=False):
    """
    Setter method for fast_retry_on, mapped from YANG variable /mpls_state/policy/fast_retry_on (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fast_retry_on is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fast_retry_on() directly.

    YANG Description: MPLS fast retry on
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="fast-retry-on", rest_name="fast-retry-on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fast_retry_on must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="fast-retry-on", rest_name="fast-retry-on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__fast_retry_on = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fast_retry_on(self):
    self.__fast_retry_on = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="fast-retry-on", rest_name="fast-retry-on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_lsp_retry_interval(self):
    """
    Getter method for lsp_retry_interval, mapped from YANG variable /mpls_state/policy/lsp_retry_interval (uint16)

    YANG Description: MPLS lsp retry interval
    """
    return self.__lsp_retry_interval
      
  def _set_lsp_retry_interval(self, v, load=False):
    """
    Setter method for lsp_retry_interval, mapped from YANG variable /mpls_state/policy/lsp_retry_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_retry_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_retry_interval() directly.

    YANG Description: MPLS lsp retry interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="lsp-retry-interval", rest_name="lsp-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_retry_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="lsp-retry-interval", rest_name="lsp-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)""",
        })

    self.__lsp_retry_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_retry_interval(self):
    self.__lsp_retry_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="lsp-retry-interval", rest_name="lsp-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)


  def _get_frr_backup_retry_interval(self):
    """
    Getter method for frr_backup_retry_interval, mapped from YANG variable /mpls_state/policy/frr_backup_retry_interval (uint32)

    YANG Description: MPLS FRR backup retry interval
    """
    return self.__frr_backup_retry_interval
      
  def _set_frr_backup_retry_interval(self, v, load=False):
    """
    Setter method for frr_backup_retry_interval, mapped from YANG variable /mpls_state/policy/frr_backup_retry_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frr_backup_retry_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frr_backup_retry_interval() directly.

    YANG Description: MPLS FRR backup retry interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frr-backup-retry-interval", rest_name="frr-backup-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frr_backup_retry_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frr-backup-retry-interval", rest_name="frr-backup-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__frr_backup_retry_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frr_backup_retry_interval(self):
    self.__frr_backup_retry_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frr-backup-retry-interval", rest_name="frr-backup-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_auto_bandwidth_enabled(self):
    """
    Getter method for auto_bandwidth_enabled, mapped from YANG variable /mpls_state/policy/auto_bandwidth_enabled (uint8)

    YANG Description: MPLS Autobw
    """
    return self.__auto_bandwidth_enabled
      
  def _set_auto_bandwidth_enabled(self, v, load=False):
    """
    Setter method for auto_bandwidth_enabled, mapped from YANG variable /mpls_state/policy/auto_bandwidth_enabled (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_bandwidth_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_bandwidth_enabled() directly.

    YANG Description: MPLS Autobw
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="auto-bandwidth-enabled", rest_name="auto-bandwidth-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_bandwidth_enabled must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="auto-bandwidth-enabled", rest_name="auto-bandwidth-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__auto_bandwidth_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_bandwidth_enabled(self):
    self.__auto_bandwidth_enabled = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="auto-bandwidth-enabled", rest_name="auto-bandwidth-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_autobw_sample_interval(self):
    """
    Getter method for autobw_sample_interval, mapped from YANG variable /mpls_state/policy/autobw_sample_interval (uint32)

    YANG Description: MPLS Autobw sample interval
    """
    return self.__autobw_sample_interval
      
  def _set_autobw_sample_interval(self, v, load=False):
    """
    Setter method for autobw_sample_interval, mapped from YANG variable /mpls_state/policy/autobw_sample_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_autobw_sample_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_autobw_sample_interval() directly.

    YANG Description: MPLS Autobw sample interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="autobw-sample-interval", rest_name="autobw-sample-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """autobw_sample_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="autobw-sample-interval", rest_name="autobw-sample-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__autobw_sample_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_autobw_sample_interval(self):
    self.__autobw_sample_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="autobw-sample-interval", rest_name="autobw-sample-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_autobw_num_sample_record(self):
    """
    Getter method for autobw_num_sample_record, mapped from YANG variable /mpls_state/policy/autobw_num_sample_record (uint32)

    YANG Description: MPLS Autobw num sample record
    """
    return self.__autobw_num_sample_record
      
  def _set_autobw_num_sample_record(self, v, load=False):
    """
    Setter method for autobw_num_sample_record, mapped from YANG variable /mpls_state/policy/autobw_num_sample_record (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_autobw_num_sample_record is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_autobw_num_sample_record() directly.

    YANG Description: MPLS Autobw num sample record
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="autobw-num-sample-record", rest_name="autobw-num-sample-record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """autobw_num_sample_record must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="autobw-num-sample-record", rest_name="autobw-num-sample-record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__autobw_num_sample_record = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_autobw_num_sample_record(self):
    self.__autobw_num_sample_record = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="autobw-num-sample-record", rest_name="autobw-num-sample-record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_soft_preempt_cleanup_timer(self):
    """
    Getter method for soft_preempt_cleanup_timer, mapped from YANG variable /mpls_state/policy/soft_preempt_cleanup_timer (uint16)

    YANG Description: MPLS Soft Preempt cleanup timer
    """
    return self.__soft_preempt_cleanup_timer
      
  def _set_soft_preempt_cleanup_timer(self, v, load=False):
    """
    Setter method for soft_preempt_cleanup_timer, mapped from YANG variable /mpls_state/policy/soft_preempt_cleanup_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_soft_preempt_cleanup_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_soft_preempt_cleanup_timer() directly.

    YANG Description: MPLS Soft Preempt cleanup timer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="soft-preempt-cleanup-timer", rest_name="soft-preempt-cleanup-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """soft_preempt_cleanup_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="soft-preempt-cleanup-timer", rest_name="soft-preempt-cleanup-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)""",
        })

    self.__soft_preempt_cleanup_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_soft_preempt_cleanup_timer(self):
    self.__soft_preempt_cleanup_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="soft-preempt-cleanup-timer", rest_name="soft-preempt-cleanup-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)


  def _get_rsvp_periodic_flooding_timer(self):
    """
    Getter method for rsvp_periodic_flooding_timer, mapped from YANG variable /mpls_state/policy/rsvp_periodic_flooding_timer (uint16)

    YANG Description: MPLS RSVP periodic flooding timer
    """
    return self.__rsvp_periodic_flooding_timer
      
  def _set_rsvp_periodic_flooding_timer(self, v, load=False):
    """
    Setter method for rsvp_periodic_flooding_timer, mapped from YANG variable /mpls_state/policy/rsvp_periodic_flooding_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rsvp_periodic_flooding_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rsvp_periodic_flooding_timer() directly.

    YANG Description: MPLS RSVP periodic flooding timer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rsvp-periodic-flooding-timer", rest_name="rsvp-periodic-flooding-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rsvp_periodic_flooding_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rsvp-periodic-flooding-timer", rest_name="rsvp-periodic-flooding-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)""",
        })

    self.__rsvp_periodic_flooding_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rsvp_periodic_flooding_timer(self):
    self.__rsvp_periodic_flooding_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rsvp-periodic-flooding-timer", rest_name="rsvp-periodic-flooding-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)


  def _get_admin_groups(self):
    """
    Getter method for admin_groups, mapped from YANG variable /mpls_state/policy/admin_groups (list)

    YANG Description: MPLS Admin Group Entry
    """
    return self.__admin_groups
      
  def _set_admin_groups(self, v, load=False):
    """
    Setter method for admin_groups, mapped from YANG variable /mpls_state/policy/admin_groups (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_groups() directly.

    YANG Description: MPLS Admin Group Entry
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",admin_groups.admin_groups, yang_name="admin-groups", rest_name="admin-groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'callpoint': u'mpls-admin-group', u'cli-suppress-show-path': None}}), is_container='list', yang_name="admin-groups", rest_name="admin-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-admin-group', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_groups must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",admin_groups.admin_groups, yang_name="admin-groups", rest_name="admin-groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'callpoint': u'mpls-admin-group', u'cli-suppress-show-path': None}}), is_container='list', yang_name="admin-groups", rest_name="admin-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-admin-group', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__admin_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_groups(self):
    self.__admin_groups = YANGDynClass(base=YANGListType("name",admin_groups.admin_groups, yang_name="admin-groups", rest_name="admin-groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions={u'tailf-common': {u'callpoint': u'mpls-admin-group', u'cli-suppress-show-path': None}}), is_container='list', yang_name="admin-groups", rest_name="admin-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-admin-group', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)


  def _get_rsvp_flooding_thresholds(self):
    """
    Getter method for rsvp_flooding_thresholds, mapped from YANG variable /mpls_state/policy/rsvp_flooding_thresholds (list)

    YANG Description: RSVP Flooding Threshold
    """
    return self.__rsvp_flooding_thresholds
      
  def _set_rsvp_flooding_thresholds(self, v, load=False):
    """
    Setter method for rsvp_flooding_thresholds, mapped from YANG variable /mpls_state/policy/rsvp_flooding_thresholds (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rsvp_flooding_thresholds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rsvp_flooding_thresholds() directly.

    YANG Description: RSVP Flooding Threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("threshold_type",rsvp_flooding_thresholds.rsvp_flooding_thresholds, yang_name="rsvp-flooding-thresholds", rest_name="rsvp-flooding-thresholds", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='threshold-type', extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-flooding-thresholds', u'cli-suppress-show-path': None}}), is_container='list', yang_name="rsvp-flooding-thresholds", rest_name="rsvp-flooding-thresholds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-flooding-thresholds', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rsvp_flooding_thresholds must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("threshold_type",rsvp_flooding_thresholds.rsvp_flooding_thresholds, yang_name="rsvp-flooding-thresholds", rest_name="rsvp-flooding-thresholds", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='threshold-type', extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-flooding-thresholds', u'cli-suppress-show-path': None}}), is_container='list', yang_name="rsvp-flooding-thresholds", rest_name="rsvp-flooding-thresholds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-flooding-thresholds', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__rsvp_flooding_thresholds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rsvp_flooding_thresholds(self):
    self.__rsvp_flooding_thresholds = YANGDynClass(base=YANGListType("threshold_type",rsvp_flooding_thresholds.rsvp_flooding_thresholds, yang_name="rsvp-flooding-thresholds", rest_name="rsvp-flooding-thresholds", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='threshold-type', extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-flooding-thresholds', u'cli-suppress-show-path': None}}), is_container='list', yang_name="rsvp-flooding-thresholds", rest_name="rsvp-flooding-thresholds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-flooding-thresholds', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)

  cspf_intf = __builtin__.property(_get_cspf_intf)
  cspf_group_computation_mode = __builtin__.property(_get_cspf_group_computation_mode)
  cspf_comp_mode = __builtin__.property(_get_cspf_comp_mode)
  cspf_comp_ignore_overload_bit = __builtin__.property(_get_cspf_comp_ignore_overload_bit)
  implicit_commit_value = __builtin__.property(_get_implicit_commit_value)
  qos_ttl_mode = __builtin__.property(_get_qos_ttl_mode)
  rtm_route_filter_enabled = __builtin__.property(_get_rtm_route_filter_enabled)
  rtm_route_filter_all_ibgp_enabled = __builtin__.property(_get_rtm_route_filter_all_ibgp_enabled)
  ingress_tnnl_actg = __builtin__.property(_get_ingress_tnnl_actg)
  transit_session_actg = __builtin__.property(_get_transit_session_actg)
  load_interval = __builtin__.property(_get_load_interval)
  te_policy_protocol = __builtin__.property(_get_te_policy_protocol)
  te_policy_flags = __builtin__.property(_get_te_policy_flags)
  te_policy_area = __builtin__.property(_get_te_policy_area)
  handle_isis_nbr_down = __builtin__.property(_get_handle_isis_nbr_down)
  handle_ospf_nbr_down = __builtin__.property(_get_handle_ospf_nbr_down)
  max_lsp_retries = __builtin__.property(_get_max_lsp_retries)
  fast_retry_on = __builtin__.property(_get_fast_retry_on)
  lsp_retry_interval = __builtin__.property(_get_lsp_retry_interval)
  frr_backup_retry_interval = __builtin__.property(_get_frr_backup_retry_interval)
  auto_bandwidth_enabled = __builtin__.property(_get_auto_bandwidth_enabled)
  autobw_sample_interval = __builtin__.property(_get_autobw_sample_interval)
  autobw_num_sample_record = __builtin__.property(_get_autobw_num_sample_record)
  soft_preempt_cleanup_timer = __builtin__.property(_get_soft_preempt_cleanup_timer)
  rsvp_periodic_flooding_timer = __builtin__.property(_get_rsvp_periodic_flooding_timer)
  admin_groups = __builtin__.property(_get_admin_groups)
  rsvp_flooding_thresholds = __builtin__.property(_get_rsvp_flooding_thresholds)


  _pyangbind_elements = {'cspf_intf': cspf_intf, 'cspf_group_computation_mode': cspf_group_computation_mode, 'cspf_comp_mode': cspf_comp_mode, 'cspf_comp_ignore_overload_bit': cspf_comp_ignore_overload_bit, 'implicit_commit_value': implicit_commit_value, 'qos_ttl_mode': qos_ttl_mode, 'rtm_route_filter_enabled': rtm_route_filter_enabled, 'rtm_route_filter_all_ibgp_enabled': rtm_route_filter_all_ibgp_enabled, 'ingress_tnnl_actg': ingress_tnnl_actg, 'transit_session_actg': transit_session_actg, 'load_interval': load_interval, 'te_policy_protocol': te_policy_protocol, 'te_policy_flags': te_policy_flags, 'te_policy_area': te_policy_area, 'handle_isis_nbr_down': handle_isis_nbr_down, 'handle_ospf_nbr_down': handle_ospf_nbr_down, 'max_lsp_retries': max_lsp_retries, 'fast_retry_on': fast_retry_on, 'lsp_retry_interval': lsp_retry_interval, 'frr_backup_retry_interval': frr_backup_retry_interval, 'auto_bandwidth_enabled': auto_bandwidth_enabled, 'autobw_sample_interval': autobw_sample_interval, 'autobw_num_sample_record': autobw_num_sample_record, 'soft_preempt_cleanup_timer': soft_preempt_cleanup_timer, 'rsvp_periodic_flooding_timer': rsvp_periodic_flooding_timer, 'admin_groups': admin_groups, 'rsvp_flooding_thresholds': rsvp_flooding_thresholds, }


