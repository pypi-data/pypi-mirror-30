
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class auto_bandwidth(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls-operational - based on the path /mpls-state/lsp/auto-bandwidth. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Auto Bandwidth Running Information
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__adjustment_interval','__adjustment_threshold','__maximum_bandwidth','__minimum_bandwidth','__overflow_limit','__underflow_limit','__mode','__sample_recording','__is_adjustment_interval_inherited','__is_adjustment_threshold_inherited','__is_maximum_bandwidth_inherited','__is_minimum_bandwidth_inherited','__is_overflow_limit_inherited','__is_underflow_limit_inherited','__is_mode_inherited','__is_sample_recording_inherited','__working_status','__num_samples_collected','__last_sample_traffic_rate','__maximum_of_samples_collected','__maximum_of_underflow_samples','__overflow_count','__underflow_count','__time_to_adjustment','__adjustment_status','__previous_bandwidth','__new_bandwidth','__adjustment_reason','__time_of_last_adjustment',)

  _yang_name = 'auto-bandwidth'
  _rest_name = 'auto-bandwidth'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__is_underflow_limit_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-underflow-limit-inherited", rest_name="is-underflow-limit-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__previous_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="previous-bandwidth", rest_name="previous-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__is_maximum_bandwidth_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-maximum-bandwidth-inherited", rest_name="is-maximum-bandwidth-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__maximum_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-bandwidth", rest_name="maximum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__working_status = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="working-status", rest_name="working-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__is_overflow_limit_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-overflow-limit-inherited", rest_name="is-overflow-limit-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__is_sample_recording_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-sample-recording-inherited", rest_name="is-sample-recording-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__is_adjustment_interval_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-adjustment-interval-inherited", rest_name="is-adjustment-interval-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__overflow_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="overflow-count", rest_name="overflow-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__time_of_last_adjustment = YANGDynClass(base=unicode, is_leaf=True, yang_name="time-of-last-adjustment", rest_name="time-of-last-adjustment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__is_minimum_bandwidth_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-minimum-bandwidth-inherited", rest_name="is-minimum-bandwidth-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__maximum_of_underflow_samples = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-of-underflow-samples", rest_name="maximum-of-underflow-samples", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__num_samples_collected = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-samples-collected", rest_name="num-samples-collected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__time_to_adjustment = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="time-to-adjustment", rest_name="time-to-adjustment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__underflow_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="underflow-count", rest_name="underflow-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__is_adjustment_threshold_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-adjustment-threshold-inherited", rest_name="is-adjustment-threshold-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__adjustment_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-threshold", rest_name="adjustment-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__is_mode_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-mode-inherited", rest_name="is-mode-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__minimum_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minimum-bandwidth", rest_name="minimum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__sample_recording = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sample-recording", rest_name="sample-recording", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__underflow_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="underflow-limit", rest_name="underflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__last_sample_traffic_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-sample-traffic-rate", rest_name="last-sample-traffic-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__adjustment_reason = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="adjustment-reason", rest_name="adjustment-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__maximum_of_samples_collected = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-of-samples-collected", rest_name="maximum-of-samples-collected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__overflow_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="overflow-limit", rest_name="overflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'monitor-and-signal': {'value': 0}, u'monitor-only': {'value': 1}},), is_leaf=True, yang_name="mode", rest_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='autobw-mode', is_config=False)
    self.__adjustment_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-interval", rest_name="adjustment-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__adjustment_status = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="adjustment-status", rest_name="adjustment-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__new_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="new-bandwidth", rest_name="new-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mpls-state', u'lsp', u'auto-bandwidth']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'mpls-state', u'lsp', u'auto-bandwidth']

  def _get_adjustment_interval(self):
    """
    Getter method for adjustment_interval, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/adjustment_interval (uint32)

    YANG Description: Periodic Interval at which adjustment is done 
    """
    return self.__adjustment_interval
      
  def _set_adjustment_interval(self, v, load=False):
    """
    Setter method for adjustment_interval, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/adjustment_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjustment_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjustment_interval() directly.

    YANG Description: Periodic Interval at which adjustment is done 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-interval", rest_name="adjustment-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjustment_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-interval", rest_name="adjustment-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__adjustment_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjustment_interval(self):
    self.__adjustment_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-interval", rest_name="adjustment-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_adjustment_threshold(self):
    """
    Getter method for adjustment_threshold, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/adjustment_threshold (uint32)

    YANG Description: mpls_adjustmentThreshold
    """
    return self.__adjustment_threshold
      
  def _set_adjustment_threshold(self, v, load=False):
    """
    Setter method for adjustment_threshold, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/adjustment_threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjustment_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjustment_threshold() directly.

    YANG Description: mpls_adjustmentThreshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-threshold", rest_name="adjustment-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjustment_threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-threshold", rest_name="adjustment-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__adjustment_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjustment_threshold(self):
    self.__adjustment_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-threshold", rest_name="adjustment-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_maximum_bandwidth(self):
    """
    Getter method for maximum_bandwidth, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/maximum_bandwidth (uint32)

    YANG Description: Maximum bandwidth value
    """
    return self.__maximum_bandwidth
      
  def _set_maximum_bandwidth(self, v, load=False):
    """
    Setter method for maximum_bandwidth, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/maximum_bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_bandwidth() directly.

    YANG Description: Maximum bandwidth value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-bandwidth", rest_name="maximum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-bandwidth", rest_name="maximum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__maximum_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_bandwidth(self):
    self.__maximum_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-bandwidth", rest_name="maximum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_minimum_bandwidth(self):
    """
    Getter method for minimum_bandwidth, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/minimum_bandwidth (uint32)

    YANG Description: Minimum bandiwdth value
    """
    return self.__minimum_bandwidth
      
  def _set_minimum_bandwidth(self, v, load=False):
    """
    Setter method for minimum_bandwidth, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/minimum_bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minimum_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minimum_bandwidth() directly.

    YANG Description: Minimum bandiwdth value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minimum-bandwidth", rest_name="minimum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minimum_bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minimum-bandwidth", rest_name="minimum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__minimum_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minimum_bandwidth(self):
    self.__minimum_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minimum-bandwidth", rest_name="minimum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_overflow_limit(self):
    """
    Getter method for overflow_limit, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/overflow_limit (uint32)

    YANG Description: Minimum number of overflow to trigger adjustment
    """
    return self.__overflow_limit
      
  def _set_overflow_limit(self, v, load=False):
    """
    Setter method for overflow_limit, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/overflow_limit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overflow_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overflow_limit() directly.

    YANG Description: Minimum number of overflow to trigger adjustment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="overflow-limit", rest_name="overflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overflow_limit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="overflow-limit", rest_name="overflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__overflow_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overflow_limit(self):
    self.__overflow_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="overflow-limit", rest_name="overflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_underflow_limit(self):
    """
    Getter method for underflow_limit, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/underflow_limit (uint32)

    YANG Description: Minimum number of underflow to trigger adjustment
    """
    return self.__underflow_limit
      
  def _set_underflow_limit(self, v, load=False):
    """
    Setter method for underflow_limit, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/underflow_limit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_underflow_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_underflow_limit() directly.

    YANG Description: Minimum number of underflow to trigger adjustment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="underflow-limit", rest_name="underflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """underflow_limit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="underflow-limit", rest_name="underflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__underflow_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_underflow_limit(self):
    self.__underflow_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="underflow-limit", rest_name="underflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/mode (autobw-mode)

    YANG Description: Monitor only or Monitor and Signal
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/mode (autobw-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: Monitor only or Monitor and Signal
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'monitor-and-signal': {'value': 0}, u'monitor-only': {'value': 1}},), is_leaf=True, yang_name="mode", rest_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='autobw-mode', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with autobw-mode""",
          'defined-type': "brocade-mpls-operational:autobw-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'monitor-and-signal': {'value': 0}, u'monitor-only': {'value': 1}},), is_leaf=True, yang_name="mode", rest_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='autobw-mode', is_config=False)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'monitor-and-signal': {'value': 0}, u'monitor-only': {'value': 1}},), is_leaf=True, yang_name="mode", rest_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='autobw-mode', is_config=False)


  def _get_sample_recording(self):
    """
    Getter method for sample_recording, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/sample_recording (boolean)

    YANG Description: Enable logging history of rate samples
    """
    return self.__sample_recording
      
  def _set_sample_recording(self, v, load=False):
    """
    Setter method for sample_recording, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/sample_recording (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sample_recording is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sample_recording() directly.

    YANG Description: Enable logging history of rate samples
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="sample-recording", rest_name="sample-recording", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sample_recording must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sample-recording", rest_name="sample-recording", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__sample_recording = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sample_recording(self):
    self.__sample_recording = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sample-recording", rest_name="sample-recording", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_is_adjustment_interval_inherited(self):
    """
    Getter method for is_adjustment_interval_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_adjustment_interval_inherited (boolean)

    YANG Description: Is parameter inherited from template
    """
    return self.__is_adjustment_interval_inherited
      
  def _set_is_adjustment_interval_inherited(self, v, load=False):
    """
    Setter method for is_adjustment_interval_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_adjustment_interval_inherited (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_adjustment_interval_inherited is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_adjustment_interval_inherited() directly.

    YANG Description: Is parameter inherited from template
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-adjustment-interval-inherited", rest_name="is-adjustment-interval-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_adjustment_interval_inherited must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-adjustment-interval-inherited", rest_name="is-adjustment-interval-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_adjustment_interval_inherited = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_adjustment_interval_inherited(self):
    self.__is_adjustment_interval_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-adjustment-interval-inherited", rest_name="is-adjustment-interval-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_is_adjustment_threshold_inherited(self):
    """
    Getter method for is_adjustment_threshold_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_adjustment_threshold_inherited (boolean)

    YANG Description: Is parameter inherited from template
    """
    return self.__is_adjustment_threshold_inherited
      
  def _set_is_adjustment_threshold_inherited(self, v, load=False):
    """
    Setter method for is_adjustment_threshold_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_adjustment_threshold_inherited (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_adjustment_threshold_inherited is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_adjustment_threshold_inherited() directly.

    YANG Description: Is parameter inherited from template
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-adjustment-threshold-inherited", rest_name="is-adjustment-threshold-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_adjustment_threshold_inherited must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-adjustment-threshold-inherited", rest_name="is-adjustment-threshold-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_adjustment_threshold_inherited = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_adjustment_threshold_inherited(self):
    self.__is_adjustment_threshold_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-adjustment-threshold-inherited", rest_name="is-adjustment-threshold-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_is_maximum_bandwidth_inherited(self):
    """
    Getter method for is_maximum_bandwidth_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_maximum_bandwidth_inherited (boolean)

    YANG Description: Is parameter inherited from template
    """
    return self.__is_maximum_bandwidth_inherited
      
  def _set_is_maximum_bandwidth_inherited(self, v, load=False):
    """
    Setter method for is_maximum_bandwidth_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_maximum_bandwidth_inherited (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_maximum_bandwidth_inherited is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_maximum_bandwidth_inherited() directly.

    YANG Description: Is parameter inherited from template
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-maximum-bandwidth-inherited", rest_name="is-maximum-bandwidth-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_maximum_bandwidth_inherited must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-maximum-bandwidth-inherited", rest_name="is-maximum-bandwidth-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_maximum_bandwidth_inherited = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_maximum_bandwidth_inherited(self):
    self.__is_maximum_bandwidth_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-maximum-bandwidth-inherited", rest_name="is-maximum-bandwidth-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_is_minimum_bandwidth_inherited(self):
    """
    Getter method for is_minimum_bandwidth_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_minimum_bandwidth_inherited (boolean)

    YANG Description: Is parameter inherited from template
    """
    return self.__is_minimum_bandwidth_inherited
      
  def _set_is_minimum_bandwidth_inherited(self, v, load=False):
    """
    Setter method for is_minimum_bandwidth_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_minimum_bandwidth_inherited (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_minimum_bandwidth_inherited is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_minimum_bandwidth_inherited() directly.

    YANG Description: Is parameter inherited from template
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-minimum-bandwidth-inherited", rest_name="is-minimum-bandwidth-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_minimum_bandwidth_inherited must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-minimum-bandwidth-inherited", rest_name="is-minimum-bandwidth-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_minimum_bandwidth_inherited = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_minimum_bandwidth_inherited(self):
    self.__is_minimum_bandwidth_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-minimum-bandwidth-inherited", rest_name="is-minimum-bandwidth-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_is_overflow_limit_inherited(self):
    """
    Getter method for is_overflow_limit_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_overflow_limit_inherited (boolean)

    YANG Description: Is parameter inherited from template
    """
    return self.__is_overflow_limit_inherited
      
  def _set_is_overflow_limit_inherited(self, v, load=False):
    """
    Setter method for is_overflow_limit_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_overflow_limit_inherited (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_overflow_limit_inherited is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_overflow_limit_inherited() directly.

    YANG Description: Is parameter inherited from template
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-overflow-limit-inherited", rest_name="is-overflow-limit-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_overflow_limit_inherited must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-overflow-limit-inherited", rest_name="is-overflow-limit-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_overflow_limit_inherited = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_overflow_limit_inherited(self):
    self.__is_overflow_limit_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-overflow-limit-inherited", rest_name="is-overflow-limit-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_is_underflow_limit_inherited(self):
    """
    Getter method for is_underflow_limit_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_underflow_limit_inherited (boolean)

    YANG Description: Is parameter inherited from template
    """
    return self.__is_underflow_limit_inherited
      
  def _set_is_underflow_limit_inherited(self, v, load=False):
    """
    Setter method for is_underflow_limit_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_underflow_limit_inherited (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_underflow_limit_inherited is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_underflow_limit_inherited() directly.

    YANG Description: Is parameter inherited from template
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-underflow-limit-inherited", rest_name="is-underflow-limit-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_underflow_limit_inherited must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-underflow-limit-inherited", rest_name="is-underflow-limit-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_underflow_limit_inherited = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_underflow_limit_inherited(self):
    self.__is_underflow_limit_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-underflow-limit-inherited", rest_name="is-underflow-limit-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_is_mode_inherited(self):
    """
    Getter method for is_mode_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_mode_inherited (boolean)

    YANG Description: Is parameter inherited from template
    """
    return self.__is_mode_inherited
      
  def _set_is_mode_inherited(self, v, load=False):
    """
    Setter method for is_mode_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_mode_inherited (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_mode_inherited is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_mode_inherited() directly.

    YANG Description: Is parameter inherited from template
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-mode-inherited", rest_name="is-mode-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_mode_inherited must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-mode-inherited", rest_name="is-mode-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_mode_inherited = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_mode_inherited(self):
    self.__is_mode_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-mode-inherited", rest_name="is-mode-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_is_sample_recording_inherited(self):
    """
    Getter method for is_sample_recording_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_sample_recording_inherited (boolean)

    YANG Description: EIs parameter inherited from template
    """
    return self.__is_sample_recording_inherited
      
  def _set_is_sample_recording_inherited(self, v, load=False):
    """
    Setter method for is_sample_recording_inherited, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/is_sample_recording_inherited (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_sample_recording_inherited is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_sample_recording_inherited() directly.

    YANG Description: EIs parameter inherited from template
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-sample-recording-inherited", rest_name="is-sample-recording-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_sample_recording_inherited must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-sample-recording-inherited", rest_name="is-sample-recording-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_sample_recording_inherited = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_sample_recording_inherited(self):
    self.__is_sample_recording_inherited = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-sample-recording-inherited", rest_name="is-sample-recording-inherited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_working_status(self):
    """
    Getter method for working_status, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/working_status (uint8)

    YANG Description: Auto Bandwidth working status
    """
    return self.__working_status
      
  def _set_working_status(self, v, load=False):
    """
    Setter method for working_status, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/working_status (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_working_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_working_status() directly.

    YANG Description: Auto Bandwidth working status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="working-status", rest_name="working-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """working_status must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="working-status", rest_name="working-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__working_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_working_status(self):
    self.__working_status = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="working-status", rest_name="working-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_num_samples_collected(self):
    """
    Getter method for num_samples_collected, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/num_samples_collected (uint32)

    YANG Description: Number of samples collected
    """
    return self.__num_samples_collected
      
  def _set_num_samples_collected(self, v, load=False):
    """
    Setter method for num_samples_collected, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/num_samples_collected (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_samples_collected is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_samples_collected() directly.

    YANG Description: Number of samples collected
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-samples-collected", rest_name="num-samples-collected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_samples_collected must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-samples-collected", rest_name="num-samples-collected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_samples_collected = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_samples_collected(self):
    self.__num_samples_collected = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-samples-collected", rest_name="num-samples-collected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_last_sample_traffic_rate(self):
    """
    Getter method for last_sample_traffic_rate, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/last_sample_traffic_rate (uint32)

    YANG Description: Last traffic rate sample
    """
    return self.__last_sample_traffic_rate
      
  def _set_last_sample_traffic_rate(self, v, load=False):
    """
    Setter method for last_sample_traffic_rate, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/last_sample_traffic_rate (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_sample_traffic_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_sample_traffic_rate() directly.

    YANG Description: Last traffic rate sample
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-sample-traffic-rate", rest_name="last-sample-traffic-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_sample_traffic_rate must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-sample-traffic-rate", rest_name="last-sample-traffic-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__last_sample_traffic_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_sample_traffic_rate(self):
    self.__last_sample_traffic_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-sample-traffic-rate", rest_name="last-sample-traffic-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_maximum_of_samples_collected(self):
    """
    Getter method for maximum_of_samples_collected, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/maximum_of_samples_collected (uint32)

    YANG Description: Maximum sample in the adjustment interval
    """
    return self.__maximum_of_samples_collected
      
  def _set_maximum_of_samples_collected(self, v, load=False):
    """
    Setter method for maximum_of_samples_collected, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/maximum_of_samples_collected (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_of_samples_collected is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_of_samples_collected() directly.

    YANG Description: Maximum sample in the adjustment interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-of-samples-collected", rest_name="maximum-of-samples-collected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_of_samples_collected must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-of-samples-collected", rest_name="maximum-of-samples-collected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__maximum_of_samples_collected = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_of_samples_collected(self):
    self.__maximum_of_samples_collected = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-of-samples-collected", rest_name="maximum-of-samples-collected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_maximum_of_underflow_samples(self):
    """
    Getter method for maximum_of_underflow_samples, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/maximum_of_underflow_samples (uint32)

    YANG Description: Maximum among the underflow samples
    """
    return self.__maximum_of_underflow_samples
      
  def _set_maximum_of_underflow_samples(self, v, load=False):
    """
    Setter method for maximum_of_underflow_samples, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/maximum_of_underflow_samples (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_of_underflow_samples is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_of_underflow_samples() directly.

    YANG Description: Maximum among the underflow samples
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-of-underflow-samples", rest_name="maximum-of-underflow-samples", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_of_underflow_samples must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-of-underflow-samples", rest_name="maximum-of-underflow-samples", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__maximum_of_underflow_samples = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_of_underflow_samples(self):
    self.__maximum_of_underflow_samples = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-of-underflow-samples", rest_name="maximum-of-underflow-samples", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_overflow_count(self):
    """
    Getter method for overflow_count, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/overflow_count (uint32)

    YANG Description: Number of consecutive samples overflown
    """
    return self.__overflow_count
      
  def _set_overflow_count(self, v, load=False):
    """
    Setter method for overflow_count, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/overflow_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overflow_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overflow_count() directly.

    YANG Description: Number of consecutive samples overflown
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="overflow-count", rest_name="overflow-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overflow_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="overflow-count", rest_name="overflow-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__overflow_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overflow_count(self):
    self.__overflow_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="overflow-count", rest_name="overflow-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_underflow_count(self):
    """
    Getter method for underflow_count, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/underflow_count (uint32)

    YANG Description: Number of consecutive samples underflown
    """
    return self.__underflow_count
      
  def _set_underflow_count(self, v, load=False):
    """
    Setter method for underflow_count, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/underflow_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_underflow_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_underflow_count() directly.

    YANG Description: Number of consecutive samples underflown
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="underflow-count", rest_name="underflow-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """underflow_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="underflow-count", rest_name="underflow-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__underflow_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_underflow_count(self):
    self.__underflow_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="underflow-count", rest_name="underflow-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_time_to_adjustment(self):
    """
    Getter method for time_to_adjustment, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/time_to_adjustment (uint32)

    YANG Description: Remaining seconds for adjustment-interval expiry
    """
    return self.__time_to_adjustment
      
  def _set_time_to_adjustment(self, v, load=False):
    """
    Setter method for time_to_adjustment, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/time_to_adjustment (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_to_adjustment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_to_adjustment() directly.

    YANG Description: Remaining seconds for adjustment-interval expiry
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="time-to-adjustment", rest_name="time-to-adjustment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_to_adjustment must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="time-to-adjustment", rest_name="time-to-adjustment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__time_to_adjustment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_to_adjustment(self):
    self.__time_to_adjustment = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="time-to-adjustment", rest_name="time-to-adjustment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_adjustment_status(self):
    """
    Getter method for adjustment_status, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/adjustment_status (uint8)

    YANG Description: Last adjustment status
    """
    return self.__adjustment_status
      
  def _set_adjustment_status(self, v, load=False):
    """
    Setter method for adjustment_status, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/adjustment_status (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjustment_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjustment_status() directly.

    YANG Description: Last adjustment status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="adjustment-status", rest_name="adjustment-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjustment_status must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="adjustment-status", rest_name="adjustment-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__adjustment_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjustment_status(self):
    self.__adjustment_status = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="adjustment-status", rest_name="adjustment-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_previous_bandwidth(self):
    """
    Getter method for previous_bandwidth, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/previous_bandwidth (uint32)

    YANG Description: Previous LSP Bandwidth
    """
    return self.__previous_bandwidth
      
  def _set_previous_bandwidth(self, v, load=False):
    """
    Setter method for previous_bandwidth, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/previous_bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_previous_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_previous_bandwidth() directly.

    YANG Description: Previous LSP Bandwidth
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="previous-bandwidth", rest_name="previous-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """previous_bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="previous-bandwidth", rest_name="previous-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__previous_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_previous_bandwidth(self):
    self.__previous_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="previous-bandwidth", rest_name="previous-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_new_bandwidth(self):
    """
    Getter method for new_bandwidth, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/new_bandwidth (uint32)

    YANG Description: Current LSP Bandwidth
    """
    return self.__new_bandwidth
      
  def _set_new_bandwidth(self, v, load=False):
    """
    Setter method for new_bandwidth, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/new_bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_new_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_new_bandwidth() directly.

    YANG Description: Current LSP Bandwidth
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="new-bandwidth", rest_name="new-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """new_bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="new-bandwidth", rest_name="new-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__new_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_new_bandwidth(self):
    self.__new_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="new-bandwidth", rest_name="new-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_adjustment_reason(self):
    """
    Getter method for adjustment_reason, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/adjustment_reason (uint8)

    YANG Description: Reason for adjustment
    """
    return self.__adjustment_reason
      
  def _set_adjustment_reason(self, v, load=False):
    """
    Setter method for adjustment_reason, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/adjustment_reason (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjustment_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjustment_reason() directly.

    YANG Description: Reason for adjustment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="adjustment-reason", rest_name="adjustment-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjustment_reason must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="adjustment-reason", rest_name="adjustment-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__adjustment_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjustment_reason(self):
    self.__adjustment_reason = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="adjustment-reason", rest_name="adjustment-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_time_of_last_adjustment(self):
    """
    Getter method for time_of_last_adjustment, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/time_of_last_adjustment (string)

    YANG Description: Time of last adjustment
    """
    return self.__time_of_last_adjustment
      
  def _set_time_of_last_adjustment(self, v, load=False):
    """
    Setter method for time_of_last_adjustment, mapped from YANG variable /mpls_state/lsp/auto_bandwidth/time_of_last_adjustment (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_of_last_adjustment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_of_last_adjustment() directly.

    YANG Description: Time of last adjustment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="time-of-last-adjustment", rest_name="time-of-last-adjustment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_of_last_adjustment must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="time-of-last-adjustment", rest_name="time-of-last-adjustment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__time_of_last_adjustment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_of_last_adjustment(self):
    self.__time_of_last_adjustment = YANGDynClass(base=unicode, is_leaf=True, yang_name="time-of-last-adjustment", rest_name="time-of-last-adjustment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)

  adjustment_interval = __builtin__.property(_get_adjustment_interval)
  adjustment_threshold = __builtin__.property(_get_adjustment_threshold)
  maximum_bandwidth = __builtin__.property(_get_maximum_bandwidth)
  minimum_bandwidth = __builtin__.property(_get_minimum_bandwidth)
  overflow_limit = __builtin__.property(_get_overflow_limit)
  underflow_limit = __builtin__.property(_get_underflow_limit)
  mode = __builtin__.property(_get_mode)
  sample_recording = __builtin__.property(_get_sample_recording)
  is_adjustment_interval_inherited = __builtin__.property(_get_is_adjustment_interval_inherited)
  is_adjustment_threshold_inherited = __builtin__.property(_get_is_adjustment_threshold_inherited)
  is_maximum_bandwidth_inherited = __builtin__.property(_get_is_maximum_bandwidth_inherited)
  is_minimum_bandwidth_inherited = __builtin__.property(_get_is_minimum_bandwidth_inherited)
  is_overflow_limit_inherited = __builtin__.property(_get_is_overflow_limit_inherited)
  is_underflow_limit_inherited = __builtin__.property(_get_is_underflow_limit_inherited)
  is_mode_inherited = __builtin__.property(_get_is_mode_inherited)
  is_sample_recording_inherited = __builtin__.property(_get_is_sample_recording_inherited)
  working_status = __builtin__.property(_get_working_status)
  num_samples_collected = __builtin__.property(_get_num_samples_collected)
  last_sample_traffic_rate = __builtin__.property(_get_last_sample_traffic_rate)
  maximum_of_samples_collected = __builtin__.property(_get_maximum_of_samples_collected)
  maximum_of_underflow_samples = __builtin__.property(_get_maximum_of_underflow_samples)
  overflow_count = __builtin__.property(_get_overflow_count)
  underflow_count = __builtin__.property(_get_underflow_count)
  time_to_adjustment = __builtin__.property(_get_time_to_adjustment)
  adjustment_status = __builtin__.property(_get_adjustment_status)
  previous_bandwidth = __builtin__.property(_get_previous_bandwidth)
  new_bandwidth = __builtin__.property(_get_new_bandwidth)
  adjustment_reason = __builtin__.property(_get_adjustment_reason)
  time_of_last_adjustment = __builtin__.property(_get_time_of_last_adjustment)


  _pyangbind_elements = {'adjustment_interval': adjustment_interval, 'adjustment_threshold': adjustment_threshold, 'maximum_bandwidth': maximum_bandwidth, 'minimum_bandwidth': minimum_bandwidth, 'overflow_limit': overflow_limit, 'underflow_limit': underflow_limit, 'mode': mode, 'sample_recording': sample_recording, 'is_adjustment_interval_inherited': is_adjustment_interval_inherited, 'is_adjustment_threshold_inherited': is_adjustment_threshold_inherited, 'is_maximum_bandwidth_inherited': is_maximum_bandwidth_inherited, 'is_minimum_bandwidth_inherited': is_minimum_bandwidth_inherited, 'is_overflow_limit_inherited': is_overflow_limit_inherited, 'is_underflow_limit_inherited': is_underflow_limit_inherited, 'is_mode_inherited': is_mode_inherited, 'is_sample_recording_inherited': is_sample_recording_inherited, 'working_status': working_status, 'num_samples_collected': num_samples_collected, 'last_sample_traffic_rate': last_sample_traffic_rate, 'maximum_of_samples_collected': maximum_of_samples_collected, 'maximum_of_underflow_samples': maximum_of_underflow_samples, 'overflow_count': overflow_count, 'underflow_count': underflow_count, 'time_to_adjustment': time_to_adjustment, 'adjustment_status': adjustment_status, 'previous_bandwidth': previous_bandwidth, 'new_bandwidth': new_bandwidth, 'adjustment_reason': adjustment_reason, 'time_of_last_adjustment': time_of_last_adjustment, }


