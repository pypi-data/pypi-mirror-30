
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import nexthops
import prefix_downstream
import prefix_upstream
class ldp_fec_prefix(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls-operational - based on the path /mpls-state/ldp/ldp-fec-prefix. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: LDP Prefix FEC information
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__destination','__state','__ingress','__egress','__filtered','__lwd','__filter_type','__prefix_filtered','__longer','__prefix_feccb','__prefix_idx','__prefix_type','__prefix_pend_notif','__prefix_um_dist_done','__prefix_lwd_started','__prefix_is_ldp_o_rsvp','__prefix_excess_dms','__nexthops','__prefix_downstream','__prefix_upstream',)

  _yang_name = 'ldp-fec-prefix'
  _rest_name = 'ldp-fec-prefix'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__prefix_type = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="prefix-type", rest_name="prefix-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__prefix_filtered = YANGDynClass(base=unicode, is_leaf=True, yang_name="prefix-filtered", rest_name="prefix-filtered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__ingress = YANGDynClass(base=unicode, is_leaf=True, yang_name="ingress", rest_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__prefix_um_dist_done = YANGDynClass(base=unicode, is_leaf=True, yang_name="prefix-um-dist-done", rest_name="prefix-um-dist-done", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__longer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="longer", rest_name="longer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__prefix_is_ldp_o_rsvp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="prefix-is-ldp-o-rsvp", rest_name="prefix-is-ldp-o-rsvp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__prefix_excess_dms = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="prefix-excess-dms", rest_name="prefix-excess-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__destination = YANGDynClass(base=unicode, is_leaf=True, yang_name="destination", rest_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__prefix_pend_notif = YANGDynClass(base=unicode, is_leaf=True, yang_name="prefix-pend-notif", rest_name="prefix-pend-notif", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__prefix_upstream = YANGDynClass(base=YANGListType("mapping_index",prefix_upstream.prefix_upstream, yang_name="prefix-upstream", rest_name="prefix-upstream", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mapping-index', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-upstream', u'cli-suppress-show-path': None}}), is_container='list', yang_name="prefix-upstream", rest_name="prefix-upstream", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-upstream', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__filter_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'filtered-in': {'value': 2}, u'filtered-out': {'value': 3}, u'filtered-all': {'value': 1}},), is_leaf=True, yang_name="filter-type", rest_name="filter-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='fec-filter-type', is_config=False)
    self.__state = YANGDynClass(base=unicode, is_leaf=True, yang_name="state", rest_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__egress = YANGDynClass(base=unicode, is_leaf=True, yang_name="egress", rest_name="egress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__prefix_lwd_started = YANGDynClass(base=unicode, is_leaf=True, yang_name="prefix-lwd-started", rest_name="prefix-lwd-started", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__prefix_idx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="prefix-idx", rest_name="prefix-idx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__prefix_feccb = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="prefix-feccb", rest_name="prefix-feccb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__filtered = YANGDynClass(base=unicode, is_leaf=True, yang_name="filtered", rest_name="filtered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__prefix_downstream = YANGDynClass(base=YANGListType("mapping_index",prefix_downstream.prefix_downstream, yang_name="prefix-downstream", rest_name="prefix-downstream", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mapping-index', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-downstream', u'cli-suppress-show-path': None}}), is_container='list', yang_name="prefix-downstream", rest_name="prefix-downstream", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-downstream', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__lwd = YANGDynClass(base=unicode, is_leaf=True, yang_name="lwd", rest_name="lwd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__nexthops = YANGDynClass(base=YANGListType("nexthop",nexthops.nexthops, yang_name="nexthops", rest_name="nexthops", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='nexthop', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="nexthops", rest_name="nexthops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mpls-state', u'ldp', u'ldp-fec-prefix']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'mpls-state', u'ldp', u'ldp-fec-prefix']

  def _get_destination(self):
    """
    Getter method for destination, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/destination (string)

    YANG Description: The IP Prefix associated with the host address or the prefix FEC type
    """
    return self.__destination
      
  def _set_destination(self, v, load=False):
    """
    Setter method for destination, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/destination (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination() directly.

    YANG Description: The IP Prefix associated with the host address or the prefix FEC type
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="destination", rest_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="destination", rest_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__destination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination(self):
    self.__destination = YANGDynClass(base=unicode, is_leaf=True, yang_name="destination", rest_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/state (string)

    YANG Description: State of the FEC which indicates the FEC advertised to any LDP session (state equal to 'current'). When it has no session, it is either called 'cur_no_sess' (currently no session) for local FECs or is marked 'retained' for non-local FECs
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/state (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State of the FEC which indicates the FEC advertised to any LDP session (state equal to 'current'). When it has no session, it is either called 'cur_no_sess' (currently no session) for local FECs or is marked 'retained' for non-local FECs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="state", rest_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="state", rest_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=unicode, is_leaf=True, yang_name="state", rest_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_ingress(self):
    """
    Getter method for ingress, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/ingress (string)

    YANG Description: Whether the FEC is an ingress FEC
    """
    return self.__ingress
      
  def _set_ingress(self, v, load=False):
    """
    Setter method for ingress, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/ingress (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ingress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ingress() directly.

    YANG Description: Whether the FEC is an ingress FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="ingress", rest_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ingress must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="ingress", rest_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__ingress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ingress(self):
    self.__ingress = YANGDynClass(base=unicode, is_leaf=True, yang_name="ingress", rest_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_egress(self):
    """
    Getter method for egress, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/egress (string)

    YANG Description: Whether the FEC is an egress FEC
    """
    return self.__egress
      
  def _set_egress(self, v, load=False):
    """
    Setter method for egress, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/egress (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_egress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_egress() directly.

    YANG Description: Whether the FEC is an egress FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="egress", rest_name="egress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """egress must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="egress", rest_name="egress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__egress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_egress(self):
    self.__egress = YANGDynClass(base=unicode, is_leaf=True, yang_name="egress", rest_name="egress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_filtered(self):
    """
    Getter method for filtered, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/filtered (string)

    YANG Description: Whether FEC is filtered. Value could be 'In' or 'Out'
    """
    return self.__filtered
      
  def _set_filtered(self, v, load=False):
    """
    Setter method for filtered, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/filtered (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filtered is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filtered() directly.

    YANG Description: Whether FEC is filtered. Value could be 'In' or 'Out'
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="filtered", rest_name="filtered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filtered must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="filtered", rest_name="filtered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__filtered = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filtered(self):
    self.__filtered = YANGDynClass(base=unicode, is_leaf=True, yang_name="filtered", rest_name="filtered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_lwd(self):
    """
    Getter method for lwd, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/lwd (string)

    YANG Description: Label withdrawal delay state
    """
    return self.__lwd
      
  def _set_lwd(self, v, load=False):
    """
    Setter method for lwd, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/lwd (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lwd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lwd() directly.

    YANG Description: Label withdrawal delay state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="lwd", rest_name="lwd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lwd must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="lwd", rest_name="lwd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__lwd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lwd(self):
    self.__lwd = YANGDynClass(base=unicode, is_leaf=True, yang_name="lwd", rest_name="lwd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_filter_type(self):
    """
    Getter method for filter_type, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/filter_type (fec-filter-type)

    YANG Description: Tells if inbound or outbound or all filtered FECs have to be shown
    """
    return self.__filter_type
      
  def _set_filter_type(self, v, load=False):
    """
    Setter method for filter_type, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/filter_type (fec-filter-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filter_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filter_type() directly.

    YANG Description: Tells if inbound or outbound or all filtered FECs have to be shown
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'filtered-in': {'value': 2}, u'filtered-out': {'value': 3}, u'filtered-all': {'value': 1}},), is_leaf=True, yang_name="filter-type", rest_name="filter-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='fec-filter-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filter_type must be of a type compatible with fec-filter-type""",
          'defined-type': "brocade-mpls-operational:fec-filter-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'filtered-in': {'value': 2}, u'filtered-out': {'value': 3}, u'filtered-all': {'value': 1}},), is_leaf=True, yang_name="filter-type", rest_name="filter-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='fec-filter-type', is_config=False)""",
        })

    self.__filter_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filter_type(self):
    self.__filter_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'filtered-in': {'value': 2}, u'filtered-out': {'value': 3}, u'filtered-all': {'value': 1}},), is_leaf=True, yang_name="filter-type", rest_name="filter-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='fec-filter-type', is_config=False)


  def _get_prefix_filtered(self):
    """
    Getter method for prefix_filtered, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_filtered (string)

    YANG Description: filter name
    """
    return self.__prefix_filtered
      
  def _set_prefix_filtered(self, v, load=False):
    """
    Setter method for prefix_filtered, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_filtered (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_filtered is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_filtered() directly.

    YANG Description: filter name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="prefix-filtered", rest_name="prefix-filtered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_filtered must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="prefix-filtered", rest_name="prefix-filtered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__prefix_filtered = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_filtered(self):
    self.__prefix_filtered = YANGDynClass(base=unicode, is_leaf=True, yang_name="prefix-filtered", rest_name="prefix-filtered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_longer(self):
    """
    Getter method for longer, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/longer (boolean)

    YANG Description: Tells if detailed output is needed for LDP FECs
    """
    return self.__longer
      
  def _set_longer(self, v, load=False):
    """
    Setter method for longer, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/longer (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_longer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_longer() directly.

    YANG Description: Tells if detailed output is needed for LDP FECs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="longer", rest_name="longer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """longer must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="longer", rest_name="longer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__longer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_longer(self):
    self.__longer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="longer", rest_name="longer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_prefix_feccb(self):
    """
    Getter method for prefix_feccb, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_feccb (uint32)

    YANG Description: Memory address of the FEC CB
    """
    return self.__prefix_feccb
      
  def _set_prefix_feccb(self, v, load=False):
    """
    Setter method for prefix_feccb, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_feccb (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_feccb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_feccb() directly.

    YANG Description: Memory address of the FEC CB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="prefix-feccb", rest_name="prefix-feccb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_feccb must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="prefix-feccb", rest_name="prefix-feccb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__prefix_feccb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_feccb(self):
    self.__prefix_feccb = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="prefix-feccb", rest_name="prefix-feccb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_prefix_idx(self):
    """
    Getter method for prefix_idx, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_idx (uint32)

    YANG Description: A monotonically increasing number assigned to each FEC in the LDP internal FEC tree
    """
    return self.__prefix_idx
      
  def _set_prefix_idx(self, v, load=False):
    """
    Setter method for prefix_idx, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_idx (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_idx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_idx() directly.

    YANG Description: A monotonically increasing number assigned to each FEC in the LDP internal FEC tree
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="prefix-idx", rest_name="prefix-idx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_idx must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="prefix-idx", rest_name="prefix-idx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__prefix_idx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_idx(self):
    self.__prefix_idx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="prefix-idx", rest_name="prefix-idx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_prefix_type(self):
    """
    Getter method for prefix_type, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_type (uint32)

    YANG Description: FEC type - Prefix FEC is type 2 and Host Address is assigned type 3
    """
    return self.__prefix_type
      
  def _set_prefix_type(self, v, load=False):
    """
    Setter method for prefix_type, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_type (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_type() directly.

    YANG Description: FEC type - Prefix FEC is type 2 and Host Address is assigned type 3
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="prefix-type", rest_name="prefix-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_type must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="prefix-type", rest_name="prefix-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__prefix_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_type(self):
    self.__prefix_type = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="prefix-type", rest_name="prefix-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_prefix_pend_notif(self):
    """
    Getter method for prefix_pend_notif, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_pend_notif (string)

    YANG Description: Any notification pending on this FEC
    """
    return self.__prefix_pend_notif
      
  def _set_prefix_pend_notif(self, v, load=False):
    """
    Setter method for prefix_pend_notif, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_pend_notif (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_pend_notif is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_pend_notif() directly.

    YANG Description: Any notification pending on this FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="prefix-pend-notif", rest_name="prefix-pend-notif", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_pend_notif must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="prefix-pend-notif", rest_name="prefix-pend-notif", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__prefix_pend_notif = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_pend_notif(self):
    self.__prefix_pend_notif = YANGDynClass(base=unicode, is_leaf=True, yang_name="prefix-pend-notif", rest_name="prefix-pend-notif", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_prefix_um_dist_done(self):
    """
    Getter method for prefix_um_dist_done, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_um_dist_done (string)

    YANG Description: Specifies when Upstream Mapping Distribution is complete
    """
    return self.__prefix_um_dist_done
      
  def _set_prefix_um_dist_done(self, v, load=False):
    """
    Setter method for prefix_um_dist_done, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_um_dist_done (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_um_dist_done is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_um_dist_done() directly.

    YANG Description: Specifies when Upstream Mapping Distribution is complete
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="prefix-um-dist-done", rest_name="prefix-um-dist-done", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_um_dist_done must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="prefix-um-dist-done", rest_name="prefix-um-dist-done", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__prefix_um_dist_done = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_um_dist_done(self):
    self.__prefix_um_dist_done = YANGDynClass(base=unicode, is_leaf=True, yang_name="prefix-um-dist-done", rest_name="prefix-um-dist-done", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_prefix_lwd_started(self):
    """
    Getter method for prefix_lwd_started, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_lwd_started (string)

    YANG Description: lwd_started
    """
    return self.__prefix_lwd_started
      
  def _set_prefix_lwd_started(self, v, load=False):
    """
    Setter method for prefix_lwd_started, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_lwd_started (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_lwd_started is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_lwd_started() directly.

    YANG Description: lwd_started
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="prefix-lwd-started", rest_name="prefix-lwd-started", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_lwd_started must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="prefix-lwd-started", rest_name="prefix-lwd-started", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__prefix_lwd_started = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_lwd_started(self):
    self.__prefix_lwd_started = YANGDynClass(base=unicode, is_leaf=True, yang_name="prefix-lwd-started", rest_name="prefix-lwd-started", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_prefix_is_ldp_o_rsvp(self):
    """
    Getter method for prefix_is_ldp_o_rsvp, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_is_ldp_o_rsvp (boolean)

    YANG Description: prefix is ldp or rsvp
    """
    return self.__prefix_is_ldp_o_rsvp
      
  def _set_prefix_is_ldp_o_rsvp(self, v, load=False):
    """
    Setter method for prefix_is_ldp_o_rsvp, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_is_ldp_o_rsvp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_is_ldp_o_rsvp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_is_ldp_o_rsvp() directly.

    YANG Description: prefix is ldp or rsvp
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="prefix-is-ldp-o-rsvp", rest_name="prefix-is-ldp-o-rsvp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_is_ldp_o_rsvp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="prefix-is-ldp-o-rsvp", rest_name="prefix-is-ldp-o-rsvp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__prefix_is_ldp_o_rsvp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_is_ldp_o_rsvp(self):
    self.__prefix_is_ldp_o_rsvp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="prefix-is-ldp-o-rsvp", rest_name="prefix-is-ldp-o-rsvp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_prefix_excess_dms(self):
    """
    Getter method for prefix_excess_dms, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_excess_dms (boolean)

    YANG Description: Tells if number of downstream mappings exceeds the threshold value. only 8 of the Downstreams may be installed
    """
    return self.__prefix_excess_dms
      
  def _set_prefix_excess_dms(self, v, load=False):
    """
    Setter method for prefix_excess_dms, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_excess_dms (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_excess_dms is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_excess_dms() directly.

    YANG Description: Tells if number of downstream mappings exceeds the threshold value. only 8 of the Downstreams may be installed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="prefix-excess-dms", rest_name="prefix-excess-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_excess_dms must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="prefix-excess-dms", rest_name="prefix-excess-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__prefix_excess_dms = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_excess_dms(self):
    self.__prefix_excess_dms = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="prefix-excess-dms", rest_name="prefix-excess-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_nexthops(self):
    """
    Getter method for nexthops, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/nexthops (list)
    """
    return self.__nexthops
      
  def _set_nexthops(self, v, load=False):
    """
    Setter method for nexthops, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/nexthops (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nexthops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nexthops() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("nexthop",nexthops.nexthops, yang_name="nexthops", rest_name="nexthops", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='nexthop', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="nexthops", rest_name="nexthops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nexthops must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("nexthop",nexthops.nexthops, yang_name="nexthops", rest_name="nexthops", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='nexthop', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="nexthops", rest_name="nexthops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__nexthops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nexthops(self):
    self.__nexthops = YANGDynClass(base=YANGListType("nexthop",nexthops.nexthops, yang_name="nexthops", rest_name="nexthops", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='nexthop', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="nexthops", rest_name="nexthops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)


  def _get_prefix_downstream(self):
    """
    Getter method for prefix_downstream, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_downstream (list)

    YANG Description: LDP prefix fec for downstream mapping
    """
    return self.__prefix_downstream
      
  def _set_prefix_downstream(self, v, load=False):
    """
    Setter method for prefix_downstream, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_downstream (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_downstream is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_downstream() directly.

    YANG Description: LDP prefix fec for downstream mapping
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("mapping_index",prefix_downstream.prefix_downstream, yang_name="prefix-downstream", rest_name="prefix-downstream", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mapping-index', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-downstream', u'cli-suppress-show-path': None}}), is_container='list', yang_name="prefix-downstream", rest_name="prefix-downstream", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-downstream', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_downstream must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("mapping_index",prefix_downstream.prefix_downstream, yang_name="prefix-downstream", rest_name="prefix-downstream", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mapping-index', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-downstream', u'cli-suppress-show-path': None}}), is_container='list', yang_name="prefix-downstream", rest_name="prefix-downstream", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-downstream', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__prefix_downstream = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_downstream(self):
    self.__prefix_downstream = YANGDynClass(base=YANGListType("mapping_index",prefix_downstream.prefix_downstream, yang_name="prefix-downstream", rest_name="prefix-downstream", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mapping-index', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-downstream', u'cli-suppress-show-path': None}}), is_container='list', yang_name="prefix-downstream", rest_name="prefix-downstream", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-downstream', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)


  def _get_prefix_upstream(self):
    """
    Getter method for prefix_upstream, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_upstream (list)

    YANG Description: LDP prefix fec for upstream mapping
    """
    return self.__prefix_upstream
      
  def _set_prefix_upstream(self, v, load=False):
    """
    Setter method for prefix_upstream, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix/prefix_upstream (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_upstream is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_upstream() directly.

    YANG Description: LDP prefix fec for upstream mapping
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("mapping_index",prefix_upstream.prefix_upstream, yang_name="prefix-upstream", rest_name="prefix-upstream", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mapping-index', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-upstream', u'cli-suppress-show-path': None}}), is_container='list', yang_name="prefix-upstream", rest_name="prefix-upstream", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-upstream', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_upstream must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("mapping_index",prefix_upstream.prefix_upstream, yang_name="prefix-upstream", rest_name="prefix-upstream", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mapping-index', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-upstream', u'cli-suppress-show-path': None}}), is_container='list', yang_name="prefix-upstream", rest_name="prefix-upstream", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-upstream', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__prefix_upstream = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_upstream(self):
    self.__prefix_upstream = YANGDynClass(base=YANGListType("mapping_index",prefix_upstream.prefix_upstream, yang_name="prefix-upstream", rest_name="prefix-upstream", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mapping-index', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-upstream', u'cli-suppress-show-path': None}}), is_container='list', yang_name="prefix-upstream", rest_name="prefix-upstream", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-prefix-fec-upstream', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)

  destination = __builtin__.property(_get_destination)
  state = __builtin__.property(_get_state)
  ingress = __builtin__.property(_get_ingress)
  egress = __builtin__.property(_get_egress)
  filtered = __builtin__.property(_get_filtered)
  lwd = __builtin__.property(_get_lwd)
  filter_type = __builtin__.property(_get_filter_type)
  prefix_filtered = __builtin__.property(_get_prefix_filtered)
  longer = __builtin__.property(_get_longer)
  prefix_feccb = __builtin__.property(_get_prefix_feccb)
  prefix_idx = __builtin__.property(_get_prefix_idx)
  prefix_type = __builtin__.property(_get_prefix_type)
  prefix_pend_notif = __builtin__.property(_get_prefix_pend_notif)
  prefix_um_dist_done = __builtin__.property(_get_prefix_um_dist_done)
  prefix_lwd_started = __builtin__.property(_get_prefix_lwd_started)
  prefix_is_ldp_o_rsvp = __builtin__.property(_get_prefix_is_ldp_o_rsvp)
  prefix_excess_dms = __builtin__.property(_get_prefix_excess_dms)
  nexthops = __builtin__.property(_get_nexthops)
  prefix_downstream = __builtin__.property(_get_prefix_downstream)
  prefix_upstream = __builtin__.property(_get_prefix_upstream)


  _pyangbind_elements = {'destination': destination, 'state': state, 'ingress': ingress, 'egress': egress, 'filtered': filtered, 'lwd': lwd, 'filter_type': filter_type, 'prefix_filtered': prefix_filtered, 'longer': longer, 'prefix_feccb': prefix_feccb, 'prefix_idx': prefix_idx, 'prefix_type': prefix_type, 'prefix_pend_notif': prefix_pend_notif, 'prefix_um_dist_done': prefix_um_dist_done, 'prefix_lwd_started': prefix_lwd_started, 'prefix_is_ldp_o_rsvp': prefix_is_ldp_o_rsvp, 'prefix_excess_dms': prefix_excess_dms, 'nexthops': nexthops, 'prefix_downstream': prefix_downstream, 'prefix_upstream': prefix_upstream, }


