
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class show_lsp_input_info(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls - based on the path /brocade_mpls_rpc/show-mpls-bypass-lsp-name-detail/input/show-lsp-input-info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__lsp','__lsp_wide','__lsp_detail','__lsp_extensive','__lsp_debug','__lsp_name','__lsp_name_extensive','__lsp_name_debug','__bypass_lsp','__bypass_lsp_wide','__bypass_lsp_detail','__bypass_lsp_extensive','__bypass_lsp_debug','__bypass_lsp_name','__bypass_lsp_name_extensive','__bypass_lsp_name_debug','__bypass_lsp_static','__bypass_lsp_static_wide','__bypass_lsp_static_detail','__bypass_lsp_static_extensive','__bypass_lsp_static_debug','__bypass_lsp_static_name','__bypass_lsp_static_name_extensive','__bypass_lsp_static_name_debug','__bypass_lsp_dynamic','__bypass_lsp_dynamic_wide','__bypass_lsp_dynamic_detail','__bypass_lsp_dynamic_extensive','__bypass_lsp_dynamic_debug','__bypass_lsp_dynamic_name','__bypass_lsp_dynamic_name_extensive','__bypass_lsp_dynamic_name_debug','__lsp_input_lsp_name','__lsp_input_bypass','__lsp_input_dynamic','__lsp_input_brief','__lsp_input_wide','__lsp_input_detail','__lsp_input_extensive','__lsp_input_debug','__lsp_input_one','__lsp_input_all','__lsp_input_more',)

  _yang_name = 'show-lsp-input-info'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__lsp_input_detail = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-detail", rest_name="lsp-input-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp_input_wide = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-wide", rest_name="lsp-input-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_name_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-name-extensive", rest_name="bypass-lsp-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="lsp-name", rest_name="lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__lsp_input_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-debug", rest_name="lsp-input-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp_wide = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-wide", rest_name="lsp-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_dynamic_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-debug", rest_name="bypass-lsp-dynamic-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-debug", rest_name="bypass-lsp-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp_input_more = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-more", rest_name="lsp-input-more", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_static_name_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-name-extensive", rest_name="bypass-lsp-static-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-debug", rest_name="lsp-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp = YANGDynClass(base=unicode, is_leaf=True, yang_name="lsp", rest_name="lsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__bypass_lsp_static_wide = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-wide", rest_name="bypass-lsp-static-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_static_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-extensive", rest_name="bypass-lsp-static-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp-name", rest_name="bypass-lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__bypass_lsp_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-extensive", rest_name="bypass-lsp-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_static_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp-static-name", rest_name="bypass-lsp-static-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__bypass_lsp_dynamic_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp-dynamic-name", rest_name="bypass-lsp-dynamic-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__bypass_lsp = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp", rest_name="bypass-lsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__bypass_lsp_dynamic_wide = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-wide", rest_name="bypass-lsp-dynamic-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_dynamic_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-extensive", rest_name="bypass-lsp-dynamic-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp_name_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-name-debug", rest_name="lsp-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp_input_lsp_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="lsp-input-lsp-name", rest_name="lsp-input-lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__bypass_lsp_static_detail = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-detail", rest_name="bypass-lsp-static-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_static = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp-static", rest_name="bypass-lsp-static", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__lsp_detail = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-detail", rest_name="lsp-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp_name_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-name-extensive", rest_name="lsp-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_dynamic_detail = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-detail", rest_name="bypass-lsp-dynamic-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp_input_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-extensive", rest_name="lsp-input-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_dynamic_name_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-name-debug", rest_name="bypass-lsp-dynamic-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_dynamic = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp-dynamic", rest_name="bypass-lsp-dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__bypass_lsp_detail = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-detail", rest_name="bypass-lsp-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-extensive", rest_name="lsp-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp_input_dynamic = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-dynamic", rest_name="lsp-input-dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_static_name_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-name-debug", rest_name="bypass-lsp-static-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp_input_one = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-one", rest_name="lsp-input-one", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp_input_all = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-all", rest_name="lsp-input-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_static_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-debug", rest_name="bypass-lsp-static-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_wide = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-wide", rest_name="bypass-lsp-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp_input_brief = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-brief", rest_name="lsp-input-brief", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsp_input_bypass = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-bypass", rest_name="lsp-input-bypass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_dynamic_name_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-name-extensive", rest_name="bypass-lsp-dynamic-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__bypass_lsp_name_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-name-debug", rest_name="bypass-lsp-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'brocade_mpls_rpc', u'show-mpls-bypass-lsp-name-detail', u'input', u'show-lsp-input-info']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'show-mpls-bypass-lsp-name-detail', u'input']

  def _get_lsp(self):
    """
    Getter method for lsp, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp (string)

    YANG Description: Show all lsps in brief
    """
    return self.__lsp
      
  def _set_lsp(self, v, load=False):
    """
    Setter method for lsp, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp() directly.

    YANG Description: Show all lsps in brief
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="lsp", rest_name="lsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="lsp", rest_name="lsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__lsp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp(self):
    self.__lsp = YANGDynClass(base=unicode, is_leaf=True, yang_name="lsp", rest_name="lsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_lsp_wide(self):
    """
    Getter method for lsp_wide, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_wide (boolean)

    YANG Description: Show all lsps in brief and wide
    """
    return self.__lsp_wide
      
  def _set_lsp_wide(self, v, load=False):
    """
    Setter method for lsp_wide, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_wide (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_wide is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_wide() directly.

    YANG Description: Show all lsps in brief and wide
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-wide", rest_name="lsp-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_wide must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-wide", rest_name="lsp-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_wide = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_wide(self):
    self.__lsp_wide = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-wide", rest_name="lsp-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsp_detail(self):
    """
    Getter method for lsp_detail, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_detail (boolean)

    YANG Description: Show all lsps in detail
    """
    return self.__lsp_detail
      
  def _set_lsp_detail(self, v, load=False):
    """
    Setter method for lsp_detail, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_detail (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_detail is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_detail() directly.

    YANG Description: Show all lsps in detail
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-detail", rest_name="lsp-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_detail must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-detail", rest_name="lsp-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_detail = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_detail(self):
    self.__lsp_detail = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-detail", rest_name="lsp-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsp_extensive(self):
    """
    Getter method for lsp_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_extensive (boolean)

    YANG Description: Show all lsps in extensive
    """
    return self.__lsp_extensive
      
  def _set_lsp_extensive(self, v, load=False):
    """
    Setter method for lsp_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_extensive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_extensive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_extensive() directly.

    YANG Description: Show all lsps in extensive
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-extensive", rest_name="lsp-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_extensive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-extensive", rest_name="lsp-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_extensive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_extensive(self):
    self.__lsp_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-extensive", rest_name="lsp-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsp_debug(self):
    """
    Getter method for lsp_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_debug (boolean)

    YANG Description: Show all lsps in extensive debug
    """
    return self.__lsp_debug
      
  def _set_lsp_debug(self, v, load=False):
    """
    Setter method for lsp_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_debug (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_debug is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_debug() directly.

    YANG Description: Show all lsps in extensive debug
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-debug", rest_name="lsp-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_debug must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-debug", rest_name="lsp-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_debug = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_debug(self):
    self.__lsp_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-debug", rest_name="lsp-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsp_name(self):
    """
    Getter method for lsp_name, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_name (string)

    YANG Description: Show one lsp detailed info by name
    """
    return self.__lsp_name
      
  def _set_lsp_name(self, v, load=False):
    """
    Setter method for lsp_name, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_name() directly.

    YANG Description: Show one lsp detailed info by name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="lsp-name", rest_name="lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="lsp-name", rest_name="lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__lsp_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_name(self):
    self.__lsp_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="lsp-name", rest_name="lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_lsp_name_extensive(self):
    """
    Getter method for lsp_name_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_name_extensive (boolean)

    YANG Description: Show one lsp extensive info by name
    """
    return self.__lsp_name_extensive
      
  def _set_lsp_name_extensive(self, v, load=False):
    """
    Setter method for lsp_name_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_name_extensive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_name_extensive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_name_extensive() directly.

    YANG Description: Show one lsp extensive info by name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-name-extensive", rest_name="lsp-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_name_extensive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-name-extensive", rest_name="lsp-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_name_extensive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_name_extensive(self):
    self.__lsp_name_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-name-extensive", rest_name="lsp-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsp_name_debug(self):
    """
    Getter method for lsp_name_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_name_debug (boolean)

    YANG Description: Show one lsp extensive debug info by name
    """
    return self.__lsp_name_debug
      
  def _set_lsp_name_debug(self, v, load=False):
    """
    Setter method for lsp_name_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_name_debug (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_name_debug is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_name_debug() directly.

    YANG Description: Show one lsp extensive debug info by name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-name-debug", rest_name="lsp-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_name_debug must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-name-debug", rest_name="lsp-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_name_debug = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_name_debug(self):
    self.__lsp_name_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-name-debug", rest_name="lsp-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp(self):
    """
    Getter method for bypass_lsp, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp (string)

    YANG Description: Show all bypass-lsps in brief
    """
    return self.__bypass_lsp
      
  def _set_bypass_lsp(self, v, load=False):
    """
    Setter method for bypass_lsp, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp() directly.

    YANG Description: Show all bypass-lsps in brief
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="bypass-lsp", rest_name="bypass-lsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp", rest_name="bypass-lsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__bypass_lsp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp(self):
    self.__bypass_lsp = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp", rest_name="bypass-lsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_bypass_lsp_wide(self):
    """
    Getter method for bypass_lsp_wide, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_wide (boolean)

    YANG Description: Show all bypass-lsps in brief and wide
    """
    return self.__bypass_lsp_wide
      
  def _set_bypass_lsp_wide(self, v, load=False):
    """
    Setter method for bypass_lsp_wide, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_wide (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_wide is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_wide() directly.

    YANG Description: Show all bypass-lsps in brief and wide
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-wide", rest_name="bypass-lsp-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_wide must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-wide", rest_name="bypass-lsp-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_wide = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_wide(self):
    self.__bypass_lsp_wide = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-wide", rest_name="bypass-lsp-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_detail(self):
    """
    Getter method for bypass_lsp_detail, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_detail (boolean)

    YANG Description: Show all bypass-lsps in detail
    """
    return self.__bypass_lsp_detail
      
  def _set_bypass_lsp_detail(self, v, load=False):
    """
    Setter method for bypass_lsp_detail, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_detail (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_detail is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_detail() directly.

    YANG Description: Show all bypass-lsps in detail
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-detail", rest_name="bypass-lsp-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_detail must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-detail", rest_name="bypass-lsp-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_detail = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_detail(self):
    self.__bypass_lsp_detail = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-detail", rest_name="bypass-lsp-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_extensive(self):
    """
    Getter method for bypass_lsp_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_extensive (boolean)

    YANG Description: Show all bypass-lsps in extensive
    """
    return self.__bypass_lsp_extensive
      
  def _set_bypass_lsp_extensive(self, v, load=False):
    """
    Setter method for bypass_lsp_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_extensive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_extensive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_extensive() directly.

    YANG Description: Show all bypass-lsps in extensive
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-extensive", rest_name="bypass-lsp-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_extensive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-extensive", rest_name="bypass-lsp-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_extensive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_extensive(self):
    self.__bypass_lsp_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-extensive", rest_name="bypass-lsp-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_debug(self):
    """
    Getter method for bypass_lsp_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_debug (boolean)

    YANG Description: Show all bypass-lsps in extensive debug
    """
    return self.__bypass_lsp_debug
      
  def _set_bypass_lsp_debug(self, v, load=False):
    """
    Setter method for bypass_lsp_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_debug (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_debug is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_debug() directly.

    YANG Description: Show all bypass-lsps in extensive debug
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-debug", rest_name="bypass-lsp-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_debug must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-debug", rest_name="bypass-lsp-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_debug = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_debug(self):
    self.__bypass_lsp_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-debug", rest_name="bypass-lsp-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_name(self):
    """
    Getter method for bypass_lsp_name, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_name (string)

    YANG Description: Show one bypass-lsp detailed info by name
    """
    return self.__bypass_lsp_name
      
  def _set_bypass_lsp_name(self, v, load=False):
    """
    Setter method for bypass_lsp_name, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_name() directly.

    YANG Description: Show one bypass-lsp detailed info by name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="bypass-lsp-name", rest_name="bypass-lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp-name", rest_name="bypass-lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__bypass_lsp_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_name(self):
    self.__bypass_lsp_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp-name", rest_name="bypass-lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_bypass_lsp_name_extensive(self):
    """
    Getter method for bypass_lsp_name_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_name_extensive (boolean)

    YANG Description: Show one bypass-lsp extensive info by name
    """
    return self.__bypass_lsp_name_extensive
      
  def _set_bypass_lsp_name_extensive(self, v, load=False):
    """
    Setter method for bypass_lsp_name_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_name_extensive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_name_extensive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_name_extensive() directly.

    YANG Description: Show one bypass-lsp extensive info by name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-name-extensive", rest_name="bypass-lsp-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_name_extensive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-name-extensive", rest_name="bypass-lsp-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_name_extensive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_name_extensive(self):
    self.__bypass_lsp_name_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-name-extensive", rest_name="bypass-lsp-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_name_debug(self):
    """
    Getter method for bypass_lsp_name_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_name_debug (boolean)

    YANG Description: Show one bypass-lsp extensive debug info by name
    """
    return self.__bypass_lsp_name_debug
      
  def _set_bypass_lsp_name_debug(self, v, load=False):
    """
    Setter method for bypass_lsp_name_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_name_debug (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_name_debug is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_name_debug() directly.

    YANG Description: Show one bypass-lsp extensive debug info by name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-name-debug", rest_name="bypass-lsp-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_name_debug must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-name-debug", rest_name="bypass-lsp-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_name_debug = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_name_debug(self):
    self.__bypass_lsp_name_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-name-debug", rest_name="bypass-lsp-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_static(self):
    """
    Getter method for bypass_lsp_static, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static (string)

    YANG Description: Show all static bypass-lsps in brief
    """
    return self.__bypass_lsp_static
      
  def _set_bypass_lsp_static(self, v, load=False):
    """
    Setter method for bypass_lsp_static, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_static is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_static() directly.

    YANG Description: Show all static bypass-lsps in brief
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="bypass-lsp-static", rest_name="bypass-lsp-static", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_static must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp-static", rest_name="bypass-lsp-static", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__bypass_lsp_static = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_static(self):
    self.__bypass_lsp_static = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp-static", rest_name="bypass-lsp-static", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_bypass_lsp_static_wide(self):
    """
    Getter method for bypass_lsp_static_wide, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static_wide (boolean)

    YANG Description: Show all static bypass-lsps in brief and wide
    """
    return self.__bypass_lsp_static_wide
      
  def _set_bypass_lsp_static_wide(self, v, load=False):
    """
    Setter method for bypass_lsp_static_wide, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static_wide (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_static_wide is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_static_wide() directly.

    YANG Description: Show all static bypass-lsps in brief and wide
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-wide", rest_name="bypass-lsp-static-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_static_wide must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-wide", rest_name="bypass-lsp-static-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_static_wide = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_static_wide(self):
    self.__bypass_lsp_static_wide = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-wide", rest_name="bypass-lsp-static-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_static_detail(self):
    """
    Getter method for bypass_lsp_static_detail, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static_detail (boolean)

    YANG Description: Show all static bypass-lsps in detail
    """
    return self.__bypass_lsp_static_detail
      
  def _set_bypass_lsp_static_detail(self, v, load=False):
    """
    Setter method for bypass_lsp_static_detail, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static_detail (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_static_detail is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_static_detail() directly.

    YANG Description: Show all static bypass-lsps in detail
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-detail", rest_name="bypass-lsp-static-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_static_detail must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-detail", rest_name="bypass-lsp-static-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_static_detail = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_static_detail(self):
    self.__bypass_lsp_static_detail = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-detail", rest_name="bypass-lsp-static-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_static_extensive(self):
    """
    Getter method for bypass_lsp_static_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static_extensive (boolean)

    YANG Description: Show all static bypass-lsps in extensive
    """
    return self.__bypass_lsp_static_extensive
      
  def _set_bypass_lsp_static_extensive(self, v, load=False):
    """
    Setter method for bypass_lsp_static_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static_extensive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_static_extensive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_static_extensive() directly.

    YANG Description: Show all static bypass-lsps in extensive
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-extensive", rest_name="bypass-lsp-static-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_static_extensive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-extensive", rest_name="bypass-lsp-static-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_static_extensive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_static_extensive(self):
    self.__bypass_lsp_static_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-extensive", rest_name="bypass-lsp-static-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_static_debug(self):
    """
    Getter method for bypass_lsp_static_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static_debug (boolean)

    YANG Description: Show all static bypass-lsps in extensive debug
    """
    return self.__bypass_lsp_static_debug
      
  def _set_bypass_lsp_static_debug(self, v, load=False):
    """
    Setter method for bypass_lsp_static_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static_debug (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_static_debug is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_static_debug() directly.

    YANG Description: Show all static bypass-lsps in extensive debug
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-debug", rest_name="bypass-lsp-static-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_static_debug must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-debug", rest_name="bypass-lsp-static-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_static_debug = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_static_debug(self):
    self.__bypass_lsp_static_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-debug", rest_name="bypass-lsp-static-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_static_name(self):
    """
    Getter method for bypass_lsp_static_name, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static_name (string)

    YANG Description: Show one static bypass-lsp detailed info by name
    """
    return self.__bypass_lsp_static_name
      
  def _set_bypass_lsp_static_name(self, v, load=False):
    """
    Setter method for bypass_lsp_static_name, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_static_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_static_name() directly.

    YANG Description: Show one static bypass-lsp detailed info by name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="bypass-lsp-static-name", rest_name="bypass-lsp-static-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_static_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp-static-name", rest_name="bypass-lsp-static-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__bypass_lsp_static_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_static_name(self):
    self.__bypass_lsp_static_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp-static-name", rest_name="bypass-lsp-static-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_bypass_lsp_static_name_extensive(self):
    """
    Getter method for bypass_lsp_static_name_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static_name_extensive (boolean)

    YANG Description: Show one static bypass-lsp extensive info by name
    """
    return self.__bypass_lsp_static_name_extensive
      
  def _set_bypass_lsp_static_name_extensive(self, v, load=False):
    """
    Setter method for bypass_lsp_static_name_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static_name_extensive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_static_name_extensive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_static_name_extensive() directly.

    YANG Description: Show one static bypass-lsp extensive info by name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-name-extensive", rest_name="bypass-lsp-static-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_static_name_extensive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-name-extensive", rest_name="bypass-lsp-static-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_static_name_extensive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_static_name_extensive(self):
    self.__bypass_lsp_static_name_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-name-extensive", rest_name="bypass-lsp-static-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_static_name_debug(self):
    """
    Getter method for bypass_lsp_static_name_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static_name_debug (boolean)

    YANG Description: Show one static bypass-lsp extensive debug info by name
    """
    return self.__bypass_lsp_static_name_debug
      
  def _set_bypass_lsp_static_name_debug(self, v, load=False):
    """
    Setter method for bypass_lsp_static_name_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_static_name_debug (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_static_name_debug is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_static_name_debug() directly.

    YANG Description: Show one static bypass-lsp extensive debug info by name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-name-debug", rest_name="bypass-lsp-static-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_static_name_debug must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-name-debug", rest_name="bypass-lsp-static-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_static_name_debug = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_static_name_debug(self):
    self.__bypass_lsp_static_name_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-static-name-debug", rest_name="bypass-lsp-static-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_dynamic(self):
    """
    Getter method for bypass_lsp_dynamic, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic (string)

    YANG Description: Show all dynamic bypass-lsps in brief
    """
    return self.__bypass_lsp_dynamic
      
  def _set_bypass_lsp_dynamic(self, v, load=False):
    """
    Setter method for bypass_lsp_dynamic, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_dynamic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_dynamic() directly.

    YANG Description: Show all dynamic bypass-lsps in brief
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="bypass-lsp-dynamic", rest_name="bypass-lsp-dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_dynamic must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp-dynamic", rest_name="bypass-lsp-dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__bypass_lsp_dynamic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_dynamic(self):
    self.__bypass_lsp_dynamic = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp-dynamic", rest_name="bypass-lsp-dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_bypass_lsp_dynamic_wide(self):
    """
    Getter method for bypass_lsp_dynamic_wide, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic_wide (boolean)

    YANG Description: Show all dynamic bypass-lsps in brief and wide
    """
    return self.__bypass_lsp_dynamic_wide
      
  def _set_bypass_lsp_dynamic_wide(self, v, load=False):
    """
    Setter method for bypass_lsp_dynamic_wide, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic_wide (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_dynamic_wide is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_dynamic_wide() directly.

    YANG Description: Show all dynamic bypass-lsps in brief and wide
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-wide", rest_name="bypass-lsp-dynamic-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_dynamic_wide must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-wide", rest_name="bypass-lsp-dynamic-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_dynamic_wide = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_dynamic_wide(self):
    self.__bypass_lsp_dynamic_wide = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-wide", rest_name="bypass-lsp-dynamic-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_dynamic_detail(self):
    """
    Getter method for bypass_lsp_dynamic_detail, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic_detail (boolean)

    YANG Description: Show all dynamic bypass-lsps in detail
    """
    return self.__bypass_lsp_dynamic_detail
      
  def _set_bypass_lsp_dynamic_detail(self, v, load=False):
    """
    Setter method for bypass_lsp_dynamic_detail, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic_detail (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_dynamic_detail is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_dynamic_detail() directly.

    YANG Description: Show all dynamic bypass-lsps in detail
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-detail", rest_name="bypass-lsp-dynamic-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_dynamic_detail must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-detail", rest_name="bypass-lsp-dynamic-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_dynamic_detail = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_dynamic_detail(self):
    self.__bypass_lsp_dynamic_detail = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-detail", rest_name="bypass-lsp-dynamic-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_dynamic_extensive(self):
    """
    Getter method for bypass_lsp_dynamic_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic_extensive (boolean)

    YANG Description: Show all dynamic bypass-lsps in extensive
    """
    return self.__bypass_lsp_dynamic_extensive
      
  def _set_bypass_lsp_dynamic_extensive(self, v, load=False):
    """
    Setter method for bypass_lsp_dynamic_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic_extensive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_dynamic_extensive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_dynamic_extensive() directly.

    YANG Description: Show all dynamic bypass-lsps in extensive
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-extensive", rest_name="bypass-lsp-dynamic-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_dynamic_extensive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-extensive", rest_name="bypass-lsp-dynamic-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_dynamic_extensive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_dynamic_extensive(self):
    self.__bypass_lsp_dynamic_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-extensive", rest_name="bypass-lsp-dynamic-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_dynamic_debug(self):
    """
    Getter method for bypass_lsp_dynamic_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic_debug (boolean)

    YANG Description: Show all dynamic bypass-lsps in extensive debug
    """
    return self.__bypass_lsp_dynamic_debug
      
  def _set_bypass_lsp_dynamic_debug(self, v, load=False):
    """
    Setter method for bypass_lsp_dynamic_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic_debug (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_dynamic_debug is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_dynamic_debug() directly.

    YANG Description: Show all dynamic bypass-lsps in extensive debug
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-debug", rest_name="bypass-lsp-dynamic-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_dynamic_debug must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-debug", rest_name="bypass-lsp-dynamic-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_dynamic_debug = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_dynamic_debug(self):
    self.__bypass_lsp_dynamic_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-debug", rest_name="bypass-lsp-dynamic-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_dynamic_name(self):
    """
    Getter method for bypass_lsp_dynamic_name, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic_name (string)

    YANG Description: Show one dynamic bypass-lsp detailed info by name
    """
    return self.__bypass_lsp_dynamic_name
      
  def _set_bypass_lsp_dynamic_name(self, v, load=False):
    """
    Setter method for bypass_lsp_dynamic_name, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_dynamic_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_dynamic_name() directly.

    YANG Description: Show one dynamic bypass-lsp detailed info by name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="bypass-lsp-dynamic-name", rest_name="bypass-lsp-dynamic-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_dynamic_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp-dynamic-name", rest_name="bypass-lsp-dynamic-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__bypass_lsp_dynamic_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_dynamic_name(self):
    self.__bypass_lsp_dynamic_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-lsp-dynamic-name", rest_name="bypass-lsp-dynamic-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_bypass_lsp_dynamic_name_extensive(self):
    """
    Getter method for bypass_lsp_dynamic_name_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic_name_extensive (boolean)

    YANG Description: Show one dynamic bypass-lsp extensive info by name
    """
    return self.__bypass_lsp_dynamic_name_extensive
      
  def _set_bypass_lsp_dynamic_name_extensive(self, v, load=False):
    """
    Setter method for bypass_lsp_dynamic_name_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic_name_extensive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_dynamic_name_extensive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_dynamic_name_extensive() directly.

    YANG Description: Show one dynamic bypass-lsp extensive info by name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-name-extensive", rest_name="bypass-lsp-dynamic-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_dynamic_name_extensive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-name-extensive", rest_name="bypass-lsp-dynamic-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_dynamic_name_extensive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_dynamic_name_extensive(self):
    self.__bypass_lsp_dynamic_name_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-name-extensive", rest_name="bypass-lsp-dynamic-name-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_bypass_lsp_dynamic_name_debug(self):
    """
    Getter method for bypass_lsp_dynamic_name_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic_name_debug (boolean)

    YANG Description: Show one dynamic bypass-lsp extensive debug info by name
    """
    return self.__bypass_lsp_dynamic_name_debug
      
  def _set_bypass_lsp_dynamic_name_debug(self, v, load=False):
    """
    Setter method for bypass_lsp_dynamic_name_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/bypass_lsp_dynamic_name_debug (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_dynamic_name_debug is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_dynamic_name_debug() directly.

    YANG Description: Show one dynamic bypass-lsp extensive debug info by name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-name-debug", rest_name="bypass-lsp-dynamic-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_dynamic_name_debug must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-name-debug", rest_name="bypass-lsp-dynamic-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_lsp_dynamic_name_debug = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_dynamic_name_debug(self):
    self.__bypass_lsp_dynamic_name_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-lsp-dynamic-name-debug", rest_name="bypass-lsp-dynamic-name-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsp_input_lsp_name(self):
    """
    Getter method for lsp_input_lsp_name, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_lsp_name (string)

    YANG Description: Lsp name for show lsp command
    """
    return self.__lsp_input_lsp_name
      
  def _set_lsp_input_lsp_name(self, v, load=False):
    """
    Setter method for lsp_input_lsp_name, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_lsp_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_input_lsp_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_input_lsp_name() directly.

    YANG Description: Lsp name for show lsp command
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="lsp-input-lsp-name", rest_name="lsp-input-lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_input_lsp_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="lsp-input-lsp-name", rest_name="lsp-input-lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__lsp_input_lsp_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_input_lsp_name(self):
    self.__lsp_input_lsp_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="lsp-input-lsp-name", rest_name="lsp-input-lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_lsp_input_bypass(self):
    """
    Getter method for lsp_input_bypass, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_bypass (boolean)

    YANG Description: Lsp type is bypass show lsp command
    """
    return self.__lsp_input_bypass
      
  def _set_lsp_input_bypass(self, v, load=False):
    """
    Setter method for lsp_input_bypass, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_bypass (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_input_bypass is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_input_bypass() directly.

    YANG Description: Lsp type is bypass show lsp command
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-input-bypass", rest_name="lsp-input-bypass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_input_bypass must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-bypass", rest_name="lsp-input-bypass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_input_bypass = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_input_bypass(self):
    self.__lsp_input_bypass = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-bypass", rest_name="lsp-input-bypass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsp_input_dynamic(self):
    """
    Getter method for lsp_input_dynamic, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_dynamic (boolean)

    YANG Description: Lsp type is dynamically created show lsp command
    """
    return self.__lsp_input_dynamic
      
  def _set_lsp_input_dynamic(self, v, load=False):
    """
    Setter method for lsp_input_dynamic, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_dynamic (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_input_dynamic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_input_dynamic() directly.

    YANG Description: Lsp type is dynamically created show lsp command
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-input-dynamic", rest_name="lsp-input-dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_input_dynamic must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-dynamic", rest_name="lsp-input-dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_input_dynamic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_input_dynamic(self):
    self.__lsp_input_dynamic = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-dynamic", rest_name="lsp-input-dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsp_input_brief(self):
    """
    Getter method for lsp_input_brief, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_brief (boolean)

    YANG Description: Lsp show type is brief
    """
    return self.__lsp_input_brief
      
  def _set_lsp_input_brief(self, v, load=False):
    """
    Setter method for lsp_input_brief, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_brief (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_input_brief is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_input_brief() directly.

    YANG Description: Lsp show type is brief
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-input-brief", rest_name="lsp-input-brief", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_input_brief must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-brief", rest_name="lsp-input-brief", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_input_brief = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_input_brief(self):
    self.__lsp_input_brief = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-brief", rest_name="lsp-input-brief", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsp_input_wide(self):
    """
    Getter method for lsp_input_wide, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_wide (boolean)

    YANG Description: Lsp show type is brief and wide
    """
    return self.__lsp_input_wide
      
  def _set_lsp_input_wide(self, v, load=False):
    """
    Setter method for lsp_input_wide, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_wide (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_input_wide is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_input_wide() directly.

    YANG Description: Lsp show type is brief and wide
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-input-wide", rest_name="lsp-input-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_input_wide must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-wide", rest_name="lsp-input-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_input_wide = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_input_wide(self):
    self.__lsp_input_wide = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-wide", rest_name="lsp-input-wide", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsp_input_detail(self):
    """
    Getter method for lsp_input_detail, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_detail (boolean)

    YANG Description: Lsp show type is detail
    """
    return self.__lsp_input_detail
      
  def _set_lsp_input_detail(self, v, load=False):
    """
    Setter method for lsp_input_detail, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_detail (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_input_detail is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_input_detail() directly.

    YANG Description: Lsp show type is detail
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-input-detail", rest_name="lsp-input-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_input_detail must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-detail", rest_name="lsp-input-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_input_detail = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_input_detail(self):
    self.__lsp_input_detail = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-detail", rest_name="lsp-input-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsp_input_extensive(self):
    """
    Getter method for lsp_input_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_extensive (boolean)

    YANG Description: Lsp show type is extensive
    """
    return self.__lsp_input_extensive
      
  def _set_lsp_input_extensive(self, v, load=False):
    """
    Setter method for lsp_input_extensive, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_extensive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_input_extensive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_input_extensive() directly.

    YANG Description: Lsp show type is extensive
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-input-extensive", rest_name="lsp-input-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_input_extensive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-extensive", rest_name="lsp-input-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_input_extensive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_input_extensive(self):
    self.__lsp_input_extensive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-extensive", rest_name="lsp-input-extensive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsp_input_debug(self):
    """
    Getter method for lsp_input_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_debug (boolean)

    YANG Description: Lsp show type is debug
    """
    return self.__lsp_input_debug
      
  def _set_lsp_input_debug(self, v, load=False):
    """
    Setter method for lsp_input_debug, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_debug (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_input_debug is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_input_debug() directly.

    YANG Description: Lsp show type is debug
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-input-debug", rest_name="lsp-input-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_input_debug must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-debug", rest_name="lsp-input-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_input_debug = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_input_debug(self):
    self.__lsp_input_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-debug", rest_name="lsp-input-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsp_input_one(self):
    """
    Getter method for lsp_input_one, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_one (boolean)

    YANG Description: One Lsp show
    """
    return self.__lsp_input_one
      
  def _set_lsp_input_one(self, v, load=False):
    """
    Setter method for lsp_input_one, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_one (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_input_one is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_input_one() directly.

    YANG Description: One Lsp show
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-input-one", rest_name="lsp-input-one", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_input_one must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-one", rest_name="lsp-input-one", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_input_one = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_input_one(self):
    self.__lsp_input_one = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-one", rest_name="lsp-input-one", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsp_input_all(self):
    """
    Getter method for lsp_input_all, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_all (boolean)

    YANG Description: All Lsp show
    """
    return self.__lsp_input_all
      
  def _set_lsp_input_all(self, v, load=False):
    """
    Setter method for lsp_input_all, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_all (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_input_all is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_input_all() directly.

    YANG Description: All Lsp show
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-input-all", rest_name="lsp-input-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_input_all must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-all", rest_name="lsp-input-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_input_all = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_input_all(self):
    self.__lsp_input_all = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-all", rest_name="lsp-input-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsp_input_more(self):
    """
    Getter method for lsp_input_more, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_more (boolean)

    YANG Description: More Lsps to show
    """
    return self.__lsp_input_more
      
  def _set_lsp_input_more(self, v, load=False):
    """
    Setter method for lsp_input_more, mapped from YANG variable /brocade_mpls_rpc/show_mpls_bypass_lsp_name_detail/input/show_lsp_input_info/lsp_input_more (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_input_more is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_input_more() directly.

    YANG Description: More Lsps to show
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsp-input-more", rest_name="lsp-input-more", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_input_more must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-more", rest_name="lsp-input-more", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsp_input_more = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_input_more(self):
    self.__lsp_input_more = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsp-input-more", rest_name="lsp-input-more", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)

  lsp = __builtin__.property(_get_lsp, _set_lsp)
  lsp_wide = __builtin__.property(_get_lsp_wide, _set_lsp_wide)
  lsp_detail = __builtin__.property(_get_lsp_detail, _set_lsp_detail)
  lsp_extensive = __builtin__.property(_get_lsp_extensive, _set_lsp_extensive)
  lsp_debug = __builtin__.property(_get_lsp_debug, _set_lsp_debug)
  lsp_name = __builtin__.property(_get_lsp_name, _set_lsp_name)
  lsp_name_extensive = __builtin__.property(_get_lsp_name_extensive, _set_lsp_name_extensive)
  lsp_name_debug = __builtin__.property(_get_lsp_name_debug, _set_lsp_name_debug)
  bypass_lsp = __builtin__.property(_get_bypass_lsp, _set_bypass_lsp)
  bypass_lsp_wide = __builtin__.property(_get_bypass_lsp_wide, _set_bypass_lsp_wide)
  bypass_lsp_detail = __builtin__.property(_get_bypass_lsp_detail, _set_bypass_lsp_detail)
  bypass_lsp_extensive = __builtin__.property(_get_bypass_lsp_extensive, _set_bypass_lsp_extensive)
  bypass_lsp_debug = __builtin__.property(_get_bypass_lsp_debug, _set_bypass_lsp_debug)
  bypass_lsp_name = __builtin__.property(_get_bypass_lsp_name, _set_bypass_lsp_name)
  bypass_lsp_name_extensive = __builtin__.property(_get_bypass_lsp_name_extensive, _set_bypass_lsp_name_extensive)
  bypass_lsp_name_debug = __builtin__.property(_get_bypass_lsp_name_debug, _set_bypass_lsp_name_debug)
  bypass_lsp_static = __builtin__.property(_get_bypass_lsp_static, _set_bypass_lsp_static)
  bypass_lsp_static_wide = __builtin__.property(_get_bypass_lsp_static_wide, _set_bypass_lsp_static_wide)
  bypass_lsp_static_detail = __builtin__.property(_get_bypass_lsp_static_detail, _set_bypass_lsp_static_detail)
  bypass_lsp_static_extensive = __builtin__.property(_get_bypass_lsp_static_extensive, _set_bypass_lsp_static_extensive)
  bypass_lsp_static_debug = __builtin__.property(_get_bypass_lsp_static_debug, _set_bypass_lsp_static_debug)
  bypass_lsp_static_name = __builtin__.property(_get_bypass_lsp_static_name, _set_bypass_lsp_static_name)
  bypass_lsp_static_name_extensive = __builtin__.property(_get_bypass_lsp_static_name_extensive, _set_bypass_lsp_static_name_extensive)
  bypass_lsp_static_name_debug = __builtin__.property(_get_bypass_lsp_static_name_debug, _set_bypass_lsp_static_name_debug)
  bypass_lsp_dynamic = __builtin__.property(_get_bypass_lsp_dynamic, _set_bypass_lsp_dynamic)
  bypass_lsp_dynamic_wide = __builtin__.property(_get_bypass_lsp_dynamic_wide, _set_bypass_lsp_dynamic_wide)
  bypass_lsp_dynamic_detail = __builtin__.property(_get_bypass_lsp_dynamic_detail, _set_bypass_lsp_dynamic_detail)
  bypass_lsp_dynamic_extensive = __builtin__.property(_get_bypass_lsp_dynamic_extensive, _set_bypass_lsp_dynamic_extensive)
  bypass_lsp_dynamic_debug = __builtin__.property(_get_bypass_lsp_dynamic_debug, _set_bypass_lsp_dynamic_debug)
  bypass_lsp_dynamic_name = __builtin__.property(_get_bypass_lsp_dynamic_name, _set_bypass_lsp_dynamic_name)
  bypass_lsp_dynamic_name_extensive = __builtin__.property(_get_bypass_lsp_dynamic_name_extensive, _set_bypass_lsp_dynamic_name_extensive)
  bypass_lsp_dynamic_name_debug = __builtin__.property(_get_bypass_lsp_dynamic_name_debug, _set_bypass_lsp_dynamic_name_debug)
  lsp_input_lsp_name = __builtin__.property(_get_lsp_input_lsp_name, _set_lsp_input_lsp_name)
  lsp_input_bypass = __builtin__.property(_get_lsp_input_bypass, _set_lsp_input_bypass)
  lsp_input_dynamic = __builtin__.property(_get_lsp_input_dynamic, _set_lsp_input_dynamic)
  lsp_input_brief = __builtin__.property(_get_lsp_input_brief, _set_lsp_input_brief)
  lsp_input_wide = __builtin__.property(_get_lsp_input_wide, _set_lsp_input_wide)
  lsp_input_detail = __builtin__.property(_get_lsp_input_detail, _set_lsp_input_detail)
  lsp_input_extensive = __builtin__.property(_get_lsp_input_extensive, _set_lsp_input_extensive)
  lsp_input_debug = __builtin__.property(_get_lsp_input_debug, _set_lsp_input_debug)
  lsp_input_one = __builtin__.property(_get_lsp_input_one, _set_lsp_input_one)
  lsp_input_all = __builtin__.property(_get_lsp_input_all, _set_lsp_input_all)
  lsp_input_more = __builtin__.property(_get_lsp_input_more, _set_lsp_input_more)


  _pyangbind_elements = {'lsp': lsp, 'lsp_wide': lsp_wide, 'lsp_detail': lsp_detail, 'lsp_extensive': lsp_extensive, 'lsp_debug': lsp_debug, 'lsp_name': lsp_name, 'lsp_name_extensive': lsp_name_extensive, 'lsp_name_debug': lsp_name_debug, 'bypass_lsp': bypass_lsp, 'bypass_lsp_wide': bypass_lsp_wide, 'bypass_lsp_detail': bypass_lsp_detail, 'bypass_lsp_extensive': bypass_lsp_extensive, 'bypass_lsp_debug': bypass_lsp_debug, 'bypass_lsp_name': bypass_lsp_name, 'bypass_lsp_name_extensive': bypass_lsp_name_extensive, 'bypass_lsp_name_debug': bypass_lsp_name_debug, 'bypass_lsp_static': bypass_lsp_static, 'bypass_lsp_static_wide': bypass_lsp_static_wide, 'bypass_lsp_static_detail': bypass_lsp_static_detail, 'bypass_lsp_static_extensive': bypass_lsp_static_extensive, 'bypass_lsp_static_debug': bypass_lsp_static_debug, 'bypass_lsp_static_name': bypass_lsp_static_name, 'bypass_lsp_static_name_extensive': bypass_lsp_static_name_extensive, 'bypass_lsp_static_name_debug': bypass_lsp_static_name_debug, 'bypass_lsp_dynamic': bypass_lsp_dynamic, 'bypass_lsp_dynamic_wide': bypass_lsp_dynamic_wide, 'bypass_lsp_dynamic_detail': bypass_lsp_dynamic_detail, 'bypass_lsp_dynamic_extensive': bypass_lsp_dynamic_extensive, 'bypass_lsp_dynamic_debug': bypass_lsp_dynamic_debug, 'bypass_lsp_dynamic_name': bypass_lsp_dynamic_name, 'bypass_lsp_dynamic_name_extensive': bypass_lsp_dynamic_name_extensive, 'bypass_lsp_dynamic_name_debug': bypass_lsp_dynamic_name_debug, 'lsp_input_lsp_name': lsp_input_lsp_name, 'lsp_input_bypass': lsp_input_bypass, 'lsp_input_dynamic': lsp_input_dynamic, 'lsp_input_brief': lsp_input_brief, 'lsp_input_wide': lsp_input_wide, 'lsp_input_detail': lsp_input_detail, 'lsp_input_extensive': lsp_input_extensive, 'lsp_input_debug': lsp_input_debug, 'lsp_input_one': lsp_input_one, 'lsp_input_all': lsp_input_all, 'lsp_input_more': lsp_input_more, }


