
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import interfaces
import addresses
class summary(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls - based on the path /brocade_mpls_rpc/get-mpls-ldp-session-detail/output/mpls-ldp-session-detail/summary. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__peerLdpId','__localLdpId','__state','__adjacency','__role','__nextKeepAlive','__isRetry','__nextRetry','__maxHold','__timeLeft','__keepaliveInterval','__localKeepaliveTimeout','__peerProposedKeepaliveTimeout','__sessionUpTime','__md5AuthKey','__tcpConnLocal','__tcpConnRemote','__tcpState','__numFecsReceivedFromPeer','__numFecsInstalledFromPeer','__isFecsPendingUninstall','__numFecsFilteredOut','__numFecsFilteredIn','__outFilterPrefixList','__outFilterPrefixListExists','__isOnlyGRValid','__grEnabled','__peerReconectTime','__peerRecoveryTime','__isInUse','__reconnectOrRecovery','__grTimeInUse','__grTimeRemaining','__grState','__localEolUnrecognizedNotification','__remoteEolUnrecognizedNotification','__doesSessionSupportEol','__localState','__remoteState','__eolNotificationTime','__eolNotificationTimeRemaining','__eolTxLabelSilenceTime','__eolTxLabelSilenceTimeRunning','__eolRxLabelSilenceTime','__eolRxLabelSilenceTimeRunning','__interfaces','__addresses',)

  _yang_name = 'summary'
  _rest_name = 'summary'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__eolTxLabelSilenceTimeRunning = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolTxLabelSilenceTimeRunning", rest_name="eolTxLabelSilenceTimeRunning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__isFecsPendingUninstall = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isFecsPendingUninstall", rest_name="isFecsPendingUninstall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__outFilterPrefixListExists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="outFilterPrefixListExists", rest_name="outFilterPrefixListExists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__addresses = YANGDynClass(base=YANGListType("address",addresses.addresses, yang_name="addresses", rest_name="addresses", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="addresses", rest_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions=None, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)
    self.__isRetry = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isRetry", rest_name="isRetry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__tcpState = YANGDynClass(base=unicode, is_leaf=True, yang_name="tcpState", rest_name="tcpState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__outFilterPrefixList = YANGDynClass(base=unicode, is_leaf=True, yang_name="outFilterPrefixList", rest_name="outFilterPrefixList", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__reconnectOrRecovery = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="reconnectOrRecovery", rest_name="reconnectOrRecovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__isOnlyGRValid = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isOnlyGRValid", rest_name="isOnlyGRValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__numFecsReceivedFromPeer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsReceivedFromPeer", rest_name="numFecsReceivedFromPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__numFecsInstalledFromPeer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsInstalledFromPeer", rest_name="numFecsInstalledFromPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__grState = YANGDynClass(base=unicode, is_leaf=True, yang_name="grState", rest_name="grState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__maxHold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxHold", rest_name="maxHold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__peerRecoveryTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerRecoveryTime", rest_name="peerRecoveryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__numFecsFilteredOut = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsFilteredOut", rest_name="numFecsFilteredOut", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__localLdpId = YANGDynClass(base=unicode, is_leaf=True, yang_name="localLdpId", rest_name="localLdpId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__localKeepaliveTimeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="localKeepaliveTimeout", rest_name="localKeepaliveTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__tcpConnRemote = YANGDynClass(base=unicode, is_leaf=True, yang_name="tcpConnRemote", rest_name="tcpConnRemote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__state = YANGDynClass(base=unicode, is_leaf=True, yang_name="state", rest_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__role = YANGDynClass(base=unicode, is_leaf=True, yang_name="role", rest_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__grTimeInUse = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="grTimeInUse", rest_name="grTimeInUse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__doesSessionSupportEol = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="doesSessionSupportEol", rest_name="doesSessionSupportEol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__eolNotificationTimeRemaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolNotificationTimeRemaining", rest_name="eolNotificationTimeRemaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__grTimeRemaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="grTimeRemaining", rest_name="grTimeRemaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__timeLeft = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="timeLeft", rest_name="timeLeft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__sessionUpTime = YANGDynClass(base=unicode, is_leaf=True, yang_name="sessionUpTime", rest_name="sessionUpTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__nextRetry = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nextRetry", rest_name="nextRetry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__numFecsFilteredIn = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsFilteredIn", rest_name="numFecsFilteredIn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__md5AuthKey = YANGDynClass(base=unicode, is_leaf=True, yang_name="md5AuthKey", rest_name="md5AuthKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__interfaces = YANGDynClass(base=YANGListType("interface",interfaces.interfaces, yang_name="interfaces", rest_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="interfaces", rest_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions=None, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)
    self.__adjacency = YANGDynClass(base=unicode, is_leaf=True, yang_name="adjacency", rest_name="adjacency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__keepaliveInterval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="keepaliveInterval", rest_name="keepaliveInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__eolTxLabelSilenceTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolTxLabelSilenceTime", rest_name="eolTxLabelSilenceTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__peerLdpId = YANGDynClass(base=unicode, is_leaf=True, yang_name="peerLdpId", rest_name="peerLdpId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__remoteEolUnrecognizedNotification = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="remoteEolUnrecognizedNotification", rest_name="remoteEolUnrecognizedNotification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__eolRxLabelSilenceTimeRunning = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolRxLabelSilenceTimeRunning", rest_name="eolRxLabelSilenceTimeRunning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__tcpConnLocal = YANGDynClass(base=unicode, is_leaf=True, yang_name="tcpConnLocal", rest_name="tcpConnLocal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__grEnabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="grEnabled", rest_name="grEnabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__peerProposedKeepaliveTimeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerProposedKeepaliveTimeout", rest_name="peerProposedKeepaliveTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__eolNotificationTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolNotificationTime", rest_name="eolNotificationTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__remoteState = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="remoteState", rest_name="remoteState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__localState = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="localState", rest_name="localState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__isInUse = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isInUse", rest_name="isInUse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__peerReconectTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerReconectTime", rest_name="peerReconectTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__eolRxLabelSilenceTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolRxLabelSilenceTime", rest_name="eolRxLabelSilenceTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__localEolUnrecognizedNotification = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="localEolUnrecognizedNotification", rest_name="localEolUnrecognizedNotification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__nextKeepAlive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nextKeepAlive", rest_name="nextKeepAlive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'brocade_mpls_rpc', u'get-mpls-ldp-session-detail', u'output', u'mpls-ldp-session-detail', u'summary']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'get-mpls-ldp-session-detail', u'output', u'mpls-ldp-session-detail', u'summary']

  def _get_peerLdpId(self):
    """
    Getter method for peerLdpId, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/peerLdpId (string)

    YANG Description: Peer LDP ID
    """
    return self.__peerLdpId
      
  def _set_peerLdpId(self, v, load=False):
    """
    Setter method for peerLdpId, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/peerLdpId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerLdpId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerLdpId() directly.

    YANG Description: Peer LDP ID
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="peerLdpId", rest_name="peerLdpId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerLdpId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="peerLdpId", rest_name="peerLdpId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__peerLdpId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerLdpId(self):
    self.__peerLdpId = YANGDynClass(base=unicode, is_leaf=True, yang_name="peerLdpId", rest_name="peerLdpId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_localLdpId(self):
    """
    Getter method for localLdpId, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/localLdpId (string)

    YANG Description: Local LDP ID
    """
    return self.__localLdpId
      
  def _set_localLdpId(self, v, load=False):
    """
    Setter method for localLdpId, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/localLdpId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localLdpId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localLdpId() directly.

    YANG Description: Local LDP ID
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="localLdpId", rest_name="localLdpId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localLdpId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="localLdpId", rest_name="localLdpId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__localLdpId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localLdpId(self):
    self.__localLdpId = YANGDynClass(base=unicode, is_leaf=True, yang_name="localLdpId", rest_name="localLdpId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/state (string)

    YANG Description: Session State
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/state (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Session State
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="state", rest_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="state", rest_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=unicode, is_leaf=True, yang_name="state", rest_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_adjacency(self):
    """
    Getter method for adjacency, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/adjacency (string)

    YANG Description: Adjacency Used
    """
    return self.__adjacency
      
  def _set_adjacency(self, v, load=False):
    """
    Setter method for adjacency, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/adjacency (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjacency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjacency() directly.

    YANG Description: Adjacency Used
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="adjacency", rest_name="adjacency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjacency must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="adjacency", rest_name="adjacency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__adjacency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjacency(self):
    self.__adjacency = YANGDynClass(base=unicode, is_leaf=True, yang_name="adjacency", rest_name="adjacency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_role(self):
    """
    Getter method for role, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/role (string)

    YANG Description: My Role
    """
    return self.__role
      
  def _set_role(self, v, load=False):
    """
    Setter method for role, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/role (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.

    YANG Description: My Role
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="role", rest_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """role must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="role", rest_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_role(self):
    self.__role = YANGDynClass(base=unicode, is_leaf=True, yang_name="role", rest_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_nextKeepAlive(self):
    """
    Getter method for nextKeepAlive, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/nextKeepAlive (uint32)

    YANG Description: Max Hold Time
    """
    return self.__nextKeepAlive
      
  def _set_nextKeepAlive(self, v, load=False):
    """
    Setter method for nextKeepAlive, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/nextKeepAlive (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nextKeepAlive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nextKeepAlive() directly.

    YANG Description: Max Hold Time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nextKeepAlive", rest_name="nextKeepAlive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nextKeepAlive must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nextKeepAlive", rest_name="nextKeepAlive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__nextKeepAlive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nextKeepAlive(self):
    self.__nextKeepAlive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nextKeepAlive", rest_name="nextKeepAlive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_isRetry(self):
    """
    Getter method for isRetry, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/isRetry (boolean)

    YANG Description: Is Retrying
    """
    return self.__isRetry
      
  def _set_isRetry(self, v, load=False):
    """
    Setter method for isRetry, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/isRetry (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isRetry is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isRetry() directly.

    YANG Description: Is Retrying
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="isRetry", rest_name="isRetry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isRetry must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isRetry", rest_name="isRetry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__isRetry = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isRetry(self):
    self.__isRetry = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isRetry", rest_name="isRetry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_nextRetry(self):
    """
    Getter method for nextRetry, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/nextRetry (uint32)

    YANG Description: Next Retry Time
    """
    return self.__nextRetry
      
  def _set_nextRetry(self, v, load=False):
    """
    Setter method for nextRetry, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/nextRetry (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nextRetry is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nextRetry() directly.

    YANG Description: Next Retry Time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nextRetry", rest_name="nextRetry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nextRetry must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nextRetry", rest_name="nextRetry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__nextRetry = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nextRetry(self):
    self.__nextRetry = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nextRetry", rest_name="nextRetry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_maxHold(self):
    """
    Getter method for maxHold, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/maxHold (uint32)

    YANG Description: Max Hold Time
    """
    return self.__maxHold
      
  def _set_maxHold(self, v, load=False):
    """
    Setter method for maxHold, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/maxHold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxHold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxHold() directly.

    YANG Description: Max Hold Time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxHold", rest_name="maxHold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxHold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxHold", rest_name="maxHold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__maxHold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxHold(self):
    self.__maxHold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxHold", rest_name="maxHold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_timeLeft(self):
    """
    Getter method for timeLeft, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/timeLeft (uint32)

    YANG Description: Hold time left
    """
    return self.__timeLeft
      
  def _set_timeLeft(self, v, load=False):
    """
    Setter method for timeLeft, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/timeLeft (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeLeft is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeLeft() directly.

    YANG Description: Hold time left
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="timeLeft", rest_name="timeLeft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeLeft must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="timeLeft", rest_name="timeLeft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__timeLeft = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeLeft(self):
    self.__timeLeft = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="timeLeft", rest_name="timeLeft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_keepaliveInterval(self):
    """
    Getter method for keepaliveInterval, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/keepaliveInterval (uint32)

    YANG Description: Keepalive Interval
    """
    return self.__keepaliveInterval
      
  def _set_keepaliveInterval(self, v, load=False):
    """
    Setter method for keepaliveInterval, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/keepaliveInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepaliveInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepaliveInterval() directly.

    YANG Description: Keepalive Interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="keepaliveInterval", rest_name="keepaliveInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepaliveInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="keepaliveInterval", rest_name="keepaliveInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__keepaliveInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepaliveInterval(self):
    self.__keepaliveInterval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="keepaliveInterval", rest_name="keepaliveInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_localKeepaliveTimeout(self):
    """
    Getter method for localKeepaliveTimeout, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/localKeepaliveTimeout (uint32)

    YANG Description: Local keepalive timeout
    """
    return self.__localKeepaliveTimeout
      
  def _set_localKeepaliveTimeout(self, v, load=False):
    """
    Setter method for localKeepaliveTimeout, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/localKeepaliveTimeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localKeepaliveTimeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localKeepaliveTimeout() directly.

    YANG Description: Local keepalive timeout
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="localKeepaliveTimeout", rest_name="localKeepaliveTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localKeepaliveTimeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="localKeepaliveTimeout", rest_name="localKeepaliveTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__localKeepaliveTimeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localKeepaliveTimeout(self):
    self.__localKeepaliveTimeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="localKeepaliveTimeout", rest_name="localKeepaliveTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_peerProposedKeepaliveTimeout(self):
    """
    Getter method for peerProposedKeepaliveTimeout, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/peerProposedKeepaliveTimeout (uint32)

    YANG Description: Peer Proposed keepalive timeout
    """
    return self.__peerProposedKeepaliveTimeout
      
  def _set_peerProposedKeepaliveTimeout(self, v, load=False):
    """
    Setter method for peerProposedKeepaliveTimeout, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/peerProposedKeepaliveTimeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerProposedKeepaliveTimeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerProposedKeepaliveTimeout() directly.

    YANG Description: Peer Proposed keepalive timeout
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerProposedKeepaliveTimeout", rest_name="peerProposedKeepaliveTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerProposedKeepaliveTimeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerProposedKeepaliveTimeout", rest_name="peerProposedKeepaliveTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__peerProposedKeepaliveTimeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerProposedKeepaliveTimeout(self):
    self.__peerProposedKeepaliveTimeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerProposedKeepaliveTimeout", rest_name="peerProposedKeepaliveTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_sessionUpTime(self):
    """
    Getter method for sessionUpTime, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/sessionUpTime (string)

    YANG Description: Up Time
    """
    return self.__sessionUpTime
      
  def _set_sessionUpTime(self, v, load=False):
    """
    Setter method for sessionUpTime, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/sessionUpTime (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sessionUpTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sessionUpTime() directly.

    YANG Description: Up Time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="sessionUpTime", rest_name="sessionUpTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sessionUpTime must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="sessionUpTime", rest_name="sessionUpTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__sessionUpTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sessionUpTime(self):
    self.__sessionUpTime = YANGDynClass(base=unicode, is_leaf=True, yang_name="sessionUpTime", rest_name="sessionUpTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_md5AuthKey(self):
    """
    Getter method for md5AuthKey, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/md5AuthKey (string)

    YANG Description: md5AuthKey
    """
    return self.__md5AuthKey
      
  def _set_md5AuthKey(self, v, load=False):
    """
    Setter method for md5AuthKey, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/md5AuthKey (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_md5AuthKey is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_md5AuthKey() directly.

    YANG Description: md5AuthKey
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="md5AuthKey", rest_name="md5AuthKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """md5AuthKey must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="md5AuthKey", rest_name="md5AuthKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__md5AuthKey = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_md5AuthKey(self):
    self.__md5AuthKey = YANGDynClass(base=unicode, is_leaf=True, yang_name="md5AuthKey", rest_name="md5AuthKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_tcpConnLocal(self):
    """
    Getter method for tcpConnLocal, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/tcpConnLocal (string)

    YANG Description: TCP connection local info
    """
    return self.__tcpConnLocal
      
  def _set_tcpConnLocal(self, v, load=False):
    """
    Setter method for tcpConnLocal, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/tcpConnLocal (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcpConnLocal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcpConnLocal() directly.

    YANG Description: TCP connection local info
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tcpConnLocal", rest_name="tcpConnLocal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcpConnLocal must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tcpConnLocal", rest_name="tcpConnLocal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__tcpConnLocal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcpConnLocal(self):
    self.__tcpConnLocal = YANGDynClass(base=unicode, is_leaf=True, yang_name="tcpConnLocal", rest_name="tcpConnLocal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_tcpConnRemote(self):
    """
    Getter method for tcpConnRemote, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/tcpConnRemote (string)

    YANG Description: TCP connection remote info
    """
    return self.__tcpConnRemote
      
  def _set_tcpConnRemote(self, v, load=False):
    """
    Setter method for tcpConnRemote, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/tcpConnRemote (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcpConnRemote is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcpConnRemote() directly.

    YANG Description: TCP connection remote info
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tcpConnRemote", rest_name="tcpConnRemote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcpConnRemote must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tcpConnRemote", rest_name="tcpConnRemote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__tcpConnRemote = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcpConnRemote(self):
    self.__tcpConnRemote = YANGDynClass(base=unicode, is_leaf=True, yang_name="tcpConnRemote", rest_name="tcpConnRemote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_tcpState(self):
    """
    Getter method for tcpState, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/tcpState (string)

    YANG Description: TCP connection state
    """
    return self.__tcpState
      
  def _set_tcpState(self, v, load=False):
    """
    Setter method for tcpState, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/tcpState (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcpState is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcpState() directly.

    YANG Description: TCP connection state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tcpState", rest_name="tcpState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcpState must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tcpState", rest_name="tcpState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__tcpState = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcpState(self):
    self.__tcpState = YANGDynClass(base=unicode, is_leaf=True, yang_name="tcpState", rest_name="tcpState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_numFecsReceivedFromPeer(self):
    """
    Getter method for numFecsReceivedFromPeer, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/numFecsReceivedFromPeer (uint32)

    YANG Description: Number of FECs received from peer
    """
    return self.__numFecsReceivedFromPeer
      
  def _set_numFecsReceivedFromPeer(self, v, load=False):
    """
    Setter method for numFecsReceivedFromPeer, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/numFecsReceivedFromPeer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numFecsReceivedFromPeer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numFecsReceivedFromPeer() directly.

    YANG Description: Number of FECs received from peer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsReceivedFromPeer", rest_name="numFecsReceivedFromPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """numFecsReceivedFromPeer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsReceivedFromPeer", rest_name="numFecsReceivedFromPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__numFecsReceivedFromPeer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_numFecsReceivedFromPeer(self):
    self.__numFecsReceivedFromPeer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsReceivedFromPeer", rest_name="numFecsReceivedFromPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_numFecsInstalledFromPeer(self):
    """
    Getter method for numFecsInstalledFromPeer, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/numFecsInstalledFromPeer (uint32)

    YANG Description: Number of FECs installed from peer
    """
    return self.__numFecsInstalledFromPeer
      
  def _set_numFecsInstalledFromPeer(self, v, load=False):
    """
    Setter method for numFecsInstalledFromPeer, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/numFecsInstalledFromPeer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numFecsInstalledFromPeer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numFecsInstalledFromPeer() directly.

    YANG Description: Number of FECs installed from peer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsInstalledFromPeer", rest_name="numFecsInstalledFromPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """numFecsInstalledFromPeer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsInstalledFromPeer", rest_name="numFecsInstalledFromPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__numFecsInstalledFromPeer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_numFecsInstalledFromPeer(self):
    self.__numFecsInstalledFromPeer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsInstalledFromPeer", rest_name="numFecsInstalledFromPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_isFecsPendingUninstall(self):
    """
    Getter method for isFecsPendingUninstall, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/isFecsPendingUninstall (boolean)

    YANG Description: FECs pending uninstall status
    """
    return self.__isFecsPendingUninstall
      
  def _set_isFecsPendingUninstall(self, v, load=False):
    """
    Setter method for isFecsPendingUninstall, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/isFecsPendingUninstall (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isFecsPendingUninstall is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isFecsPendingUninstall() directly.

    YANG Description: FECs pending uninstall status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="isFecsPendingUninstall", rest_name="isFecsPendingUninstall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isFecsPendingUninstall must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isFecsPendingUninstall", rest_name="isFecsPendingUninstall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__isFecsPendingUninstall = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isFecsPendingUninstall(self):
    self.__isFecsPendingUninstall = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isFecsPendingUninstall", rest_name="isFecsPendingUninstall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_numFecsFilteredOut(self):
    """
    Getter method for numFecsFilteredOut, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/numFecsFilteredOut (uint32)

    YANG Description: Number of outbound FECs filtered out
    """
    return self.__numFecsFilteredOut
      
  def _set_numFecsFilteredOut(self, v, load=False):
    """
    Setter method for numFecsFilteredOut, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/numFecsFilteredOut (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numFecsFilteredOut is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numFecsFilteredOut() directly.

    YANG Description: Number of outbound FECs filtered out
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsFilteredOut", rest_name="numFecsFilteredOut", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """numFecsFilteredOut must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsFilteredOut", rest_name="numFecsFilteredOut", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__numFecsFilteredOut = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_numFecsFilteredOut(self):
    self.__numFecsFilteredOut = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsFilteredOut", rest_name="numFecsFilteredOut", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_numFecsFilteredIn(self):
    """
    Getter method for numFecsFilteredIn, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/numFecsFilteredIn (uint32)

    YANG Description: Number of inbound FECs filtered out
    """
    return self.__numFecsFilteredIn
      
  def _set_numFecsFilteredIn(self, v, load=False):
    """
    Setter method for numFecsFilteredIn, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/numFecsFilteredIn (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numFecsFilteredIn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numFecsFilteredIn() directly.

    YANG Description: Number of inbound FECs filtered out
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsFilteredIn", rest_name="numFecsFilteredIn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """numFecsFilteredIn must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsFilteredIn", rest_name="numFecsFilteredIn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__numFecsFilteredIn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_numFecsFilteredIn(self):
    self.__numFecsFilteredIn = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numFecsFilteredIn", rest_name="numFecsFilteredIn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_outFilterPrefixList(self):
    """
    Getter method for outFilterPrefixList, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/outFilterPrefixList (string)

    YANG Description: Prefix list used for outbound filtering
    """
    return self.__outFilterPrefixList
      
  def _set_outFilterPrefixList(self, v, load=False):
    """
    Setter method for outFilterPrefixList, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/outFilterPrefixList (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outFilterPrefixList is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outFilterPrefixList() directly.

    YANG Description: Prefix list used for outbound filtering
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="outFilterPrefixList", rest_name="outFilterPrefixList", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outFilterPrefixList must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="outFilterPrefixList", rest_name="outFilterPrefixList", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__outFilterPrefixList = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outFilterPrefixList(self):
    self.__outFilterPrefixList = YANGDynClass(base=unicode, is_leaf=True, yang_name="outFilterPrefixList", rest_name="outFilterPrefixList", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_outFilterPrefixListExists(self):
    """
    Getter method for outFilterPrefixListExists, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/outFilterPrefixListExists (boolean)

    YANG Description: Does prefix list used for outbound filtering exist
    """
    return self.__outFilterPrefixListExists
      
  def _set_outFilterPrefixListExists(self, v, load=False):
    """
    Setter method for outFilterPrefixListExists, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/outFilterPrefixListExists (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outFilterPrefixListExists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outFilterPrefixListExists() directly.

    YANG Description: Does prefix list used for outbound filtering exist
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="outFilterPrefixListExists", rest_name="outFilterPrefixListExists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outFilterPrefixListExists must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="outFilterPrefixListExists", rest_name="outFilterPrefixListExists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__outFilterPrefixListExists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outFilterPrefixListExists(self):
    self.__outFilterPrefixListExists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="outFilterPrefixListExists", rest_name="outFilterPrefixListExists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_isOnlyGRValid(self):
    """
    Getter method for isOnlyGRValid, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/isOnlyGRValid (boolean)

    YANG Description: Only GR info to be printed
    """
    return self.__isOnlyGRValid
      
  def _set_isOnlyGRValid(self, v, load=False):
    """
    Setter method for isOnlyGRValid, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/isOnlyGRValid (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isOnlyGRValid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isOnlyGRValid() directly.

    YANG Description: Only GR info to be printed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="isOnlyGRValid", rest_name="isOnlyGRValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isOnlyGRValid must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isOnlyGRValid", rest_name="isOnlyGRValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__isOnlyGRValid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isOnlyGRValid(self):
    self.__isOnlyGRValid = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isOnlyGRValid", rest_name="isOnlyGRValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_grEnabled(self):
    """
    Getter method for grEnabled, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/grEnabled (boolean)

    YANG Description: GR enabled
    """
    return self.__grEnabled
      
  def _set_grEnabled(self, v, load=False):
    """
    Setter method for grEnabled, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/grEnabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grEnabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grEnabled() directly.

    YANG Description: GR enabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="grEnabled", rest_name="grEnabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grEnabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="grEnabled", rest_name="grEnabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__grEnabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grEnabled(self):
    self.__grEnabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="grEnabled", rest_name="grEnabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_peerReconectTime(self):
    """
    Getter method for peerReconectTime, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/peerReconectTime (uint32)

    YANG Description: Peer Reconnect Time
    """
    return self.__peerReconectTime
      
  def _set_peerReconectTime(self, v, load=False):
    """
    Setter method for peerReconectTime, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/peerReconectTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerReconectTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerReconectTime() directly.

    YANG Description: Peer Reconnect Time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerReconectTime", rest_name="peerReconectTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerReconectTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerReconectTime", rest_name="peerReconectTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__peerReconectTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerReconectTime(self):
    self.__peerReconectTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerReconectTime", rest_name="peerReconectTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_peerRecoveryTime(self):
    """
    Getter method for peerRecoveryTime, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/peerRecoveryTime (uint32)

    YANG Description: Peer Recovery Time
    """
    return self.__peerRecoveryTime
      
  def _set_peerRecoveryTime(self, v, load=False):
    """
    Setter method for peerRecoveryTime, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/peerRecoveryTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerRecoveryTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerRecoveryTime() directly.

    YANG Description: Peer Recovery Time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerRecoveryTime", rest_name="peerRecoveryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerRecoveryTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerRecoveryTime", rest_name="peerRecoveryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__peerRecoveryTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerRecoveryTime(self):
    self.__peerRecoveryTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerRecoveryTime", rest_name="peerRecoveryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_isInUse(self):
    """
    Getter method for isInUse, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/isInUse (boolean)

    YANG Description: GR In use
    """
    return self.__isInUse
      
  def _set_isInUse(self, v, load=False):
    """
    Setter method for isInUse, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/isInUse (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isInUse is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isInUse() directly.

    YANG Description: GR In use
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="isInUse", rest_name="isInUse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isInUse must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isInUse", rest_name="isInUse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__isInUse = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isInUse(self):
    self.__isInUse = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isInUse", rest_name="isInUse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_reconnectOrRecovery(self):
    """
    Getter method for reconnectOrRecovery, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/reconnectOrRecovery (uint8)

    YANG Description: Is Reconnect/Recovery running
    """
    return self.__reconnectOrRecovery
      
  def _set_reconnectOrRecovery(self, v, load=False):
    """
    Setter method for reconnectOrRecovery, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/reconnectOrRecovery (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reconnectOrRecovery is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reconnectOrRecovery() directly.

    YANG Description: Is Reconnect/Recovery running
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="reconnectOrRecovery", rest_name="reconnectOrRecovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reconnectOrRecovery must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="reconnectOrRecovery", rest_name="reconnectOrRecovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__reconnectOrRecovery = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reconnectOrRecovery(self):
    self.__reconnectOrRecovery = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="reconnectOrRecovery", rest_name="reconnectOrRecovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_grTimeInUse(self):
    """
    Getter method for grTimeInUse, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/grTimeInUse (uint32)

    YANG Description: Reconnect/Recovery Time in Use
    """
    return self.__grTimeInUse
      
  def _set_grTimeInUse(self, v, load=False):
    """
    Setter method for grTimeInUse, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/grTimeInUse (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grTimeInUse is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grTimeInUse() directly.

    YANG Description: Reconnect/Recovery Time in Use
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="grTimeInUse", rest_name="grTimeInUse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grTimeInUse must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="grTimeInUse", rest_name="grTimeInUse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__grTimeInUse = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grTimeInUse(self):
    self.__grTimeInUse = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="grTimeInUse", rest_name="grTimeInUse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_grTimeRemaining(self):
    """
    Getter method for grTimeRemaining, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/grTimeRemaining (uint32)

    YANG Description: Reconnect/Recovery Time Remaining
    """
    return self.__grTimeRemaining
      
  def _set_grTimeRemaining(self, v, load=False):
    """
    Setter method for grTimeRemaining, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/grTimeRemaining (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grTimeRemaining is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grTimeRemaining() directly.

    YANG Description: Reconnect/Recovery Time Remaining
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="grTimeRemaining", rest_name="grTimeRemaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grTimeRemaining must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="grTimeRemaining", rest_name="grTimeRemaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__grTimeRemaining = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grTimeRemaining(self):
    self.__grTimeRemaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="grTimeRemaining", rest_name="grTimeRemaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_grState(self):
    """
    Getter method for grState, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/grState (string)

    YANG Description: GR FSM State
    """
    return self.__grState
      
  def _set_grState(self, v, load=False):
    """
    Setter method for grState, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/grState (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grState is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grState() directly.

    YANG Description: GR FSM State
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="grState", rest_name="grState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grState must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="grState", rest_name="grState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__grState = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grState(self):
    self.__grState = YANGDynClass(base=unicode, is_leaf=True, yang_name="grState", rest_name="grState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_localEolUnrecognizedNotification(self):
    """
    Getter method for localEolUnrecognizedNotification, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/localEolUnrecognizedNotification (boolean)

    YANG Description: EOL Local Unrecognized Notification Capability
    """
    return self.__localEolUnrecognizedNotification
      
  def _set_localEolUnrecognizedNotification(self, v, load=False):
    """
    Setter method for localEolUnrecognizedNotification, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/localEolUnrecognizedNotification (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localEolUnrecognizedNotification is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localEolUnrecognizedNotification() directly.

    YANG Description: EOL Local Unrecognized Notification Capability
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="localEolUnrecognizedNotification", rest_name="localEolUnrecognizedNotification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localEolUnrecognizedNotification must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="localEolUnrecognizedNotification", rest_name="localEolUnrecognizedNotification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__localEolUnrecognizedNotification = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localEolUnrecognizedNotification(self):
    self.__localEolUnrecognizedNotification = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="localEolUnrecognizedNotification", rest_name="localEolUnrecognizedNotification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_remoteEolUnrecognizedNotification(self):
    """
    Getter method for remoteEolUnrecognizedNotification, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/remoteEolUnrecognizedNotification (boolean)

    YANG Description: EOL Remote Unrecognized Notification Capability
    """
    return self.__remoteEolUnrecognizedNotification
      
  def _set_remoteEolUnrecognizedNotification(self, v, load=False):
    """
    Setter method for remoteEolUnrecognizedNotification, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/remoteEolUnrecognizedNotification (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remoteEolUnrecognizedNotification is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remoteEolUnrecognizedNotification() directly.

    YANG Description: EOL Remote Unrecognized Notification Capability
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="remoteEolUnrecognizedNotification", rest_name="remoteEolUnrecognizedNotification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remoteEolUnrecognizedNotification must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="remoteEolUnrecognizedNotification", rest_name="remoteEolUnrecognizedNotification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__remoteEolUnrecognizedNotification = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remoteEolUnrecognizedNotification(self):
    self.__remoteEolUnrecognizedNotification = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="remoteEolUnrecognizedNotification", rest_name="remoteEolUnrecognizedNotification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_doesSessionSupportEol(self):
    """
    Getter method for doesSessionSupportEol, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/doesSessionSupportEol (boolean)

    YANG Description: Does session support EOL
    """
    return self.__doesSessionSupportEol
      
  def _set_doesSessionSupportEol(self, v, load=False):
    """
    Setter method for doesSessionSupportEol, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/doesSessionSupportEol (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_doesSessionSupportEol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_doesSessionSupportEol() directly.

    YANG Description: Does session support EOL
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="doesSessionSupportEol", rest_name="doesSessionSupportEol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """doesSessionSupportEol must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="doesSessionSupportEol", rest_name="doesSessionSupportEol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__doesSessionSupportEol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_doesSessionSupportEol(self):
    self.__doesSessionSupportEol = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="doesSessionSupportEol", rest_name="doesSessionSupportEol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_localState(self):
    """
    Getter method for localState, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/localState (boolean)

    YANG Description: Local State
    """
    return self.__localState
      
  def _set_localState(self, v, load=False):
    """
    Setter method for localState, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/localState (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localState is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localState() directly.

    YANG Description: Local State
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="localState", rest_name="localState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localState must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="localState", rest_name="localState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__localState = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localState(self):
    self.__localState = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="localState", rest_name="localState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_remoteState(self):
    """
    Getter method for remoteState, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/remoteState (boolean)

    YANG Description: Remote State
    """
    return self.__remoteState
      
  def _set_remoteState(self, v, load=False):
    """
    Setter method for remoteState, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/remoteState (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remoteState is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remoteState() directly.

    YANG Description: Remote State
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="remoteState", rest_name="remoteState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remoteState must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="remoteState", rest_name="remoteState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__remoteState = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remoteState(self):
    self.__remoteState = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="remoteState", rest_name="remoteState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_eolNotificationTime(self):
    """
    Getter method for eolNotificationTime, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/eolNotificationTime (uint32)

    YANG Description: EOL Notification Time
    """
    return self.__eolNotificationTime
      
  def _set_eolNotificationTime(self, v, load=False):
    """
    Setter method for eolNotificationTime, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/eolNotificationTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eolNotificationTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eolNotificationTime() directly.

    YANG Description: EOL Notification Time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolNotificationTime", rest_name="eolNotificationTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eolNotificationTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolNotificationTime", rest_name="eolNotificationTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__eolNotificationTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eolNotificationTime(self):
    self.__eolNotificationTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolNotificationTime", rest_name="eolNotificationTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_eolNotificationTimeRemaining(self):
    """
    Getter method for eolNotificationTimeRemaining, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/eolNotificationTimeRemaining (uint32)

    YANG Description: EOL Notification Time Remaining
    """
    return self.__eolNotificationTimeRemaining
      
  def _set_eolNotificationTimeRemaining(self, v, load=False):
    """
    Setter method for eolNotificationTimeRemaining, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/eolNotificationTimeRemaining (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eolNotificationTimeRemaining is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eolNotificationTimeRemaining() directly.

    YANG Description: EOL Notification Time Remaining
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolNotificationTimeRemaining", rest_name="eolNotificationTimeRemaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eolNotificationTimeRemaining must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolNotificationTimeRemaining", rest_name="eolNotificationTimeRemaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__eolNotificationTimeRemaining = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eolNotificationTimeRemaining(self):
    self.__eolNotificationTimeRemaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolNotificationTimeRemaining", rest_name="eolNotificationTimeRemaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_eolTxLabelSilenceTime(self):
    """
    Getter method for eolTxLabelSilenceTime, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/eolTxLabelSilenceTime (uint32)

    YANG Description: EOL Tx Label Silence Time
    """
    return self.__eolTxLabelSilenceTime
      
  def _set_eolTxLabelSilenceTime(self, v, load=False):
    """
    Setter method for eolTxLabelSilenceTime, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/eolTxLabelSilenceTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eolTxLabelSilenceTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eolTxLabelSilenceTime() directly.

    YANG Description: EOL Tx Label Silence Time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolTxLabelSilenceTime", rest_name="eolTxLabelSilenceTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eolTxLabelSilenceTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolTxLabelSilenceTime", rest_name="eolTxLabelSilenceTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__eolTxLabelSilenceTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eolTxLabelSilenceTime(self):
    self.__eolTxLabelSilenceTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolTxLabelSilenceTime", rest_name="eolTxLabelSilenceTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_eolTxLabelSilenceTimeRunning(self):
    """
    Getter method for eolTxLabelSilenceTimeRunning, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/eolTxLabelSilenceTimeRunning (uint32)

    YANG Description: EOL Tx Label Silence Time Running
    """
    return self.__eolTxLabelSilenceTimeRunning
      
  def _set_eolTxLabelSilenceTimeRunning(self, v, load=False):
    """
    Setter method for eolTxLabelSilenceTimeRunning, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/eolTxLabelSilenceTimeRunning (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eolTxLabelSilenceTimeRunning is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eolTxLabelSilenceTimeRunning() directly.

    YANG Description: EOL Tx Label Silence Time Running
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolTxLabelSilenceTimeRunning", rest_name="eolTxLabelSilenceTimeRunning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eolTxLabelSilenceTimeRunning must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolTxLabelSilenceTimeRunning", rest_name="eolTxLabelSilenceTimeRunning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__eolTxLabelSilenceTimeRunning = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eolTxLabelSilenceTimeRunning(self):
    self.__eolTxLabelSilenceTimeRunning = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolTxLabelSilenceTimeRunning", rest_name="eolTxLabelSilenceTimeRunning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_eolRxLabelSilenceTime(self):
    """
    Getter method for eolRxLabelSilenceTime, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/eolRxLabelSilenceTime (uint32)

    YANG Description: EOL Rx Label Silence Time
    """
    return self.__eolRxLabelSilenceTime
      
  def _set_eolRxLabelSilenceTime(self, v, load=False):
    """
    Setter method for eolRxLabelSilenceTime, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/eolRxLabelSilenceTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eolRxLabelSilenceTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eolRxLabelSilenceTime() directly.

    YANG Description: EOL Rx Label Silence Time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolRxLabelSilenceTime", rest_name="eolRxLabelSilenceTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eolRxLabelSilenceTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolRxLabelSilenceTime", rest_name="eolRxLabelSilenceTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__eolRxLabelSilenceTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eolRxLabelSilenceTime(self):
    self.__eolRxLabelSilenceTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolRxLabelSilenceTime", rest_name="eolRxLabelSilenceTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_eolRxLabelSilenceTimeRunning(self):
    """
    Getter method for eolRxLabelSilenceTimeRunning, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/eolRxLabelSilenceTimeRunning (uint32)

    YANG Description: EOL Rx Label Silence Time Running
    """
    return self.__eolRxLabelSilenceTimeRunning
      
  def _set_eolRxLabelSilenceTimeRunning(self, v, load=False):
    """
    Setter method for eolRxLabelSilenceTimeRunning, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/eolRxLabelSilenceTimeRunning (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eolRxLabelSilenceTimeRunning is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eolRxLabelSilenceTimeRunning() directly.

    YANG Description: EOL Rx Label Silence Time Running
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolRxLabelSilenceTimeRunning", rest_name="eolRxLabelSilenceTimeRunning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eolRxLabelSilenceTimeRunning must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolRxLabelSilenceTimeRunning", rest_name="eolRxLabelSilenceTimeRunning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__eolRxLabelSilenceTimeRunning = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eolRxLabelSilenceTimeRunning(self):
    self.__eolRxLabelSilenceTimeRunning = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eolRxLabelSilenceTimeRunning", rest_name="eolRxLabelSilenceTimeRunning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/interfaces (list)
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/interfaces (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("interface",interfaces.interfaces, yang_name="interfaces", rest_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="interfaces", rest_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions=None, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("interface",interfaces.interfaces, yang_name="interfaces", rest_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="interfaces", rest_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions=None, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=YANGListType("interface",interfaces.interfaces, yang_name="interfaces", rest_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="interfaces", rest_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions=None, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)


  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/addresses (list)
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /brocade_mpls_rpc/get_mpls_ldp_session_detail/output/mpls_ldp_session_detail/summary/addresses (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("address",addresses.addresses, yang_name="addresses", rest_name="addresses", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="addresses", rest_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions=None, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("address",addresses.addresses, yang_name="addresses", rest_name="addresses", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="addresses", rest_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions=None, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=YANGListType("address",addresses.addresses, yang_name="addresses", rest_name="addresses", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="addresses", rest_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions=None, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)

  peerLdpId = __builtin__.property(_get_peerLdpId, _set_peerLdpId)
  localLdpId = __builtin__.property(_get_localLdpId, _set_localLdpId)
  state = __builtin__.property(_get_state, _set_state)
  adjacency = __builtin__.property(_get_adjacency, _set_adjacency)
  role = __builtin__.property(_get_role, _set_role)
  nextKeepAlive = __builtin__.property(_get_nextKeepAlive, _set_nextKeepAlive)
  isRetry = __builtin__.property(_get_isRetry, _set_isRetry)
  nextRetry = __builtin__.property(_get_nextRetry, _set_nextRetry)
  maxHold = __builtin__.property(_get_maxHold, _set_maxHold)
  timeLeft = __builtin__.property(_get_timeLeft, _set_timeLeft)
  keepaliveInterval = __builtin__.property(_get_keepaliveInterval, _set_keepaliveInterval)
  localKeepaliveTimeout = __builtin__.property(_get_localKeepaliveTimeout, _set_localKeepaliveTimeout)
  peerProposedKeepaliveTimeout = __builtin__.property(_get_peerProposedKeepaliveTimeout, _set_peerProposedKeepaliveTimeout)
  sessionUpTime = __builtin__.property(_get_sessionUpTime, _set_sessionUpTime)
  md5AuthKey = __builtin__.property(_get_md5AuthKey, _set_md5AuthKey)
  tcpConnLocal = __builtin__.property(_get_tcpConnLocal, _set_tcpConnLocal)
  tcpConnRemote = __builtin__.property(_get_tcpConnRemote, _set_tcpConnRemote)
  tcpState = __builtin__.property(_get_tcpState, _set_tcpState)
  numFecsReceivedFromPeer = __builtin__.property(_get_numFecsReceivedFromPeer, _set_numFecsReceivedFromPeer)
  numFecsInstalledFromPeer = __builtin__.property(_get_numFecsInstalledFromPeer, _set_numFecsInstalledFromPeer)
  isFecsPendingUninstall = __builtin__.property(_get_isFecsPendingUninstall, _set_isFecsPendingUninstall)
  numFecsFilteredOut = __builtin__.property(_get_numFecsFilteredOut, _set_numFecsFilteredOut)
  numFecsFilteredIn = __builtin__.property(_get_numFecsFilteredIn, _set_numFecsFilteredIn)
  outFilterPrefixList = __builtin__.property(_get_outFilterPrefixList, _set_outFilterPrefixList)
  outFilterPrefixListExists = __builtin__.property(_get_outFilterPrefixListExists, _set_outFilterPrefixListExists)
  isOnlyGRValid = __builtin__.property(_get_isOnlyGRValid, _set_isOnlyGRValid)
  grEnabled = __builtin__.property(_get_grEnabled, _set_grEnabled)
  peerReconectTime = __builtin__.property(_get_peerReconectTime, _set_peerReconectTime)
  peerRecoveryTime = __builtin__.property(_get_peerRecoveryTime, _set_peerRecoveryTime)
  isInUse = __builtin__.property(_get_isInUse, _set_isInUse)
  reconnectOrRecovery = __builtin__.property(_get_reconnectOrRecovery, _set_reconnectOrRecovery)
  grTimeInUse = __builtin__.property(_get_grTimeInUse, _set_grTimeInUse)
  grTimeRemaining = __builtin__.property(_get_grTimeRemaining, _set_grTimeRemaining)
  grState = __builtin__.property(_get_grState, _set_grState)
  localEolUnrecognizedNotification = __builtin__.property(_get_localEolUnrecognizedNotification, _set_localEolUnrecognizedNotification)
  remoteEolUnrecognizedNotification = __builtin__.property(_get_remoteEolUnrecognizedNotification, _set_remoteEolUnrecognizedNotification)
  doesSessionSupportEol = __builtin__.property(_get_doesSessionSupportEol, _set_doesSessionSupportEol)
  localState = __builtin__.property(_get_localState, _set_localState)
  remoteState = __builtin__.property(_get_remoteState, _set_remoteState)
  eolNotificationTime = __builtin__.property(_get_eolNotificationTime, _set_eolNotificationTime)
  eolNotificationTimeRemaining = __builtin__.property(_get_eolNotificationTimeRemaining, _set_eolNotificationTimeRemaining)
  eolTxLabelSilenceTime = __builtin__.property(_get_eolTxLabelSilenceTime, _set_eolTxLabelSilenceTime)
  eolTxLabelSilenceTimeRunning = __builtin__.property(_get_eolTxLabelSilenceTimeRunning, _set_eolTxLabelSilenceTimeRunning)
  eolRxLabelSilenceTime = __builtin__.property(_get_eolRxLabelSilenceTime, _set_eolRxLabelSilenceTime)
  eolRxLabelSilenceTimeRunning = __builtin__.property(_get_eolRxLabelSilenceTimeRunning, _set_eolRxLabelSilenceTimeRunning)
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)
  addresses = __builtin__.property(_get_addresses, _set_addresses)


  _pyangbind_elements = {'peerLdpId': peerLdpId, 'localLdpId': localLdpId, 'state': state, 'adjacency': adjacency, 'role': role, 'nextKeepAlive': nextKeepAlive, 'isRetry': isRetry, 'nextRetry': nextRetry, 'maxHold': maxHold, 'timeLeft': timeLeft, 'keepaliveInterval': keepaliveInterval, 'localKeepaliveTimeout': localKeepaliveTimeout, 'peerProposedKeepaliveTimeout': peerProposedKeepaliveTimeout, 'sessionUpTime': sessionUpTime, 'md5AuthKey': md5AuthKey, 'tcpConnLocal': tcpConnLocal, 'tcpConnRemote': tcpConnRemote, 'tcpState': tcpState, 'numFecsReceivedFromPeer': numFecsReceivedFromPeer, 'numFecsInstalledFromPeer': numFecsInstalledFromPeer, 'isFecsPendingUninstall': isFecsPendingUninstall, 'numFecsFilteredOut': numFecsFilteredOut, 'numFecsFilteredIn': numFecsFilteredIn, 'outFilterPrefixList': outFilterPrefixList, 'outFilterPrefixListExists': outFilterPrefixListExists, 'isOnlyGRValid': isOnlyGRValid, 'grEnabled': grEnabled, 'peerReconectTime': peerReconectTime, 'peerRecoveryTime': peerRecoveryTime, 'isInUse': isInUse, 'reconnectOrRecovery': reconnectOrRecovery, 'grTimeInUse': grTimeInUse, 'grTimeRemaining': grTimeRemaining, 'grState': grState, 'localEolUnrecognizedNotification': localEolUnrecognizedNotification, 'remoteEolUnrecognizedNotification': remoteEolUnrecognizedNotification, 'doesSessionSupportEol': doesSessionSupportEol, 'localState': localState, 'remoteState': remoteState, 'eolNotificationTime': eolNotificationTime, 'eolNotificationTimeRemaining': eolNotificationTimeRemaining, 'eolTxLabelSilenceTime': eolTxLabelSilenceTime, 'eolTxLabelSilenceTimeRunning': eolTxLabelSilenceTimeRunning, 'eolRxLabelSilenceTime': eolRxLabelSilenceTime, 'eolRxLabelSilenceTimeRunning': eolRxLabelSilenceTimeRunning, 'interfaces': interfaces, 'addresses': addresses, }


