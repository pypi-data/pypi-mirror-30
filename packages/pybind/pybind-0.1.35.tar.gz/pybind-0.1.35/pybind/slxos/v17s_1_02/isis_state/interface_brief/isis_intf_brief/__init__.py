
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class isis_intf_brief(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-isis-operational - based on the path /isis-state/interface-brief/isis-intf-brief. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: ISIS light weight interface info object
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__intf_name','__circuit_type','__is_circuit_passive','__circuit_mode','__circ_state','__mtu_size','__circ_adj_up','__circ_changes','__adj_changes','__is_l1_dis','__is_l2_dis',)

  _yang_name = 'isis-intf-brief'
  _rest_name = 'isis-intf-brief'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__circuit_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'isis-level1-2': {'value': 0}, u'isis-level1': {'value': 1}, u'isis-level2': {'value': 2}},), is_leaf=True, yang_name="circuit-mode", rest_name="circuit-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='isis-level', is_config=False)
    self.__circ_adj_up = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="circ-adj-up", rest_name="circ-adj-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint16', is_config=False)
    self.__circuit_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'is-circ-lan': {'value': 2}, u'is-circ-ptpt': {'value': 1}, u'is-circ-unknown': {'value': 0}},), is_leaf=True, yang_name="circuit-type", rest_name="circuit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='isis-circ-type', is_config=False)
    self.__mtu_size = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu-size", rest_name="mtu-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint16', is_config=False)
    self.__is_circuit_passive = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'is-enabled': {'value': 1}, u'is-disabled': {'value': 0}},), is_leaf=True, yang_name="is-circuit-passive", rest_name="is-circuit-passive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='isis-status', is_config=False)
    self.__intf_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="intf-name", rest_name="intf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='string', is_config=False)
    self.__circ_changes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="circ-changes", rest_name="circ-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint32', is_config=False)
    self.__is_l2_dis = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-l2-dis", rest_name="is-l2-dis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='boolean', is_config=False)
    self.__adj_changes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adj-changes", rest_name="adj-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint32', is_config=False)
    self.__circ_state = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="circ-state", rest_name="circ-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='boolean', is_config=False)
    self.__is_l1_dis = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-l1-dis", rest_name="is-l1-dis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'isis-state', u'interface-brief', u'isis-intf-brief']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'isis-state', u'interface-brief', u'isis-intf-brief']

  def _get_intf_name(self):
    """
    Getter method for intf_name, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/intf_name (string)

    YANG Description: Interface name
    """
    return self.__intf_name
      
  def _set_intf_name(self, v, load=False):
    """
    Setter method for intf_name, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/intf_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intf_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intf_name() directly.

    YANG Description: Interface name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="intf-name", rest_name="intf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intf_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="intf-name", rest_name="intf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='string', is_config=False)""",
        })

    self.__intf_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intf_name(self):
    self.__intf_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="intf-name", rest_name="intf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='string', is_config=False)


  def _get_circuit_type(self):
    """
    Getter method for circuit_type, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/circuit_type (isis-circ-type)

    YANG Description: Type of ISIS Circuit
    """
    return self.__circuit_type
      
  def _set_circuit_type(self, v, load=False):
    """
    Setter method for circuit_type, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/circuit_type (isis-circ-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_circuit_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_circuit_type() directly.

    YANG Description: Type of ISIS Circuit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'is-circ-lan': {'value': 2}, u'is-circ-ptpt': {'value': 1}, u'is-circ-unknown': {'value': 0}},), is_leaf=True, yang_name="circuit-type", rest_name="circuit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='isis-circ-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """circuit_type must be of a type compatible with isis-circ-type""",
          'defined-type': "brocade-isis-operational:isis-circ-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'is-circ-lan': {'value': 2}, u'is-circ-ptpt': {'value': 1}, u'is-circ-unknown': {'value': 0}},), is_leaf=True, yang_name="circuit-type", rest_name="circuit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='isis-circ-type', is_config=False)""",
        })

    self.__circuit_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_circuit_type(self):
    self.__circuit_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'is-circ-lan': {'value': 2}, u'is-circ-ptpt': {'value': 1}, u'is-circ-unknown': {'value': 0}},), is_leaf=True, yang_name="circuit-type", rest_name="circuit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='isis-circ-type', is_config=False)


  def _get_is_circuit_passive(self):
    """
    Getter method for is_circuit_passive, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/is_circuit_passive (isis-status)

    YANG Description: If Circuit is in Passive state
    """
    return self.__is_circuit_passive
      
  def _set_is_circuit_passive(self, v, load=False):
    """
    Setter method for is_circuit_passive, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/is_circuit_passive (isis-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_circuit_passive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_circuit_passive() directly.

    YANG Description: If Circuit is in Passive state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'is-enabled': {'value': 1}, u'is-disabled': {'value': 0}},), is_leaf=True, yang_name="is-circuit-passive", rest_name="is-circuit-passive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='isis-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_circuit_passive must be of a type compatible with isis-status""",
          'defined-type': "brocade-isis-operational:isis-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'is-enabled': {'value': 1}, u'is-disabled': {'value': 0}},), is_leaf=True, yang_name="is-circuit-passive", rest_name="is-circuit-passive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='isis-status', is_config=False)""",
        })

    self.__is_circuit_passive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_circuit_passive(self):
    self.__is_circuit_passive = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'is-enabled': {'value': 1}, u'is-disabled': {'value': 0}},), is_leaf=True, yang_name="is-circuit-passive", rest_name="is-circuit-passive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='isis-status', is_config=False)


  def _get_circuit_mode(self):
    """
    Getter method for circuit_mode, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/circuit_mode (isis-level)

    YANG Description: ISIS operation mode
    """
    return self.__circuit_mode
      
  def _set_circuit_mode(self, v, load=False):
    """
    Setter method for circuit_mode, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/circuit_mode (isis-level)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_circuit_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_circuit_mode() directly.

    YANG Description: ISIS operation mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'isis-level1-2': {'value': 0}, u'isis-level1': {'value': 1}, u'isis-level2': {'value': 2}},), is_leaf=True, yang_name="circuit-mode", rest_name="circuit-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='isis-level', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """circuit_mode must be of a type compatible with isis-level""",
          'defined-type': "brocade-isis-operational:isis-level",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'isis-level1-2': {'value': 0}, u'isis-level1': {'value': 1}, u'isis-level2': {'value': 2}},), is_leaf=True, yang_name="circuit-mode", rest_name="circuit-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='isis-level', is_config=False)""",
        })

    self.__circuit_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_circuit_mode(self):
    self.__circuit_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'isis-level1-2': {'value': 0}, u'isis-level1': {'value': 1}, u'isis-level2': {'value': 2}},), is_leaf=True, yang_name="circuit-mode", rest_name="circuit-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='isis-level', is_config=False)


  def _get_circ_state(self):
    """
    Getter method for circ_state, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/circ_state (boolean)

    YANG Description: If ISIS circuit is UP
    """
    return self.__circ_state
      
  def _set_circ_state(self, v, load=False):
    """
    Setter method for circ_state, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/circ_state (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_circ_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_circ_state() directly.

    YANG Description: If ISIS circuit is UP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="circ-state", rest_name="circ-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """circ_state must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="circ-state", rest_name="circ-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='boolean', is_config=False)""",
        })

    self.__circ_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_circ_state(self):
    self.__circ_state = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="circ-state", rest_name="circ-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='boolean', is_config=False)


  def _get_mtu_size(self):
    """
    Getter method for mtu_size, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/mtu_size (uint16)

    YANG Description: MTU
    """
    return self.__mtu_size
      
  def _set_mtu_size(self, v, load=False):
    """
    Setter method for mtu_size, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/mtu_size (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu_size() directly.

    YANG Description: MTU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu-size", rest_name="mtu-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu_size must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu-size", rest_name="mtu-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint16', is_config=False)""",
        })

    self.__mtu_size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu_size(self):
    self.__mtu_size = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu-size", rest_name="mtu-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint16', is_config=False)


  def _get_circ_adj_up(self):
    """
    Getter method for circ_adj_up, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/circ_adj_up (uint16)

    YANG Description: Number of circuit UP adjacencies
    """
    return self.__circ_adj_up
      
  def _set_circ_adj_up(self, v, load=False):
    """
    Setter method for circ_adj_up, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/circ_adj_up (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_circ_adj_up is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_circ_adj_up() directly.

    YANG Description: Number of circuit UP adjacencies
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="circ-adj-up", rest_name="circ-adj-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """circ_adj_up must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="circ-adj-up", rest_name="circ-adj-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint16', is_config=False)""",
        })

    self.__circ_adj_up = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_circ_adj_up(self):
    self.__circ_adj_up = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="circ-adj-up", rest_name="circ-adj-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint16', is_config=False)


  def _get_circ_changes(self):
    """
    Getter method for circ_changes, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/circ_changes (uint32)

    YANG Description: Number of circuit state changes
    """
    return self.__circ_changes
      
  def _set_circ_changes(self, v, load=False):
    """
    Setter method for circ_changes, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/circ_changes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_circ_changes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_circ_changes() directly.

    YANG Description: Number of circuit state changes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="circ-changes", rest_name="circ-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """circ_changes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="circ-changes", rest_name="circ-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint32', is_config=False)""",
        })

    self.__circ_changes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_circ_changes(self):
    self.__circ_changes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="circ-changes", rest_name="circ-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint32', is_config=False)


  def _get_adj_changes(self):
    """
    Getter method for adj_changes, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/adj_changes (uint32)

    YANG Description: Number of adjacency changes
    """
    return self.__adj_changes
      
  def _set_adj_changes(self, v, load=False):
    """
    Setter method for adj_changes, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/adj_changes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adj_changes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adj_changes() directly.

    YANG Description: Number of adjacency changes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adj-changes", rest_name="adj-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adj_changes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adj-changes", rest_name="adj-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint32', is_config=False)""",
        })

    self.__adj_changes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adj_changes(self):
    self.__adj_changes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adj-changes", rest_name="adj-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='uint32', is_config=False)


  def _get_is_l1_dis(self):
    """
    Getter method for is_l1_dis, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/is_l1_dis (boolean)

    YANG Description: If this is the Designated IS of the L1 circuit
    """
    return self.__is_l1_dis
      
  def _set_is_l1_dis(self, v, load=False):
    """
    Setter method for is_l1_dis, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/is_l1_dis (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_l1_dis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_l1_dis() directly.

    YANG Description: If this is the Designated IS of the L1 circuit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-l1-dis", rest_name="is-l1-dis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_l1_dis must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-l1-dis", rest_name="is-l1-dis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_l1_dis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_l1_dis(self):
    self.__is_l1_dis = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-l1-dis", rest_name="is-l1-dis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='boolean', is_config=False)


  def _get_is_l2_dis(self):
    """
    Getter method for is_l2_dis, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/is_l2_dis (boolean)

    YANG Description: If this is the Designated IS of the L2 circuit
    """
    return self.__is_l2_dis
      
  def _set_is_l2_dis(self, v, load=False):
    """
    Setter method for is_l2_dis, mapped from YANG variable /isis_state/interface_brief/isis_intf_brief/is_l2_dis (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_l2_dis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_l2_dis() directly.

    YANG Description: If this is the Designated IS of the L2 circuit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-l2-dis", rest_name="is-l2-dis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_l2_dis must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-l2-dis", rest_name="is-l2-dis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_l2_dis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_l2_dis(self):
    self.__is_l2_dis = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-l2-dis", rest_name="is-l2-dis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-isis-operational', defining_module='brocade-isis-operational', yang_type='boolean', is_config=False)

  intf_name = __builtin__.property(_get_intf_name)
  circuit_type = __builtin__.property(_get_circuit_type)
  is_circuit_passive = __builtin__.property(_get_is_circuit_passive)
  circuit_mode = __builtin__.property(_get_circuit_mode)
  circ_state = __builtin__.property(_get_circ_state)
  mtu_size = __builtin__.property(_get_mtu_size)
  circ_adj_up = __builtin__.property(_get_circ_adj_up)
  circ_changes = __builtin__.property(_get_circ_changes)
  adj_changes = __builtin__.property(_get_adj_changes)
  is_l1_dis = __builtin__.property(_get_is_l1_dis)
  is_l2_dis = __builtin__.property(_get_is_l2_dis)


  _pyangbind_elements = {'intf_name': intf_name, 'circuit_type': circuit_type, 'is_circuit_passive': is_circuit_passive, 'circuit_mode': circuit_mode, 'circ_state': circ_state, 'mtu_size': mtu_size, 'circ_adj_up': circ_adj_up, 'circ_changes': circ_changes, 'adj_changes': adj_changes, 'is_l1_dis': is_l1_dis, 'is_l2_dis': is_l2_dis, }


