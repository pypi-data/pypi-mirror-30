
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import active_vlan_list
import active_bd_list
import peer_info_list
import client_info_list
import config_vlan_list
import bd_list
class show_cluster(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-nsm-operational - based on the path /mct-state/show-cluster. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: parent mo name
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__cluster_id','__is_cluster_client_command','__is_cluster_all_command','__cluster_name','__cluster_status','__client_isolation_status','__num_peers','__num_clients','__num_config_vlans','__num_active_vlans','__num_bds','__num_active_bds','__client_interfaces_shutdown','__control_vlan','__df_hold_time','__active_vlan_list','__active_bd_list','__peer_info_list','__client_info_list','__config_vlan_list','__bd_list',)

  _yang_name = 'show-cluster'
  _rest_name = 'show-cluster'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__config_vlan_list = YANGDynClass(base=YANGListType("vlan_id",config_vlan_list.config_vlan_list, yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}), is_container='list', yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    self.__active_vlan_list = YANGDynClass(base=YANGListType("vlan_id",active_vlan_list.active_vlan_list, yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    self.__num_active_bds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-bds", rest_name="num-active-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__bd_list = YANGDynClass(base=YANGListType("bd_id",bd_list.bd_list, yang_name="bd-list", rest_name="bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}), is_container='list', yang_name="bd-list", rest_name="bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    self.__num_active_vlans = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-vlans", rest_name="num-active-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__peer_info_list = YANGDynClass(base=YANGListType("peer_ip_addr",peer_info_list.peer_info_list, yang_name="peer-info-list", rest_name="peer-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip-addr', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="peer-info-list", rest_name="peer-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    self.__client_isolation_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="client-isolation-status", rest_name="client-isolation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    self.__client_interfaces_shutdown = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="client-interfaces-shutdown", rest_name="client-interfaces-shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    self.__is_cluster_client_command = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-cluster-client-command", rest_name="is-cluster-client-command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    self.__num_config_vlans = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-config-vlans", rest_name="num-config-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__num_bds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-bds", rest_name="num-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__cluster_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="cluster-name", rest_name="cluster-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='string', is_config=False)
    self.__df_hold_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="df-hold-time", rest_name="df-hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__is_cluster_all_command = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-cluster-all-command", rest_name="is-cluster-all-command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    self.__cluster_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cluster-id", rest_name="cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__cluster_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cluster-status", rest_name="cluster-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    self.__client_info_list = YANGDynClass(base=YANGListType("cluster_id client_id",client_info_list.client_info_list, yang_name="client-info-list", rest_name="client-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="client-info-list", rest_name="client-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    self.__active_bd_list = YANGDynClass(base=YANGListType("bd_id",active_bd_list.active_bd_list, yang_name="active-bd-list", rest_name="active-bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-bd-list", rest_name="active-bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    self.__num_peers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-peers", rest_name="num-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__num_clients = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-clients", rest_name="num-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__control_vlan = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="control-vlan", rest_name="control-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mct-state', u'show-cluster']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'mct-state', u'show-cluster']

  def _get_cluster_id(self):
    """
    Getter method for cluster_id, mapped from YANG variable /mct_state/show_cluster/cluster_id (uint32)

    YANG Description: cluster ID
    """
    return self.__cluster_id
      
  def _set_cluster_id(self, v, load=False):
    """
    Setter method for cluster_id, mapped from YANG variable /mct_state/show_cluster/cluster_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cluster_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cluster_id() directly.

    YANG Description: cluster ID
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cluster-id", rest_name="cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cluster_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cluster-id", rest_name="cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__cluster_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cluster_id(self):
    self.__cluster_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cluster-id", rest_name="cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_is_cluster_client_command(self):
    """
    Getter method for is_cluster_client_command, mapped from YANG variable /mct_state/show_cluster/is_cluster_client_command (boolean)

    YANG Description: Is the client ID specific command
    """
    return self.__is_cluster_client_command
      
  def _set_is_cluster_client_command(self, v, load=False):
    """
    Setter method for is_cluster_client_command, mapped from YANG variable /mct_state/show_cluster/is_cluster_client_command (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_cluster_client_command is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_cluster_client_command() directly.

    YANG Description: Is the client ID specific command
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-cluster-client-command", rest_name="is-cluster-client-command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_cluster_client_command must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-cluster-client-command", rest_name="is-cluster-client-command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_cluster_client_command = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_cluster_client_command(self):
    self.__is_cluster_client_command = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-cluster-client-command", rest_name="is-cluster-client-command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)


  def _get_is_cluster_all_command(self):
    """
    Getter method for is_cluster_all_command, mapped from YANG variable /mct_state/show_cluster/is_cluster_all_command (boolean)

    YANG Description: Is the show all command
    """
    return self.__is_cluster_all_command
      
  def _set_is_cluster_all_command(self, v, load=False):
    """
    Setter method for is_cluster_all_command, mapped from YANG variable /mct_state/show_cluster/is_cluster_all_command (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_cluster_all_command is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_cluster_all_command() directly.

    YANG Description: Is the show all command
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-cluster-all-command", rest_name="is-cluster-all-command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_cluster_all_command must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-cluster-all-command", rest_name="is-cluster-all-command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_cluster_all_command = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_cluster_all_command(self):
    self.__is_cluster_all_command = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-cluster-all-command", rest_name="is-cluster-all-command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)


  def _get_cluster_name(self):
    """
    Getter method for cluster_name, mapped from YANG variable /mct_state/show_cluster/cluster_name (string)

    YANG Description: cluster name
    """
    return self.__cluster_name
      
  def _set_cluster_name(self, v, load=False):
    """
    Setter method for cluster_name, mapped from YANG variable /mct_state/show_cluster/cluster_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cluster_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cluster_name() directly.

    YANG Description: cluster name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cluster-name", rest_name="cluster-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cluster_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cluster-name", rest_name="cluster-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='string', is_config=False)""",
        })

    self.__cluster_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cluster_name(self):
    self.__cluster_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="cluster-name", rest_name="cluster-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='string', is_config=False)


  def _get_cluster_status(self):
    """
    Getter method for cluster_status, mapped from YANG variable /mct_state/show_cluster/cluster_status (boolean)

    YANG Description: cluster status
    """
    return self.__cluster_status
      
  def _set_cluster_status(self, v, load=False):
    """
    Setter method for cluster_status, mapped from YANG variable /mct_state/show_cluster/cluster_status (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cluster_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cluster_status() directly.

    YANG Description: cluster status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="cluster-status", rest_name="cluster-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cluster_status must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cluster-status", rest_name="cluster-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)""",
        })

    self.__cluster_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cluster_status(self):
    self.__cluster_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cluster-status", rest_name="cluster-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)


  def _get_client_isolation_status(self):
    """
    Getter method for client_isolation_status, mapped from YANG variable /mct_state/show_cluster/client_isolation_status (boolean)

    YANG Description: Is client islotaion strict or loose
    """
    return self.__client_isolation_status
      
  def _set_client_isolation_status(self, v, load=False):
    """
    Setter method for client_isolation_status, mapped from YANG variable /mct_state/show_cluster/client_isolation_status (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_isolation_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_isolation_status() directly.

    YANG Description: Is client islotaion strict or loose
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="client-isolation-status", rest_name="client-isolation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_isolation_status must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="client-isolation-status", rest_name="client-isolation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)""",
        })

    self.__client_isolation_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_isolation_status(self):
    self.__client_isolation_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="client-isolation-status", rest_name="client-isolation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)


  def _get_num_peers(self):
    """
    Getter method for num_peers, mapped from YANG variable /mct_state/show_cluster/num_peers (uint32)

    YANG Description: Number of Peers
    """
    return self.__num_peers
      
  def _set_num_peers(self, v, load=False):
    """
    Setter method for num_peers, mapped from YANG variable /mct_state/show_cluster/num_peers (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_peers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_peers() directly.

    YANG Description: Number of Peers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-peers", rest_name="num-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_peers must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-peers", rest_name="num-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_peers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_peers(self):
    self.__num_peers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-peers", rest_name="num-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_num_clients(self):
    """
    Getter method for num_clients, mapped from YANG variable /mct_state/show_cluster/num_clients (uint32)

    YANG Description: Number of Clients
    """
    return self.__num_clients
      
  def _set_num_clients(self, v, load=False):
    """
    Setter method for num_clients, mapped from YANG variable /mct_state/show_cluster/num_clients (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_clients is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_clients() directly.

    YANG Description: Number of Clients
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-clients", rest_name="num-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_clients must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-clients", rest_name="num-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_clients = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_clients(self):
    self.__num_clients = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-clients", rest_name="num-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_num_config_vlans(self):
    """
    Getter method for num_config_vlans, mapped from YANG variable /mct_state/show_cluster/num_config_vlans (uint32)

    YANG Description: Number of configured vlans
    """
    return self.__num_config_vlans
      
  def _set_num_config_vlans(self, v, load=False):
    """
    Setter method for num_config_vlans, mapped from YANG variable /mct_state/show_cluster/num_config_vlans (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_config_vlans is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_config_vlans() directly.

    YANG Description: Number of configured vlans
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-config-vlans", rest_name="num-config-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_config_vlans must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-config-vlans", rest_name="num-config-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_config_vlans = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_config_vlans(self):
    self.__num_config_vlans = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-config-vlans", rest_name="num-config-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_num_active_vlans(self):
    """
    Getter method for num_active_vlans, mapped from YANG variable /mct_state/show_cluster/num_active_vlans (uint32)

    YANG Description: Number of active vlans
    """
    return self.__num_active_vlans
      
  def _set_num_active_vlans(self, v, load=False):
    """
    Setter method for num_active_vlans, mapped from YANG variable /mct_state/show_cluster/num_active_vlans (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_active_vlans is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_active_vlans() directly.

    YANG Description: Number of active vlans
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-vlans", rest_name="num-active-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_active_vlans must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-vlans", rest_name="num-active-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_active_vlans = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_active_vlans(self):
    self.__num_active_vlans = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-vlans", rest_name="num-active-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_num_bds(self):
    """
    Getter method for num_bds, mapped from YANG variable /mct_state/show_cluster/num_bds (uint32)
    """
    return self.__num_bds
      
  def _set_num_bds(self, v, load=False):
    """
    Setter method for num_bds, mapped from YANG variable /mct_state/show_cluster/num_bds (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_bds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_bds() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-bds", rest_name="num-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_bds must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-bds", rest_name="num-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_bds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_bds(self):
    self.__num_bds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-bds", rest_name="num-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_num_active_bds(self):
    """
    Getter method for num_active_bds, mapped from YANG variable /mct_state/show_cluster/num_active_bds (uint32)
    """
    return self.__num_active_bds
      
  def _set_num_active_bds(self, v, load=False):
    """
    Setter method for num_active_bds, mapped from YANG variable /mct_state/show_cluster/num_active_bds (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_active_bds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_active_bds() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-bds", rest_name="num-active-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_active_bds must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-bds", rest_name="num-active-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_active_bds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_active_bds(self):
    self.__num_active_bds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-bds", rest_name="num-active-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_client_interfaces_shutdown(self):
    """
    Getter method for client_interfaces_shutdown, mapped from YANG variable /mct_state/show_cluster/client_interfaces_shutdown (boolean)

    YANG Description: client interfaces shutdown
    """
    return self.__client_interfaces_shutdown
      
  def _set_client_interfaces_shutdown(self, v, load=False):
    """
    Setter method for client_interfaces_shutdown, mapped from YANG variable /mct_state/show_cluster/client_interfaces_shutdown (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_interfaces_shutdown is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_interfaces_shutdown() directly.

    YANG Description: client interfaces shutdown
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="client-interfaces-shutdown", rest_name="client-interfaces-shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_interfaces_shutdown must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="client-interfaces-shutdown", rest_name="client-interfaces-shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)""",
        })

    self.__client_interfaces_shutdown = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_interfaces_shutdown(self):
    self.__client_interfaces_shutdown = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="client-interfaces-shutdown", rest_name="client-interfaces-shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)


  def _get_control_vlan(self):
    """
    Getter method for control_vlan, mapped from YANG variable /mct_state/show_cluster/control_vlan (uint32)

    YANG Description: cluster control vlan
    """
    return self.__control_vlan
      
  def _set_control_vlan(self, v, load=False):
    """
    Setter method for control_vlan, mapped from YANG variable /mct_state/show_cluster/control_vlan (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_vlan() directly.

    YANG Description: cluster control vlan
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="control-vlan", rest_name="control-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_vlan must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="control-vlan", rest_name="control-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__control_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_vlan(self):
    self.__control_vlan = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="control-vlan", rest_name="control-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_df_hold_time(self):
    """
    Getter method for df_hold_time, mapped from YANG variable /mct_state/show_cluster/df_hold_time (uint32)

    YANG Description: Designated Forwarder Hold Time
    """
    return self.__df_hold_time
      
  def _set_df_hold_time(self, v, load=False):
    """
    Setter method for df_hold_time, mapped from YANG variable /mct_state/show_cluster/df_hold_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_df_hold_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_df_hold_time() directly.

    YANG Description: Designated Forwarder Hold Time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="df-hold-time", rest_name="df-hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """df_hold_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="df-hold-time", rest_name="df-hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__df_hold_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_df_hold_time(self):
    self.__df_hold_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="df-hold-time", rest_name="df-hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_active_vlan_list(self):
    """
    Getter method for active_vlan_list, mapped from YANG variable /mct_state/show_cluster/active_vlan_list (list)
    """
    return self.__active_vlan_list
      
  def _set_active_vlan_list(self, v, load=False):
    """
    Setter method for active_vlan_list, mapped from YANG variable /mct_state/show_cluster/active_vlan_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active_vlan_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active_vlan_list() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vlan_id",active_vlan_list.active_vlan_list, yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active_vlan_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vlan_id",active_vlan_list.active_vlan_list, yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)""",
        })

    self.__active_vlan_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active_vlan_list(self):
    self.__active_vlan_list = YANGDynClass(base=YANGListType("vlan_id",active_vlan_list.active_vlan_list, yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)


  def _get_active_bd_list(self):
    """
    Getter method for active_bd_list, mapped from YANG variable /mct_state/show_cluster/active_bd_list (list)

    YANG Description: List of BDs Active
    """
    return self.__active_bd_list
      
  def _set_active_bd_list(self, v, load=False):
    """
    Setter method for active_bd_list, mapped from YANG variable /mct_state/show_cluster/active_bd_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active_bd_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active_bd_list() directly.

    YANG Description: List of BDs Active
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("bd_id",active_bd_list.active_bd_list, yang_name="active-bd-list", rest_name="active-bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-bd-list", rest_name="active-bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active_bd_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("bd_id",active_bd_list.active_bd_list, yang_name="active-bd-list", rest_name="active-bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-bd-list", rest_name="active-bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)""",
        })

    self.__active_bd_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active_bd_list(self):
    self.__active_bd_list = YANGDynClass(base=YANGListType("bd_id",active_bd_list.active_bd_list, yang_name="active-bd-list", rest_name="active-bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-bd-list", rest_name="active-bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)


  def _get_peer_info_list(self):
    """
    Getter method for peer_info_list, mapped from YANG variable /mct_state/show_cluster/peer_info_list (list)

    YANG Description: Peer Info
    """
    return self.__peer_info_list
      
  def _set_peer_info_list(self, v, load=False):
    """
    Setter method for peer_info_list, mapped from YANG variable /mct_state/show_cluster/peer_info_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_info_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_info_list() directly.

    YANG Description: Peer Info
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peer_ip_addr",peer_info_list.peer_info_list, yang_name="peer-info-list", rest_name="peer-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip-addr', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="peer-info-list", rest_name="peer-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_info_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peer_ip_addr",peer_info_list.peer_info_list, yang_name="peer-info-list", rest_name="peer-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip-addr', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="peer-info-list", rest_name="peer-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)""",
        })

    self.__peer_info_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_info_list(self):
    self.__peer_info_list = YANGDynClass(base=YANGListType("peer_ip_addr",peer_info_list.peer_info_list, yang_name="peer-info-list", rest_name="peer-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip-addr', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="peer-info-list", rest_name="peer-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)


  def _get_client_info_list(self):
    """
    Getter method for client_info_list, mapped from YANG variable /mct_state/show_cluster/client_info_list (list)
    """
    return self.__client_info_list
      
  def _set_client_info_list(self, v, load=False):
    """
    Setter method for client_info_list, mapped from YANG variable /mct_state/show_cluster/client_info_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_info_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_info_list() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("cluster_id client_id",client_info_list.client_info_list, yang_name="client-info-list", rest_name="client-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="client-info-list", rest_name="client-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_info_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("cluster_id client_id",client_info_list.client_info_list, yang_name="client-info-list", rest_name="client-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="client-info-list", rest_name="client-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)""",
        })

    self.__client_info_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_info_list(self):
    self.__client_info_list = YANGDynClass(base=YANGListType("cluster_id client_id",client_info_list.client_info_list, yang_name="client-info-list", rest_name="client-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="client-info-list", rest_name="client-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)


  def _get_config_vlan_list(self):
    """
    Getter method for config_vlan_list, mapped from YANG variable /mct_state/show_cluster/config_vlan_list (list)
    """
    return self.__config_vlan_list
      
  def _set_config_vlan_list(self, v, load=False):
    """
    Setter method for config_vlan_list, mapped from YANG variable /mct_state/show_cluster/config_vlan_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_vlan_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_vlan_list() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vlan_id",config_vlan_list.config_vlan_list, yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}), is_container='list', yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_vlan_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vlan_id",config_vlan_list.config_vlan_list, yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}), is_container='list', yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)""",
        })

    self.__config_vlan_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_vlan_list(self):
    self.__config_vlan_list = YANGDynClass(base=YANGListType("vlan_id",config_vlan_list.config_vlan_list, yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}), is_container='list', yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)


  def _get_bd_list(self):
    """
    Getter method for bd_list, mapped from YANG variable /mct_state/show_cluster/bd_list (list)
    """
    return self.__bd_list
      
  def _set_bd_list(self, v, load=False):
    """
    Setter method for bd_list, mapped from YANG variable /mct_state/show_cluster/bd_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bd_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bd_list() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("bd_id",bd_list.bd_list, yang_name="bd-list", rest_name="bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}), is_container='list', yang_name="bd-list", rest_name="bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bd_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("bd_id",bd_list.bd_list, yang_name="bd-list", rest_name="bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}), is_container='list', yang_name="bd-list", rest_name="bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)""",
        })

    self.__bd_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bd_list(self):
    self.__bd_list = YANGDynClass(base=YANGListType("bd_id",bd_list.bd_list, yang_name="bd-list", rest_name="bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}), is_container='list', yang_name="bd-list", rest_name="bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)

  cluster_id = __builtin__.property(_get_cluster_id)
  is_cluster_client_command = __builtin__.property(_get_is_cluster_client_command)
  is_cluster_all_command = __builtin__.property(_get_is_cluster_all_command)
  cluster_name = __builtin__.property(_get_cluster_name)
  cluster_status = __builtin__.property(_get_cluster_status)
  client_isolation_status = __builtin__.property(_get_client_isolation_status)
  num_peers = __builtin__.property(_get_num_peers)
  num_clients = __builtin__.property(_get_num_clients)
  num_config_vlans = __builtin__.property(_get_num_config_vlans)
  num_active_vlans = __builtin__.property(_get_num_active_vlans)
  num_bds = __builtin__.property(_get_num_bds)
  num_active_bds = __builtin__.property(_get_num_active_bds)
  client_interfaces_shutdown = __builtin__.property(_get_client_interfaces_shutdown)
  control_vlan = __builtin__.property(_get_control_vlan)
  df_hold_time = __builtin__.property(_get_df_hold_time)
  active_vlan_list = __builtin__.property(_get_active_vlan_list)
  active_bd_list = __builtin__.property(_get_active_bd_list)
  peer_info_list = __builtin__.property(_get_peer_info_list)
  client_info_list = __builtin__.property(_get_client_info_list)
  config_vlan_list = __builtin__.property(_get_config_vlan_list)
  bd_list = __builtin__.property(_get_bd_list)


  _pyangbind_elements = {'cluster_id': cluster_id, 'is_cluster_client_command': is_cluster_client_command, 'is_cluster_all_command': is_cluster_all_command, 'cluster_name': cluster_name, 'cluster_status': cluster_status, 'client_isolation_status': client_isolation_status, 'num_peers': num_peers, 'num_clients': num_clients, 'num_config_vlans': num_config_vlans, 'num_active_vlans': num_active_vlans, 'num_bds': num_bds, 'num_active_bds': num_active_bds, 'client_interfaces_shutdown': client_interfaces_shutdown, 'control_vlan': control_vlan, 'df_hold_time': df_hold_time, 'active_vlan_list': active_vlan_list, 'active_bd_list': active_bd_list, 'peer_info_list': peer_info_list, 'client_info_list': client_info_list, 'config_vlan_list': config_vlan_list, 'bd_list': bd_list, }


