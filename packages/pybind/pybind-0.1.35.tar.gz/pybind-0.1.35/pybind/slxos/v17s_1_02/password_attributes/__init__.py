
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import character_restriction
class password_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-aaa - based on the path /password-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__min_length','__max_retry','__max_lockout_duration','__character_restriction','__admin_lockout_enable',)

  _yang_name = 'password-attributes'
  _rest_name = 'password-attributes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__max_retry = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0 .. 16']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="max-retry", rest_name="max-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Maximum number of login retries before which\n the user account is locked. 0 for unlimited\n login retries. (default=0)'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='uint32', is_config=True)
    self.__min_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'8 .. 32']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(8), is_leaf=True, yang_name="min-length", rest_name="min-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Minimum length of the password. (default=8)'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='uint32', is_config=True)
    self.__admin_lockout_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="admin-lockout-enable", rest_name="admin-lockout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable lockout for admin role accounts after\nmax retry failed login attempts', u'alt-name': u'admin-lockout'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='empty', is_config=True)
    self.__max_lockout_duration = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0 .. 99999']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="max-lockout-duration", rest_name="max-lockout-duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Maximum number of minutes after which \n the user account is unlocked. (default=0)'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='uint32', is_config=True)
    self.__character_restriction = YANGDynClass(base=character_restriction.character_restriction, is_container='container', presence=False, yang_name="character-restriction", rest_name="character-restriction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure restriction on various types of\n characters'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'password-attributes']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'password-attributes']

  def _get_min_length(self):
    """
    Getter method for min_length, mapped from YANG variable /password_attributes/min_length (uint32)
    """
    return self.__min_length
      
  def _set_min_length(self, v, load=False):
    """
    Setter method for min_length, mapped from YANG variable /password_attributes/min_length (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_length() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'8 .. 32']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(8), is_leaf=True, yang_name="min-length", rest_name="min-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Minimum length of the password. (default=8)'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_length must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'8 .. 32']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(8), is_leaf=True, yang_name="min-length", rest_name="min-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Minimum length of the password. (default=8)'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='uint32', is_config=True)""",
        })

    self.__min_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_length(self):
    self.__min_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'8 .. 32']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(8), is_leaf=True, yang_name="min-length", rest_name="min-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Minimum length of the password. (default=8)'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='uint32', is_config=True)


  def _get_max_retry(self):
    """
    Getter method for max_retry, mapped from YANG variable /password_attributes/max_retry (uint32)
    """
    return self.__max_retry
      
  def _set_max_retry(self, v, load=False):
    """
    Setter method for max_retry, mapped from YANG variable /password_attributes/max_retry (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_retry is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_retry() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0 .. 16']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="max-retry", rest_name="max-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Maximum number of login retries before which\n the user account is locked. 0 for unlimited\n login retries. (default=0)'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_retry must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0 .. 16']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="max-retry", rest_name="max-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Maximum number of login retries before which\n the user account is locked. 0 for unlimited\n login retries. (default=0)'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='uint32', is_config=True)""",
        })

    self.__max_retry = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_retry(self):
    self.__max_retry = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0 .. 16']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="max-retry", rest_name="max-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Maximum number of login retries before which\n the user account is locked. 0 for unlimited\n login retries. (default=0)'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='uint32', is_config=True)


  def _get_max_lockout_duration(self):
    """
    Getter method for max_lockout_duration, mapped from YANG variable /password_attributes/max_lockout_duration (uint32)
    """
    return self.__max_lockout_duration
      
  def _set_max_lockout_duration(self, v, load=False):
    """
    Setter method for max_lockout_duration, mapped from YANG variable /password_attributes/max_lockout_duration (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_lockout_duration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_lockout_duration() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0 .. 99999']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="max-lockout-duration", rest_name="max-lockout-duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Maximum number of minutes after which \n the user account is unlocked. (default=0)'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_lockout_duration must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0 .. 99999']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="max-lockout-duration", rest_name="max-lockout-duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Maximum number of minutes after which \n the user account is unlocked. (default=0)'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='uint32', is_config=True)""",
        })

    self.__max_lockout_duration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_lockout_duration(self):
    self.__max_lockout_duration = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0 .. 99999']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="max-lockout-duration", rest_name="max-lockout-duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Maximum number of minutes after which \n the user account is unlocked. (default=0)'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='uint32', is_config=True)


  def _get_character_restriction(self):
    """
    Getter method for character_restriction, mapped from YANG variable /password_attributes/character_restriction (container)
    """
    return self.__character_restriction
      
  def _set_character_restriction(self, v, load=False):
    """
    Setter method for character_restriction, mapped from YANG variable /password_attributes/character_restriction (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_character_restriction is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_character_restriction() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=character_restriction.character_restriction, is_container='container', presence=False, yang_name="character-restriction", rest_name="character-restriction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure restriction on various types of\n characters'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """character_restriction must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=character_restriction.character_restriction, is_container='container', presence=False, yang_name="character-restriction", rest_name="character-restriction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure restriction on various types of\n characters'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__character_restriction = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_character_restriction(self):
    self.__character_restriction = YANGDynClass(base=character_restriction.character_restriction, is_container='container', presence=False, yang_name="character-restriction", rest_name="character-restriction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure restriction on various types of\n characters'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_admin_lockout_enable(self):
    """
    Getter method for admin_lockout_enable, mapped from YANG variable /password_attributes/admin_lockout_enable (empty)
    """
    return self.__admin_lockout_enable
      
  def _set_admin_lockout_enable(self, v, load=False):
    """
    Setter method for admin_lockout_enable, mapped from YANG variable /password_attributes/admin_lockout_enable (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_lockout_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_lockout_enable() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="admin-lockout-enable", rest_name="admin-lockout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable lockout for admin role accounts after\nmax retry failed login attempts', u'alt-name': u'admin-lockout'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_lockout_enable must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="admin-lockout-enable", rest_name="admin-lockout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable lockout for admin role accounts after\nmax retry failed login attempts', u'alt-name': u'admin-lockout'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='empty', is_config=True)""",
        })

    self.__admin_lockout_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_lockout_enable(self):
    self.__admin_lockout_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="admin-lockout-enable", rest_name="admin-lockout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable lockout for admin role accounts after\nmax retry failed login attempts', u'alt-name': u'admin-lockout'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='empty', is_config=True)

  min_length = __builtin__.property(_get_min_length, _set_min_length)
  max_retry = __builtin__.property(_get_max_retry, _set_max_retry)
  max_lockout_duration = __builtin__.property(_get_max_lockout_duration, _set_max_lockout_duration)
  character_restriction = __builtin__.property(_get_character_restriction, _set_character_restriction)
  admin_lockout_enable = __builtin__.property(_get_admin_lockout_enable, _set_admin_lockout_enable)


  _pyangbind_elements = {'min_length': min_length, 'max_retry': max_retry, 'max_lockout_duration': max_lockout_duration, 'character_restriction': character_restriction, 'admin_lockout_enable': admin_lockout_enable, }


