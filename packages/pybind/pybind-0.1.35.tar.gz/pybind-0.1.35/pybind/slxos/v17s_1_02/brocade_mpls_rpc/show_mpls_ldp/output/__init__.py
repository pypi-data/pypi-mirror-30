
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls - based on the path /brocade_mpls_rpc/show-mpls-ldp/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__ldp_initialized','__lsr_id','__lsr_id_configured','__loopback','__hello_interval_link','__hello_interval_target','__hold_time_sent_link','__hold_time_sent_target','__ka_interval','__ka_multiple','__ka_timeout','__ka_timeout_default','__load_sharing','__advertise_fecs_for_prefix_list','__advertise_fecs_for_prefix_list_exists','__inbound_fecs_filtering_prefix_list','__inbound_fecs_filtering_prefix_list_exists','__outbound_fecs_filtering_prefix_list','__outbound_fecs_filtering_prefix_list_exists','__tunnel_metric','__fec_128_used_for_auto_disc_current','__fec_128_used_for_auto_disc_configured','__end_of_lib','__eol_notification_time','__tx_silence_time','__rx_silence_time','__gr_enable','__gr_helper','__gr_reconnect_time','__gr_max_peer_reconnect_time','__gr_recovery_time','__gr_max_peer_recovery_time','__forwarding_state_timer_running','__forwarding_state_timer_remaining','__lwd_delay','__lwd_default',)

  _yang_name = 'output'
  _rest_name = 'output'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__forwarding_state_timer_remaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="forwarding-state-timer-remaining", rest_name="forwarding-state-timer-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__fec_128_used_for_auto_disc_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-configured", rest_name="fec-128-used-for-auto-disc-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__fec_128_used_for_auto_disc_current = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-current", rest_name="fec-128-used-for-auto-disc-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__gr_max_peer_recovery_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-recovery-time", rest_name="gr-max-peer-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__gr_max_peer_reconnect_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-reconnect-time", rest_name="gr-max-peer-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__hold_time_sent_target = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-target", rest_name="hold-time-sent-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__advertise_fecs_for_prefix_list_exists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-fecs-for-prefix-list-exists", rest_name="advertise-fecs-for-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__end_of_lib = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="end-of-lib", rest_name="end-of-lib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsr_id_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsr-id-configured", rest_name="lsr-id-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lsr_id = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="lsr-id", rest_name="lsr-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='inet:ipv4-address', is_config=True)
    self.__ka_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-timeout", rest_name="ka-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__ka_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-interval", rest_name="ka-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__inbound_fecs_filtering_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list", rest_name="inbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__hello_interval_link = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-link", rest_name="hello-interval-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__lwd_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lwd-delay", rest_name="lwd-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__gr_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-enable", rest_name="gr-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__loopback = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="loopback", rest_name="loopback", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__outbound_fecs_filtering_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list", rest_name="outbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__outbound_fecs_filtering_prefix_list_exists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list-exists", rest_name="outbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__inbound_fecs_filtering_prefix_list_exists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list-exists", rest_name="inbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__ldp_initialized = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ldp-initialized", rest_name="ldp-initialized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__load_sharing = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="load-sharing", rest_name="load-sharing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__gr_reconnect_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-reconnect-time", rest_name="gr-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__eol_notification_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time", rest_name="eol-notification-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__gr_recovery_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-recovery-time", rest_name="gr-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__tx_silence_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-silence-time", rest_name="tx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__rx_silence_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rx-silence-time", rest_name="rx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__gr_helper = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-helper", rest_name="gr-helper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__tunnel_metric = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-metric", rest_name="tunnel-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)
    self.__hello_interval_target = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-target", rest_name="hello-interval-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__hold_time_sent_link = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-link", rest_name="hold-time-sent-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__ka_timeout_default = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ka-timeout-default", rest_name="ka-timeout-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__ka_multiple = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-multiple", rest_name="ka-multiple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__forwarding_state_timer_running = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="forwarding-state-timer-running", rest_name="forwarding-state-timer-running", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__lwd_default = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lwd-default", rest_name="lwd-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    self.__advertise_fecs_for_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="advertise-fecs-for-prefix-list", rest_name="advertise-fecs-for-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'brocade_mpls_rpc', u'show-mpls-ldp', u'output']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'show-mpls-ldp', u'output']

  def _get_ldp_initialized(self):
    """
    Getter method for ldp_initialized, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/ldp_initialized (boolean)

    YANG Description: LDP initialized
    """
    return self.__ldp_initialized
      
  def _set_ldp_initialized(self, v, load=False):
    """
    Setter method for ldp_initialized, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/ldp_initialized (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_initialized is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_initialized() directly.

    YANG Description: LDP initialized
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ldp-initialized", rest_name="ldp-initialized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_initialized must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ldp-initialized", rest_name="ldp-initialized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__ldp_initialized = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_initialized(self):
    self.__ldp_initialized = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ldp-initialized", rest_name="ldp-initialized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_lsr_id(self):
    """
    Getter method for lsr_id, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/lsr_id (inet:ipv4-address)

    YANG Description: LDP LSR ID
    """
    return self.__lsr_id
      
  def _set_lsr_id(self, v, load=False):
    """
    Setter method for lsr_id, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/lsr_id (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsr_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsr_id() directly.

    YANG Description: LDP LSR ID
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="lsr-id", rest_name="lsr-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsr_id must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="lsr-id", rest_name="lsr-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__lsr_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsr_id(self):
    self.__lsr_id = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="lsr-id", rest_name="lsr-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='inet:ipv4-address', is_config=True)


  def _get_lsr_id_configured(self):
    """
    Getter method for lsr_id_configured, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/lsr_id_configured (boolean)

    YANG Description: LSR ID configured
    """
    return self.__lsr_id_configured
      
  def _set_lsr_id_configured(self, v, load=False):
    """
    Setter method for lsr_id_configured, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/lsr_id_configured (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsr_id_configured is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsr_id_configured() directly.

    YANG Description: LSR ID configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsr-id-configured", rest_name="lsr-id-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsr_id_configured must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsr-id-configured", rest_name="lsr-id-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lsr_id_configured = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsr_id_configured(self):
    self.__lsr_id_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsr-id-configured", rest_name="lsr-id-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_loopback(self):
    """
    Getter method for loopback, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/loopback (uint8)

    YANG Description: Loopback used
    """
    return self.__loopback
      
  def _set_loopback(self, v, load=False):
    """
    Setter method for loopback, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/loopback (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loopback is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loopback() directly.

    YANG Description: Loopback used
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="loopback", rest_name="loopback", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loopback must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="loopback", rest_name="loopback", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__loopback = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loopback(self):
    self.__loopback = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="loopback", rest_name="loopback", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_hello_interval_link(self):
    """
    Getter method for hello_interval_link, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/hello_interval_link (uint32)

    YANG Description: Global link hello interval
    """
    return self.__hello_interval_link
      
  def _set_hello_interval_link(self, v, load=False):
    """
    Setter method for hello_interval_link, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/hello_interval_link (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval_link is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval_link() directly.

    YANG Description: Global link hello interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-link", rest_name="hello-interval-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval_link must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-link", rest_name="hello-interval-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__hello_interval_link = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval_link(self):
    self.__hello_interval_link = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-link", rest_name="hello-interval-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_hello_interval_target(self):
    """
    Getter method for hello_interval_target, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/hello_interval_target (uint32)

    YANG Description: Target hello interval
    """
    return self.__hello_interval_target
      
  def _set_hello_interval_target(self, v, load=False):
    """
    Setter method for hello_interval_target, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/hello_interval_target (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval_target() directly.

    YANG Description: Target hello interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-target", rest_name="hello-interval-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval_target must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-target", rest_name="hello-interval-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__hello_interval_target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval_target(self):
    self.__hello_interval_target = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-target", rest_name="hello-interval-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_hold_time_sent_link(self):
    """
    Getter method for hold_time_sent_link, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/hold_time_sent_link (uint32)

    YANG Description: Hold time value sent in link hellos
    """
    return self.__hold_time_sent_link
      
  def _set_hold_time_sent_link(self, v, load=False):
    """
    Setter method for hold_time_sent_link, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/hold_time_sent_link (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_time_sent_link is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_time_sent_link() directly.

    YANG Description: Hold time value sent in link hellos
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-link", rest_name="hold-time-sent-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_time_sent_link must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-link", rest_name="hold-time-sent-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__hold_time_sent_link = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_time_sent_link(self):
    self.__hold_time_sent_link = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-link", rest_name="hold-time-sent-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_hold_time_sent_target(self):
    """
    Getter method for hold_time_sent_target, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/hold_time_sent_target (uint32)

    YANG Description: Hold time value sent in targeted hellos
    """
    return self.__hold_time_sent_target
      
  def _set_hold_time_sent_target(self, v, load=False):
    """
    Setter method for hold_time_sent_target, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/hold_time_sent_target (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_time_sent_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_time_sent_target() directly.

    YANG Description: Hold time value sent in targeted hellos
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-target", rest_name="hold-time-sent-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_time_sent_target must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-target", rest_name="hold-time-sent-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__hold_time_sent_target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_time_sent_target(self):
    self.__hold_time_sent_target = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-target", rest_name="hold-time-sent-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_ka_interval(self):
    """
    Getter method for ka_interval, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/ka_interval (uint32)

    YANG Description: Keepalive interval
    """
    return self.__ka_interval
      
  def _set_ka_interval(self, v, load=False):
    """
    Setter method for ka_interval, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/ka_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ka_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ka_interval() directly.

    YANG Description: Keepalive interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-interval", rest_name="ka-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ka_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-interval", rest_name="ka-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__ka_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ka_interval(self):
    self.__ka_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-interval", rest_name="ka-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_ka_multiple(self):
    """
    Getter method for ka_multiple, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/ka_multiple (uint32)

    YANG Description: Keepalive multiple
    """
    return self.__ka_multiple
      
  def _set_ka_multiple(self, v, load=False):
    """
    Setter method for ka_multiple, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/ka_multiple (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ka_multiple is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ka_multiple() directly.

    YANG Description: Keepalive multiple
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-multiple", rest_name="ka-multiple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ka_multiple must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-multiple", rest_name="ka-multiple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__ka_multiple = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ka_multiple(self):
    self.__ka_multiple = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-multiple", rest_name="ka-multiple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_ka_timeout(self):
    """
    Getter method for ka_timeout, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/ka_timeout (uint32)

    YANG Description: Keepalive timeout
    """
    return self.__ka_timeout
      
  def _set_ka_timeout(self, v, load=False):
    """
    Setter method for ka_timeout, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/ka_timeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ka_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ka_timeout() directly.

    YANG Description: Keepalive timeout
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-timeout", rest_name="ka-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ka_timeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-timeout", rest_name="ka-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__ka_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ka_timeout(self):
    self.__ka_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-timeout", rest_name="ka-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_ka_timeout_default(self):
    """
    Getter method for ka_timeout_default, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/ka_timeout_default (boolean)

    YANG Description: Keepalive timeout is default
    """
    return self.__ka_timeout_default
      
  def _set_ka_timeout_default(self, v, load=False):
    """
    Setter method for ka_timeout_default, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/ka_timeout_default (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ka_timeout_default is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ka_timeout_default() directly.

    YANG Description: Keepalive timeout is default
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ka-timeout-default", rest_name="ka-timeout-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ka_timeout_default must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ka-timeout-default", rest_name="ka-timeout-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__ka_timeout_default = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ka_timeout_default(self):
    self.__ka_timeout_default = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ka-timeout-default", rest_name="ka-timeout-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_load_sharing(self):
    """
    Getter method for load_sharing, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/load_sharing (uint8)

    YANG Description: Load sharing
    """
    return self.__load_sharing
      
  def _set_load_sharing(self, v, load=False):
    """
    Setter method for load_sharing, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/load_sharing (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_load_sharing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_load_sharing() directly.

    YANG Description: Load sharing
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="load-sharing", rest_name="load-sharing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """load_sharing must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="load-sharing", rest_name="load-sharing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__load_sharing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_load_sharing(self):
    self.__load_sharing = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="load-sharing", rest_name="load-sharing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_advertise_fecs_for_prefix_list(self):
    """
    Getter method for advertise_fecs_for_prefix_list, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/advertise_fecs_for_prefix_list (string)

    YANG Description: Advertise FECS for this prefix list
    """
    return self.__advertise_fecs_for_prefix_list
      
  def _set_advertise_fecs_for_prefix_list(self, v, load=False):
    """
    Setter method for advertise_fecs_for_prefix_list, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/advertise_fecs_for_prefix_list (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_fecs_for_prefix_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_fecs_for_prefix_list() directly.

    YANG Description: Advertise FECS for this prefix list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="advertise-fecs-for-prefix-list", rest_name="advertise-fecs-for-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_fecs_for_prefix_list must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="advertise-fecs-for-prefix-list", rest_name="advertise-fecs-for-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__advertise_fecs_for_prefix_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_fecs_for_prefix_list(self):
    self.__advertise_fecs_for_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="advertise-fecs-for-prefix-list", rest_name="advertise-fecs-for-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_advertise_fecs_for_prefix_list_exists(self):
    """
    Getter method for advertise_fecs_for_prefix_list_exists, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/advertise_fecs_for_prefix_list_exists (boolean)

    YANG Description: Advertise FECS for prefix list exists
    """
    return self.__advertise_fecs_for_prefix_list_exists
      
  def _set_advertise_fecs_for_prefix_list_exists(self, v, load=False):
    """
    Setter method for advertise_fecs_for_prefix_list_exists, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/advertise_fecs_for_prefix_list_exists (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_fecs_for_prefix_list_exists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_fecs_for_prefix_list_exists() directly.

    YANG Description: Advertise FECS for prefix list exists
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="advertise-fecs-for-prefix-list-exists", rest_name="advertise-fecs-for-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_fecs_for_prefix_list_exists must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-fecs-for-prefix-list-exists", rest_name="advertise-fecs-for-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__advertise_fecs_for_prefix_list_exists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_fecs_for_prefix_list_exists(self):
    self.__advertise_fecs_for_prefix_list_exists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-fecs-for-prefix-list-exists", rest_name="advertise-fecs-for-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_inbound_fecs_filtering_prefix_list(self):
    """
    Getter method for inbound_fecs_filtering_prefix_list, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/inbound_fecs_filtering_prefix_list (string)

    YANG Description: Inbound FECS filtering prefix list
    """
    return self.__inbound_fecs_filtering_prefix_list
      
  def _set_inbound_fecs_filtering_prefix_list(self, v, load=False):
    """
    Setter method for inbound_fecs_filtering_prefix_list, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/inbound_fecs_filtering_prefix_list (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inbound_fecs_filtering_prefix_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inbound_fecs_filtering_prefix_list() directly.

    YANG Description: Inbound FECS filtering prefix list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list", rest_name="inbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inbound_fecs_filtering_prefix_list must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list", rest_name="inbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__inbound_fecs_filtering_prefix_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inbound_fecs_filtering_prefix_list(self):
    self.__inbound_fecs_filtering_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list", rest_name="inbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_inbound_fecs_filtering_prefix_list_exists(self):
    """
    Getter method for inbound_fecs_filtering_prefix_list_exists, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/inbound_fecs_filtering_prefix_list_exists (boolean)

    YANG Description: Inbound FECS prefix list exists
    """
    return self.__inbound_fecs_filtering_prefix_list_exists
      
  def _set_inbound_fecs_filtering_prefix_list_exists(self, v, load=False):
    """
    Setter method for inbound_fecs_filtering_prefix_list_exists, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/inbound_fecs_filtering_prefix_list_exists (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inbound_fecs_filtering_prefix_list_exists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inbound_fecs_filtering_prefix_list_exists() directly.

    YANG Description: Inbound FECS prefix list exists
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list-exists", rest_name="inbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inbound_fecs_filtering_prefix_list_exists must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list-exists", rest_name="inbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__inbound_fecs_filtering_prefix_list_exists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inbound_fecs_filtering_prefix_list_exists(self):
    self.__inbound_fecs_filtering_prefix_list_exists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list-exists", rest_name="inbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_outbound_fecs_filtering_prefix_list(self):
    """
    Getter method for outbound_fecs_filtering_prefix_list, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/outbound_fecs_filtering_prefix_list (string)

    YANG Description: Outbound FECS filtering prefix list
    """
    return self.__outbound_fecs_filtering_prefix_list
      
  def _set_outbound_fecs_filtering_prefix_list(self, v, load=False):
    """
    Setter method for outbound_fecs_filtering_prefix_list, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/outbound_fecs_filtering_prefix_list (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outbound_fecs_filtering_prefix_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outbound_fecs_filtering_prefix_list() directly.

    YANG Description: Outbound FECS filtering prefix list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list", rest_name="outbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outbound_fecs_filtering_prefix_list must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list", rest_name="outbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__outbound_fecs_filtering_prefix_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outbound_fecs_filtering_prefix_list(self):
    self.__outbound_fecs_filtering_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list", rest_name="outbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_outbound_fecs_filtering_prefix_list_exists(self):
    """
    Getter method for outbound_fecs_filtering_prefix_list_exists, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/outbound_fecs_filtering_prefix_list_exists (boolean)

    YANG Description: Outbound FECS prefix list exists
    """
    return self.__outbound_fecs_filtering_prefix_list_exists
      
  def _set_outbound_fecs_filtering_prefix_list_exists(self, v, load=False):
    """
    Setter method for outbound_fecs_filtering_prefix_list_exists, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/outbound_fecs_filtering_prefix_list_exists (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outbound_fecs_filtering_prefix_list_exists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outbound_fecs_filtering_prefix_list_exists() directly.

    YANG Description: Outbound FECS prefix list exists
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list-exists", rest_name="outbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outbound_fecs_filtering_prefix_list_exists must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list-exists", rest_name="outbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__outbound_fecs_filtering_prefix_list_exists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outbound_fecs_filtering_prefix_list_exists(self):
    self.__outbound_fecs_filtering_prefix_list_exists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list-exists", rest_name="outbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_tunnel_metric(self):
    """
    Getter method for tunnel_metric, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/tunnel_metric (uint16)

    YANG Description: Tunnel metric
    """
    return self.__tunnel_metric
      
  def _set_tunnel_metric(self, v, load=False):
    """
    Setter method for tunnel_metric, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/tunnel_metric (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_metric() directly.

    YANG Description: Tunnel metric
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-metric", rest_name="tunnel-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_metric must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-metric", rest_name="tunnel-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)""",
        })

    self.__tunnel_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_metric(self):
    self.__tunnel_metric = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-metric", rest_name="tunnel-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)


  def _get_fec_128_used_for_auto_disc_current(self):
    """
    Getter method for fec_128_used_for_auto_disc_current, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/fec_128_used_for_auto_disc_current (boolean)

    YANG Description: Use 128 for auto discovered FECs current
    """
    return self.__fec_128_used_for_auto_disc_current
      
  def _set_fec_128_used_for_auto_disc_current(self, v, load=False):
    """
    Setter method for fec_128_used_for_auto_disc_current, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/fec_128_used_for_auto_disc_current (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_128_used_for_auto_disc_current is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_128_used_for_auto_disc_current() directly.

    YANG Description: Use 128 for auto discovered FECs current
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-current", rest_name="fec-128-used-for-auto-disc-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_128_used_for_auto_disc_current must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-current", rest_name="fec-128-used-for-auto-disc-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__fec_128_used_for_auto_disc_current = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_128_used_for_auto_disc_current(self):
    self.__fec_128_used_for_auto_disc_current = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-current", rest_name="fec-128-used-for-auto-disc-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_fec_128_used_for_auto_disc_configured(self):
    """
    Getter method for fec_128_used_for_auto_disc_configured, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/fec_128_used_for_auto_disc_configured (boolean)

    YANG Description: Use 128 for auto discovered FECs configured
    """
    return self.__fec_128_used_for_auto_disc_configured
      
  def _set_fec_128_used_for_auto_disc_configured(self, v, load=False):
    """
    Setter method for fec_128_used_for_auto_disc_configured, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/fec_128_used_for_auto_disc_configured (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_128_used_for_auto_disc_configured is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_128_used_for_auto_disc_configured() directly.

    YANG Description: Use 128 for auto discovered FECs configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-configured", rest_name="fec-128-used-for-auto-disc-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_128_used_for_auto_disc_configured must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-configured", rest_name="fec-128-used-for-auto-disc-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__fec_128_used_for_auto_disc_configured = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_128_used_for_auto_disc_configured(self):
    self.__fec_128_used_for_auto_disc_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-configured", rest_name="fec-128-used-for-auto-disc-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_end_of_lib(self):
    """
    Getter method for end_of_lib, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/end_of_lib (boolean)

    YANG Description: End of lib
    """
    return self.__end_of_lib
      
  def _set_end_of_lib(self, v, load=False):
    """
    Setter method for end_of_lib, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/end_of_lib (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_of_lib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_of_lib() directly.

    YANG Description: End of lib
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="end-of-lib", rest_name="end-of-lib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_of_lib must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="end-of-lib", rest_name="end-of-lib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__end_of_lib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_of_lib(self):
    self.__end_of_lib = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="end-of-lib", rest_name="end-of-lib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_eol_notification_time(self):
    """
    Getter method for eol_notification_time, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/eol_notification_time (uint32)

    YANG Description: End of lib notification time
    """
    return self.__eol_notification_time
      
  def _set_eol_notification_time(self, v, load=False):
    """
    Setter method for eol_notification_time, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/eol_notification_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eol_notification_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eol_notification_time() directly.

    YANG Description: End of lib notification time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time", rest_name="eol-notification-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eol_notification_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time", rest_name="eol-notification-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__eol_notification_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eol_notification_time(self):
    self.__eol_notification_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time", rest_name="eol-notification-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_tx_silence_time(self):
    """
    Getter method for tx_silence_time, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/tx_silence_time (uint32)

    YANG Description: End of lib transmit label silence time
    """
    return self.__tx_silence_time
      
  def _set_tx_silence_time(self, v, load=False):
    """
    Setter method for tx_silence_time, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/tx_silence_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_silence_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_silence_time() directly.

    YANG Description: End of lib transmit label silence time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-silence-time", rest_name="tx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_silence_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-silence-time", rest_name="tx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__tx_silence_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_silence_time(self):
    self.__tx_silence_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-silence-time", rest_name="tx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_rx_silence_time(self):
    """
    Getter method for rx_silence_time, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/rx_silence_time (uint32)

    YANG Description: End of lib receive label silence time
    """
    return self.__rx_silence_time
      
  def _set_rx_silence_time(self, v, load=False):
    """
    Setter method for rx_silence_time, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/rx_silence_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_silence_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_silence_time() directly.

    YANG Description: End of lib receive label silence time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rx-silence-time", rest_name="rx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_silence_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rx-silence-time", rest_name="rx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__rx_silence_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_silence_time(self):
    self.__rx_silence_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rx-silence-time", rest_name="rx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_gr_enable(self):
    """
    Getter method for gr_enable, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/gr_enable (boolean)

    YANG Description: Graceful restart enabled
    """
    return self.__gr_enable
      
  def _set_gr_enable(self, v, load=False):
    """
    Setter method for gr_enable, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/gr_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_enable() directly.

    YANG Description: Graceful restart enabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="gr-enable", rest_name="gr-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-enable", rest_name="gr-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__gr_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_enable(self):
    self.__gr_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-enable", rest_name="gr-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_gr_helper(self):
    """
    Getter method for gr_helper, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/gr_helper (boolean)

    YANG Description: Graceful restart helper mode
    """
    return self.__gr_helper
      
  def _set_gr_helper(self, v, load=False):
    """
    Setter method for gr_helper, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/gr_helper (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_helper is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_helper() directly.

    YANG Description: Graceful restart helper mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="gr-helper", rest_name="gr-helper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_helper must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-helper", rest_name="gr-helper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__gr_helper = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_helper(self):
    self.__gr_helper = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-helper", rest_name="gr-helper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_gr_reconnect_time(self):
    """
    Getter method for gr_reconnect_time, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/gr_reconnect_time (uint32)

    YANG Description: GR reconnect time
    """
    return self.__gr_reconnect_time
      
  def _set_gr_reconnect_time(self, v, load=False):
    """
    Setter method for gr_reconnect_time, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/gr_reconnect_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_reconnect_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_reconnect_time() directly.

    YANG Description: GR reconnect time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-reconnect-time", rest_name="gr-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_reconnect_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-reconnect-time", rest_name="gr-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__gr_reconnect_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_reconnect_time(self):
    self.__gr_reconnect_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-reconnect-time", rest_name="gr-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_gr_max_peer_reconnect_time(self):
    """
    Getter method for gr_max_peer_reconnect_time, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/gr_max_peer_reconnect_time (uint32)

    YANG Description: GR max peer reconnect time
    """
    return self.__gr_max_peer_reconnect_time
      
  def _set_gr_max_peer_reconnect_time(self, v, load=False):
    """
    Setter method for gr_max_peer_reconnect_time, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/gr_max_peer_reconnect_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_max_peer_reconnect_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_max_peer_reconnect_time() directly.

    YANG Description: GR max peer reconnect time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-reconnect-time", rest_name="gr-max-peer-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_max_peer_reconnect_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-reconnect-time", rest_name="gr-max-peer-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__gr_max_peer_reconnect_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_max_peer_reconnect_time(self):
    self.__gr_max_peer_reconnect_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-reconnect-time", rest_name="gr-max-peer-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_gr_recovery_time(self):
    """
    Getter method for gr_recovery_time, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/gr_recovery_time (uint32)

    YANG Description: GR recovery time
    """
    return self.__gr_recovery_time
      
  def _set_gr_recovery_time(self, v, load=False):
    """
    Setter method for gr_recovery_time, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/gr_recovery_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_recovery_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_recovery_time() directly.

    YANG Description: GR recovery time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-recovery-time", rest_name="gr-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_recovery_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-recovery-time", rest_name="gr-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__gr_recovery_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_recovery_time(self):
    self.__gr_recovery_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-recovery-time", rest_name="gr-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_gr_max_peer_recovery_time(self):
    """
    Getter method for gr_max_peer_recovery_time, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/gr_max_peer_recovery_time (uint32)

    YANG Description: GR max peer recovery time
    """
    return self.__gr_max_peer_recovery_time
      
  def _set_gr_max_peer_recovery_time(self, v, load=False):
    """
    Setter method for gr_max_peer_recovery_time, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/gr_max_peer_recovery_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_max_peer_recovery_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_max_peer_recovery_time() directly.

    YANG Description: GR max peer recovery time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-recovery-time", rest_name="gr-max-peer-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_max_peer_recovery_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-recovery-time", rest_name="gr-max-peer-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__gr_max_peer_recovery_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_max_peer_recovery_time(self):
    self.__gr_max_peer_recovery_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-recovery-time", rest_name="gr-max-peer-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_forwarding_state_timer_running(self):
    """
    Getter method for forwarding_state_timer_running, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/forwarding_state_timer_running (boolean)

    YANG Description: Forwarding state timer is running
    """
    return self.__forwarding_state_timer_running
      
  def _set_forwarding_state_timer_running(self, v, load=False):
    """
    Setter method for forwarding_state_timer_running, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/forwarding_state_timer_running (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_forwarding_state_timer_running is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_forwarding_state_timer_running() directly.

    YANG Description: Forwarding state timer is running
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="forwarding-state-timer-running", rest_name="forwarding-state-timer-running", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """forwarding_state_timer_running must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="forwarding-state-timer-running", rest_name="forwarding-state-timer-running", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__forwarding_state_timer_running = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_forwarding_state_timer_running(self):
    self.__forwarding_state_timer_running = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="forwarding-state-timer-running", rest_name="forwarding-state-timer-running", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)


  def _get_forwarding_state_timer_remaining(self):
    """
    Getter method for forwarding_state_timer_remaining, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/forwarding_state_timer_remaining (uint32)

    YANG Description: Forwarding state timer remaining
    """
    return self.__forwarding_state_timer_remaining
      
  def _set_forwarding_state_timer_remaining(self, v, load=False):
    """
    Setter method for forwarding_state_timer_remaining, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/forwarding_state_timer_remaining (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_forwarding_state_timer_remaining is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_forwarding_state_timer_remaining() directly.

    YANG Description: Forwarding state timer remaining
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="forwarding-state-timer-remaining", rest_name="forwarding-state-timer-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """forwarding_state_timer_remaining must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="forwarding-state-timer-remaining", rest_name="forwarding-state-timer-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__forwarding_state_timer_remaining = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_forwarding_state_timer_remaining(self):
    self.__forwarding_state_timer_remaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="forwarding-state-timer-remaining", rest_name="forwarding-state-timer-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_lwd_delay(self):
    """
    Getter method for lwd_delay, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/lwd_delay (uint32)

    YANG Description: Label withdraw delay timer configured
    """
    return self.__lwd_delay
      
  def _set_lwd_delay(self, v, load=False):
    """
    Setter method for lwd_delay, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/lwd_delay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lwd_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lwd_delay() directly.

    YANG Description: Label withdraw delay timer configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lwd-delay", rest_name="lwd-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lwd_delay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lwd-delay", rest_name="lwd-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__lwd_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lwd_delay(self):
    self.__lwd_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lwd-delay", rest_name="lwd-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_lwd_default(self):
    """
    Getter method for lwd_default, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/lwd_default (boolean)

    YANG Description: Is label withdraw delay value default
    """
    return self.__lwd_default
      
  def _set_lwd_default(self, v, load=False):
    """
    Setter method for lwd_default, mapped from YANG variable /brocade_mpls_rpc/show_mpls_ldp/output/lwd_default (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lwd_default is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lwd_default() directly.

    YANG Description: Is label withdraw delay value default
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lwd-default", rest_name="lwd-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lwd_default must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lwd-default", rest_name="lwd-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)""",
        })

    self.__lwd_default = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lwd_default(self):
    self.__lwd_default = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lwd-default", rest_name="lwd-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='boolean', is_config=True)

  ldp_initialized = __builtin__.property(_get_ldp_initialized, _set_ldp_initialized)
  lsr_id = __builtin__.property(_get_lsr_id, _set_lsr_id)
  lsr_id_configured = __builtin__.property(_get_lsr_id_configured, _set_lsr_id_configured)
  loopback = __builtin__.property(_get_loopback, _set_loopback)
  hello_interval_link = __builtin__.property(_get_hello_interval_link, _set_hello_interval_link)
  hello_interval_target = __builtin__.property(_get_hello_interval_target, _set_hello_interval_target)
  hold_time_sent_link = __builtin__.property(_get_hold_time_sent_link, _set_hold_time_sent_link)
  hold_time_sent_target = __builtin__.property(_get_hold_time_sent_target, _set_hold_time_sent_target)
  ka_interval = __builtin__.property(_get_ka_interval, _set_ka_interval)
  ka_multiple = __builtin__.property(_get_ka_multiple, _set_ka_multiple)
  ka_timeout = __builtin__.property(_get_ka_timeout, _set_ka_timeout)
  ka_timeout_default = __builtin__.property(_get_ka_timeout_default, _set_ka_timeout_default)
  load_sharing = __builtin__.property(_get_load_sharing, _set_load_sharing)
  advertise_fecs_for_prefix_list = __builtin__.property(_get_advertise_fecs_for_prefix_list, _set_advertise_fecs_for_prefix_list)
  advertise_fecs_for_prefix_list_exists = __builtin__.property(_get_advertise_fecs_for_prefix_list_exists, _set_advertise_fecs_for_prefix_list_exists)
  inbound_fecs_filtering_prefix_list = __builtin__.property(_get_inbound_fecs_filtering_prefix_list, _set_inbound_fecs_filtering_prefix_list)
  inbound_fecs_filtering_prefix_list_exists = __builtin__.property(_get_inbound_fecs_filtering_prefix_list_exists, _set_inbound_fecs_filtering_prefix_list_exists)
  outbound_fecs_filtering_prefix_list = __builtin__.property(_get_outbound_fecs_filtering_prefix_list, _set_outbound_fecs_filtering_prefix_list)
  outbound_fecs_filtering_prefix_list_exists = __builtin__.property(_get_outbound_fecs_filtering_prefix_list_exists, _set_outbound_fecs_filtering_prefix_list_exists)
  tunnel_metric = __builtin__.property(_get_tunnel_metric, _set_tunnel_metric)
  fec_128_used_for_auto_disc_current = __builtin__.property(_get_fec_128_used_for_auto_disc_current, _set_fec_128_used_for_auto_disc_current)
  fec_128_used_for_auto_disc_configured = __builtin__.property(_get_fec_128_used_for_auto_disc_configured, _set_fec_128_used_for_auto_disc_configured)
  end_of_lib = __builtin__.property(_get_end_of_lib, _set_end_of_lib)
  eol_notification_time = __builtin__.property(_get_eol_notification_time, _set_eol_notification_time)
  tx_silence_time = __builtin__.property(_get_tx_silence_time, _set_tx_silence_time)
  rx_silence_time = __builtin__.property(_get_rx_silence_time, _set_rx_silence_time)
  gr_enable = __builtin__.property(_get_gr_enable, _set_gr_enable)
  gr_helper = __builtin__.property(_get_gr_helper, _set_gr_helper)
  gr_reconnect_time = __builtin__.property(_get_gr_reconnect_time, _set_gr_reconnect_time)
  gr_max_peer_reconnect_time = __builtin__.property(_get_gr_max_peer_reconnect_time, _set_gr_max_peer_reconnect_time)
  gr_recovery_time = __builtin__.property(_get_gr_recovery_time, _set_gr_recovery_time)
  gr_max_peer_recovery_time = __builtin__.property(_get_gr_max_peer_recovery_time, _set_gr_max_peer_recovery_time)
  forwarding_state_timer_running = __builtin__.property(_get_forwarding_state_timer_running, _set_forwarding_state_timer_running)
  forwarding_state_timer_remaining = __builtin__.property(_get_forwarding_state_timer_remaining, _set_forwarding_state_timer_remaining)
  lwd_delay = __builtin__.property(_get_lwd_delay, _set_lwd_delay)
  lwd_default = __builtin__.property(_get_lwd_default, _set_lwd_default)


  _pyangbind_elements = {'ldp_initialized': ldp_initialized, 'lsr_id': lsr_id, 'lsr_id_configured': lsr_id_configured, 'loopback': loopback, 'hello_interval_link': hello_interval_link, 'hello_interval_target': hello_interval_target, 'hold_time_sent_link': hold_time_sent_link, 'hold_time_sent_target': hold_time_sent_target, 'ka_interval': ka_interval, 'ka_multiple': ka_multiple, 'ka_timeout': ka_timeout, 'ka_timeout_default': ka_timeout_default, 'load_sharing': load_sharing, 'advertise_fecs_for_prefix_list': advertise_fecs_for_prefix_list, 'advertise_fecs_for_prefix_list_exists': advertise_fecs_for_prefix_list_exists, 'inbound_fecs_filtering_prefix_list': inbound_fecs_filtering_prefix_list, 'inbound_fecs_filtering_prefix_list_exists': inbound_fecs_filtering_prefix_list_exists, 'outbound_fecs_filtering_prefix_list': outbound_fecs_filtering_prefix_list, 'outbound_fecs_filtering_prefix_list_exists': outbound_fecs_filtering_prefix_list_exists, 'tunnel_metric': tunnel_metric, 'fec_128_used_for_auto_disc_current': fec_128_used_for_auto_disc_current, 'fec_128_used_for_auto_disc_configured': fec_128_used_for_auto_disc_configured, 'end_of_lib': end_of_lib, 'eol_notification_time': eol_notification_time, 'tx_silence_time': tx_silence_time, 'rx_silence_time': rx_silence_time, 'gr_enable': gr_enable, 'gr_helper': gr_helper, 'gr_reconnect_time': gr_reconnect_time, 'gr_max_peer_reconnect_time': gr_max_peer_reconnect_time, 'gr_recovery_time': gr_recovery_time, 'gr_max_peer_recovery_time': gr_max_peer_recovery_time, 'forwarding_state_timer_running': forwarding_state_timer_running, 'forwarding_state_timer_remaining': forwarding_state_timer_remaining, 'lwd_delay': lwd_delay, 'lwd_default': lwd_default, }


