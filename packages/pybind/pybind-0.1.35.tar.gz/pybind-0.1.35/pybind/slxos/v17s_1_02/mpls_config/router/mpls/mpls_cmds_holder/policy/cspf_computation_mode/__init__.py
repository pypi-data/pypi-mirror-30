
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class cspf_computation_mode(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls - based on the path /mpls-config/router/mpls/mpls-cmds-holder/policy/cspf-computation-mode. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__use_bypass_liberal','__use_bypass_metric','__ignore_overload_bit','__cspf_metric_type',)

  _yang_name = 'cspf-computation-mode'
  _rest_name = 'cspf-computation-mode'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__ignore_overload_bit = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ignore-overload-bit", rest_name="ignore-overload-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'ignore overload bit during cspf computation', u'cli-full-command': None, u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    self.__cspf_metric_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'use-igp-metric': {'value': 1}, u'use-te-metric': {'value': 2}},), is_leaf=True, yang_name="cspf-metric-type", rest_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Select metric type for cspf computation', u'cli-full-command': None, u'alt-name': u'metric-type', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='cspf-computation-mode', is_config=True)
    self.__use_bypass_liberal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-bypass-liberal", rest_name="use-bypass-liberal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'use liberal mode for CSPF facility backup computation', u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    self.__use_bypass_metric = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-bypass-metric", rest_name="use-bypass-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u"use bypass LSP's path cost for selection between bypass LSP's", u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mpls-config', u'router', u'mpls', u'mpls-cmds-holder', u'policy', u'cspf-computation-mode']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'router', u'mpls', u'policy', u'cspf-computation-mode']

  def _get_use_bypass_liberal(self):
    """
    Getter method for use_bypass_liberal, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/cspf_computation_mode/use_bypass_liberal (empty)
    """
    return self.__use_bypass_liberal
      
  def _set_use_bypass_liberal(self, v, load=False):
    """
    Setter method for use_bypass_liberal, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/cspf_computation_mode/use_bypass_liberal (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_bypass_liberal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_bypass_liberal() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="use-bypass-liberal", rest_name="use-bypass-liberal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'use liberal mode for CSPF facility backup computation', u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_bypass_liberal must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-bypass-liberal", rest_name="use-bypass-liberal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'use liberal mode for CSPF facility backup computation', u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)""",
        })

    self.__use_bypass_liberal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_bypass_liberal(self):
    self.__use_bypass_liberal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-bypass-liberal", rest_name="use-bypass-liberal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'use liberal mode for CSPF facility backup computation', u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)


  def _get_use_bypass_metric(self):
    """
    Getter method for use_bypass_metric, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/cspf_computation_mode/use_bypass_metric (empty)
    """
    return self.__use_bypass_metric
      
  def _set_use_bypass_metric(self, v, load=False):
    """
    Setter method for use_bypass_metric, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/cspf_computation_mode/use_bypass_metric (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_bypass_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_bypass_metric() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="use-bypass-metric", rest_name="use-bypass-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u"use bypass LSP's path cost for selection between bypass LSP's", u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_bypass_metric must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-bypass-metric", rest_name="use-bypass-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u"use bypass LSP's path cost for selection between bypass LSP's", u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)""",
        })

    self.__use_bypass_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_bypass_metric(self):
    self.__use_bypass_metric = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-bypass-metric", rest_name="use-bypass-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u"use bypass LSP's path cost for selection between bypass LSP's", u'cli-full-command': None, u'hidden': u'full', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)


  def _get_ignore_overload_bit(self):
    """
    Getter method for ignore_overload_bit, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/cspf_computation_mode/ignore_overload_bit (empty)
    """
    return self.__ignore_overload_bit
      
  def _set_ignore_overload_bit(self, v, load=False):
    """
    Setter method for ignore_overload_bit, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/cspf_computation_mode/ignore_overload_bit (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_overload_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_overload_bit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ignore-overload-bit", rest_name="ignore-overload-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'ignore overload bit during cspf computation', u'cli-full-command': None, u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_overload_bit must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ignore-overload-bit", rest_name="ignore-overload-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'ignore overload bit during cspf computation', u'cli-full-command': None, u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)""",
        })

    self.__ignore_overload_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_overload_bit(self):
    self.__ignore_overload_bit = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ignore-overload-bit", rest_name="ignore-overload-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'ignore overload bit during cspf computation', u'cli-full-command': None, u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)


  def _get_cspf_metric_type(self):
    """
    Getter method for cspf_metric_type, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/cspf_computation_mode/cspf_metric_type (cspf-computation-mode)
    """
    return self.__cspf_metric_type
      
  def _set_cspf_metric_type(self, v, load=False):
    """
    Setter method for cspf_metric_type, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/cspf_computation_mode/cspf_metric_type (cspf-computation-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cspf_metric_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cspf_metric_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'use-igp-metric': {'value': 1}, u'use-te-metric': {'value': 2}},), is_leaf=True, yang_name="cspf-metric-type", rest_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Select metric type for cspf computation', u'cli-full-command': None, u'alt-name': u'metric-type', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='cspf-computation-mode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cspf_metric_type must be of a type compatible with cspf-computation-mode""",
          'defined-type': "brocade-mpls:cspf-computation-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'use-igp-metric': {'value': 1}, u'use-te-metric': {'value': 2}},), is_leaf=True, yang_name="cspf-metric-type", rest_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Select metric type for cspf computation', u'cli-full-command': None, u'alt-name': u'metric-type', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='cspf-computation-mode', is_config=True)""",
        })

    self.__cspf_metric_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cspf_metric_type(self):
    self.__cspf_metric_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'use-igp-metric': {'value': 1}, u'use-te-metric': {'value': 2}},), is_leaf=True, yang_name="cspf-metric-type", rest_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Select metric type for cspf computation', u'cli-full-command': None, u'alt-name': u'metric-type', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='cspf-computation-mode', is_config=True)

  use_bypass_liberal = __builtin__.property(_get_use_bypass_liberal, _set_use_bypass_liberal)
  use_bypass_metric = __builtin__.property(_get_use_bypass_metric, _set_use_bypass_metric)
  ignore_overload_bit = __builtin__.property(_get_ignore_overload_bit, _set_ignore_overload_bit)
  cspf_metric_type = __builtin__.property(_get_cspf_metric_type, _set_cspf_metric_type)


  _pyangbind_elements = {'use_bypass_liberal': use_bypass_liberal, 'use_bypass_metric': use_bypass_metric, 'ignore_overload_bit': ignore_overload_bit, 'cspf_metric_type': cspf_metric_type, }


