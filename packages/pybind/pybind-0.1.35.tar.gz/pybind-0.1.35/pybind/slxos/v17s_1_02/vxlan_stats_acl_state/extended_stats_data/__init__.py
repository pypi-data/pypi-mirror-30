
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class extended_stats_data(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-ssm-operational - based on the path /vxlan-stats-acl-state/extended-stats-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Extended stats ACL
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__acl_name','__seq_num','__permit_deny','__dst_vtep_ip','__src_vtep_ip','__vni','__vni_mask','__native_tag','__dst_ip','__dst_ip_mask','__src_ip','__src_ip_mask','__dst_port','__src_port','__count','__byte_count','__sflow','__redir_interface','__mirror_interface',)

  _yang_name = 'extended-stats-data'
  _rest_name = 'extended-stats-data'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", rest_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint64', is_config=False)
    self.__sflow = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sflow", rest_name="sflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='boolean', is_config=False)
    self.__src_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="src-port", rest_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)
    self.__native_tag = YANGDynClass(base=unicode, is_leaf=True, yang_name="native-tag", rest_name="native-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)
    self.__acl_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="acl-name", rest_name="acl-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)
    self.__seq_num = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="seq-num", rest_name="seq-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint32', is_config=False)
    self.__vni_mask = YANGDynClass(base=unicode, is_leaf=True, yang_name="vni-mask", rest_name="vni-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)
    self.__redir_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="redir-interface", rest_name="redir-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)
    self.__vni = YANGDynClass(base=unicode, is_leaf=True, yang_name="vni", rest_name="vni", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)
    self.__byte_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="byte-count", rest_name="byte-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint64', is_config=False)
    self.__src_ip = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="src-ip", rest_name="src-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)
    self.__permit_deny = YANGDynClass(base=unicode, is_leaf=True, yang_name="permit-deny", rest_name="permit-deny", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)
    self.__dst_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dst-port", rest_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)
    self.__dst_ip_mask = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dst-ip-mask", rest_name="dst-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)
    self.__dst_ip = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dst-ip", rest_name="dst-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)
    self.__src_ip_mask = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="src-ip-mask", rest_name="src-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)
    self.__src_vtep_ip = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="src-vtep-ip", rest_name="src-vtep-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)
    self.__dst_vtep_ip = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dst-vtep-ip", rest_name="dst-vtep-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)
    self.__mirror_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="mirror-interface", rest_name="mirror-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vxlan-stats-acl-state', u'extended-stats-data']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'vxlan-stats-acl-state', u'extended-stats-data']

  def _get_acl_name(self):
    """
    Getter method for acl_name, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/acl_name (string)

    YANG Description: input_Acl_name
    """
    return self.__acl_name
      
  def _set_acl_name(self, v, load=False):
    """
    Setter method for acl_name, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/acl_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acl_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acl_name() directly.

    YANG Description: input_Acl_name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="acl-name", rest_name="acl-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acl_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="acl-name", rest_name="acl-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)""",
        })

    self.__acl_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acl_name(self):
    self.__acl_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="acl-name", rest_name="acl-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)


  def _get_seq_num(self):
    """
    Getter method for seq_num, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/seq_num (uint32)

    YANG Description: sequence number
    """
    return self.__seq_num
      
  def _set_seq_num(self, v, load=False):
    """
    Setter method for seq_num, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/seq_num (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq_num() directly.

    YANG Description: sequence number
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="seq-num", rest_name="seq-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq_num must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="seq-num", rest_name="seq-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__seq_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq_num(self):
    self.__seq_num = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="seq-num", rest_name="seq-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint32', is_config=False)


  def _get_permit_deny(self):
    """
    Getter method for permit_deny, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/permit_deny (string)

    YANG Description: permit or deny
    """
    return self.__permit_deny
      
  def _set_permit_deny(self, v, load=False):
    """
    Setter method for permit_deny, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/permit_deny (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_permit_deny is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_permit_deny() directly.

    YANG Description: permit or deny
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="permit-deny", rest_name="permit-deny", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """permit_deny must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="permit-deny", rest_name="permit-deny", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)""",
        })

    self.__permit_deny = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_permit_deny(self):
    self.__permit_deny = YANGDynClass(base=unicode, is_leaf=True, yang_name="permit-deny", rest_name="permit-deny", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)


  def _get_dst_vtep_ip(self):
    """
    Getter method for dst_vtep_ip, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/dst_vtep_ip (inet:ipv4-address)

    YANG Description: dst vtep ip or any
    """
    return self.__dst_vtep_ip
      
  def _set_dst_vtep_ip(self, v, load=False):
    """
    Setter method for dst_vtep_ip, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/dst_vtep_ip (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_vtep_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_vtep_ip() directly.

    YANG Description: dst vtep ip or any
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dst-vtep-ip", rest_name="dst-vtep-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_vtep_ip must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dst-vtep-ip", rest_name="dst-vtep-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)""",
        })

    self.__dst_vtep_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_vtep_ip(self):
    self.__dst_vtep_ip = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dst-vtep-ip", rest_name="dst-vtep-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)


  def _get_src_vtep_ip(self):
    """
    Getter method for src_vtep_ip, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/src_vtep_ip (inet:ipv4-address)

    YANG Description: src vtep ip or any
    """
    return self.__src_vtep_ip
      
  def _set_src_vtep_ip(self, v, load=False):
    """
    Setter method for src_vtep_ip, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/src_vtep_ip (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_vtep_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_vtep_ip() directly.

    YANG Description: src vtep ip or any
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="src-vtep-ip", rest_name="src-vtep-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_vtep_ip must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="src-vtep-ip", rest_name="src-vtep-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)""",
        })

    self.__src_vtep_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_vtep_ip(self):
    self.__src_vtep_ip = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="src-vtep-ip", rest_name="src-vtep-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)


  def _get_vni(self):
    """
    Getter method for vni, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/vni (string)

    YANG Description: vni number or any
    """
    return self.__vni
      
  def _set_vni(self, v, load=False):
    """
    Setter method for vni, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/vni (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vni is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vni() directly.

    YANG Description: vni number or any
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vni", rest_name="vni", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vni must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vni", rest_name="vni", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)""",
        })

    self.__vni = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vni(self):
    self.__vni = YANGDynClass(base=unicode, is_leaf=True, yang_name="vni", rest_name="vni", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)


  def _get_vni_mask(self):
    """
    Getter method for vni_mask, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/vni_mask (string)

    YANG Description: vni mask
    """
    return self.__vni_mask
      
  def _set_vni_mask(self, v, load=False):
    """
    Setter method for vni_mask, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/vni_mask (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vni_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vni_mask() directly.

    YANG Description: vni mask
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vni-mask", rest_name="vni-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vni_mask must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vni-mask", rest_name="vni-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)""",
        })

    self.__vni_mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vni_mask(self):
    self.__vni_mask = YANGDynClass(base=unicode, is_leaf=True, yang_name="vni-mask", rest_name="vni-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)


  def _get_native_tag(self):
    """
    Getter method for native_tag, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/native_tag (string)

    YANG Description: native tag
    """
    return self.__native_tag
      
  def _set_native_tag(self, v, load=False):
    """
    Setter method for native_tag, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/native_tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_native_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_native_tag() directly.

    YANG Description: native tag
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="native-tag", rest_name="native-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """native_tag must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="native-tag", rest_name="native-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)""",
        })

    self.__native_tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_native_tag(self):
    self.__native_tag = YANGDynClass(base=unicode, is_leaf=True, yang_name="native-tag", rest_name="native-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)


  def _get_dst_ip(self):
    """
    Getter method for dst_ip, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/dst_ip (inet:ipv4-address)

    YANG Description: dst ip or any
    """
    return self.__dst_ip
      
  def _set_dst_ip(self, v, load=False):
    """
    Setter method for dst_ip, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/dst_ip (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_ip() directly.

    YANG Description: dst ip or any
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dst-ip", rest_name="dst-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_ip must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dst-ip", rest_name="dst-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)""",
        })

    self.__dst_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_ip(self):
    self.__dst_ip = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dst-ip", rest_name="dst-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)


  def _get_dst_ip_mask(self):
    """
    Getter method for dst_ip_mask, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/dst_ip_mask (uint16)

    YANG Description: dst ip mask
    """
    return self.__dst_ip_mask
      
  def _set_dst_ip_mask(self, v, load=False):
    """
    Setter method for dst_ip_mask, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/dst_ip_mask (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_ip_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_ip_mask() directly.

    YANG Description: dst ip mask
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dst-ip-mask", rest_name="dst-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_ip_mask must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dst-ip-mask", rest_name="dst-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)""",
        })

    self.__dst_ip_mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_ip_mask(self):
    self.__dst_ip_mask = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dst-ip-mask", rest_name="dst-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)


  def _get_src_ip(self):
    """
    Getter method for src_ip, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/src_ip (inet:ipv4-address)

    YANG Description: src ip or any
    """
    return self.__src_ip
      
  def _set_src_ip(self, v, load=False):
    """
    Setter method for src_ip, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/src_ip (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_ip() directly.

    YANG Description: src ip or any
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="src-ip", rest_name="src-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_ip must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="src-ip", rest_name="src-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)""",
        })

    self.__src_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_ip(self):
    self.__src_ip = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="src-ip", rest_name="src-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='inet:ipv4-address', is_config=False)


  def _get_src_ip_mask(self):
    """
    Getter method for src_ip_mask, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/src_ip_mask (uint16)

    YANG Description: src ip mask
    """
    return self.__src_ip_mask
      
  def _set_src_ip_mask(self, v, load=False):
    """
    Setter method for src_ip_mask, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/src_ip_mask (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_ip_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_ip_mask() directly.

    YANG Description: src ip mask
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="src-ip-mask", rest_name="src-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_ip_mask must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="src-ip-mask", rest_name="src-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)""",
        })

    self.__src_ip_mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_ip_mask(self):
    self.__src_ip_mask = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="src-ip-mask", rest_name="src-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)


  def _get_dst_port(self):
    """
    Getter method for dst_port, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/dst_port (uint16)

    YANG Description: dst port number
    """
    return self.__dst_port
      
  def _set_dst_port(self, v, load=False):
    """
    Setter method for dst_port, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/dst_port (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_port() directly.

    YANG Description: dst port number
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dst-port", rest_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_port must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dst-port", rest_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)""",
        })

    self.__dst_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_port(self):
    self.__dst_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dst-port", rest_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)


  def _get_src_port(self):
    """
    Getter method for src_port, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/src_port (uint16)

    YANG Description: src port number
    """
    return self.__src_port
      
  def _set_src_port(self, v, load=False):
    """
    Setter method for src_port, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/src_port (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_port() directly.

    YANG Description: src port number
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="src-port", rest_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_port must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="src-port", rest_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)""",
        })

    self.__src_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_port(self):
    self.__src_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="src-port", rest_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint16', is_config=False)


  def _get_count(self):
    """
    Getter method for count, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/count (uint64)

    YANG Description: count
    """
    return self.__count
      
  def _set_count(self, v, load=False):
    """
    Setter method for count, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: count
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", rest_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """count must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", rest_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint64', is_config=False)""",
        })

    self.__count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_count(self):
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", rest_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint64', is_config=False)


  def _get_byte_count(self):
    """
    Getter method for byte_count, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/byte_count (uint64)

    YANG Description: byte_count
    """
    return self.__byte_count
      
  def _set_byte_count(self, v, load=False):
    """
    Setter method for byte_count, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/byte_count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_byte_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_byte_count() directly.

    YANG Description: byte_count
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="byte-count", rest_name="byte-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """byte_count must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="byte-count", rest_name="byte-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint64', is_config=False)""",
        })

    self.__byte_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_byte_count(self):
    self.__byte_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="byte-count", rest_name="byte-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='uint64', is_config=False)


  def _get_sflow(self):
    """
    Getter method for sflow, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/sflow (boolean)

    YANG Description: sflow enable or disable
    """
    return self.__sflow
      
  def _set_sflow(self, v, load=False):
    """
    Setter method for sflow, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/sflow (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sflow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sflow() directly.

    YANG Description: sflow enable or disable
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="sflow", rest_name="sflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sflow must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sflow", rest_name="sflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='boolean', is_config=False)""",
        })

    self.__sflow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sflow(self):
    self.__sflow = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sflow", rest_name="sflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='boolean', is_config=False)


  def _get_redir_interface(self):
    """
    Getter method for redir_interface, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/redir_interface (string)

    YANG Description: redirect interface
    """
    return self.__redir_interface
      
  def _set_redir_interface(self, v, load=False):
    """
    Setter method for redir_interface, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/redir_interface (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_redir_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_redir_interface() directly.

    YANG Description: redirect interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="redir-interface", rest_name="redir-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """redir_interface must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="redir-interface", rest_name="redir-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)""",
        })

    self.__redir_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_redir_interface(self):
    self.__redir_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="redir-interface", rest_name="redir-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)


  def _get_mirror_interface(self):
    """
    Getter method for mirror_interface, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/mirror_interface (string)

    YANG Description: mirror interface
    """
    return self.__mirror_interface
      
  def _set_mirror_interface(self, v, load=False):
    """
    Setter method for mirror_interface, mapped from YANG variable /vxlan_stats_acl_state/extended_stats_data/mirror_interface (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mirror_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mirror_interface() directly.

    YANG Description: mirror interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="mirror-interface", rest_name="mirror-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mirror_interface must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="mirror-interface", rest_name="mirror-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)""",
        })

    self.__mirror_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mirror_interface(self):
    self.__mirror_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="mirror-interface", rest_name="mirror-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-ssm-operational', defining_module='brocade-ssm-operational', yang_type='string', is_config=False)

  acl_name = __builtin__.property(_get_acl_name)
  seq_num = __builtin__.property(_get_seq_num)
  permit_deny = __builtin__.property(_get_permit_deny)
  dst_vtep_ip = __builtin__.property(_get_dst_vtep_ip)
  src_vtep_ip = __builtin__.property(_get_src_vtep_ip)
  vni = __builtin__.property(_get_vni)
  vni_mask = __builtin__.property(_get_vni_mask)
  native_tag = __builtin__.property(_get_native_tag)
  dst_ip = __builtin__.property(_get_dst_ip)
  dst_ip_mask = __builtin__.property(_get_dst_ip_mask)
  src_ip = __builtin__.property(_get_src_ip)
  src_ip_mask = __builtin__.property(_get_src_ip_mask)
  dst_port = __builtin__.property(_get_dst_port)
  src_port = __builtin__.property(_get_src_port)
  count = __builtin__.property(_get_count)
  byte_count = __builtin__.property(_get_byte_count)
  sflow = __builtin__.property(_get_sflow)
  redir_interface = __builtin__.property(_get_redir_interface)
  mirror_interface = __builtin__.property(_get_mirror_interface)


  _pyangbind_elements = {'acl_name': acl_name, 'seq_num': seq_num, 'permit_deny': permit_deny, 'dst_vtep_ip': dst_vtep_ip, 'src_vtep_ip': src_vtep_ip, 'vni': vni, 'vni_mask': vni_mask, 'native_tag': native_tag, 'dst_ip': dst_ip, 'dst_ip_mask': dst_ip_mask, 'src_ip': src_ip, 'src_ip_mask': src_ip_mask, 'dst_port': dst_port, 'src_port': src_port, 'count': count, 'byte_count': byte_count, 'sflow': sflow, 'redir_interface': redir_interface, 'mirror_interface': mirror_interface, }


