
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import controller_detail_list
import hybrid_interfaces
class detail(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-openflow-operational - based on the path /openflow-state/detail. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__admin_status','__ssl_status','__num_controllers','__data_path','__l2_match','__l3_match','__max_l2_flows','__active_flows','__enabled_ports','__default_action','__controller_detail_list','__hybrid_interfaces',)

  _yang_name = 'detail'
  _rest_name = 'detail'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__active_flows = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="active-flows", rest_name="active-flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    self.__num_controllers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-controllers", rest_name="num-controllers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    self.__controller_detail_list = YANGDynClass(base=YANGListType("controller_idx",controller_detail_list.controller_detail_list, yang_name="controller-detail-list", rest_name="controller-detail-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='controller-idx', extensions={u'tailf-common': {u'callpoint': u'openflow-controller-detail-list', u'cli-suppress-show-path': None}}), is_container='list', yang_name="controller-detail-list", rest_name="controller-detail-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-controller-detail-list', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)
    self.__data_path = YANGDynClass(base=unicode, is_leaf=True, yang_name="data-path", rest_name="data-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__hybrid_interfaces = YANGDynClass(base=YANGListType("hybrid_interface",hybrid_interfaces.hybrid_interfaces, yang_name="hybrid-interfaces", rest_name="hybrid-interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hybrid-interface', extensions={u'tailf-common': {u'callpoint': u'openflow-hybrid-interfaces', u'cli-suppress-show-path': None}}), is_container='list', yang_name="hybrid-interfaces", rest_name="hybrid-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-hybrid-interfaces', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)
    self.__admin_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="admin-status", rest_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='boolean', is_config=False)
    self.__l3_match = YANGDynClass(base=unicode, is_leaf=True, yang_name="l3-match", rest_name="l3-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__l2_match = YANGDynClass(base=unicode, is_leaf=True, yang_name="l2-match", rest_name="l2-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__default_action = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dcm-action-drop': {'value': 1}, u'dcm-action-invalid': {'value': 0}, u'dcm-action-send-to-controller': {'value': 2}},), is_leaf=True, yang_name="default-action", rest_name="default-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='default-packet-action', is_config=False)
    self.__enabled_ports = YANGDynClass(base=unicode, is_leaf=True, yang_name="enabled-ports", rest_name="enabled-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__max_l2_flows = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-l2-flows", rest_name="max-l2-flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    self.__ssl_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ssl-status", rest_name="ssl-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'openflow-state', u'detail']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'openflow-state', u'detail']

  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /openflow_state/detail/admin_status (boolean)

    YANG Description: Admin status Enabled or Disabled
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /openflow_state/detail/admin_status (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: Admin status Enabled or Disabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="admin-status", rest_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="admin-status", rest_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='boolean', is_config=False)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="admin-status", rest_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='boolean', is_config=False)


  def _get_ssl_status(self):
    """
    Getter method for ssl_status, mapped from YANG variable /openflow_state/detail/ssl_status (boolean)

    YANG Description: SSL status Enabled or Disabled
    """
    return self.__ssl_status
      
  def _set_ssl_status(self, v, load=False):
    """
    Setter method for ssl_status, mapped from YANG variable /openflow_state/detail/ssl_status (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssl_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssl_status() directly.

    YANG Description: SSL status Enabled or Disabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ssl-status", rest_name="ssl-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssl_status must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ssl-status", rest_name="ssl-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='boolean', is_config=False)""",
        })

    self.__ssl_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssl_status(self):
    self.__ssl_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ssl-status", rest_name="ssl-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='boolean', is_config=False)


  def _get_num_controllers(self):
    """
    Getter method for num_controllers, mapped from YANG variable /openflow_state/detail/num_controllers (uint32)

    YANG Description: Number of controllers
    """
    return self.__num_controllers
      
  def _set_num_controllers(self, v, load=False):
    """
    Setter method for num_controllers, mapped from YANG variable /openflow_state/detail/num_controllers (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_controllers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_controllers() directly.

    YANG Description: Number of controllers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-controllers", rest_name="num-controllers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_controllers must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-controllers", rest_name="num-controllers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_controllers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_controllers(self):
    self.__num_controllers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-controllers", rest_name="num-controllers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)


  def _get_data_path(self):
    """
    Getter method for data_path, mapped from YANG variable /openflow_state/detail/data_path (string)

    YANG Description: Data path
    """
    return self.__data_path
      
  def _set_data_path(self, v, load=False):
    """
    Setter method for data_path, mapped from YANG variable /openflow_state/detail/data_path (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_path() directly.

    YANG Description: Data path
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="data-path", rest_name="data-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_path must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="data-path", rest_name="data-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__data_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_path(self):
    self.__data_path = YANGDynClass(base=unicode, is_leaf=True, yang_name="data-path", rest_name="data-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_l2_match(self):
    """
    Getter method for l2_match, mapped from YANG variable /openflow_state/detail/l2_match (string)

    YANG Description: L2 match
    """
    return self.__l2_match
      
  def _set_l2_match(self, v, load=False):
    """
    Setter method for l2_match, mapped from YANG variable /openflow_state/detail/l2_match (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_match is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_match() directly.

    YANG Description: L2 match
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="l2-match", rest_name="l2-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2_match must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="l2-match", rest_name="l2-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__l2_match = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2_match(self):
    self.__l2_match = YANGDynClass(base=unicode, is_leaf=True, yang_name="l2-match", rest_name="l2-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_l3_match(self):
    """
    Getter method for l3_match, mapped from YANG variable /openflow_state/detail/l3_match (string)

    YANG Description: L3 match
    """
    return self.__l3_match
      
  def _set_l3_match(self, v, load=False):
    """
    Setter method for l3_match, mapped from YANG variable /openflow_state/detail/l3_match (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3_match is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3_match() directly.

    YANG Description: L3 match
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="l3-match", rest_name="l3-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3_match must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="l3-match", rest_name="l3-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__l3_match = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3_match(self):
    self.__l3_match = YANGDynClass(base=unicode, is_leaf=True, yang_name="l3-match", rest_name="l3-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_max_l2_flows(self):
    """
    Getter method for max_l2_flows, mapped from YANG variable /openflow_state/detail/max_l2_flows (uint32)

    YANG Description: Maximum number of flows allowed
    """
    return self.__max_l2_flows
      
  def _set_max_l2_flows(self, v, load=False):
    """
    Setter method for max_l2_flows, mapped from YANG variable /openflow_state/detail/max_l2_flows (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_l2_flows is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_l2_flows() directly.

    YANG Description: Maximum number of flows allowed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-l2-flows", rest_name="max-l2-flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_l2_flows must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-l2-flows", rest_name="max-l2-flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)""",
        })

    self.__max_l2_flows = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_l2_flows(self):
    self.__max_l2_flows = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-l2-flows", rest_name="max-l2-flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)


  def _get_active_flows(self):
    """
    Getter method for active_flows, mapped from YANG variable /openflow_state/detail/active_flows (uint32)

    YANG Description: Active flows
    """
    return self.__active_flows
      
  def _set_active_flows(self, v, load=False):
    """
    Setter method for active_flows, mapped from YANG variable /openflow_state/detail/active_flows (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active_flows is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active_flows() directly.

    YANG Description: Active flows
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="active-flows", rest_name="active-flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active_flows must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="active-flows", rest_name="active-flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)""",
        })

    self.__active_flows = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active_flows(self):
    self.__active_flows = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="active-flows", rest_name="active-flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)


  def _get_enabled_ports(self):
    """
    Getter method for enabled_ports, mapped from YANG variable /openflow_state/detail/enabled_ports (string)

    YANG Description: Openflow Enabled Ports
    """
    return self.__enabled_ports
      
  def _set_enabled_ports(self, v, load=False):
    """
    Setter method for enabled_ports, mapped from YANG variable /openflow_state/detail/enabled_ports (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled_ports() directly.

    YANG Description: Openflow Enabled Ports
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="enabled-ports", rest_name="enabled-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled_ports must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="enabled-ports", rest_name="enabled-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__enabled_ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled_ports(self):
    self.__enabled_ports = YANGDynClass(base=unicode, is_leaf=True, yang_name="enabled-ports", rest_name="enabled-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_default_action(self):
    """
    Getter method for default_action, mapped from YANG variable /openflow_state/detail/default_action (default-packet-action)

    YANG Description: Default action
    """
    return self.__default_action
      
  def _set_default_action(self, v, load=False):
    """
    Setter method for default_action, mapped from YANG variable /openflow_state/detail/default_action (default-packet-action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_action() directly.

    YANG Description: Default action
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dcm-action-drop': {'value': 1}, u'dcm-action-invalid': {'value': 0}, u'dcm-action-send-to-controller': {'value': 2}},), is_leaf=True, yang_name="default-action", rest_name="default-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='default-packet-action', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_action must be of a type compatible with default-packet-action""",
          'defined-type': "brocade-openflow-operational:default-packet-action",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dcm-action-drop': {'value': 1}, u'dcm-action-invalid': {'value': 0}, u'dcm-action-send-to-controller': {'value': 2}},), is_leaf=True, yang_name="default-action", rest_name="default-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='default-packet-action', is_config=False)""",
        })

    self.__default_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_action(self):
    self.__default_action = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dcm-action-drop': {'value': 1}, u'dcm-action-invalid': {'value': 0}, u'dcm-action-send-to-controller': {'value': 2}},), is_leaf=True, yang_name="default-action", rest_name="default-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='default-packet-action', is_config=False)


  def _get_controller_detail_list(self):
    """
    Getter method for controller_detail_list, mapped from YANG variable /openflow_state/detail/controller_detail_list (list)

    YANG Description: Controller detail
    """
    return self.__controller_detail_list
      
  def _set_controller_detail_list(self, v, load=False):
    """
    Setter method for controller_detail_list, mapped from YANG variable /openflow_state/detail/controller_detail_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_controller_detail_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_controller_detail_list() directly.

    YANG Description: Controller detail
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("controller_idx",controller_detail_list.controller_detail_list, yang_name="controller-detail-list", rest_name="controller-detail-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='controller-idx', extensions={u'tailf-common': {u'callpoint': u'openflow-controller-detail-list', u'cli-suppress-show-path': None}}), is_container='list', yang_name="controller-detail-list", rest_name="controller-detail-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-controller-detail-list', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """controller_detail_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("controller_idx",controller_detail_list.controller_detail_list, yang_name="controller-detail-list", rest_name="controller-detail-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='controller-idx', extensions={u'tailf-common': {u'callpoint': u'openflow-controller-detail-list', u'cli-suppress-show-path': None}}), is_container='list', yang_name="controller-detail-list", rest_name="controller-detail-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-controller-detail-list', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)""",
        })

    self.__controller_detail_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_controller_detail_list(self):
    self.__controller_detail_list = YANGDynClass(base=YANGListType("controller_idx",controller_detail_list.controller_detail_list, yang_name="controller-detail-list", rest_name="controller-detail-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='controller-idx', extensions={u'tailf-common': {u'callpoint': u'openflow-controller-detail-list', u'cli-suppress-show-path': None}}), is_container='list', yang_name="controller-detail-list", rest_name="controller-detail-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-controller-detail-list', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)


  def _get_hybrid_interfaces(self):
    """
    Getter method for hybrid_interfaces, mapped from YANG variable /openflow_state/detail/hybrid_interfaces (list)
    """
    return self.__hybrid_interfaces
      
  def _set_hybrid_interfaces(self, v, load=False):
    """
    Setter method for hybrid_interfaces, mapped from YANG variable /openflow_state/detail/hybrid_interfaces (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hybrid_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hybrid_interfaces() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("hybrid_interface",hybrid_interfaces.hybrid_interfaces, yang_name="hybrid-interfaces", rest_name="hybrid-interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hybrid-interface', extensions={u'tailf-common': {u'callpoint': u'openflow-hybrid-interfaces', u'cli-suppress-show-path': None}}), is_container='list', yang_name="hybrid-interfaces", rest_name="hybrid-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-hybrid-interfaces', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hybrid_interfaces must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("hybrid_interface",hybrid_interfaces.hybrid_interfaces, yang_name="hybrid-interfaces", rest_name="hybrid-interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hybrid-interface', extensions={u'tailf-common': {u'callpoint': u'openflow-hybrid-interfaces', u'cli-suppress-show-path': None}}), is_container='list', yang_name="hybrid-interfaces", rest_name="hybrid-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-hybrid-interfaces', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)""",
        })

    self.__hybrid_interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hybrid_interfaces(self):
    self.__hybrid_interfaces = YANGDynClass(base=YANGListType("hybrid_interface",hybrid_interfaces.hybrid_interfaces, yang_name="hybrid-interfaces", rest_name="hybrid-interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hybrid-interface', extensions={u'tailf-common': {u'callpoint': u'openflow-hybrid-interfaces', u'cli-suppress-show-path': None}}), is_container='list', yang_name="hybrid-interfaces", rest_name="hybrid-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-hybrid-interfaces', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)

  admin_status = __builtin__.property(_get_admin_status)
  ssl_status = __builtin__.property(_get_ssl_status)
  num_controllers = __builtin__.property(_get_num_controllers)
  data_path = __builtin__.property(_get_data_path)
  l2_match = __builtin__.property(_get_l2_match)
  l3_match = __builtin__.property(_get_l3_match)
  max_l2_flows = __builtin__.property(_get_max_l2_flows)
  active_flows = __builtin__.property(_get_active_flows)
  enabled_ports = __builtin__.property(_get_enabled_ports)
  default_action = __builtin__.property(_get_default_action)
  controller_detail_list = __builtin__.property(_get_controller_detail_list)
  hybrid_interfaces = __builtin__.property(_get_hybrid_interfaces)


  _pyangbind_elements = {'admin_status': admin_status, 'ssl_status': ssl_status, 'num_controllers': num_controllers, 'data_path': data_path, 'l2_match': l2_match, 'l3_match': l3_match, 'max_l2_flows': max_l2_flows, 'active_flows': active_flows, 'enabled_ports': enabled_ports, 'default_action': default_action, 'controller_detail_list': controller_detail_list, 'hybrid_interfaces': hybrid_interfaces, }


