
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import mp_infos
class dynamic_bypass_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls-operational - based on the path /mpls-state/dynamic-bypass/dynamic-bypass-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: MPLS dynamic bypass interface
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__if_name','__if_type','__active_status','__admin_type','__admin_status','__hop_limit','__tie_breaking','__cos','__cspf_comp_mode','__setup_priority','__hold_priority','__traffic_eng_max_rate','__traffic_eng_mean_rate','__traffic_eng_max_burst','__from_addr','__reoptimize_timer','__adaptive','__record_route','__name_prefix','__primary_path','__max_bypasses_per_mp','__bypass_count','__exclude_any','__include_all','__include_any','__status_flags','__mp_count','__mp_infos',)

  _yang_name = 'dynamic-bypass-interface'
  _rest_name = 'dynamic-bypass-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__record_route = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="record-route", rest_name="record-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__include_all = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="include-all", rest_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__traffic_eng_max_burst = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="traffic-eng-max-burst", rest_name="traffic-eng-max-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__tie_breaking = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tie-breaking", rest_name="tie-breaking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__status_flags = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="status-flags", rest_name="status-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__include_any = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="include-any", rest_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__from_addr = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="from-addr", rest_name="from-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='inet:ipv4-address', is_config=False)
    self.__mp_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mp-count", rest_name="mp-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__active_status = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="active-status", rest_name="active-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__primary_path = YANGDynClass(base=unicode, is_leaf=True, yang_name="primary-path", rest_name="primary-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__traffic_eng_mean_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="traffic-eng-mean-rate", rest_name="traffic-eng-mean-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__hold_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="hold-priority", rest_name="hold-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__reoptimize_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reoptimize-timer", rest_name="reoptimize-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__bypass_count = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="bypass-count", rest_name="bypass-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    self.__max_bypasses_per_mp = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-bypasses-per-mp", rest_name="max-bypasses-per-mp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    self.__adaptive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adaptive", rest_name="adaptive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__name_prefix = YANGDynClass(base=unicode, is_leaf=True, yang_name="name-prefix", rest_name="name-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__mp_infos = YANGDynClass(base=YANGListType("router_id",mp_infos.mp_infos, yang_name="mp-infos", rest_name="mp-infos", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id', extensions={u'tailf-common': {u'callpoint': u'mpls-mp-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="mp-infos", rest_name="mp-infos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-mp-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__cspf_comp_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cspf-comp-mode", rest_name="cspf-comp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__if_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="if-name", rest_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="admin-status", rest_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__exclude_any = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exclude-any", rest_name="exclude-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__setup_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="setup-priority", rest_name="setup-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__cos = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cos", rest_name="cos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__admin_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="admin-type", rest_name="admin-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__traffic_eng_max_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="traffic-eng-max-rate", rest_name="traffic-eng-max-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__if_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'loopback-interface': {'value': 7}, u'ethernet-interface': {'value': 2}, u'port-channel-interface': {'value': 5}, u'unknown-interface': {'value': 1}, u've-interface': {'value': 6}, u'fbr-channel-interface': {'value': 8}},), is_leaf=True, yang_name="if-type", rest_name="if-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='mpls-if-type', is_config=False)
    self.__hop_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="hop-limit", rest_name="hop-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mpls-state', u'dynamic-bypass', u'dynamic-bypass-interface']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'mpls-state', u'dynamic-bypass', u'dynamic-bypass-interface']

  def _get_if_name(self):
    """
    Getter method for if_name, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/if_name (string)

    YANG Description: Interface name
    """
    return self.__if_name
      
  def _set_if_name(self, v, load=False):
    """
    Setter method for if_name, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/if_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_name() directly.

    YANG Description: Interface name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="if-name", rest_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="if-name", rest_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__if_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_name(self):
    self.__if_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="if-name", rest_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_if_type(self):
    """
    Getter method for if_type, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/if_type (mpls-if-type)

    YANG Description: Interface type
    """
    return self.__if_type
      
  def _set_if_type(self, v, load=False):
    """
    Setter method for if_type, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/if_type (mpls-if-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_type() directly.

    YANG Description: Interface type
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'loopback-interface': {'value': 7}, u'ethernet-interface': {'value': 2}, u'port-channel-interface': {'value': 5}, u'unknown-interface': {'value': 1}, u've-interface': {'value': 6}, u'fbr-channel-interface': {'value': 8}},), is_leaf=True, yang_name="if-type", rest_name="if-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='mpls-if-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_type must be of a type compatible with mpls-if-type""",
          'defined-type': "brocade-mpls-operational:mpls-if-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'loopback-interface': {'value': 7}, u'ethernet-interface': {'value': 2}, u'port-channel-interface': {'value': 5}, u'unknown-interface': {'value': 1}, u've-interface': {'value': 6}, u'fbr-channel-interface': {'value': 8}},), is_leaf=True, yang_name="if-type", rest_name="if-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='mpls-if-type', is_config=False)""",
        })

    self.__if_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_type(self):
    self.__if_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'loopback-interface': {'value': 7}, u'ethernet-interface': {'value': 2}, u'port-channel-interface': {'value': 5}, u'unknown-interface': {'value': 1}, u've-interface': {'value': 6}, u'fbr-channel-interface': {'value': 8}},), is_leaf=True, yang_name="if-type", rest_name="if-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='mpls-if-type', is_config=False)


  def _get_active_status(self):
    """
    Getter method for active_status, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/active_status (uint8)

    YANG Description: Active Status
    """
    return self.__active_status
      
  def _set_active_status(self, v, load=False):
    """
    Setter method for active_status, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/active_status (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active_status() directly.

    YANG Description: Active Status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="active-status", rest_name="active-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active_status must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="active-status", rest_name="active-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__active_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active_status(self):
    self.__active_status = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="active-status", rest_name="active-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_admin_type(self):
    """
    Getter method for admin_type, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/admin_type (uint8)

    YANG Description: Type of admin
    """
    return self.__admin_type
      
  def _set_admin_type(self, v, load=False):
    """
    Setter method for admin_type, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/admin_type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_type() directly.

    YANG Description: Type of admin
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="admin-type", rest_name="admin-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="admin-type", rest_name="admin-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__admin_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_type(self):
    self.__admin_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="admin-type", rest_name="admin-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/admin_status (uint8)

    YANG Description: Admin status
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/admin_status (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: Admin status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="admin-status", rest_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="admin-status", rest_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="admin-status", rest_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_hop_limit(self):
    """
    Getter method for hop_limit, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/hop_limit (uint8)

    YANG Description: Hop Limit
    """
    return self.__hop_limit
      
  def _set_hop_limit(self, v, load=False):
    """
    Setter method for hop_limit, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/hop_limit (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hop_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hop_limit() directly.

    YANG Description: Hop Limit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="hop-limit", rest_name="hop-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hop_limit must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="hop-limit", rest_name="hop-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__hop_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hop_limit(self):
    self.__hop_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="hop-limit", rest_name="hop-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_tie_breaking(self):
    """
    Getter method for tie_breaking, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/tie_breaking (uint8)

    YANG Description: Tie Breaking
    """
    return self.__tie_breaking
      
  def _set_tie_breaking(self, v, load=False):
    """
    Setter method for tie_breaking, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/tie_breaking (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tie_breaking is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tie_breaking() directly.

    YANG Description: Tie Breaking
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tie-breaking", rest_name="tie-breaking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tie_breaking must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tie-breaking", rest_name="tie-breaking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__tie_breaking = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tie_breaking(self):
    self.__tie_breaking = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tie-breaking", rest_name="tie-breaking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_cos(self):
    """
    Getter method for cos, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/cos (uint8)

    YANG Description: COS value
    """
    return self.__cos
      
  def _set_cos(self, v, load=False):
    """
    Setter method for cos, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/cos (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cos() directly.

    YANG Description: COS value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cos", rest_name="cos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cos must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cos", rest_name="cos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__cos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cos(self):
    self.__cos = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cos", rest_name="cos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_cspf_comp_mode(self):
    """
    Getter method for cspf_comp_mode, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/cspf_comp_mode (uint8)

    YANG Description: CSPF Computation Mode
    """
    return self.__cspf_comp_mode
      
  def _set_cspf_comp_mode(self, v, load=False):
    """
    Setter method for cspf_comp_mode, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/cspf_comp_mode (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cspf_comp_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cspf_comp_mode() directly.

    YANG Description: CSPF Computation Mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cspf-comp-mode", rest_name="cspf-comp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cspf_comp_mode must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cspf-comp-mode", rest_name="cspf-comp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__cspf_comp_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cspf_comp_mode(self):
    self.__cspf_comp_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="cspf-comp-mode", rest_name="cspf-comp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_setup_priority(self):
    """
    Getter method for setup_priority, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/setup_priority (uint8)

    YANG Description: Setup Priority
    """
    return self.__setup_priority
      
  def _set_setup_priority(self, v, load=False):
    """
    Setter method for setup_priority, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/setup_priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_setup_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_setup_priority() directly.

    YANG Description: Setup Priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="setup-priority", rest_name="setup-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """setup_priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="setup-priority", rest_name="setup-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__setup_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_setup_priority(self):
    self.__setup_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="setup-priority", rest_name="setup-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_hold_priority(self):
    """
    Getter method for hold_priority, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/hold_priority (uint8)

    YANG Description: Hold Priority
    """
    return self.__hold_priority
      
  def _set_hold_priority(self, v, load=False):
    """
    Setter method for hold_priority, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/hold_priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_priority() directly.

    YANG Description: Hold Priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="hold-priority", rest_name="hold-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="hold-priority", rest_name="hold-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__hold_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_priority(self):
    self.__hold_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="hold-priority", rest_name="hold-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_traffic_eng_max_rate(self):
    """
    Getter method for traffic_eng_max_rate, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/traffic_eng_max_rate (uint32)

    YANG Description: Traffic Engineering max rate
    """
    return self.__traffic_eng_max_rate
      
  def _set_traffic_eng_max_rate(self, v, load=False):
    """
    Setter method for traffic_eng_max_rate, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/traffic_eng_max_rate (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_eng_max_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_eng_max_rate() directly.

    YANG Description: Traffic Engineering max rate
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="traffic-eng-max-rate", rest_name="traffic-eng-max-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_eng_max_rate must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="traffic-eng-max-rate", rest_name="traffic-eng-max-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__traffic_eng_max_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_eng_max_rate(self):
    self.__traffic_eng_max_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="traffic-eng-max-rate", rest_name="traffic-eng-max-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_traffic_eng_mean_rate(self):
    """
    Getter method for traffic_eng_mean_rate, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/traffic_eng_mean_rate (uint32)

    YANG Description: Traffic Engineering mean rate
    """
    return self.__traffic_eng_mean_rate
      
  def _set_traffic_eng_mean_rate(self, v, load=False):
    """
    Setter method for traffic_eng_mean_rate, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/traffic_eng_mean_rate (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_eng_mean_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_eng_mean_rate() directly.

    YANG Description: Traffic Engineering mean rate
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="traffic-eng-mean-rate", rest_name="traffic-eng-mean-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_eng_mean_rate must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="traffic-eng-mean-rate", rest_name="traffic-eng-mean-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__traffic_eng_mean_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_eng_mean_rate(self):
    self.__traffic_eng_mean_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="traffic-eng-mean-rate", rest_name="traffic-eng-mean-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_traffic_eng_max_burst(self):
    """
    Getter method for traffic_eng_max_burst, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/traffic_eng_max_burst (uint32)

    YANG Description: Traffic Engineering max burst
    """
    return self.__traffic_eng_max_burst
      
  def _set_traffic_eng_max_burst(self, v, load=False):
    """
    Setter method for traffic_eng_max_burst, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/traffic_eng_max_burst (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_eng_max_burst is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_eng_max_burst() directly.

    YANG Description: Traffic Engineering max burst
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="traffic-eng-max-burst", rest_name="traffic-eng-max-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_eng_max_burst must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="traffic-eng-max-burst", rest_name="traffic-eng-max-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__traffic_eng_max_burst = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_eng_max_burst(self):
    self.__traffic_eng_max_burst = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="traffic-eng-max-burst", rest_name="traffic-eng-max-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_from_addr(self):
    """
    Getter method for from_addr, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/from_addr (inet:ipv4-address)

    YANG Description: From address of the box
    """
    return self.__from_addr
      
  def _set_from_addr(self, v, load=False):
    """
    Setter method for from_addr, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/from_addr (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_from_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_from_addr() directly.

    YANG Description: From address of the box
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="from-addr", rest_name="from-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """from_addr must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="from-addr", rest_name="from-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='inet:ipv4-address', is_config=False)""",
        })

    self.__from_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_from_addr(self):
    self.__from_addr = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="from-addr", rest_name="from-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='inet:ipv4-address', is_config=False)


  def _get_reoptimize_timer(self):
    """
    Getter method for reoptimize_timer, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/reoptimize_timer (uint32)

    YANG Description: Reoptimize timer
    """
    return self.__reoptimize_timer
      
  def _set_reoptimize_timer(self, v, load=False):
    """
    Setter method for reoptimize_timer, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/reoptimize_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reoptimize_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reoptimize_timer() directly.

    YANG Description: Reoptimize timer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reoptimize-timer", rest_name="reoptimize-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reoptimize_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reoptimize-timer", rest_name="reoptimize-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__reoptimize_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reoptimize_timer(self):
    self.__reoptimize_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reoptimize-timer", rest_name="reoptimize-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_adaptive(self):
    """
    Getter method for adaptive, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/adaptive (uint32)

    YANG Description: Adaptive configuration
    """
    return self.__adaptive
      
  def _set_adaptive(self, v, load=False):
    """
    Setter method for adaptive, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/adaptive (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adaptive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adaptive() directly.

    YANG Description: Adaptive configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adaptive", rest_name="adaptive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adaptive must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adaptive", rest_name="adaptive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__adaptive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adaptive(self):
    self.__adaptive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adaptive", rest_name="adaptive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_record_route(self):
    """
    Getter method for record_route, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/record_route (uint32)

    YANG Description: Record Route configuration
    """
    return self.__record_route
      
  def _set_record_route(self, v, load=False):
    """
    Setter method for record_route, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/record_route (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_record_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_record_route() directly.

    YANG Description: Record Route configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="record-route", rest_name="record-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """record_route must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="record-route", rest_name="record-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__record_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_record_route(self):
    self.__record_route = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="record-route", rest_name="record-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_name_prefix(self):
    """
    Getter method for name_prefix, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/name_prefix (string)

    YANG Description: Dynamic bypass name prefix
    """
    return self.__name_prefix
      
  def _set_name_prefix(self, v, load=False):
    """
    Setter method for name_prefix, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/name_prefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name_prefix() directly.

    YANG Description: Dynamic bypass name prefix
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name-prefix", rest_name="name-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name_prefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name-prefix", rest_name="name-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__name_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name_prefix(self):
    self.__name_prefix = YANGDynClass(base=unicode, is_leaf=True, yang_name="name-prefix", rest_name="name-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_primary_path(self):
    """
    Getter method for primary_path, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/primary_path (string)

    YANG Description: Primary path
    """
    return self.__primary_path
      
  def _set_primary_path(self, v, load=False):
    """
    Setter method for primary_path, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/primary_path (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_path() directly.

    YANG Description: Primary path
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="primary-path", rest_name="primary-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_path must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="primary-path", rest_name="primary-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__primary_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_path(self):
    self.__primary_path = YANGDynClass(base=unicode, is_leaf=True, yang_name="primary-path", rest_name="primary-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_max_bypasses_per_mp(self):
    """
    Getter method for max_bypasses_per_mp, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/max_bypasses_per_mp (uint16)

    YANG Description: Maximum Bypasses per merge point
    """
    return self.__max_bypasses_per_mp
      
  def _set_max_bypasses_per_mp(self, v, load=False):
    """
    Setter method for max_bypasses_per_mp, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/max_bypasses_per_mp (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_bypasses_per_mp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_bypasses_per_mp() directly.

    YANG Description: Maximum Bypasses per merge point
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-bypasses-per-mp", rest_name="max-bypasses-per-mp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_bypasses_per_mp must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-bypasses-per-mp", rest_name="max-bypasses-per-mp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)""",
        })

    self.__max_bypasses_per_mp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_bypasses_per_mp(self):
    self.__max_bypasses_per_mp = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-bypasses-per-mp", rest_name="max-bypasses-per-mp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)


  def _get_bypass_count(self):
    """
    Getter method for bypass_count, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/bypass_count (uint16)

    YANG Description: Dynamic Bypass count for the interface
    """
    return self.__bypass_count
      
  def _set_bypass_count(self, v, load=False):
    """
    Setter method for bypass_count, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/bypass_count (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_count() directly.

    YANG Description: Dynamic Bypass count for the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="bypass-count", rest_name="bypass-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_count must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="bypass-count", rest_name="bypass-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)""",
        })

    self.__bypass_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_count(self):
    self.__bypass_count = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="bypass-count", rest_name="bypass-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)


  def _get_exclude_any(self):
    """
    Getter method for exclude_any, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/exclude_any (uint32)

    YANG Description: Exclude any admin group
    """
    return self.__exclude_any
      
  def _set_exclude_any(self, v, load=False):
    """
    Setter method for exclude_any, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/exclude_any (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exclude_any is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exclude_any() directly.

    YANG Description: Exclude any admin group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exclude-any", rest_name="exclude-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exclude_any must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exclude-any", rest_name="exclude-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__exclude_any = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exclude_any(self):
    self.__exclude_any = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exclude-any", rest_name="exclude-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_include_all(self):
    """
    Getter method for include_all, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/include_all (uint32)

    YANG Description: Include all admin groups
    """
    return self.__include_all
      
  def _set_include_all(self, v, load=False):
    """
    Setter method for include_all, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/include_all (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_all is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_all() directly.

    YANG Description: Include all admin groups
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="include-all", rest_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_all must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="include-all", rest_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__include_all = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_all(self):
    self.__include_all = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="include-all", rest_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_include_any(self):
    """
    Getter method for include_any, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/include_any (uint32)

    YANG Description: Include any admin group
    """
    return self.__include_any
      
  def _set_include_any(self, v, load=False):
    """
    Setter method for include_any, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/include_any (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_any is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_any() directly.

    YANG Description: Include any admin group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="include-any", rest_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_any must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="include-any", rest_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__include_any = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_any(self):
    self.__include_any = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="include-any", rest_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_status_flags(self):
    """
    Getter method for status_flags, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/status_flags (uint32)

    YANG Description: Status flags
    """
    return self.__status_flags
      
  def _set_status_flags(self, v, load=False):
    """
    Setter method for status_flags, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/status_flags (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status_flags is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status_flags() directly.

    YANG Description: Status flags
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="status-flags", rest_name="status-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status_flags must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="status-flags", rest_name="status-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__status_flags = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status_flags(self):
    self.__status_flags = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="status-flags", rest_name="status-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_mp_count(self):
    """
    Getter method for mp_count, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/mp_count (uint32)

    YANG Description: Count of merge points
    """
    return self.__mp_count
      
  def _set_mp_count(self, v, load=False):
    """
    Setter method for mp_count, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/mp_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mp_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mp_count() directly.

    YANG Description: Count of merge points
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mp-count", rest_name="mp-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mp_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mp-count", rest_name="mp-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__mp_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mp_count(self):
    self.__mp_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mp-count", rest_name="mp-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_mp_infos(self):
    """
    Getter method for mp_infos, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/mp_infos (list)

    YANG Description: Merge point info
    """
    return self.__mp_infos
      
  def _set_mp_infos(self, v, load=False):
    """
    Setter method for mp_infos, mapped from YANG variable /mpls_state/dynamic_bypass/dynamic_bypass_interface/mp_infos (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mp_infos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mp_infos() directly.

    YANG Description: Merge point info
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("router_id",mp_infos.mp_infos, yang_name="mp-infos", rest_name="mp-infos", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id', extensions={u'tailf-common': {u'callpoint': u'mpls-mp-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="mp-infos", rest_name="mp-infos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-mp-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mp_infos must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("router_id",mp_infos.mp_infos, yang_name="mp-infos", rest_name="mp-infos", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id', extensions={u'tailf-common': {u'callpoint': u'mpls-mp-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="mp-infos", rest_name="mp-infos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-mp-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__mp_infos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mp_infos(self):
    self.__mp_infos = YANGDynClass(base=YANGListType("router_id",mp_infos.mp_infos, yang_name="mp-infos", rest_name="mp-infos", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id', extensions={u'tailf-common': {u'callpoint': u'mpls-mp-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="mp-infos", rest_name="mp-infos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-mp-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)

  if_name = __builtin__.property(_get_if_name)
  if_type = __builtin__.property(_get_if_type)
  active_status = __builtin__.property(_get_active_status)
  admin_type = __builtin__.property(_get_admin_type)
  admin_status = __builtin__.property(_get_admin_status)
  hop_limit = __builtin__.property(_get_hop_limit)
  tie_breaking = __builtin__.property(_get_tie_breaking)
  cos = __builtin__.property(_get_cos)
  cspf_comp_mode = __builtin__.property(_get_cspf_comp_mode)
  setup_priority = __builtin__.property(_get_setup_priority)
  hold_priority = __builtin__.property(_get_hold_priority)
  traffic_eng_max_rate = __builtin__.property(_get_traffic_eng_max_rate)
  traffic_eng_mean_rate = __builtin__.property(_get_traffic_eng_mean_rate)
  traffic_eng_max_burst = __builtin__.property(_get_traffic_eng_max_burst)
  from_addr = __builtin__.property(_get_from_addr)
  reoptimize_timer = __builtin__.property(_get_reoptimize_timer)
  adaptive = __builtin__.property(_get_adaptive)
  record_route = __builtin__.property(_get_record_route)
  name_prefix = __builtin__.property(_get_name_prefix)
  primary_path = __builtin__.property(_get_primary_path)
  max_bypasses_per_mp = __builtin__.property(_get_max_bypasses_per_mp)
  bypass_count = __builtin__.property(_get_bypass_count)
  exclude_any = __builtin__.property(_get_exclude_any)
  include_all = __builtin__.property(_get_include_all)
  include_any = __builtin__.property(_get_include_any)
  status_flags = __builtin__.property(_get_status_flags)
  mp_count = __builtin__.property(_get_mp_count)
  mp_infos = __builtin__.property(_get_mp_infos)


  _pyangbind_elements = {'if_name': if_name, 'if_type': if_type, 'active_status': active_status, 'admin_type': admin_type, 'admin_status': admin_status, 'hop_limit': hop_limit, 'tie_breaking': tie_breaking, 'cos': cos, 'cspf_comp_mode': cspf_comp_mode, 'setup_priority': setup_priority, 'hold_priority': hold_priority, 'traffic_eng_max_rate': traffic_eng_max_rate, 'traffic_eng_mean_rate': traffic_eng_mean_rate, 'traffic_eng_max_burst': traffic_eng_max_burst, 'from_addr': from_addr, 'reoptimize_timer': reoptimize_timer, 'adaptive': adaptive, 'record_route': record_route, 'name_prefix': name_prefix, 'primary_path': primary_path, 'max_bypasses_per_mp': max_bypasses_per_mp, 'bypass_count': bypass_count, 'exclude_any': exclude_any, 'include_all': include_all, 'include_any': include_any, 'status_flags': status_flags, 'mp_count': mp_count, 'mp_infos': mp_infos, }


