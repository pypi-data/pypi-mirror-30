
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import session_ldp_stats
import filtered_fecs_in
import filtered_fecs_out
class ldp_session(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls-operational - based on the path /mpls-state/ldp/ldp-session. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__peer_ldp_id','__peer_lblspc_id','__state','__adjacency','__role','__max_hold','__time_left','__session_status','__local_ldp_id','__local_lblspc_id','__next_keepalive','__entity_index','__targeted_adj_added','__is_retry','__next_retry','__keepalive_interval','__local_keepalive_timeout','__peer_proposed_keepalive_timeout','__session_up_time','__md5_auth_key','__tcp_conn_local','__tcp_conn_remote','__tcp_state','__num_fecs_received_from_peer','__num_fecs_installed_from_peer','__is_fecs_pending_uninstall','__num_fecs_filtered_out','__num_fecs_filtered_in','__filter_prefix_list_name','__filter_prefix_list_exists','__is_only_gr_valid','__gr_enabled','__peer_reconnect_time','__peer_recovery_time','__reconnect_time_in_use','__reconnect_time_remaining','__recovery_time_in_use','__recovery_time_remaining','__gr_state','__local_eol_unrecognized_notification','__remote_eol_unrecognized_notification','__does_session_support_eol','__local_state','__remote_state','__eol_notification_time','__eol_notification_time_remaining','__eol_tx_label_silence_time','__eol_tx_label_silence_time_remaining','__eol_rx_label_silence_time','__eol_rx_label_silence_time_remaining','__filtered','__interfaces','__addresses','__session_ldp_stats','__filtered_fecs_in','__filtered_fecs_out',)

  _yang_name = 'ldp-session'
  _rest_name = 'ldp-session'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__local_ldp_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-ldp-id", rest_name="local-ldp-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__eol_notification_time_remaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time-remaining", rest_name="eol-notification-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__entity_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="entity-index", rest_name="entity-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__addresses = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="addresses", rest_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__remote_state = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="remote-state", rest_name="remote-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__peer_recovery_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-recovery-time", rest_name="peer-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__time_left = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="time-left", rest_name="time-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__targeted_adj_added = YANGDynClass(base=unicode, is_leaf=True, yang_name="targeted-adj-added", rest_name="targeted-adj-added", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__local_state = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="local-state", rest_name="local-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__local_lblspc_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-lblspc-id", rest_name="local-lblspc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__recovery_time_remaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="recovery-time-remaining", rest_name="recovery-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__session_ldp_stats = YANGDynClass(base=session_ldp_stats.session_ldp_stats, is_container='container', presence=False, yang_name="session-ldp-stats", rest_name="session-ldp-stats", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-session-ldp-stats', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    self.__filter_prefix_list_exists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="filter-prefix-list-exists", rest_name="filter-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__eol_rx_label_silence_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-rx-label-silence-time", rest_name="eol-rx-label-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__session_up_time = YANGDynClass(base=unicode, is_leaf=True, yang_name="session-up-time", rest_name="session-up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__peer_proposed_keepalive_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-proposed-keepalive-timeout", rest_name="peer-proposed-keepalive-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__gr_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-enabled", rest_name="gr-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__md5_auth_key = YANGDynClass(base=unicode, is_leaf=True, yang_name="md5-auth-key", rest_name="md5-auth-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__recovery_time_in_use = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="recovery-time-in-use", rest_name="recovery-time-in-use", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__local_keepalive_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-keepalive-timeout", rest_name="local-keepalive-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__peer_ldp_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="peer-ldp-id", rest_name="peer-ldp-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__state = YANGDynClass(base=unicode, is_leaf=True, yang_name="state", rest_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__role = YANGDynClass(base=unicode, is_leaf=True, yang_name="role", rest_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__tcp_state = YANGDynClass(base=unicode, is_leaf=True, yang_name="tcp-state", rest_name="tcp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__peer_reconnect_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-reconnect-time", rest_name="peer-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__num_fecs_filtered_out = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-filtered-out", rest_name="num-fecs-filtered-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__reconnect_time_in_use = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reconnect-time-in-use", rest_name="reconnect-time-in-use", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__next_keepalive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="next-keepalive", rest_name="next-keepalive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__adjacency = YANGDynClass(base=unicode, is_leaf=True, yang_name="adjacency", rest_name="adjacency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__tcp_conn_remote = YANGDynClass(base=unicode, is_leaf=True, yang_name="tcp-conn-remote", rest_name="tcp-conn-remote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__num_fecs_filtered_in = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-filtered-in", rest_name="num-fecs-filtered-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__session_status = YANGDynClass(base=unicode, is_leaf=True, yang_name="session-status", rest_name="session-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__filter_prefix_list_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="filter-prefix-list-name", rest_name="filter-prefix-list-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__interfaces = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="interfaces", rest_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__is_retry = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-retry", rest_name="is-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__reconnect_time_remaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reconnect-time-remaining", rest_name="reconnect-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__does_session_support_eol = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="does-session-support-eol", rest_name="does-session-support-eol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__eol_rx_label_silence_time_remaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-rx-label-silence-time-remaining", rest_name="eol-rx-label-silence-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__peer_lblspc_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="peer-lblspc-id", rest_name="peer-lblspc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__gr_state = YANGDynClass(base=unicode, is_leaf=True, yang_name="gr-state", rest_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__num_fecs_received_from_peer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-received-from-peer", rest_name="num-fecs-received-from-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__eol_notification_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time", rest_name="eol-notification-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__filtered_fecs_in = YANGDynClass(base=YANGListType("fec_addr",filtered_fecs_in.filtered_fecs_in, yang_name="filtered-fecs-in", rest_name="filtered-fecs-in", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='fec-addr', extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-in-1'}}), is_container='list', yang_name="filtered-fecs-in", rest_name="filtered-fecs-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-in-1'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__max_hold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-hold", rest_name="max-hold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__filtered_fecs_out = YANGDynClass(base=YANGListType("fec_addr",filtered_fecs_out.filtered_fecs_out, yang_name="filtered-fecs-out", rest_name="filtered-fecs-out", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='fec-addr', extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-out-1'}}), is_container='list', yang_name="filtered-fecs-out", rest_name="filtered-fecs-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-out-1'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__keepalive_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="keepalive-interval", rest_name="keepalive-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__filtered = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'sess-filtered-out': {'value': 3}, u'sess-filtered-in': {'value': 2}, u'sess-filtered': {'value': 1}},), is_leaf=True, yang_name="filtered", rest_name="filtered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='session-filter-type', is_config=False)
    self.__next_retry = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="next-retry", rest_name="next-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__is_fecs_pending_uninstall = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-fecs-pending-uninstall", rest_name="is-fecs-pending-uninstall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__eol_tx_label_silence_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-tx-label-silence-time", rest_name="eol-tx-label-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__remote_eol_unrecognized_notification = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="remote-eol-unrecognized-notification", rest_name="remote-eol-unrecognized-notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__tcp_conn_local = YANGDynClass(base=unicode, is_leaf=True, yang_name="tcp-conn-local", rest_name="tcp-conn-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__is_only_gr_valid = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-only-gr-valid", rest_name="is-only-gr-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__local_eol_unrecognized_notification = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="local-eol-unrecognized-notification", rest_name="local-eol-unrecognized-notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__eol_tx_label_silence_time_remaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-tx-label-silence-time-remaining", rest_name="eol-tx-label-silence-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__num_fecs_installed_from_peer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-installed-from-peer", rest_name="num-fecs-installed-from-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mpls-state', u'ldp', u'ldp-session']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'mpls-state', u'ldp', u'ldp-session']

  def _get_peer_ldp_id(self):
    """
    Getter method for peer_ldp_id, mapped from YANG variable /mpls_state/ldp/ldp_session/peer_ldp_id (string)

    YANG Description: peer_ldp_id
    """
    return self.__peer_ldp_id
      
  def _set_peer_ldp_id(self, v, load=False):
    """
    Setter method for peer_ldp_id, mapped from YANG variable /mpls_state/ldp/ldp_session/peer_ldp_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_ldp_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_ldp_id() directly.

    YANG Description: peer_ldp_id
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="peer-ldp-id", rest_name="peer-ldp-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_ldp_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="peer-ldp-id", rest_name="peer-ldp-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__peer_ldp_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_ldp_id(self):
    self.__peer_ldp_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="peer-ldp-id", rest_name="peer-ldp-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_peer_lblspc_id(self):
    """
    Getter method for peer_lblspc_id, mapped from YANG variable /mpls_state/ldp/ldp_session/peer_lblspc_id (string)

    YANG Description: peer_lblspc_id
    """
    return self.__peer_lblspc_id
      
  def _set_peer_lblspc_id(self, v, load=False):
    """
    Setter method for peer_lblspc_id, mapped from YANG variable /mpls_state/ldp/ldp_session/peer_lblspc_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_lblspc_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_lblspc_id() directly.

    YANG Description: peer_lblspc_id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="peer-lblspc-id", rest_name="peer-lblspc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_lblspc_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="peer-lblspc-id", rest_name="peer-lblspc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__peer_lblspc_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_lblspc_id(self):
    self.__peer_lblspc_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="peer-lblspc-id", rest_name="peer-lblspc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /mpls_state/ldp/ldp_session/state (string)

    YANG Description: state
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /mpls_state/ldp/ldp_session/state (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="state", rest_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="state", rest_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=unicode, is_leaf=True, yang_name="state", rest_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_adjacency(self):
    """
    Getter method for adjacency, mapped from YANG variable /mpls_state/ldp/ldp_session/adjacency (string)

    YANG Description: adjacency
    """
    return self.__adjacency
      
  def _set_adjacency(self, v, load=False):
    """
    Setter method for adjacency, mapped from YANG variable /mpls_state/ldp/ldp_session/adjacency (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjacency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjacency() directly.

    YANG Description: adjacency
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="adjacency", rest_name="adjacency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjacency must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="adjacency", rest_name="adjacency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__adjacency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjacency(self):
    self.__adjacency = YANGDynClass(base=unicode, is_leaf=True, yang_name="adjacency", rest_name="adjacency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_role(self):
    """
    Getter method for role, mapped from YANG variable /mpls_state/ldp/ldp_session/role (string)

    YANG Description: role
    """
    return self.__role
      
  def _set_role(self, v, load=False):
    """
    Setter method for role, mapped from YANG variable /mpls_state/ldp/ldp_session/role (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.

    YANG Description: role
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="role", rest_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """role must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="role", rest_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_role(self):
    self.__role = YANGDynClass(base=unicode, is_leaf=True, yang_name="role", rest_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_max_hold(self):
    """
    Getter method for max_hold, mapped from YANG variable /mpls_state/ldp/ldp_session/max_hold (uint32)

    YANG Description: maxHold
    """
    return self.__max_hold
      
  def _set_max_hold(self, v, load=False):
    """
    Setter method for max_hold, mapped from YANG variable /mpls_state/ldp/ldp_session/max_hold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_hold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_hold() directly.

    YANG Description: maxHold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-hold", rest_name="max-hold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_hold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-hold", rest_name="max-hold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__max_hold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_hold(self):
    self.__max_hold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-hold", rest_name="max-hold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_time_left(self):
    """
    Getter method for time_left, mapped from YANG variable /mpls_state/ldp/ldp_session/time_left (uint32)

    YANG Description: timeLeft
    """
    return self.__time_left
      
  def _set_time_left(self, v, load=False):
    """
    Setter method for time_left, mapped from YANG variable /mpls_state/ldp/ldp_session/time_left (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_left is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_left() directly.

    YANG Description: timeLeft
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="time-left", rest_name="time-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_left must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="time-left", rest_name="time-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__time_left = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_left(self):
    self.__time_left = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="time-left", rest_name="time-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_session_status(self):
    """
    Getter method for session_status, mapped from YANG variable /mpls_state/ldp/ldp_session/session_status (string)

    YANG Description: sessionStatus
    """
    return self.__session_status
      
  def _set_session_status(self, v, load=False):
    """
    Setter method for session_status, mapped from YANG variable /mpls_state/ldp/ldp_session/session_status (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_session_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_session_status() directly.

    YANG Description: sessionStatus
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="session-status", rest_name="session-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """session_status must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="session-status", rest_name="session-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__session_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_session_status(self):
    self.__session_status = YANGDynClass(base=unicode, is_leaf=True, yang_name="session-status", rest_name="session-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_local_ldp_id(self):
    """
    Getter method for local_ldp_id, mapped from YANG variable /mpls_state/ldp/ldp_session/local_ldp_id (string)

    YANG Description: localLdpId
    """
    return self.__local_ldp_id
      
  def _set_local_ldp_id(self, v, load=False):
    """
    Setter method for local_ldp_id, mapped from YANG variable /mpls_state/ldp/ldp_session/local_ldp_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ldp_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ldp_id() directly.

    YANG Description: localLdpId
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="local-ldp-id", rest_name="local-ldp-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ldp_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="local-ldp-id", rest_name="local-ldp-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__local_ldp_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ldp_id(self):
    self.__local_ldp_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-ldp-id", rest_name="local-ldp-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_local_lblspc_id(self):
    """
    Getter method for local_lblspc_id, mapped from YANG variable /mpls_state/ldp/ldp_session/local_lblspc_id (string)

    YANG Description: local_lblspc_id
    """
    return self.__local_lblspc_id
      
  def _set_local_lblspc_id(self, v, load=False):
    """
    Setter method for local_lblspc_id, mapped from YANG variable /mpls_state/ldp/ldp_session/local_lblspc_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_lblspc_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_lblspc_id() directly.

    YANG Description: local_lblspc_id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="local-lblspc-id", rest_name="local-lblspc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_lblspc_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="local-lblspc-id", rest_name="local-lblspc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__local_lblspc_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_lblspc_id(self):
    self.__local_lblspc_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-lblspc-id", rest_name="local-lblspc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_next_keepalive(self):
    """
    Getter method for next_keepalive, mapped from YANG variable /mpls_state/ldp/ldp_session/next_keepalive (uint32)

    YANG Description: nextKeepalive
    """
    return self.__next_keepalive
      
  def _set_next_keepalive(self, v, load=False):
    """
    Setter method for next_keepalive, mapped from YANG variable /mpls_state/ldp/ldp_session/next_keepalive (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_keepalive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_keepalive() directly.

    YANG Description: nextKeepalive
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="next-keepalive", rest_name="next-keepalive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_keepalive must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="next-keepalive", rest_name="next-keepalive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__next_keepalive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_keepalive(self):
    self.__next_keepalive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="next-keepalive", rest_name="next-keepalive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_entity_index(self):
    """
    Getter method for entity_index, mapped from YANG variable /mpls_state/ldp/ldp_session/entity_index (uint32)

    YANG Description: entityIndex
    """
    return self.__entity_index
      
  def _set_entity_index(self, v, load=False):
    """
    Setter method for entity_index, mapped from YANG variable /mpls_state/ldp/ldp_session/entity_index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_entity_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_entity_index() directly.

    YANG Description: entityIndex
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="entity-index", rest_name="entity-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """entity_index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="entity-index", rest_name="entity-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__entity_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_entity_index(self):
    self.__entity_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="entity-index", rest_name="entity-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_targeted_adj_added(self):
    """
    Getter method for targeted_adj_added, mapped from YANG variable /mpls_state/ldp/ldp_session/targeted_adj_added (string)

    YANG Description: targetedAdjAdded
    """
    return self.__targeted_adj_added
      
  def _set_targeted_adj_added(self, v, load=False):
    """
    Setter method for targeted_adj_added, mapped from YANG variable /mpls_state/ldp/ldp_session/targeted_adj_added (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_targeted_adj_added is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_targeted_adj_added() directly.

    YANG Description: targetedAdjAdded
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="targeted-adj-added", rest_name="targeted-adj-added", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """targeted_adj_added must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="targeted-adj-added", rest_name="targeted-adj-added", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__targeted_adj_added = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_targeted_adj_added(self):
    self.__targeted_adj_added = YANGDynClass(base=unicode, is_leaf=True, yang_name="targeted-adj-added", rest_name="targeted-adj-added", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_is_retry(self):
    """
    Getter method for is_retry, mapped from YANG variable /mpls_state/ldp/ldp_session/is_retry (boolean)

    YANG Description: isRetry
    """
    return self.__is_retry
      
  def _set_is_retry(self, v, load=False):
    """
    Setter method for is_retry, mapped from YANG variable /mpls_state/ldp/ldp_session/is_retry (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_retry is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_retry() directly.

    YANG Description: isRetry
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-retry", rest_name="is-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_retry must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-retry", rest_name="is-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_retry = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_retry(self):
    self.__is_retry = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-retry", rest_name="is-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_next_retry(self):
    """
    Getter method for next_retry, mapped from YANG variable /mpls_state/ldp/ldp_session/next_retry (uint32)

    YANG Description: nextRetry
    """
    return self.__next_retry
      
  def _set_next_retry(self, v, load=False):
    """
    Setter method for next_retry, mapped from YANG variable /mpls_state/ldp/ldp_session/next_retry (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_retry is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_retry() directly.

    YANG Description: nextRetry
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="next-retry", rest_name="next-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_retry must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="next-retry", rest_name="next-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__next_retry = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_retry(self):
    self.__next_retry = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="next-retry", rest_name="next-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_keepalive_interval(self):
    """
    Getter method for keepalive_interval, mapped from YANG variable /mpls_state/ldp/ldp_session/keepalive_interval (uint32)

    YANG Description: keepaliveInterval
    """
    return self.__keepalive_interval
      
  def _set_keepalive_interval(self, v, load=False):
    """
    Setter method for keepalive_interval, mapped from YANG variable /mpls_state/ldp/ldp_session/keepalive_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepalive_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepalive_interval() directly.

    YANG Description: keepaliveInterval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="keepalive-interval", rest_name="keepalive-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepalive_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="keepalive-interval", rest_name="keepalive-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__keepalive_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepalive_interval(self):
    self.__keepalive_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="keepalive-interval", rest_name="keepalive-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_local_keepalive_timeout(self):
    """
    Getter method for local_keepalive_timeout, mapped from YANG variable /mpls_state/ldp/ldp_session/local_keepalive_timeout (uint32)

    YANG Description: localKeepaliveTimeout
    """
    return self.__local_keepalive_timeout
      
  def _set_local_keepalive_timeout(self, v, load=False):
    """
    Setter method for local_keepalive_timeout, mapped from YANG variable /mpls_state/ldp/ldp_session/local_keepalive_timeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_keepalive_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_keepalive_timeout() directly.

    YANG Description: localKeepaliveTimeout
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-keepalive-timeout", rest_name="local-keepalive-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_keepalive_timeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-keepalive-timeout", rest_name="local-keepalive-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__local_keepalive_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_keepalive_timeout(self):
    self.__local_keepalive_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-keepalive-timeout", rest_name="local-keepalive-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_peer_proposed_keepalive_timeout(self):
    """
    Getter method for peer_proposed_keepalive_timeout, mapped from YANG variable /mpls_state/ldp/ldp_session/peer_proposed_keepalive_timeout (uint32)

    YANG Description: peerProposedKeepaliveTimeout
    """
    return self.__peer_proposed_keepalive_timeout
      
  def _set_peer_proposed_keepalive_timeout(self, v, load=False):
    """
    Setter method for peer_proposed_keepalive_timeout, mapped from YANG variable /mpls_state/ldp/ldp_session/peer_proposed_keepalive_timeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_proposed_keepalive_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_proposed_keepalive_timeout() directly.

    YANG Description: peerProposedKeepaliveTimeout
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-proposed-keepalive-timeout", rest_name="peer-proposed-keepalive-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_proposed_keepalive_timeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-proposed-keepalive-timeout", rest_name="peer-proposed-keepalive-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__peer_proposed_keepalive_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_proposed_keepalive_timeout(self):
    self.__peer_proposed_keepalive_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-proposed-keepalive-timeout", rest_name="peer-proposed-keepalive-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_session_up_time(self):
    """
    Getter method for session_up_time, mapped from YANG variable /mpls_state/ldp/ldp_session/session_up_time (string)

    YANG Description: sessionUpTime
    """
    return self.__session_up_time
      
  def _set_session_up_time(self, v, load=False):
    """
    Setter method for session_up_time, mapped from YANG variable /mpls_state/ldp/ldp_session/session_up_time (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_session_up_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_session_up_time() directly.

    YANG Description: sessionUpTime
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="session-up-time", rest_name="session-up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """session_up_time must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="session-up-time", rest_name="session-up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__session_up_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_session_up_time(self):
    self.__session_up_time = YANGDynClass(base=unicode, is_leaf=True, yang_name="session-up-time", rest_name="session-up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_md5_auth_key(self):
    """
    Getter method for md5_auth_key, mapped from YANG variable /mpls_state/ldp/ldp_session/md5_auth_key (string)

    YANG Description: md5AuthKey
    """
    return self.__md5_auth_key
      
  def _set_md5_auth_key(self, v, load=False):
    """
    Setter method for md5_auth_key, mapped from YANG variable /mpls_state/ldp/ldp_session/md5_auth_key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_md5_auth_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_md5_auth_key() directly.

    YANG Description: md5AuthKey
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="md5-auth-key", rest_name="md5-auth-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """md5_auth_key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="md5-auth-key", rest_name="md5-auth-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__md5_auth_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_md5_auth_key(self):
    self.__md5_auth_key = YANGDynClass(base=unicode, is_leaf=True, yang_name="md5-auth-key", rest_name="md5-auth-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_tcp_conn_local(self):
    """
    Getter method for tcp_conn_local, mapped from YANG variable /mpls_state/ldp/ldp_session/tcp_conn_local (string)

    YANG Description: tcpConnLocal
    """
    return self.__tcp_conn_local
      
  def _set_tcp_conn_local(self, v, load=False):
    """
    Setter method for tcp_conn_local, mapped from YANG variable /mpls_state/ldp/ldp_session/tcp_conn_local (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcp_conn_local is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcp_conn_local() directly.

    YANG Description: tcpConnLocal
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tcp-conn-local", rest_name="tcp-conn-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcp_conn_local must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tcp-conn-local", rest_name="tcp-conn-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__tcp_conn_local = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcp_conn_local(self):
    self.__tcp_conn_local = YANGDynClass(base=unicode, is_leaf=True, yang_name="tcp-conn-local", rest_name="tcp-conn-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_tcp_conn_remote(self):
    """
    Getter method for tcp_conn_remote, mapped from YANG variable /mpls_state/ldp/ldp_session/tcp_conn_remote (string)

    YANG Description: tcpConnRemote
    """
    return self.__tcp_conn_remote
      
  def _set_tcp_conn_remote(self, v, load=False):
    """
    Setter method for tcp_conn_remote, mapped from YANG variable /mpls_state/ldp/ldp_session/tcp_conn_remote (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcp_conn_remote is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcp_conn_remote() directly.

    YANG Description: tcpConnRemote
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tcp-conn-remote", rest_name="tcp-conn-remote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcp_conn_remote must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tcp-conn-remote", rest_name="tcp-conn-remote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__tcp_conn_remote = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcp_conn_remote(self):
    self.__tcp_conn_remote = YANGDynClass(base=unicode, is_leaf=True, yang_name="tcp-conn-remote", rest_name="tcp-conn-remote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_tcp_state(self):
    """
    Getter method for tcp_state, mapped from YANG variable /mpls_state/ldp/ldp_session/tcp_state (string)

    YANG Description: tcpState
    """
    return self.__tcp_state
      
  def _set_tcp_state(self, v, load=False):
    """
    Setter method for tcp_state, mapped from YANG variable /mpls_state/ldp/ldp_session/tcp_state (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcp_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcp_state() directly.

    YANG Description: tcpState
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tcp-state", rest_name="tcp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcp_state must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tcp-state", rest_name="tcp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__tcp_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcp_state(self):
    self.__tcp_state = YANGDynClass(base=unicode, is_leaf=True, yang_name="tcp-state", rest_name="tcp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_num_fecs_received_from_peer(self):
    """
    Getter method for num_fecs_received_from_peer, mapped from YANG variable /mpls_state/ldp/ldp_session/num_fecs_received_from_peer (uint32)

    YANG Description: numFecsReceivedFromPeer
    """
    return self.__num_fecs_received_from_peer
      
  def _set_num_fecs_received_from_peer(self, v, load=False):
    """
    Setter method for num_fecs_received_from_peer, mapped from YANG variable /mpls_state/ldp/ldp_session/num_fecs_received_from_peer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_fecs_received_from_peer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_fecs_received_from_peer() directly.

    YANG Description: numFecsReceivedFromPeer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-received-from-peer", rest_name="num-fecs-received-from-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_fecs_received_from_peer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-received-from-peer", rest_name="num-fecs-received-from-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_fecs_received_from_peer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_fecs_received_from_peer(self):
    self.__num_fecs_received_from_peer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-received-from-peer", rest_name="num-fecs-received-from-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_num_fecs_installed_from_peer(self):
    """
    Getter method for num_fecs_installed_from_peer, mapped from YANG variable /mpls_state/ldp/ldp_session/num_fecs_installed_from_peer (uint32)

    YANG Description: numFecsInstalledFromPeer
    """
    return self.__num_fecs_installed_from_peer
      
  def _set_num_fecs_installed_from_peer(self, v, load=False):
    """
    Setter method for num_fecs_installed_from_peer, mapped from YANG variable /mpls_state/ldp/ldp_session/num_fecs_installed_from_peer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_fecs_installed_from_peer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_fecs_installed_from_peer() directly.

    YANG Description: numFecsInstalledFromPeer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-installed-from-peer", rest_name="num-fecs-installed-from-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_fecs_installed_from_peer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-installed-from-peer", rest_name="num-fecs-installed-from-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_fecs_installed_from_peer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_fecs_installed_from_peer(self):
    self.__num_fecs_installed_from_peer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-installed-from-peer", rest_name="num-fecs-installed-from-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_is_fecs_pending_uninstall(self):
    """
    Getter method for is_fecs_pending_uninstall, mapped from YANG variable /mpls_state/ldp/ldp_session/is_fecs_pending_uninstall (boolean)

    YANG Description: isFecsPendingUninstall
    """
    return self.__is_fecs_pending_uninstall
      
  def _set_is_fecs_pending_uninstall(self, v, load=False):
    """
    Setter method for is_fecs_pending_uninstall, mapped from YANG variable /mpls_state/ldp/ldp_session/is_fecs_pending_uninstall (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_fecs_pending_uninstall is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_fecs_pending_uninstall() directly.

    YANG Description: isFecsPendingUninstall
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-fecs-pending-uninstall", rest_name="is-fecs-pending-uninstall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_fecs_pending_uninstall must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-fecs-pending-uninstall", rest_name="is-fecs-pending-uninstall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_fecs_pending_uninstall = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_fecs_pending_uninstall(self):
    self.__is_fecs_pending_uninstall = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-fecs-pending-uninstall", rest_name="is-fecs-pending-uninstall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_num_fecs_filtered_out(self):
    """
    Getter method for num_fecs_filtered_out, mapped from YANG variable /mpls_state/ldp/ldp_session/num_fecs_filtered_out (uint32)

    YANG Description: numFecsFilteredOut
    """
    return self.__num_fecs_filtered_out
      
  def _set_num_fecs_filtered_out(self, v, load=False):
    """
    Setter method for num_fecs_filtered_out, mapped from YANG variable /mpls_state/ldp/ldp_session/num_fecs_filtered_out (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_fecs_filtered_out is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_fecs_filtered_out() directly.

    YANG Description: numFecsFilteredOut
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-filtered-out", rest_name="num-fecs-filtered-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_fecs_filtered_out must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-filtered-out", rest_name="num-fecs-filtered-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_fecs_filtered_out = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_fecs_filtered_out(self):
    self.__num_fecs_filtered_out = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-filtered-out", rest_name="num-fecs-filtered-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_num_fecs_filtered_in(self):
    """
    Getter method for num_fecs_filtered_in, mapped from YANG variable /mpls_state/ldp/ldp_session/num_fecs_filtered_in (uint32)

    YANG Description: numFecsFilteredIn
    """
    return self.__num_fecs_filtered_in
      
  def _set_num_fecs_filtered_in(self, v, load=False):
    """
    Setter method for num_fecs_filtered_in, mapped from YANG variable /mpls_state/ldp/ldp_session/num_fecs_filtered_in (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_fecs_filtered_in is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_fecs_filtered_in() directly.

    YANG Description: numFecsFilteredIn
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-filtered-in", rest_name="num-fecs-filtered-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_fecs_filtered_in must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-filtered-in", rest_name="num-fecs-filtered-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_fecs_filtered_in = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_fecs_filtered_in(self):
    self.__num_fecs_filtered_in = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-fecs-filtered-in", rest_name="num-fecs-filtered-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_filter_prefix_list_name(self):
    """
    Getter method for filter_prefix_list_name, mapped from YANG variable /mpls_state/ldp/ldp_session/filter_prefix_list_name (string)

    YANG Description: dataFilterPrefixList
    """
    return self.__filter_prefix_list_name
      
  def _set_filter_prefix_list_name(self, v, load=False):
    """
    Setter method for filter_prefix_list_name, mapped from YANG variable /mpls_state/ldp/ldp_session/filter_prefix_list_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filter_prefix_list_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filter_prefix_list_name() directly.

    YANG Description: dataFilterPrefixList
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="filter-prefix-list-name", rest_name="filter-prefix-list-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filter_prefix_list_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="filter-prefix-list-name", rest_name="filter-prefix-list-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__filter_prefix_list_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filter_prefix_list_name(self):
    self.__filter_prefix_list_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="filter-prefix-list-name", rest_name="filter-prefix-list-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_filter_prefix_list_exists(self):
    """
    Getter method for filter_prefix_list_exists, mapped from YANG variable /mpls_state/ldp/ldp_session/filter_prefix_list_exists (boolean)

    YANG Description: dataFilterPrefixListExists
    """
    return self.__filter_prefix_list_exists
      
  def _set_filter_prefix_list_exists(self, v, load=False):
    """
    Setter method for filter_prefix_list_exists, mapped from YANG variable /mpls_state/ldp/ldp_session/filter_prefix_list_exists (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filter_prefix_list_exists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filter_prefix_list_exists() directly.

    YANG Description: dataFilterPrefixListExists
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="filter-prefix-list-exists", rest_name="filter-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filter_prefix_list_exists must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="filter-prefix-list-exists", rest_name="filter-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__filter_prefix_list_exists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filter_prefix_list_exists(self):
    self.__filter_prefix_list_exists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="filter-prefix-list-exists", rest_name="filter-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_is_only_gr_valid(self):
    """
    Getter method for is_only_gr_valid, mapped from YANG variable /mpls_state/ldp/ldp_session/is_only_gr_valid (boolean)

    YANG Description: isOnlyGRValid
    """
    return self.__is_only_gr_valid
      
  def _set_is_only_gr_valid(self, v, load=False):
    """
    Setter method for is_only_gr_valid, mapped from YANG variable /mpls_state/ldp/ldp_session/is_only_gr_valid (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_only_gr_valid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_only_gr_valid() directly.

    YANG Description: isOnlyGRValid
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-only-gr-valid", rest_name="is-only-gr-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_only_gr_valid must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-only-gr-valid", rest_name="is-only-gr-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_only_gr_valid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_only_gr_valid(self):
    self.__is_only_gr_valid = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-only-gr-valid", rest_name="is-only-gr-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_gr_enabled(self):
    """
    Getter method for gr_enabled, mapped from YANG variable /mpls_state/ldp/ldp_session/gr_enabled (boolean)

    YANG Description: grEnabled
    """
    return self.__gr_enabled
      
  def _set_gr_enabled(self, v, load=False):
    """
    Setter method for gr_enabled, mapped from YANG variable /mpls_state/ldp/ldp_session/gr_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_enabled() directly.

    YANG Description: grEnabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="gr-enabled", rest_name="gr-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-enabled", rest_name="gr-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__gr_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_enabled(self):
    self.__gr_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-enabled", rest_name="gr-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_peer_reconnect_time(self):
    """
    Getter method for peer_reconnect_time, mapped from YANG variable /mpls_state/ldp/ldp_session/peer_reconnect_time (uint32)

    YANG Description: peerReconectTime
    """
    return self.__peer_reconnect_time
      
  def _set_peer_reconnect_time(self, v, load=False):
    """
    Setter method for peer_reconnect_time, mapped from YANG variable /mpls_state/ldp/ldp_session/peer_reconnect_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_reconnect_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_reconnect_time() directly.

    YANG Description: peerReconectTime
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-reconnect-time", rest_name="peer-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_reconnect_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-reconnect-time", rest_name="peer-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__peer_reconnect_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_reconnect_time(self):
    self.__peer_reconnect_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-reconnect-time", rest_name="peer-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_peer_recovery_time(self):
    """
    Getter method for peer_recovery_time, mapped from YANG variable /mpls_state/ldp/ldp_session/peer_recovery_time (uint32)

    YANG Description: peerRecoveryTime
    """
    return self.__peer_recovery_time
      
  def _set_peer_recovery_time(self, v, load=False):
    """
    Setter method for peer_recovery_time, mapped from YANG variable /mpls_state/ldp/ldp_session/peer_recovery_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_recovery_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_recovery_time() directly.

    YANG Description: peerRecoveryTime
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-recovery-time", rest_name="peer-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_recovery_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-recovery-time", rest_name="peer-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__peer_recovery_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_recovery_time(self):
    self.__peer_recovery_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-recovery-time", rest_name="peer-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_reconnect_time_in_use(self):
    """
    Getter method for reconnect_time_in_use, mapped from YANG variable /mpls_state/ldp/ldp_session/reconnect_time_in_use (uint32)
    """
    return self.__reconnect_time_in_use
      
  def _set_reconnect_time_in_use(self, v, load=False):
    """
    Setter method for reconnect_time_in_use, mapped from YANG variable /mpls_state/ldp/ldp_session/reconnect_time_in_use (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reconnect_time_in_use is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reconnect_time_in_use() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reconnect-time-in-use", rest_name="reconnect-time-in-use", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reconnect_time_in_use must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reconnect-time-in-use", rest_name="reconnect-time-in-use", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__reconnect_time_in_use = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reconnect_time_in_use(self):
    self.__reconnect_time_in_use = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reconnect-time-in-use", rest_name="reconnect-time-in-use", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_reconnect_time_remaining(self):
    """
    Getter method for reconnect_time_remaining, mapped from YANG variable /mpls_state/ldp/ldp_session/reconnect_time_remaining (uint32)
    """
    return self.__reconnect_time_remaining
      
  def _set_reconnect_time_remaining(self, v, load=False):
    """
    Setter method for reconnect_time_remaining, mapped from YANG variable /mpls_state/ldp/ldp_session/reconnect_time_remaining (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reconnect_time_remaining is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reconnect_time_remaining() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reconnect-time-remaining", rest_name="reconnect-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reconnect_time_remaining must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reconnect-time-remaining", rest_name="reconnect-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__reconnect_time_remaining = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reconnect_time_remaining(self):
    self.__reconnect_time_remaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reconnect-time-remaining", rest_name="reconnect-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_recovery_time_in_use(self):
    """
    Getter method for recovery_time_in_use, mapped from YANG variable /mpls_state/ldp/ldp_session/recovery_time_in_use (uint32)
    """
    return self.__recovery_time_in_use
      
  def _set_recovery_time_in_use(self, v, load=False):
    """
    Setter method for recovery_time_in_use, mapped from YANG variable /mpls_state/ldp/ldp_session/recovery_time_in_use (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_recovery_time_in_use is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_recovery_time_in_use() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="recovery-time-in-use", rest_name="recovery-time-in-use", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """recovery_time_in_use must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="recovery-time-in-use", rest_name="recovery-time-in-use", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__recovery_time_in_use = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_recovery_time_in_use(self):
    self.__recovery_time_in_use = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="recovery-time-in-use", rest_name="recovery-time-in-use", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_recovery_time_remaining(self):
    """
    Getter method for recovery_time_remaining, mapped from YANG variable /mpls_state/ldp/ldp_session/recovery_time_remaining (uint32)
    """
    return self.__recovery_time_remaining
      
  def _set_recovery_time_remaining(self, v, load=False):
    """
    Setter method for recovery_time_remaining, mapped from YANG variable /mpls_state/ldp/ldp_session/recovery_time_remaining (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_recovery_time_remaining is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_recovery_time_remaining() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="recovery-time-remaining", rest_name="recovery-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """recovery_time_remaining must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="recovery-time-remaining", rest_name="recovery-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__recovery_time_remaining = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_recovery_time_remaining(self):
    self.__recovery_time_remaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="recovery-time-remaining", rest_name="recovery-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_gr_state(self):
    """
    Getter method for gr_state, mapped from YANG variable /mpls_state/ldp/ldp_session/gr_state (string)

    YANG Description: grState
    """
    return self.__gr_state
      
  def _set_gr_state(self, v, load=False):
    """
    Setter method for gr_state, mapped from YANG variable /mpls_state/ldp/ldp_session/gr_state (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_state() directly.

    YANG Description: grState
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="gr-state", rest_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_state must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="gr-state", rest_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__gr_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_state(self):
    self.__gr_state = YANGDynClass(base=unicode, is_leaf=True, yang_name="gr-state", rest_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_local_eol_unrecognized_notification(self):
    """
    Getter method for local_eol_unrecognized_notification, mapped from YANG variable /mpls_state/ldp/ldp_session/local_eol_unrecognized_notification (boolean)

    YANG Description: localEolUnrecognizedNotification
    """
    return self.__local_eol_unrecognized_notification
      
  def _set_local_eol_unrecognized_notification(self, v, load=False):
    """
    Setter method for local_eol_unrecognized_notification, mapped from YANG variable /mpls_state/ldp/ldp_session/local_eol_unrecognized_notification (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_eol_unrecognized_notification is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_eol_unrecognized_notification() directly.

    YANG Description: localEolUnrecognizedNotification
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="local-eol-unrecognized-notification", rest_name="local-eol-unrecognized-notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_eol_unrecognized_notification must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="local-eol-unrecognized-notification", rest_name="local-eol-unrecognized-notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__local_eol_unrecognized_notification = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_eol_unrecognized_notification(self):
    self.__local_eol_unrecognized_notification = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="local-eol-unrecognized-notification", rest_name="local-eol-unrecognized-notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_remote_eol_unrecognized_notification(self):
    """
    Getter method for remote_eol_unrecognized_notification, mapped from YANG variable /mpls_state/ldp/ldp_session/remote_eol_unrecognized_notification (boolean)

    YANG Description: remoteEolUnrecognizedNotification
    """
    return self.__remote_eol_unrecognized_notification
      
  def _set_remote_eol_unrecognized_notification(self, v, load=False):
    """
    Setter method for remote_eol_unrecognized_notification, mapped from YANG variable /mpls_state/ldp/ldp_session/remote_eol_unrecognized_notification (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_eol_unrecognized_notification is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_eol_unrecognized_notification() directly.

    YANG Description: remoteEolUnrecognizedNotification
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="remote-eol-unrecognized-notification", rest_name="remote-eol-unrecognized-notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_eol_unrecognized_notification must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="remote-eol-unrecognized-notification", rest_name="remote-eol-unrecognized-notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__remote_eol_unrecognized_notification = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_eol_unrecognized_notification(self):
    self.__remote_eol_unrecognized_notification = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="remote-eol-unrecognized-notification", rest_name="remote-eol-unrecognized-notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_does_session_support_eol(self):
    """
    Getter method for does_session_support_eol, mapped from YANG variable /mpls_state/ldp/ldp_session/does_session_support_eol (boolean)

    YANG Description: doesSessionSupportEol
    """
    return self.__does_session_support_eol
      
  def _set_does_session_support_eol(self, v, load=False):
    """
    Setter method for does_session_support_eol, mapped from YANG variable /mpls_state/ldp/ldp_session/does_session_support_eol (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_does_session_support_eol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_does_session_support_eol() directly.

    YANG Description: doesSessionSupportEol
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="does-session-support-eol", rest_name="does-session-support-eol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """does_session_support_eol must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="does-session-support-eol", rest_name="does-session-support-eol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__does_session_support_eol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_does_session_support_eol(self):
    self.__does_session_support_eol = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="does-session-support-eol", rest_name="does-session-support-eol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_local_state(self):
    """
    Getter method for local_state, mapped from YANG variable /mpls_state/ldp/ldp_session/local_state (boolean)

    YANG Description: localState
    """
    return self.__local_state
      
  def _set_local_state(self, v, load=False):
    """
    Setter method for local_state, mapped from YANG variable /mpls_state/ldp/ldp_session/local_state (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_state() directly.

    YANG Description: localState
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="local-state", rest_name="local-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_state must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="local-state", rest_name="local-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__local_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_state(self):
    self.__local_state = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="local-state", rest_name="local-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_remote_state(self):
    """
    Getter method for remote_state, mapped from YANG variable /mpls_state/ldp/ldp_session/remote_state (boolean)

    YANG Description: remoteState
    """
    return self.__remote_state
      
  def _set_remote_state(self, v, load=False):
    """
    Setter method for remote_state, mapped from YANG variable /mpls_state/ldp/ldp_session/remote_state (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_state() directly.

    YANG Description: remoteState
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="remote-state", rest_name="remote-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_state must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="remote-state", rest_name="remote-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__remote_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_state(self):
    self.__remote_state = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="remote-state", rest_name="remote-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_eol_notification_time(self):
    """
    Getter method for eol_notification_time, mapped from YANG variable /mpls_state/ldp/ldp_session/eol_notification_time (uint32)

    YANG Description: eolNotificationTime
    """
    return self.__eol_notification_time
      
  def _set_eol_notification_time(self, v, load=False):
    """
    Setter method for eol_notification_time, mapped from YANG variable /mpls_state/ldp/ldp_session/eol_notification_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eol_notification_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eol_notification_time() directly.

    YANG Description: eolNotificationTime
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time", rest_name="eol-notification-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eol_notification_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time", rest_name="eol-notification-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__eol_notification_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eol_notification_time(self):
    self.__eol_notification_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time", rest_name="eol-notification-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_eol_notification_time_remaining(self):
    """
    Getter method for eol_notification_time_remaining, mapped from YANG variable /mpls_state/ldp/ldp_session/eol_notification_time_remaining (uint32)

    YANG Description: eolNotificationTimeRemaining
    """
    return self.__eol_notification_time_remaining
      
  def _set_eol_notification_time_remaining(self, v, load=False):
    """
    Setter method for eol_notification_time_remaining, mapped from YANG variable /mpls_state/ldp/ldp_session/eol_notification_time_remaining (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eol_notification_time_remaining is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eol_notification_time_remaining() directly.

    YANG Description: eolNotificationTimeRemaining
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time-remaining", rest_name="eol-notification-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eol_notification_time_remaining must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time-remaining", rest_name="eol-notification-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__eol_notification_time_remaining = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eol_notification_time_remaining(self):
    self.__eol_notification_time_remaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time-remaining", rest_name="eol-notification-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_eol_tx_label_silence_time(self):
    """
    Getter method for eol_tx_label_silence_time, mapped from YANG variable /mpls_state/ldp/ldp_session/eol_tx_label_silence_time (uint32)

    YANG Description: eolTxLabelSilenceTime
    """
    return self.__eol_tx_label_silence_time
      
  def _set_eol_tx_label_silence_time(self, v, load=False):
    """
    Setter method for eol_tx_label_silence_time, mapped from YANG variable /mpls_state/ldp/ldp_session/eol_tx_label_silence_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eol_tx_label_silence_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eol_tx_label_silence_time() directly.

    YANG Description: eolTxLabelSilenceTime
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-tx-label-silence-time", rest_name="eol-tx-label-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eol_tx_label_silence_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-tx-label-silence-time", rest_name="eol-tx-label-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__eol_tx_label_silence_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eol_tx_label_silence_time(self):
    self.__eol_tx_label_silence_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-tx-label-silence-time", rest_name="eol-tx-label-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_eol_tx_label_silence_time_remaining(self):
    """
    Getter method for eol_tx_label_silence_time_remaining, mapped from YANG variable /mpls_state/ldp/ldp_session/eol_tx_label_silence_time_remaining (uint32)

    YANG Description: eolTxLabelSilenceTimeRunning
    """
    return self.__eol_tx_label_silence_time_remaining
      
  def _set_eol_tx_label_silence_time_remaining(self, v, load=False):
    """
    Setter method for eol_tx_label_silence_time_remaining, mapped from YANG variable /mpls_state/ldp/ldp_session/eol_tx_label_silence_time_remaining (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eol_tx_label_silence_time_remaining is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eol_tx_label_silence_time_remaining() directly.

    YANG Description: eolTxLabelSilenceTimeRunning
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-tx-label-silence-time-remaining", rest_name="eol-tx-label-silence-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eol_tx_label_silence_time_remaining must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-tx-label-silence-time-remaining", rest_name="eol-tx-label-silence-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__eol_tx_label_silence_time_remaining = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eol_tx_label_silence_time_remaining(self):
    self.__eol_tx_label_silence_time_remaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-tx-label-silence-time-remaining", rest_name="eol-tx-label-silence-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_eol_rx_label_silence_time(self):
    """
    Getter method for eol_rx_label_silence_time, mapped from YANG variable /mpls_state/ldp/ldp_session/eol_rx_label_silence_time (uint32)

    YANG Description: eolRxLabelSilenceTime
    """
    return self.__eol_rx_label_silence_time
      
  def _set_eol_rx_label_silence_time(self, v, load=False):
    """
    Setter method for eol_rx_label_silence_time, mapped from YANG variable /mpls_state/ldp/ldp_session/eol_rx_label_silence_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eol_rx_label_silence_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eol_rx_label_silence_time() directly.

    YANG Description: eolRxLabelSilenceTime
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-rx-label-silence-time", rest_name="eol-rx-label-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eol_rx_label_silence_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-rx-label-silence-time", rest_name="eol-rx-label-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__eol_rx_label_silence_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eol_rx_label_silence_time(self):
    self.__eol_rx_label_silence_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-rx-label-silence-time", rest_name="eol-rx-label-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_eol_rx_label_silence_time_remaining(self):
    """
    Getter method for eol_rx_label_silence_time_remaining, mapped from YANG variable /mpls_state/ldp/ldp_session/eol_rx_label_silence_time_remaining (uint32)

    YANG Description: eolRxLabelSilenceTimeRunning
    """
    return self.__eol_rx_label_silence_time_remaining
      
  def _set_eol_rx_label_silence_time_remaining(self, v, load=False):
    """
    Setter method for eol_rx_label_silence_time_remaining, mapped from YANG variable /mpls_state/ldp/ldp_session/eol_rx_label_silence_time_remaining (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eol_rx_label_silence_time_remaining is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eol_rx_label_silence_time_remaining() directly.

    YANG Description: eolRxLabelSilenceTimeRunning
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-rx-label-silence-time-remaining", rest_name="eol-rx-label-silence-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eol_rx_label_silence_time_remaining must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-rx-label-silence-time-remaining", rest_name="eol-rx-label-silence-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__eol_rx_label_silence_time_remaining = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eol_rx_label_silence_time_remaining(self):
    self.__eol_rx_label_silence_time_remaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-rx-label-silence-time-remaining", rest_name="eol-rx-label-silence-time-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_filtered(self):
    """
    Getter method for filtered, mapped from YANG variable /mpls_state/ldp/ldp_session/filtered (session-filter-type)

    YANG Description: Filter Type
    """
    return self.__filtered
      
  def _set_filtered(self, v, load=False):
    """
    Setter method for filtered, mapped from YANG variable /mpls_state/ldp/ldp_session/filtered (session-filter-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filtered is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filtered() directly.

    YANG Description: Filter Type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'sess-filtered-out': {'value': 3}, u'sess-filtered-in': {'value': 2}, u'sess-filtered': {'value': 1}},), is_leaf=True, yang_name="filtered", rest_name="filtered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='session-filter-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filtered must be of a type compatible with session-filter-type""",
          'defined-type': "brocade-mpls-operational:session-filter-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'sess-filtered-out': {'value': 3}, u'sess-filtered-in': {'value': 2}, u'sess-filtered': {'value': 1}},), is_leaf=True, yang_name="filtered", rest_name="filtered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='session-filter-type', is_config=False)""",
        })

    self.__filtered = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filtered(self):
    self.__filtered = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'sess-filtered-out': {'value': 3}, u'sess-filtered-in': {'value': 2}, u'sess-filtered': {'value': 1}},), is_leaf=True, yang_name="filtered", rest_name="filtered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='session-filter-type', is_config=False)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /mpls_state/ldp/ldp_session/interfaces (string)

    YANG Description: interface list
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /mpls_state/ldp/ldp_session/interfaces (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: interface list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="interfaces", rest_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="interfaces", rest_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="interfaces", rest_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /mpls_state/ldp/ldp_session/addresses (string)

    YANG Description: address list
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /mpls_state/ldp/ldp_session/addresses (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: address list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="addresses", rest_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="addresses", rest_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="addresses", rest_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_session_ldp_stats(self):
    """
    Getter method for session_ldp_stats, mapped from YANG variable /mpls_state/ldp/ldp_session/session_ldp_stats (container)

    YANG Description: Session LDP stats
    """
    return self.__session_ldp_stats
      
  def _set_session_ldp_stats(self, v, load=False):
    """
    Setter method for session_ldp_stats, mapped from YANG variable /mpls_state/ldp/ldp_session/session_ldp_stats (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_session_ldp_stats is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_session_ldp_stats() directly.

    YANG Description: Session LDP stats
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=session_ldp_stats.session_ldp_stats, is_container='container', presence=False, yang_name="session-ldp-stats", rest_name="session-ldp-stats", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-session-ldp-stats', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """session_ldp_stats must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=session_ldp_stats.session_ldp_stats, is_container='container', presence=False, yang_name="session-ldp-stats", rest_name="session-ldp-stats", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-session-ldp-stats', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)""",
        })

    self.__session_ldp_stats = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_session_ldp_stats(self):
    self.__session_ldp_stats = YANGDynClass(base=session_ldp_stats.session_ldp_stats, is_container='container', presence=False, yang_name="session-ldp-stats", rest_name="session-ldp-stats", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-session-ldp-stats', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)


  def _get_filtered_fecs_in(self):
    """
    Getter method for filtered_fecs_in, mapped from YANG variable /mpls_state/ldp/ldp_session/filtered_fecs_in (list)
    """
    return self.__filtered_fecs_in
      
  def _set_filtered_fecs_in(self, v, load=False):
    """
    Setter method for filtered_fecs_in, mapped from YANG variable /mpls_state/ldp/ldp_session/filtered_fecs_in (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filtered_fecs_in is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filtered_fecs_in() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("fec_addr",filtered_fecs_in.filtered_fecs_in, yang_name="filtered-fecs-in", rest_name="filtered-fecs-in", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='fec-addr', extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-in-1'}}), is_container='list', yang_name="filtered-fecs-in", rest_name="filtered-fecs-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-in-1'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filtered_fecs_in must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("fec_addr",filtered_fecs_in.filtered_fecs_in, yang_name="filtered-fecs-in", rest_name="filtered-fecs-in", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='fec-addr', extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-in-1'}}), is_container='list', yang_name="filtered-fecs-in", rest_name="filtered-fecs-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-in-1'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__filtered_fecs_in = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filtered_fecs_in(self):
    self.__filtered_fecs_in = YANGDynClass(base=YANGListType("fec_addr",filtered_fecs_in.filtered_fecs_in, yang_name="filtered-fecs-in", rest_name="filtered-fecs-in", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='fec-addr', extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-in-1'}}), is_container='list', yang_name="filtered-fecs-in", rest_name="filtered-fecs-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-in-1'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)


  def _get_filtered_fecs_out(self):
    """
    Getter method for filtered_fecs_out, mapped from YANG variable /mpls_state/ldp/ldp_session/filtered_fecs_out (list)
    """
    return self.__filtered_fecs_out
      
  def _set_filtered_fecs_out(self, v, load=False):
    """
    Setter method for filtered_fecs_out, mapped from YANG variable /mpls_state/ldp/ldp_session/filtered_fecs_out (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filtered_fecs_out is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filtered_fecs_out() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("fec_addr",filtered_fecs_out.filtered_fecs_out, yang_name="filtered-fecs-out", rest_name="filtered-fecs-out", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='fec-addr', extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-out-1'}}), is_container='list', yang_name="filtered-fecs-out", rest_name="filtered-fecs-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-out-1'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filtered_fecs_out must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("fec_addr",filtered_fecs_out.filtered_fecs_out, yang_name="filtered-fecs-out", rest_name="filtered-fecs-out", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='fec-addr', extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-out-1'}}), is_container='list', yang_name="filtered-fecs-out", rest_name="filtered-fecs-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-out-1'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__filtered_fecs_out = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filtered_fecs_out(self):
    self.__filtered_fecs_out = YANGDynClass(base=YANGListType("fec_addr",filtered_fecs_out.filtered_fecs_out, yang_name="filtered-fecs-out", rest_name="filtered-fecs-out", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='fec-addr', extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-out-1'}}), is_container='list', yang_name="filtered-fecs-out", rest_name="filtered-fecs-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-filtered-fecs-filtered-fecs-out-1'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)

  peer_ldp_id = __builtin__.property(_get_peer_ldp_id)
  peer_lblspc_id = __builtin__.property(_get_peer_lblspc_id)
  state = __builtin__.property(_get_state)
  adjacency = __builtin__.property(_get_adjacency)
  role = __builtin__.property(_get_role)
  max_hold = __builtin__.property(_get_max_hold)
  time_left = __builtin__.property(_get_time_left)
  session_status = __builtin__.property(_get_session_status)
  local_ldp_id = __builtin__.property(_get_local_ldp_id)
  local_lblspc_id = __builtin__.property(_get_local_lblspc_id)
  next_keepalive = __builtin__.property(_get_next_keepalive)
  entity_index = __builtin__.property(_get_entity_index)
  targeted_adj_added = __builtin__.property(_get_targeted_adj_added)
  is_retry = __builtin__.property(_get_is_retry)
  next_retry = __builtin__.property(_get_next_retry)
  keepalive_interval = __builtin__.property(_get_keepalive_interval)
  local_keepalive_timeout = __builtin__.property(_get_local_keepalive_timeout)
  peer_proposed_keepalive_timeout = __builtin__.property(_get_peer_proposed_keepalive_timeout)
  session_up_time = __builtin__.property(_get_session_up_time)
  md5_auth_key = __builtin__.property(_get_md5_auth_key)
  tcp_conn_local = __builtin__.property(_get_tcp_conn_local)
  tcp_conn_remote = __builtin__.property(_get_tcp_conn_remote)
  tcp_state = __builtin__.property(_get_tcp_state)
  num_fecs_received_from_peer = __builtin__.property(_get_num_fecs_received_from_peer)
  num_fecs_installed_from_peer = __builtin__.property(_get_num_fecs_installed_from_peer)
  is_fecs_pending_uninstall = __builtin__.property(_get_is_fecs_pending_uninstall)
  num_fecs_filtered_out = __builtin__.property(_get_num_fecs_filtered_out)
  num_fecs_filtered_in = __builtin__.property(_get_num_fecs_filtered_in)
  filter_prefix_list_name = __builtin__.property(_get_filter_prefix_list_name)
  filter_prefix_list_exists = __builtin__.property(_get_filter_prefix_list_exists)
  is_only_gr_valid = __builtin__.property(_get_is_only_gr_valid)
  gr_enabled = __builtin__.property(_get_gr_enabled)
  peer_reconnect_time = __builtin__.property(_get_peer_reconnect_time)
  peer_recovery_time = __builtin__.property(_get_peer_recovery_time)
  reconnect_time_in_use = __builtin__.property(_get_reconnect_time_in_use)
  reconnect_time_remaining = __builtin__.property(_get_reconnect_time_remaining)
  recovery_time_in_use = __builtin__.property(_get_recovery_time_in_use)
  recovery_time_remaining = __builtin__.property(_get_recovery_time_remaining)
  gr_state = __builtin__.property(_get_gr_state)
  local_eol_unrecognized_notification = __builtin__.property(_get_local_eol_unrecognized_notification)
  remote_eol_unrecognized_notification = __builtin__.property(_get_remote_eol_unrecognized_notification)
  does_session_support_eol = __builtin__.property(_get_does_session_support_eol)
  local_state = __builtin__.property(_get_local_state)
  remote_state = __builtin__.property(_get_remote_state)
  eol_notification_time = __builtin__.property(_get_eol_notification_time)
  eol_notification_time_remaining = __builtin__.property(_get_eol_notification_time_remaining)
  eol_tx_label_silence_time = __builtin__.property(_get_eol_tx_label_silence_time)
  eol_tx_label_silence_time_remaining = __builtin__.property(_get_eol_tx_label_silence_time_remaining)
  eol_rx_label_silence_time = __builtin__.property(_get_eol_rx_label_silence_time)
  eol_rx_label_silence_time_remaining = __builtin__.property(_get_eol_rx_label_silence_time_remaining)
  filtered = __builtin__.property(_get_filtered)
  interfaces = __builtin__.property(_get_interfaces)
  addresses = __builtin__.property(_get_addresses)
  session_ldp_stats = __builtin__.property(_get_session_ldp_stats)
  filtered_fecs_in = __builtin__.property(_get_filtered_fecs_in)
  filtered_fecs_out = __builtin__.property(_get_filtered_fecs_out)


  _pyangbind_elements = {'peer_ldp_id': peer_ldp_id, 'peer_lblspc_id': peer_lblspc_id, 'state': state, 'adjacency': adjacency, 'role': role, 'max_hold': max_hold, 'time_left': time_left, 'session_status': session_status, 'local_ldp_id': local_ldp_id, 'local_lblspc_id': local_lblspc_id, 'next_keepalive': next_keepalive, 'entity_index': entity_index, 'targeted_adj_added': targeted_adj_added, 'is_retry': is_retry, 'next_retry': next_retry, 'keepalive_interval': keepalive_interval, 'local_keepalive_timeout': local_keepalive_timeout, 'peer_proposed_keepalive_timeout': peer_proposed_keepalive_timeout, 'session_up_time': session_up_time, 'md5_auth_key': md5_auth_key, 'tcp_conn_local': tcp_conn_local, 'tcp_conn_remote': tcp_conn_remote, 'tcp_state': tcp_state, 'num_fecs_received_from_peer': num_fecs_received_from_peer, 'num_fecs_installed_from_peer': num_fecs_installed_from_peer, 'is_fecs_pending_uninstall': is_fecs_pending_uninstall, 'num_fecs_filtered_out': num_fecs_filtered_out, 'num_fecs_filtered_in': num_fecs_filtered_in, 'filter_prefix_list_name': filter_prefix_list_name, 'filter_prefix_list_exists': filter_prefix_list_exists, 'is_only_gr_valid': is_only_gr_valid, 'gr_enabled': gr_enabled, 'peer_reconnect_time': peer_reconnect_time, 'peer_recovery_time': peer_recovery_time, 'reconnect_time_in_use': reconnect_time_in_use, 'reconnect_time_remaining': reconnect_time_remaining, 'recovery_time_in_use': recovery_time_in_use, 'recovery_time_remaining': recovery_time_remaining, 'gr_state': gr_state, 'local_eol_unrecognized_notification': local_eol_unrecognized_notification, 'remote_eol_unrecognized_notification': remote_eol_unrecognized_notification, 'does_session_support_eol': does_session_support_eol, 'local_state': local_state, 'remote_state': remote_state, 'eol_notification_time': eol_notification_time, 'eol_notification_time_remaining': eol_notification_time_remaining, 'eol_tx_label_silence_time': eol_tx_label_silence_time, 'eol_tx_label_silence_time_remaining': eol_tx_label_silence_time_remaining, 'eol_rx_label_silence_time': eol_rx_label_silence_time, 'eol_rx_label_silence_time_remaining': eol_rx_label_silence_time_remaining, 'filtered': filtered, 'interfaces': interfaces, 'addresses': addresses, 'session_ldp_stats': session_ldp_stats, 'filtered_fecs_in': filtered_fecs_in, 'filtered_fecs_out': filtered_fecs_out, }


