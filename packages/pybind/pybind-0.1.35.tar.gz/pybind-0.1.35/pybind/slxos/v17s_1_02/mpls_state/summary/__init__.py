
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class summary(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls-operational - based on the path /mpls-state/summary. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: MPLS Summary
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__paths_configured','__lsps_configured','__lsps_enabled','__lsps_operational','__detour_lsps_up','__backup_lsps_up','__bypass_lsps','__bypass_lsps_up','__bypass_lsps_enabled','__ldp_lsps_operational','__transit_lsps_configured','__transit_lsps_enabled','__transit_lsps_operational','__cspf_groups_configured','__tunnels_supported','__tunnels_allocated','__cross_connects_supported','__cross_connects_allocated','__auto_bw_templates_supported','__auto_bw_templates_configured','__times_enabled',)

  _yang_name = 'summary'
  _rest_name = 'summary'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__cspf_groups_configured = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cspf-groups-configured", rest_name="cspf-groups-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__lsps_enabled = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsps-enabled", rest_name="lsps-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__paths_configured = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="paths-configured", rest_name="paths-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__lsps_configured = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsps-configured", rest_name="lsps-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__bypass_lsps_enabled = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bypass-lsps-enabled", rest_name="bypass-lsps-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__tunnels_supported = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnels-supported", rest_name="tunnels-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__cross_connects_allocated = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cross-connects-allocated", rest_name="cross-connects-allocated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__bypass_lsps_up = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bypass-lsps-up", rest_name="bypass-lsps-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__detour_lsps_up = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="detour-lsps-up", rest_name="detour-lsps-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__cross_connects_supported = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cross-connects-supported", rest_name="cross-connects-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__times_enabled = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="times-enabled", rest_name="times-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__transit_lsps_enabled = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-lsps-enabled", rest_name="transit-lsps-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__transit_lsps_configured = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-lsps-configured", rest_name="transit-lsps-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__lsps_operational = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsps-operational", rest_name="lsps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__auto_bw_templates_supported = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auto-bw-templates-supported", rest_name="auto-bw-templates-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__bypass_lsps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bypass-lsps", rest_name="bypass-lsps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__backup_lsps_up = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="backup-lsps-up", rest_name="backup-lsps-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__ldp_lsps_operational = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ldp-lsps-operational", rest_name="ldp-lsps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__auto_bw_templates_configured = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auto-bw-templates-configured", rest_name="auto-bw-templates-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__tunnels_allocated = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnels-allocated", rest_name="tunnels-allocated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__transit_lsps_operational = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-lsps-operational", rest_name="transit-lsps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mpls-state', u'summary']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'mpls-state', u'summary']

  def _get_paths_configured(self):
    """
    Getter method for paths_configured, mapped from YANG variable /mpls_state/summary/paths_configured (uint32)

    YANG Description: Paths configured
    """
    return self.__paths_configured
      
  def _set_paths_configured(self, v, load=False):
    """
    Setter method for paths_configured, mapped from YANG variable /mpls_state/summary/paths_configured (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_paths_configured is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_paths_configured() directly.

    YANG Description: Paths configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="paths-configured", rest_name="paths-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """paths_configured must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="paths-configured", rest_name="paths-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__paths_configured = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_paths_configured(self):
    self.__paths_configured = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="paths-configured", rest_name="paths-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_lsps_configured(self):
    """
    Getter method for lsps_configured, mapped from YANG variable /mpls_state/summary/lsps_configured (uint32)

    YANG Description: LSPs configured
    """
    return self.__lsps_configured
      
  def _set_lsps_configured(self, v, load=False):
    """
    Setter method for lsps_configured, mapped from YANG variable /mpls_state/summary/lsps_configured (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsps_configured is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsps_configured() directly.

    YANG Description: LSPs configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsps-configured", rest_name="lsps-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsps_configured must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsps-configured", rest_name="lsps-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__lsps_configured = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsps_configured(self):
    self.__lsps_configured = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsps-configured", rest_name="lsps-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_lsps_enabled(self):
    """
    Getter method for lsps_enabled, mapped from YANG variable /mpls_state/summary/lsps_enabled (uint32)

    YANG Description: LSPs enabled
    """
    return self.__lsps_enabled
      
  def _set_lsps_enabled(self, v, load=False):
    """
    Setter method for lsps_enabled, mapped from YANG variable /mpls_state/summary/lsps_enabled (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsps_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsps_enabled() directly.

    YANG Description: LSPs enabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsps-enabled", rest_name="lsps-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsps_enabled must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsps-enabled", rest_name="lsps-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__lsps_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsps_enabled(self):
    self.__lsps_enabled = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsps-enabled", rest_name="lsps-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_lsps_operational(self):
    """
    Getter method for lsps_operational, mapped from YANG variable /mpls_state/summary/lsps_operational (uint32)

    YANG Description: LSPs operational
    """
    return self.__lsps_operational
      
  def _set_lsps_operational(self, v, load=False):
    """
    Setter method for lsps_operational, mapped from YANG variable /mpls_state/summary/lsps_operational (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsps_operational is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsps_operational() directly.

    YANG Description: LSPs operational
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsps-operational", rest_name="lsps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsps_operational must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsps-operational", rest_name="lsps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__lsps_operational = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsps_operational(self):
    self.__lsps_operational = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsps-operational", rest_name="lsps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_detour_lsps_up(self):
    """
    Getter method for detour_lsps_up, mapped from YANG variable /mpls_state/summary/detour_lsps_up (uint32)

    YANG Description: Detour LSPs UP
    """
    return self.__detour_lsps_up
      
  def _set_detour_lsps_up(self, v, load=False):
    """
    Setter method for detour_lsps_up, mapped from YANG variable /mpls_state/summary/detour_lsps_up (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_detour_lsps_up is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_detour_lsps_up() directly.

    YANG Description: Detour LSPs UP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="detour-lsps-up", rest_name="detour-lsps-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """detour_lsps_up must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="detour-lsps-up", rest_name="detour-lsps-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__detour_lsps_up = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_detour_lsps_up(self):
    self.__detour_lsps_up = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="detour-lsps-up", rest_name="detour-lsps-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_backup_lsps_up(self):
    """
    Getter method for backup_lsps_up, mapped from YANG variable /mpls_state/summary/backup_lsps_up (uint32)

    YANG Description: Backup LSPs UP
    """
    return self.__backup_lsps_up
      
  def _set_backup_lsps_up(self, v, load=False):
    """
    Setter method for backup_lsps_up, mapped from YANG variable /mpls_state/summary/backup_lsps_up (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_backup_lsps_up is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_backup_lsps_up() directly.

    YANG Description: Backup LSPs UP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="backup-lsps-up", rest_name="backup-lsps-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """backup_lsps_up must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="backup-lsps-up", rest_name="backup-lsps-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__backup_lsps_up = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_backup_lsps_up(self):
    self.__backup_lsps_up = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="backup-lsps-up", rest_name="backup-lsps-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_bypass_lsps(self):
    """
    Getter method for bypass_lsps, mapped from YANG variable /mpls_state/summary/bypass_lsps (uint32)

    YANG Description: Bypass LSPs
    """
    return self.__bypass_lsps
      
  def _set_bypass_lsps(self, v, load=False):
    """
    Setter method for bypass_lsps, mapped from YANG variable /mpls_state/summary/bypass_lsps (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsps() directly.

    YANG Description: Bypass LSPs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bypass-lsps", rest_name="bypass-lsps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsps must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bypass-lsps", rest_name="bypass-lsps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__bypass_lsps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsps(self):
    self.__bypass_lsps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bypass-lsps", rest_name="bypass-lsps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_bypass_lsps_up(self):
    """
    Getter method for bypass_lsps_up, mapped from YANG variable /mpls_state/summary/bypass_lsps_up (uint32)

    YANG Description: Bypass LSPs UP
    """
    return self.__bypass_lsps_up
      
  def _set_bypass_lsps_up(self, v, load=False):
    """
    Setter method for bypass_lsps_up, mapped from YANG variable /mpls_state/summary/bypass_lsps_up (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsps_up is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsps_up() directly.

    YANG Description: Bypass LSPs UP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bypass-lsps-up", rest_name="bypass-lsps-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsps_up must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bypass-lsps-up", rest_name="bypass-lsps-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__bypass_lsps_up = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsps_up(self):
    self.__bypass_lsps_up = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bypass-lsps-up", rest_name="bypass-lsps-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_bypass_lsps_enabled(self):
    """
    Getter method for bypass_lsps_enabled, mapped from YANG variable /mpls_state/summary/bypass_lsps_enabled (uint32)

    YANG Description: Bypass LSPs enabled
    """
    return self.__bypass_lsps_enabled
      
  def _set_bypass_lsps_enabled(self, v, load=False):
    """
    Setter method for bypass_lsps_enabled, mapped from YANG variable /mpls_state/summary/bypass_lsps_enabled (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsps_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsps_enabled() directly.

    YANG Description: Bypass LSPs enabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bypass-lsps-enabled", rest_name="bypass-lsps-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsps_enabled must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bypass-lsps-enabled", rest_name="bypass-lsps-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__bypass_lsps_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsps_enabled(self):
    self.__bypass_lsps_enabled = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bypass-lsps-enabled", rest_name="bypass-lsps-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_ldp_lsps_operational(self):
    """
    Getter method for ldp_lsps_operational, mapped from YANG variable /mpls_state/summary/ldp_lsps_operational (uint32)

    YANG Description: LDP LSPs operational
    """
    return self.__ldp_lsps_operational
      
  def _set_ldp_lsps_operational(self, v, load=False):
    """
    Setter method for ldp_lsps_operational, mapped from YANG variable /mpls_state/summary/ldp_lsps_operational (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_lsps_operational is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_lsps_operational() directly.

    YANG Description: LDP LSPs operational
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ldp-lsps-operational", rest_name="ldp-lsps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_lsps_operational must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ldp-lsps-operational", rest_name="ldp-lsps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__ldp_lsps_operational = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_lsps_operational(self):
    self.__ldp_lsps_operational = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ldp-lsps-operational", rest_name="ldp-lsps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_transit_lsps_configured(self):
    """
    Getter method for transit_lsps_configured, mapped from YANG variable /mpls_state/summary/transit_lsps_configured (uint32)

    YANG Description: Transit LSPs configured
    """
    return self.__transit_lsps_configured
      
  def _set_transit_lsps_configured(self, v, load=False):
    """
    Setter method for transit_lsps_configured, mapped from YANG variable /mpls_state/summary/transit_lsps_configured (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transit_lsps_configured is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transit_lsps_configured() directly.

    YANG Description: Transit LSPs configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-lsps-configured", rest_name="transit-lsps-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transit_lsps_configured must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-lsps-configured", rest_name="transit-lsps-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__transit_lsps_configured = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transit_lsps_configured(self):
    self.__transit_lsps_configured = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-lsps-configured", rest_name="transit-lsps-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_transit_lsps_enabled(self):
    """
    Getter method for transit_lsps_enabled, mapped from YANG variable /mpls_state/summary/transit_lsps_enabled (uint32)

    YANG Description: Transit LSPs enabled
    """
    return self.__transit_lsps_enabled
      
  def _set_transit_lsps_enabled(self, v, load=False):
    """
    Setter method for transit_lsps_enabled, mapped from YANG variable /mpls_state/summary/transit_lsps_enabled (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transit_lsps_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transit_lsps_enabled() directly.

    YANG Description: Transit LSPs enabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-lsps-enabled", rest_name="transit-lsps-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transit_lsps_enabled must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-lsps-enabled", rest_name="transit-lsps-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__transit_lsps_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transit_lsps_enabled(self):
    self.__transit_lsps_enabled = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-lsps-enabled", rest_name="transit-lsps-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_transit_lsps_operational(self):
    """
    Getter method for transit_lsps_operational, mapped from YANG variable /mpls_state/summary/transit_lsps_operational (uint32)

    YANG Description: Transit LSPs operational
    """
    return self.__transit_lsps_operational
      
  def _set_transit_lsps_operational(self, v, load=False):
    """
    Setter method for transit_lsps_operational, mapped from YANG variable /mpls_state/summary/transit_lsps_operational (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transit_lsps_operational is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transit_lsps_operational() directly.

    YANG Description: Transit LSPs operational
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-lsps-operational", rest_name="transit-lsps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transit_lsps_operational must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-lsps-operational", rest_name="transit-lsps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__transit_lsps_operational = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transit_lsps_operational(self):
    self.__transit_lsps_operational = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-lsps-operational", rest_name="transit-lsps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_cspf_groups_configured(self):
    """
    Getter method for cspf_groups_configured, mapped from YANG variable /mpls_state/summary/cspf_groups_configured (uint32)

    YANG Description: CSPF groups configured
    """
    return self.__cspf_groups_configured
      
  def _set_cspf_groups_configured(self, v, load=False):
    """
    Setter method for cspf_groups_configured, mapped from YANG variable /mpls_state/summary/cspf_groups_configured (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cspf_groups_configured is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cspf_groups_configured() directly.

    YANG Description: CSPF groups configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cspf-groups-configured", rest_name="cspf-groups-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cspf_groups_configured must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cspf-groups-configured", rest_name="cspf-groups-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__cspf_groups_configured = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cspf_groups_configured(self):
    self.__cspf_groups_configured = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cspf-groups-configured", rest_name="cspf-groups-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_tunnels_supported(self):
    """
    Getter method for tunnels_supported, mapped from YANG variable /mpls_state/summary/tunnels_supported (uint32)

    YANG Description: Tunnels supported
    """
    return self.__tunnels_supported
      
  def _set_tunnels_supported(self, v, load=False):
    """
    Setter method for tunnels_supported, mapped from YANG variable /mpls_state/summary/tunnels_supported (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnels_supported is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnels_supported() directly.

    YANG Description: Tunnels supported
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnels-supported", rest_name="tunnels-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnels_supported must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnels-supported", rest_name="tunnels-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__tunnels_supported = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnels_supported(self):
    self.__tunnels_supported = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnels-supported", rest_name="tunnels-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_tunnels_allocated(self):
    """
    Getter method for tunnels_allocated, mapped from YANG variable /mpls_state/summary/tunnels_allocated (uint32)

    YANG Description: Tunnels allocated
    """
    return self.__tunnels_allocated
      
  def _set_tunnels_allocated(self, v, load=False):
    """
    Setter method for tunnels_allocated, mapped from YANG variable /mpls_state/summary/tunnels_allocated (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnels_allocated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnels_allocated() directly.

    YANG Description: Tunnels allocated
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnels-allocated", rest_name="tunnels-allocated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnels_allocated must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnels-allocated", rest_name="tunnels-allocated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__tunnels_allocated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnels_allocated(self):
    self.__tunnels_allocated = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnels-allocated", rest_name="tunnels-allocated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_cross_connects_supported(self):
    """
    Getter method for cross_connects_supported, mapped from YANG variable /mpls_state/summary/cross_connects_supported (uint32)

    YANG Description: Cross Connects supported
    """
    return self.__cross_connects_supported
      
  def _set_cross_connects_supported(self, v, load=False):
    """
    Setter method for cross_connects_supported, mapped from YANG variable /mpls_state/summary/cross_connects_supported (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cross_connects_supported is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cross_connects_supported() directly.

    YANG Description: Cross Connects supported
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cross-connects-supported", rest_name="cross-connects-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cross_connects_supported must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cross-connects-supported", rest_name="cross-connects-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__cross_connects_supported = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cross_connects_supported(self):
    self.__cross_connects_supported = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cross-connects-supported", rest_name="cross-connects-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_cross_connects_allocated(self):
    """
    Getter method for cross_connects_allocated, mapped from YANG variable /mpls_state/summary/cross_connects_allocated (uint32)

    YANG Description: Cross Connects allocated
    """
    return self.__cross_connects_allocated
      
  def _set_cross_connects_allocated(self, v, load=False):
    """
    Setter method for cross_connects_allocated, mapped from YANG variable /mpls_state/summary/cross_connects_allocated (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cross_connects_allocated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cross_connects_allocated() directly.

    YANG Description: Cross Connects allocated
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cross-connects-allocated", rest_name="cross-connects-allocated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cross_connects_allocated must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cross-connects-allocated", rest_name="cross-connects-allocated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__cross_connects_allocated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cross_connects_allocated(self):
    self.__cross_connects_allocated = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cross-connects-allocated", rest_name="cross-connects-allocated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_auto_bw_templates_supported(self):
    """
    Getter method for auto_bw_templates_supported, mapped from YANG variable /mpls_state/summary/auto_bw_templates_supported (uint32)

    YANG Description: Auto bandwidth templates supported
    """
    return self.__auto_bw_templates_supported
      
  def _set_auto_bw_templates_supported(self, v, load=False):
    """
    Setter method for auto_bw_templates_supported, mapped from YANG variable /mpls_state/summary/auto_bw_templates_supported (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_bw_templates_supported is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_bw_templates_supported() directly.

    YANG Description: Auto bandwidth templates supported
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auto-bw-templates-supported", rest_name="auto-bw-templates-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_bw_templates_supported must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auto-bw-templates-supported", rest_name="auto-bw-templates-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__auto_bw_templates_supported = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_bw_templates_supported(self):
    self.__auto_bw_templates_supported = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auto-bw-templates-supported", rest_name="auto-bw-templates-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_auto_bw_templates_configured(self):
    """
    Getter method for auto_bw_templates_configured, mapped from YANG variable /mpls_state/summary/auto_bw_templates_configured (uint32)

    YANG Description: Auto bandwidth templates configured
    """
    return self.__auto_bw_templates_configured
      
  def _set_auto_bw_templates_configured(self, v, load=False):
    """
    Setter method for auto_bw_templates_configured, mapped from YANG variable /mpls_state/summary/auto_bw_templates_configured (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_bw_templates_configured is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_bw_templates_configured() directly.

    YANG Description: Auto bandwidth templates configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auto-bw-templates-configured", rest_name="auto-bw-templates-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_bw_templates_configured must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auto-bw-templates-configured", rest_name="auto-bw-templates-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__auto_bw_templates_configured = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_bw_templates_configured(self):
    self.__auto_bw_templates_configured = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auto-bw-templates-configured", rest_name="auto-bw-templates-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_times_enabled(self):
    """
    Getter method for times_enabled, mapped from YANG variable /mpls_state/summary/times_enabled (uint32)

    YANG Description: Number of times MPLS has been enabled
    """
    return self.__times_enabled
      
  def _set_times_enabled(self, v, load=False):
    """
    Setter method for times_enabled, mapped from YANG variable /mpls_state/summary/times_enabled (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_times_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_times_enabled() directly.

    YANG Description: Number of times MPLS has been enabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="times-enabled", rest_name="times-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """times_enabled must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="times-enabled", rest_name="times-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__times_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_times_enabled(self):
    self.__times_enabled = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="times-enabled", rest_name="times-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)

  paths_configured = __builtin__.property(_get_paths_configured)
  lsps_configured = __builtin__.property(_get_lsps_configured)
  lsps_enabled = __builtin__.property(_get_lsps_enabled)
  lsps_operational = __builtin__.property(_get_lsps_operational)
  detour_lsps_up = __builtin__.property(_get_detour_lsps_up)
  backup_lsps_up = __builtin__.property(_get_backup_lsps_up)
  bypass_lsps = __builtin__.property(_get_bypass_lsps)
  bypass_lsps_up = __builtin__.property(_get_bypass_lsps_up)
  bypass_lsps_enabled = __builtin__.property(_get_bypass_lsps_enabled)
  ldp_lsps_operational = __builtin__.property(_get_ldp_lsps_operational)
  transit_lsps_configured = __builtin__.property(_get_transit_lsps_configured)
  transit_lsps_enabled = __builtin__.property(_get_transit_lsps_enabled)
  transit_lsps_operational = __builtin__.property(_get_transit_lsps_operational)
  cspf_groups_configured = __builtin__.property(_get_cspf_groups_configured)
  tunnels_supported = __builtin__.property(_get_tunnels_supported)
  tunnels_allocated = __builtin__.property(_get_tunnels_allocated)
  cross_connects_supported = __builtin__.property(_get_cross_connects_supported)
  cross_connects_allocated = __builtin__.property(_get_cross_connects_allocated)
  auto_bw_templates_supported = __builtin__.property(_get_auto_bw_templates_supported)
  auto_bw_templates_configured = __builtin__.property(_get_auto_bw_templates_configured)
  times_enabled = __builtin__.property(_get_times_enabled)


  _pyangbind_elements = {'paths_configured': paths_configured, 'lsps_configured': lsps_configured, 'lsps_enabled': lsps_enabled, 'lsps_operational': lsps_operational, 'detour_lsps_up': detour_lsps_up, 'backup_lsps_up': backup_lsps_up, 'bypass_lsps': bypass_lsps, 'bypass_lsps_up': bypass_lsps_up, 'bypass_lsps_enabled': bypass_lsps_enabled, 'ldp_lsps_operational': ldp_lsps_operational, 'transit_lsps_configured': transit_lsps_configured, 'transit_lsps_enabled': transit_lsps_enabled, 'transit_lsps_operational': transit_lsps_operational, 'cspf_groups_configured': cspf_groups_configured, 'tunnels_supported': tunnels_supported, 'tunnels_allocated': tunnels_allocated, 'cross_connects_supported': cross_connects_supported, 'cross_connects_allocated': cross_connects_allocated, 'auto_bw_templates_supported': auto_bw_templates_supported, 'auto_bw_templates_configured': auto_bw_templates_configured, 'times_enabled': times_enabled, }


