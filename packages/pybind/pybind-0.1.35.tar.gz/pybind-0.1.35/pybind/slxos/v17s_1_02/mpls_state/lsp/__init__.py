
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import basic
import forwarding
import frr
import backup
import instances
import secondary_path
class lsp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls-operational - based on the path /mpls-state/lsp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: MPLS LSP operational information
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__lsp_name','__lsp_type','__bypass_lsp_type','__interface','__history','__basic','__forwarding','__frr','__backup','__instances','__secondary_path',)

  _yang_name = 'lsp'
  _rest_name = 'lsp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__instances = YANGDynClass(base=YANGListType("instance_id lsp_id",instances.instances, yang_name="instances", rest_name="instances", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='instance-id lsp-id', extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-instance', u'cli-suppress-show-path': None}}), is_container='list', yang_name="instances", rest_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-instance', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__bypass_lsp_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dynamic-bypass': {'value': 2}, u'static-bypass': {'value': 1}},), is_leaf=True, yang_name="bypass-lsp-type", rest_name="bypass-lsp-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='bypass-lsp-type', is_config=False)
    self.__lsp_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="lsp-name", rest_name="lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__lsp_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'regular': {'value': 1}, u'bypass': {'value': 2}},), is_leaf=True, yang_name="lsp-type", rest_name="lsp-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='lsp-type', is_config=False)
    self.__frr = YANGDynClass(base=frr.frr, is_container='container', presence=False, yang_name="frr", rest_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-frr', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    self.__basic = YANGDynClass(base=basic.basic, is_container='container', presence=False, yang_name="basic", rest_name="basic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-basic', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    self.__interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__forwarding = YANGDynClass(base=forwarding.forwarding, is_container='container', presence=False, yang_name="forwarding", rest_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-forwarding', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    self.__backup = YANGDynClass(base=backup.backup, is_container='container', presence=False, yang_name="backup", rest_name="backup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-backup', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    self.__secondary_path = YANGDynClass(base=YANGListType("path_name",secondary_path.secondary_path, yang_name="secondary-path", rest_name="secondary-path", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='path-name', extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-sec-path', u'cli-suppress-show-path': None}}), is_container='list', yang_name="secondary-path", rest_name="secondary-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-sec-path', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__history = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="history", rest_name="history", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mpls-state', u'lsp']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'mpls-state', u'lsp']

  def _get_lsp_name(self):
    """
    Getter method for lsp_name, mapped from YANG variable /mpls_state/lsp/lsp_name (string)

    YANG Description: LSP Name
    """
    return self.__lsp_name
      
  def _set_lsp_name(self, v, load=False):
    """
    Setter method for lsp_name, mapped from YANG variable /mpls_state/lsp/lsp_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_name() directly.

    YANG Description: LSP Name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="lsp-name", rest_name="lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="lsp-name", rest_name="lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__lsp_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_name(self):
    self.__lsp_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="lsp-name", rest_name="lsp-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_lsp_type(self):
    """
    Getter method for lsp_type, mapped from YANG variable /mpls_state/lsp/lsp_type (lsp-type)

    YANG Description: LSP Type
    """
    return self.__lsp_type
      
  def _set_lsp_type(self, v, load=False):
    """
    Setter method for lsp_type, mapped from YANG variable /mpls_state/lsp/lsp_type (lsp-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_type() directly.

    YANG Description: LSP Type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'regular': {'value': 1}, u'bypass': {'value': 2}},), is_leaf=True, yang_name="lsp-type", rest_name="lsp-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='lsp-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_type must be of a type compatible with lsp-type""",
          'defined-type': "brocade-mpls-operational:lsp-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'regular': {'value': 1}, u'bypass': {'value': 2}},), is_leaf=True, yang_name="lsp-type", rest_name="lsp-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='lsp-type', is_config=False)""",
        })

    self.__lsp_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_type(self):
    self.__lsp_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'regular': {'value': 1}, u'bypass': {'value': 2}},), is_leaf=True, yang_name="lsp-type", rest_name="lsp-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='lsp-type', is_config=False)


  def _get_bypass_lsp_type(self):
    """
    Getter method for bypass_lsp_type, mapped from YANG variable /mpls_state/lsp/bypass_lsp_type (bypass-lsp-type)

    YANG Description: Bypass LSP Type
    """
    return self.__bypass_lsp_type
      
  def _set_bypass_lsp_type(self, v, load=False):
    """
    Setter method for bypass_lsp_type, mapped from YANG variable /mpls_state/lsp/bypass_lsp_type (bypass-lsp-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_lsp_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_lsp_type() directly.

    YANG Description: Bypass LSP Type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dynamic-bypass': {'value': 2}, u'static-bypass': {'value': 1}},), is_leaf=True, yang_name="bypass-lsp-type", rest_name="bypass-lsp-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='bypass-lsp-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_lsp_type must be of a type compatible with bypass-lsp-type""",
          'defined-type': "brocade-mpls-operational:bypass-lsp-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dynamic-bypass': {'value': 2}, u'static-bypass': {'value': 1}},), is_leaf=True, yang_name="bypass-lsp-type", rest_name="bypass-lsp-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='bypass-lsp-type', is_config=False)""",
        })

    self.__bypass_lsp_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_lsp_type(self):
    self.__bypass_lsp_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dynamic-bypass': {'value': 2}, u'static-bypass': {'value': 1}},), is_leaf=True, yang_name="bypass-lsp-type", rest_name="bypass-lsp-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='bypass-lsp-type', is_config=False)


  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /mpls_state/lsp/interface (string)

    YANG Description: Bypass LSP interface
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /mpls_state/lsp/interface (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Bypass LSP interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_history(self):
    """
    Getter method for history, mapped from YANG variable /mpls_state/lsp/history (string)

    YANG Description: MPLS LSP history Information
    """
    return self.__history
      
  def _set_history(self, v, load=False):
    """
    Setter method for history, mapped from YANG variable /mpls_state/lsp/history (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_history is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_history() directly.

    YANG Description: MPLS LSP history Information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="history", rest_name="history", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """history must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="history", rest_name="history", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__history = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_history(self):
    self.__history = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="history", rest_name="history", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_basic(self):
    """
    Getter method for basic, mapped from YANG variable /mpls_state/lsp/basic (container)

    YANG Description: MPLS basic LSP operational information
    """
    return self.__basic
      
  def _set_basic(self, v, load=False):
    """
    Setter method for basic, mapped from YANG variable /mpls_state/lsp/basic (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_basic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_basic() directly.

    YANG Description: MPLS basic LSP operational information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=basic.basic, is_container='container', presence=False, yang_name="basic", rest_name="basic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-basic', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """basic must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=basic.basic, is_container='container', presence=False, yang_name="basic", rest_name="basic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-basic', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)""",
        })

    self.__basic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_basic(self):
    self.__basic = YANGDynClass(base=basic.basic, is_container='container', presence=False, yang_name="basic", rest_name="basic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-basic', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)


  def _get_forwarding(self):
    """
    Getter method for forwarding, mapped from YANG variable /mpls_state/lsp/forwarding (container)

    YANG Description: MPLS LSP forwarding information
    """
    return self.__forwarding
      
  def _set_forwarding(self, v, load=False):
    """
    Setter method for forwarding, mapped from YANG variable /mpls_state/lsp/forwarding (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_forwarding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_forwarding() directly.

    YANG Description: MPLS LSP forwarding information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=forwarding.forwarding, is_container='container', presence=False, yang_name="forwarding", rest_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-forwarding', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """forwarding must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=forwarding.forwarding, is_container='container', presence=False, yang_name="forwarding", rest_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-forwarding', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)""",
        })

    self.__forwarding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_forwarding(self):
    self.__forwarding = YANGDynClass(base=forwarding.forwarding, is_container='container', presence=False, yang_name="forwarding", rest_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-forwarding', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)


  def _get_frr(self):
    """
    Getter method for frr, mapped from YANG variable /mpls_state/lsp/frr (container)

    YANG Description: MPLS LSP FRR information
    """
    return self.__frr
      
  def _set_frr(self, v, load=False):
    """
    Setter method for frr, mapped from YANG variable /mpls_state/lsp/frr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frr() directly.

    YANG Description: MPLS LSP FRR information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=frr.frr, is_container='container', presence=False, yang_name="frr", rest_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-frr', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=frr.frr, is_container='container', presence=False, yang_name="frr", rest_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-frr', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)""",
        })

    self.__frr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frr(self):
    self.__frr = YANGDynClass(base=frr.frr, is_container='container', presence=False, yang_name="frr", rest_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-frr', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)


  def _get_backup(self):
    """
    Getter method for backup, mapped from YANG variable /mpls_state/lsp/backup (container)

    YANG Description: MPLS LSP detail backup information
    """
    return self.__backup
      
  def _set_backup(self, v, load=False):
    """
    Setter method for backup, mapped from YANG variable /mpls_state/lsp/backup (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_backup is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_backup() directly.

    YANG Description: MPLS LSP detail backup information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=backup.backup, is_container='container', presence=False, yang_name="backup", rest_name="backup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-backup', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """backup must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=backup.backup, is_container='container', presence=False, yang_name="backup", rest_name="backup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-backup', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)""",
        })

    self.__backup = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_backup(self):
    self.__backup = YANGDynClass(base=backup.backup, is_container='container', presence=False, yang_name="backup", rest_name="backup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-backup', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)


  def _get_instances(self):
    """
    Getter method for instances, mapped from YANG variable /mpls_state/lsp/instances (list)

    YANG Description: MPLS LSP instancses information
    """
    return self.__instances
      
  def _set_instances(self, v, load=False):
    """
    Setter method for instances, mapped from YANG variable /mpls_state/lsp/instances (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instances() directly.

    YANG Description: MPLS LSP instancses information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("instance_id lsp_id",instances.instances, yang_name="instances", rest_name="instances", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='instance-id lsp-id', extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-instance', u'cli-suppress-show-path': None}}), is_container='list', yang_name="instances", rest_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-instance', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instances must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("instance_id lsp_id",instances.instances, yang_name="instances", rest_name="instances", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='instance-id lsp-id', extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-instance', u'cli-suppress-show-path': None}}), is_container='list', yang_name="instances", rest_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-instance', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__instances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instances(self):
    self.__instances = YANGDynClass(base=YANGListType("instance_id lsp_id",instances.instances, yang_name="instances", rest_name="instances", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='instance-id lsp-id', extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-instance', u'cli-suppress-show-path': None}}), is_container='list', yang_name="instances", rest_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-instance', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)


  def _get_secondary_path(self):
    """
    Getter method for secondary_path, mapped from YANG variable /mpls_state/lsp/secondary_path (list)

    YANG Description: MPLS LSP secondary path information
    """
    return self.__secondary_path
      
  def _set_secondary_path(self, v, load=False):
    """
    Setter method for secondary_path, mapped from YANG variable /mpls_state/lsp/secondary_path (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_path() directly.

    YANG Description: MPLS LSP secondary path information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("path_name",secondary_path.secondary_path, yang_name="secondary-path", rest_name="secondary-path", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='path-name', extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-sec-path', u'cli-suppress-show-path': None}}), is_container='list', yang_name="secondary-path", rest_name="secondary-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-sec-path', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary_path must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("path_name",secondary_path.secondary_path, yang_name="secondary-path", rest_name="secondary-path", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='path-name', extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-sec-path', u'cli-suppress-show-path': None}}), is_container='list', yang_name="secondary-path", rest_name="secondary-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-sec-path', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__secondary_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary_path(self):
    self.__secondary_path = YANGDynClass(base=YANGListType("path_name",secondary_path.secondary_path, yang_name="secondary-path", rest_name="secondary-path", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='path-name', extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-sec-path', u'cli-suppress-show-path': None}}), is_container='list', yang_name="secondary-path", rest_name="secondary-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-lsp-sec-path', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)

  lsp_name = __builtin__.property(_get_lsp_name)
  lsp_type = __builtin__.property(_get_lsp_type)
  bypass_lsp_type = __builtin__.property(_get_bypass_lsp_type)
  interface = __builtin__.property(_get_interface)
  history = __builtin__.property(_get_history)
  basic = __builtin__.property(_get_basic)
  forwarding = __builtin__.property(_get_forwarding)
  frr = __builtin__.property(_get_frr)
  backup = __builtin__.property(_get_backup)
  instances = __builtin__.property(_get_instances)
  secondary_path = __builtin__.property(_get_secondary_path)


  _pyangbind_elements = {'lsp_name': lsp_name, 'lsp_type': lsp_type, 'bypass_lsp_type': bypass_lsp_type, 'interface': interface, 'history': history, 'basic': basic, 'forwarding': forwarding, 'frr': frr, 'backup': backup, 'instances': instances, 'secondary_path': secondary_path, }


