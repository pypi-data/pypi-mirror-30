
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class tagged_ports_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-nsm-operational - based on the path /bridge-domain-state/bridge-domain-list/outer-vlan-list/tagged-ports-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: untagged_port_list
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__lif_name','__lif_ifindex','__lif_main_intf_type','__outer_vlan','__inner_vlan','__flags','__ivid','__encap_id','__ingress_stats_id','__egress_stats_id','__op_state','__service_instance',)

  _yang_name = 'tagged-ports-list'
  _rest_name = 'tagged-ports-list'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__service_instance = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="service-instance", rest_name="service-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__inner_vlan = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inner-vlan", rest_name="inner-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__op_state = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="op-state", rest_name="op-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    self.__lif_ifindex = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lif-ifindex", rest_name="lif-ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__lif_main_intf_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'nsm-dcm-lif-main-intf-type-pw': {'value': 5}, u'nsm-dcm-lif-main-intf-type-lag': {'value': 2}, u'nsm-dcm-lif-main-intf-type-phy': {'value': 1}, u'nsm-dcm-lif-main-intf-type-tunnel-l2gre': {'value': 4}, u'nsm-dcm-lif-main-intf-type-unknown': {'value': 0}, u'nsm-dcm-lif-main-intf-type-tunnel-vxlan': {'value': 3}},), is_leaf=True, yang_name="lif-main-intf-type", rest_name="lif-main-intf-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='nsm-dcm-lif-main-intf-type', is_config=False)
    self.__lif_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="lif-name", rest_name="lif-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='string', is_config=False)
    self.__encap_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="encap-id", rest_name="encap-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__ingress_stats_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ingress-stats-id", rest_name="ingress-stats-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__flags = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="flags", rest_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__outer_vlan = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="outer-vlan", rest_name="outer-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__egress_stats_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="egress-stats-id", rest_name="egress-stats-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__ivid = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ivid", rest_name="ivid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'bridge-domain-state', u'bridge-domain-list', u'outer-vlan-list', u'tagged-ports-list']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'bridge-domain-state', u'bridge-domain-list', u'outer-vlan-list', u'tagged-ports-list']

  def _get_lif_name(self):
    """
    Getter method for lif_name, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/lif_name (string)

    YANG Description: lif_name
    """
    return self.__lif_name
      
  def _set_lif_name(self, v, load=False):
    """
    Setter method for lif_name, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/lif_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lif_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lif_name() directly.

    YANG Description: lif_name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="lif-name", rest_name="lif-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lif_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="lif-name", rest_name="lif-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='string', is_config=False)""",
        })

    self.__lif_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lif_name(self):
    self.__lif_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="lif-name", rest_name="lif-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='string', is_config=False)


  def _get_lif_ifindex(self):
    """
    Getter method for lif_ifindex, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/lif_ifindex (uint32)

    YANG Description: lif_ifindex
    """
    return self.__lif_ifindex
      
  def _set_lif_ifindex(self, v, load=False):
    """
    Setter method for lif_ifindex, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/lif_ifindex (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lif_ifindex is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lif_ifindex() directly.

    YANG Description: lif_ifindex
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lif-ifindex", rest_name="lif-ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lif_ifindex must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lif-ifindex", rest_name="lif-ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__lif_ifindex = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lif_ifindex(self):
    self.__lif_ifindex = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lif-ifindex", rest_name="lif-ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_lif_main_intf_type(self):
    """
    Getter method for lif_main_intf_type, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/lif_main_intf_type (nsm-dcm-lif-main-intf-type)

    YANG Description: LIF Main interface type
    """
    return self.__lif_main_intf_type
      
  def _set_lif_main_intf_type(self, v, load=False):
    """
    Setter method for lif_main_intf_type, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/lif_main_intf_type (nsm-dcm-lif-main-intf-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lif_main_intf_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lif_main_intf_type() directly.

    YANG Description: LIF Main interface type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'nsm-dcm-lif-main-intf-type-pw': {'value': 5}, u'nsm-dcm-lif-main-intf-type-lag': {'value': 2}, u'nsm-dcm-lif-main-intf-type-phy': {'value': 1}, u'nsm-dcm-lif-main-intf-type-tunnel-l2gre': {'value': 4}, u'nsm-dcm-lif-main-intf-type-unknown': {'value': 0}, u'nsm-dcm-lif-main-intf-type-tunnel-vxlan': {'value': 3}},), is_leaf=True, yang_name="lif-main-intf-type", rest_name="lif-main-intf-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='nsm-dcm-lif-main-intf-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lif_main_intf_type must be of a type compatible with nsm-dcm-lif-main-intf-type""",
          'defined-type': "brocade-nsm-operational:nsm-dcm-lif-main-intf-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'nsm-dcm-lif-main-intf-type-pw': {'value': 5}, u'nsm-dcm-lif-main-intf-type-lag': {'value': 2}, u'nsm-dcm-lif-main-intf-type-phy': {'value': 1}, u'nsm-dcm-lif-main-intf-type-tunnel-l2gre': {'value': 4}, u'nsm-dcm-lif-main-intf-type-unknown': {'value': 0}, u'nsm-dcm-lif-main-intf-type-tunnel-vxlan': {'value': 3}},), is_leaf=True, yang_name="lif-main-intf-type", rest_name="lif-main-intf-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='nsm-dcm-lif-main-intf-type', is_config=False)""",
        })

    self.__lif_main_intf_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lif_main_intf_type(self):
    self.__lif_main_intf_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'nsm-dcm-lif-main-intf-type-pw': {'value': 5}, u'nsm-dcm-lif-main-intf-type-lag': {'value': 2}, u'nsm-dcm-lif-main-intf-type-phy': {'value': 1}, u'nsm-dcm-lif-main-intf-type-tunnel-l2gre': {'value': 4}, u'nsm-dcm-lif-main-intf-type-unknown': {'value': 0}, u'nsm-dcm-lif-main-intf-type-tunnel-vxlan': {'value': 3}},), is_leaf=True, yang_name="lif-main-intf-type", rest_name="lif-main-intf-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='nsm-dcm-lif-main-intf-type', is_config=False)


  def _get_outer_vlan(self):
    """
    Getter method for outer_vlan, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/outer_vlan (uint32)

    YANG Description: outer_tag_value
    """
    return self.__outer_vlan
      
  def _set_outer_vlan(self, v, load=False):
    """
    Setter method for outer_vlan, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/outer_vlan (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_vlan() directly.

    YANG Description: outer_tag_value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="outer-vlan", rest_name="outer-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_vlan must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="outer-vlan", rest_name="outer-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__outer_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_vlan(self):
    self.__outer_vlan = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="outer-vlan", rest_name="outer-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_inner_vlan(self):
    """
    Getter method for inner_vlan, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/inner_vlan (uint32)

    YANG Description: inner_tag_value
    """
    return self.__inner_vlan
      
  def _set_inner_vlan(self, v, load=False):
    """
    Setter method for inner_vlan, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/inner_vlan (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_vlan() directly.

    YANG Description: inner_tag_value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inner-vlan", rest_name="inner-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_vlan must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inner-vlan", rest_name="inner-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__inner_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_vlan(self):
    self.__inner_vlan = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inner-vlan", rest_name="inner-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_flags(self):
    """
    Getter method for flags, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/flags (uint32)

    YANG Description: flags
    """
    return self.__flags
      
  def _set_flags(self, v, load=False):
    """
    Setter method for flags, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/flags (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flags is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flags() directly.

    YANG Description: flags
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="flags", rest_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flags must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="flags", rest_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__flags = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flags(self):
    self.__flags = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="flags", rest_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_ivid(self):
    """
    Getter method for ivid, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/ivid (uint32)

    YANG Description: ivid
    """
    return self.__ivid
      
  def _set_ivid(self, v, load=False):
    """
    Setter method for ivid, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/ivid (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ivid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ivid() directly.

    YANG Description: ivid
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ivid", rest_name="ivid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ivid must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ivid", rest_name="ivid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__ivid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ivid(self):
    self.__ivid = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ivid", rest_name="ivid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_encap_id(self):
    """
    Getter method for encap_id, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/encap_id (uint32)

    YANG Description: encap_id
    """
    return self.__encap_id
      
  def _set_encap_id(self, v, load=False):
    """
    Setter method for encap_id, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/encap_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encap_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encap_id() directly.

    YANG Description: encap_id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="encap-id", rest_name="encap-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encap_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="encap-id", rest_name="encap-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__encap_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encap_id(self):
    self.__encap_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="encap-id", rest_name="encap-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_ingress_stats_id(self):
    """
    Getter method for ingress_stats_id, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/ingress_stats_id (uint32)

    YANG Description: ingress_stats_id
    """
    return self.__ingress_stats_id
      
  def _set_ingress_stats_id(self, v, load=False):
    """
    Setter method for ingress_stats_id, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/ingress_stats_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ingress_stats_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ingress_stats_id() directly.

    YANG Description: ingress_stats_id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ingress-stats-id", rest_name="ingress-stats-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ingress_stats_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ingress-stats-id", rest_name="ingress-stats-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__ingress_stats_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ingress_stats_id(self):
    self.__ingress_stats_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ingress-stats-id", rest_name="ingress-stats-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_egress_stats_id(self):
    """
    Getter method for egress_stats_id, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/egress_stats_id (uint32)

    YANG Description: egress_stats_id
    """
    return self.__egress_stats_id
      
  def _set_egress_stats_id(self, v, load=False):
    """
    Setter method for egress_stats_id, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/egress_stats_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_egress_stats_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_egress_stats_id() directly.

    YANG Description: egress_stats_id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="egress-stats-id", rest_name="egress-stats-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """egress_stats_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="egress-stats-id", rest_name="egress-stats-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__egress_stats_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_egress_stats_id(self):
    self.__egress_stats_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="egress-stats-id", rest_name="egress-stats-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_op_state(self):
    """
    Getter method for op_state, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/op_state (boolean)

    YANG Description: op_state
    """
    return self.__op_state
      
  def _set_op_state(self, v, load=False):
    """
    Setter method for op_state, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/op_state (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_op_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_op_state() directly.

    YANG Description: op_state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="op-state", rest_name="op-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """op_state must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="op-state", rest_name="op-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)""",
        })

    self.__op_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_op_state(self):
    self.__op_state = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="op-state", rest_name="op-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)


  def _get_service_instance(self):
    """
    Getter method for service_instance, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/service_instance (uint32)

    YANG Description: service_instance
    """
    return self.__service_instance
      
  def _set_service_instance(self, v, load=False):
    """
    Setter method for service_instance, mapped from YANG variable /bridge_domain_state/bridge_domain_list/outer_vlan_list/tagged_ports_list/service_instance (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_instance() directly.

    YANG Description: service_instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="service-instance", rest_name="service-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_instance must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="service-instance", rest_name="service-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__service_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_instance(self):
    self.__service_instance = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="service-instance", rest_name="service-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)

  lif_name = __builtin__.property(_get_lif_name)
  lif_ifindex = __builtin__.property(_get_lif_ifindex)
  lif_main_intf_type = __builtin__.property(_get_lif_main_intf_type)
  outer_vlan = __builtin__.property(_get_outer_vlan)
  inner_vlan = __builtin__.property(_get_inner_vlan)
  flags = __builtin__.property(_get_flags)
  ivid = __builtin__.property(_get_ivid)
  encap_id = __builtin__.property(_get_encap_id)
  ingress_stats_id = __builtin__.property(_get_ingress_stats_id)
  egress_stats_id = __builtin__.property(_get_egress_stats_id)
  op_state = __builtin__.property(_get_op_state)
  service_instance = __builtin__.property(_get_service_instance)


  _pyangbind_elements = {'lif_name': lif_name, 'lif_ifindex': lif_ifindex, 'lif_main_intf_type': lif_main_intf_type, 'outer_vlan': outer_vlan, 'inner_vlan': inner_vlan, 'flags': flags, 'ivid': ivid, 'encap_id': encap_id, 'ingress_stats_id': ingress_stats_id, 'egress_stats_id': egress_stats_id, 'op_state': op_state, 'service_instance': service_instance, }


