
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import interface_int
import interface_eth
import interface_eth_leaf
import interface_mgmt
import interface_pc
import interface_pc_leaf
import interface_vlan
import interface_vlan_leaf
import interface_management_leaf
import interface_loopback
import interface_loopback_leaf
import interface_ve
import interface_ve_leaf
import interface_fc
import interface_fc_leaf
import copy_cp
import copy_running
import copy_support
import clear_cl
import clear_logging
import clear_support
import protocol_pr
import protocol_spanning
import protocol_lldp
class command(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-aaa - based on the path /rule/command. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__enumList','__interface_int','__interface_eth','__interface_eth_leaf','__interface_mgmt','__interface_pc','__interface_pc_leaf','__interface_vlan','__interface_vlan_leaf','__interface_management_leaf','__interface_loopback','__interface_loopback_leaf','__interface_ve','__interface_ve_leaf','__interface_fc','__interface_fc_leaf','__copy_cp','__copy_running','__copy_support','__clear_cl','__clear_logging','__clear_support','__protocol_pr','__protocol_spanning','__protocol_lldp',)

  _yang_name = 'command'
  _rest_name = 'command'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__protocol_lldp = YANGDynClass(base=protocol_lldp.protocol_lldp, is_container='container', presence=False, yang_name="protocol-lldp", rest_name="", parent=self, choice=(u'cmdlist', u'protocol-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__interface_loopback_leaf = YANGDynClass(base=interface_loopback_leaf.interface_loopback_leaf, is_container='container', presence=False, yang_name="interface-loopback-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-o'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__interface_fc = YANGDynClass(base=interface_fc.interface_fc, is_container='container', presence=False, yang_name="interface-fc", rest_name="", parent=self, choice=(u'cmdlist', u'interface-r'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__interface_vlan = YANGDynClass(base=interface_vlan.interface_vlan, is_container='container', presence=False, yang_name="interface-vlan", rest_name="", parent=self, choice=(u'cmdlist', u'interface-k'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__copy_cp = YANGDynClass(base=copy_cp.copy_cp, is_container='container', presence=False, yang_name="copy-cp", rest_name="", parent=self, choice=(u'cmdlist', u'copy-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__clear_cl = YANGDynClass(base=clear_cl.clear_cl, is_container='container', presence=False, yang_name="clear-cl", rest_name="", parent=self, choice=(u'cmdlist', u'clear-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__interface_eth = YANGDynClass(base=interface_eth.interface_eth, is_container='container', presence=False, yang_name="interface-eth", rest_name="", parent=self, choice=(u'cmdlist', u'interface-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__interface_loopback = YANGDynClass(base=interface_loopback.interface_loopback, is_container='container', presence=False, yang_name="interface-loopback", rest_name="", parent=self, choice=(u'cmdlist', u'interface-n'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__clear_logging = YANGDynClass(base=clear_logging.clear_logging, is_container='container', presence=False, yang_name="clear-logging", rest_name="", parent=self, choice=(u'cmdlist', u'clear-b'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__interface_management_leaf = YANGDynClass(base=interface_management_leaf.interface_management_leaf, is_container='container', presence=False, yang_name="interface-management-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-m'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__interface_vlan_leaf = YANGDynClass(base=interface_vlan_leaf.interface_vlan_leaf, is_container='container', presence=False, yang_name="interface-vlan-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-l'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__interface_fc_leaf = YANGDynClass(base=interface_fc_leaf.interface_fc_leaf, is_container='container', presence=False, yang_name="interface-fc-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-s'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__interface_int = YANGDynClass(base=interface_int.interface_int, is_container='container', presence=False, yang_name="interface-int", rest_name="", parent=self, choice=(u'cmdlist', u'interface-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__interface_ve_leaf = YANGDynClass(base=interface_ve_leaf.interface_ve_leaf, is_container='container', presence=False, yang_name="interface-ve-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-q'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__interface_pc_leaf = YANGDynClass(base=interface_pc_leaf.interface_pc_leaf, is_container='container', presence=False, yang_name="interface-pc-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-j'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__copy_support = YANGDynClass(base=copy_support.copy_support, is_container='container', presence=False, yang_name="copy-support", rest_name="", parent=self, choice=(u'cmdlist', u'copy-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__interface_mgmt = YANGDynClass(base=interface_mgmt.interface_mgmt, is_container='container', presence=False, yang_name="interface-mgmt", rest_name="", parent=self, choice=(u'cmdlist', u'interface-f'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__interface_eth_leaf = YANGDynClass(base=interface_eth_leaf.interface_eth_leaf, is_container='container', presence=False, yang_name="interface-eth-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-e'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__protocol_pr = YANGDynClass(base=protocol_pr.protocol_pr, is_container='container', presence=False, yang_name="protocol-pr", rest_name="", parent=self, choice=(u'cmdlist', u'protocol-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__protocol_spanning = YANGDynClass(base=protocol_spanning.protocol_spanning, is_container='container', presence=False, yang_name="protocol-spanning", rest_name="", parent=self, choice=(u'cmdlist', u'protocol-b'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__copy_running = YANGDynClass(base=copy_running.copy_running, is_container='container', presence=False, yang_name="copy-running", rest_name="", parent=self, choice=(u'cmdlist', u'copy-b'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__interface_pc = YANGDynClass(base=interface_pc.interface_pc, is_container='container', presence=False, yang_name="interface-pc", rest_name="", parent=self, choice=(u'cmdlist', u'interface-i'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__clear_support = YANGDynClass(base=clear_support.clear_support, is_container='container', presence=False, yang_name="clear-support", rest_name="", parent=self, choice=(u'cmdlist', u'clear-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    self.__enumList = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'system-monitor': {}, u'rename': {}, u'qos': {}, u'ip': {'value': 48}, u'switch-attributes': {'value': 55}, u'lacp': {}, u'unlock': {}, u'service': {}, u'tacacs-server': {}, u'mac-address-table': {}, u'terminal': {}, u'monitor': {}, u'fastboot': {}, u'snmp-server': {}, u'support': {}, u'firmware': {}, u'ldap-server': {}, u'radius-server': {}, u'prompt1': {}, u'python': {}, u'prompt2': {}, u'role': {}, u'alias-config': {}, u'protocol': {}, u'password-attributes': {}, u'username': {}, u'configure': {}, u'df': {}, u'ntp': {}, u'vlan': {}, u'telnet': {}, u'mac': {}, u'filter-change-update-delay': {}, u'ssh': {}, u'rmon': {}, u'logging': {}, u'no-operation': {}, u'banner': {}, u'usb': {}, u'cidrecov': {}, u'vrf': {}, u'aaa': {}, u'license': {}, u'sflow': {}, u'reload': {}, u'clock': {}, u'rule': {}, u'dot1x': {}, u'ipv6': {}, u'debug': {}, u'dir': {}, u'delete': {}},), is_leaf=True, yang_name="enumList", rest_name="enumList", parent=self, choice=(u'cmdlist', u'container-cmds'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='enumeration', is_config=True)
    self.__interface_ve = YANGDynClass(base=interface_ve.interface_ve, is_container='container', presence=False, yang_name="interface-ve", rest_name="", parent=self, choice=(u'cmdlist', u'interface-p'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'rule', u'command']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'rule', u'command']

  def _get_enumList(self):
    """
    Getter method for enumList, mapped from YANG variable /rule/command/enumList (enumeration)
    """
    return self.__enumList
      
  def _set_enumList(self, v, load=False):
    """
    Setter method for enumList, mapped from YANG variable /rule/command/enumList (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enumList is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enumList() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'system-monitor': {}, u'rename': {}, u'qos': {}, u'ip': {'value': 48}, u'switch-attributes': {'value': 55}, u'lacp': {}, u'unlock': {}, u'service': {}, u'tacacs-server': {}, u'mac-address-table': {}, u'terminal': {}, u'monitor': {}, u'fastboot': {}, u'snmp-server': {}, u'support': {}, u'firmware': {}, u'ldap-server': {}, u'radius-server': {}, u'prompt1': {}, u'python': {}, u'prompt2': {}, u'role': {}, u'alias-config': {}, u'protocol': {}, u'password-attributes': {}, u'username': {}, u'configure': {}, u'df': {}, u'ntp': {}, u'vlan': {}, u'telnet': {}, u'mac': {}, u'filter-change-update-delay': {}, u'ssh': {}, u'rmon': {}, u'logging': {}, u'no-operation': {}, u'banner': {}, u'usb': {}, u'cidrecov': {}, u'vrf': {}, u'aaa': {}, u'license': {}, u'sflow': {}, u'reload': {}, u'clock': {}, u'rule': {}, u'dot1x': {}, u'ipv6': {}, u'debug': {}, u'dir': {}, u'delete': {}},), is_leaf=True, yang_name="enumList", rest_name="enumList", parent=self, choice=(u'cmdlist', u'container-cmds'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enumList must be of a type compatible with enumeration""",
          'defined-type': "brocade-aaa:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'system-monitor': {}, u'rename': {}, u'qos': {}, u'ip': {'value': 48}, u'switch-attributes': {'value': 55}, u'lacp': {}, u'unlock': {}, u'service': {}, u'tacacs-server': {}, u'mac-address-table': {}, u'terminal': {}, u'monitor': {}, u'fastboot': {}, u'snmp-server': {}, u'support': {}, u'firmware': {}, u'ldap-server': {}, u'radius-server': {}, u'prompt1': {}, u'python': {}, u'prompt2': {}, u'role': {}, u'alias-config': {}, u'protocol': {}, u'password-attributes': {}, u'username': {}, u'configure': {}, u'df': {}, u'ntp': {}, u'vlan': {}, u'telnet': {}, u'mac': {}, u'filter-change-update-delay': {}, u'ssh': {}, u'rmon': {}, u'logging': {}, u'no-operation': {}, u'banner': {}, u'usb': {}, u'cidrecov': {}, u'vrf': {}, u'aaa': {}, u'license': {}, u'sflow': {}, u'reload': {}, u'clock': {}, u'rule': {}, u'dot1x': {}, u'ipv6': {}, u'debug': {}, u'dir': {}, u'delete': {}},), is_leaf=True, yang_name="enumList", rest_name="enumList", parent=self, choice=(u'cmdlist', u'container-cmds'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='enumeration', is_config=True)""",
        })

    self.__enumList = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enumList(self):
    self.__enumList = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'system-monitor': {}, u'rename': {}, u'qos': {}, u'ip': {'value': 48}, u'switch-attributes': {'value': 55}, u'lacp': {}, u'unlock': {}, u'service': {}, u'tacacs-server': {}, u'mac-address-table': {}, u'terminal': {}, u'monitor': {}, u'fastboot': {}, u'snmp-server': {}, u'support': {}, u'firmware': {}, u'ldap-server': {}, u'radius-server': {}, u'prompt1': {}, u'python': {}, u'prompt2': {}, u'role': {}, u'alias-config': {}, u'protocol': {}, u'password-attributes': {}, u'username': {}, u'configure': {}, u'df': {}, u'ntp': {}, u'vlan': {}, u'telnet': {}, u'mac': {}, u'filter-change-update-delay': {}, u'ssh': {}, u'rmon': {}, u'logging': {}, u'no-operation': {}, u'banner': {}, u'usb': {}, u'cidrecov': {}, u'vrf': {}, u'aaa': {}, u'license': {}, u'sflow': {}, u'reload': {}, u'clock': {}, u'rule': {}, u'dot1x': {}, u'ipv6': {}, u'debug': {}, u'dir': {}, u'delete': {}},), is_leaf=True, yang_name="enumList", rest_name="enumList", parent=self, choice=(u'cmdlist', u'container-cmds'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='enumeration', is_config=True)


  def _get_interface_int(self):
    """
    Getter method for interface_int, mapped from YANG variable /rule/command/interface_int (container)
    """
    return self.__interface_int
      
  def _set_interface_int(self, v, load=False):
    """
    Setter method for interface_int, mapped from YANG variable /rule/command/interface_int (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_int is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_int() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_int.interface_int, is_container='container', presence=False, yang_name="interface-int", rest_name="", parent=self, choice=(u'cmdlist', u'interface-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_int must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_int.interface_int, is_container='container', presence=False, yang_name="interface-int", rest_name="", parent=self, choice=(u'cmdlist', u'interface-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__interface_int = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_int(self):
    self.__interface_int = YANGDynClass(base=interface_int.interface_int, is_container='container', presence=False, yang_name="interface-int", rest_name="", parent=self, choice=(u'cmdlist', u'interface-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_interface_eth(self):
    """
    Getter method for interface_eth, mapped from YANG variable /rule/command/interface_eth (container)
    """
    return self.__interface_eth
      
  def _set_interface_eth(self, v, load=False):
    """
    Setter method for interface_eth, mapped from YANG variable /rule/command/interface_eth (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_eth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_eth() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_eth.interface_eth, is_container='container', presence=False, yang_name="interface-eth", rest_name="", parent=self, choice=(u'cmdlist', u'interface-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_eth must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_eth.interface_eth, is_container='container', presence=False, yang_name="interface-eth", rest_name="", parent=self, choice=(u'cmdlist', u'interface-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__interface_eth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_eth(self):
    self.__interface_eth = YANGDynClass(base=interface_eth.interface_eth, is_container='container', presence=False, yang_name="interface-eth", rest_name="", parent=self, choice=(u'cmdlist', u'interface-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_interface_eth_leaf(self):
    """
    Getter method for interface_eth_leaf, mapped from YANG variable /rule/command/interface_eth_leaf (container)
    """
    return self.__interface_eth_leaf
      
  def _set_interface_eth_leaf(self, v, load=False):
    """
    Setter method for interface_eth_leaf, mapped from YANG variable /rule/command/interface_eth_leaf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_eth_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_eth_leaf() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_eth_leaf.interface_eth_leaf, is_container='container', presence=False, yang_name="interface-eth-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-e'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_eth_leaf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_eth_leaf.interface_eth_leaf, is_container='container', presence=False, yang_name="interface-eth-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-e'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__interface_eth_leaf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_eth_leaf(self):
    self.__interface_eth_leaf = YANGDynClass(base=interface_eth_leaf.interface_eth_leaf, is_container='container', presence=False, yang_name="interface-eth-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-e'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_interface_mgmt(self):
    """
    Getter method for interface_mgmt, mapped from YANG variable /rule/command/interface_mgmt (container)
    """
    return self.__interface_mgmt
      
  def _set_interface_mgmt(self, v, load=False):
    """
    Setter method for interface_mgmt, mapped from YANG variable /rule/command/interface_mgmt (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_mgmt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_mgmt() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_mgmt.interface_mgmt, is_container='container', presence=False, yang_name="interface-mgmt", rest_name="", parent=self, choice=(u'cmdlist', u'interface-f'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_mgmt must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_mgmt.interface_mgmt, is_container='container', presence=False, yang_name="interface-mgmt", rest_name="", parent=self, choice=(u'cmdlist', u'interface-f'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__interface_mgmt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_mgmt(self):
    self.__interface_mgmt = YANGDynClass(base=interface_mgmt.interface_mgmt, is_container='container', presence=False, yang_name="interface-mgmt", rest_name="", parent=self, choice=(u'cmdlist', u'interface-f'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_interface_pc(self):
    """
    Getter method for interface_pc, mapped from YANG variable /rule/command/interface_pc (container)
    """
    return self.__interface_pc
      
  def _set_interface_pc(self, v, load=False):
    """
    Setter method for interface_pc, mapped from YANG variable /rule/command/interface_pc (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_pc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_pc() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_pc.interface_pc, is_container='container', presence=False, yang_name="interface-pc", rest_name="", parent=self, choice=(u'cmdlist', u'interface-i'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_pc must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_pc.interface_pc, is_container='container', presence=False, yang_name="interface-pc", rest_name="", parent=self, choice=(u'cmdlist', u'interface-i'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__interface_pc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_pc(self):
    self.__interface_pc = YANGDynClass(base=interface_pc.interface_pc, is_container='container', presence=False, yang_name="interface-pc", rest_name="", parent=self, choice=(u'cmdlist', u'interface-i'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_interface_pc_leaf(self):
    """
    Getter method for interface_pc_leaf, mapped from YANG variable /rule/command/interface_pc_leaf (container)
    """
    return self.__interface_pc_leaf
      
  def _set_interface_pc_leaf(self, v, load=False):
    """
    Setter method for interface_pc_leaf, mapped from YANG variable /rule/command/interface_pc_leaf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_pc_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_pc_leaf() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_pc_leaf.interface_pc_leaf, is_container='container', presence=False, yang_name="interface-pc-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-j'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_pc_leaf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_pc_leaf.interface_pc_leaf, is_container='container', presence=False, yang_name="interface-pc-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-j'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__interface_pc_leaf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_pc_leaf(self):
    self.__interface_pc_leaf = YANGDynClass(base=interface_pc_leaf.interface_pc_leaf, is_container='container', presence=False, yang_name="interface-pc-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-j'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_interface_vlan(self):
    """
    Getter method for interface_vlan, mapped from YANG variable /rule/command/interface_vlan (container)
    """
    return self.__interface_vlan
      
  def _set_interface_vlan(self, v, load=False):
    """
    Setter method for interface_vlan, mapped from YANG variable /rule/command/interface_vlan (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_vlan() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_vlan.interface_vlan, is_container='container', presence=False, yang_name="interface-vlan", rest_name="", parent=self, choice=(u'cmdlist', u'interface-k'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_vlan must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_vlan.interface_vlan, is_container='container', presence=False, yang_name="interface-vlan", rest_name="", parent=self, choice=(u'cmdlist', u'interface-k'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__interface_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_vlan(self):
    self.__interface_vlan = YANGDynClass(base=interface_vlan.interface_vlan, is_container='container', presence=False, yang_name="interface-vlan", rest_name="", parent=self, choice=(u'cmdlist', u'interface-k'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_interface_vlan_leaf(self):
    """
    Getter method for interface_vlan_leaf, mapped from YANG variable /rule/command/interface_vlan_leaf (container)
    """
    return self.__interface_vlan_leaf
      
  def _set_interface_vlan_leaf(self, v, load=False):
    """
    Setter method for interface_vlan_leaf, mapped from YANG variable /rule/command/interface_vlan_leaf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_vlan_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_vlan_leaf() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_vlan_leaf.interface_vlan_leaf, is_container='container', presence=False, yang_name="interface-vlan-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-l'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_vlan_leaf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_vlan_leaf.interface_vlan_leaf, is_container='container', presence=False, yang_name="interface-vlan-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-l'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__interface_vlan_leaf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_vlan_leaf(self):
    self.__interface_vlan_leaf = YANGDynClass(base=interface_vlan_leaf.interface_vlan_leaf, is_container='container', presence=False, yang_name="interface-vlan-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-l'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_interface_management_leaf(self):
    """
    Getter method for interface_management_leaf, mapped from YANG variable /rule/command/interface_management_leaf (container)
    """
    return self.__interface_management_leaf
      
  def _set_interface_management_leaf(self, v, load=False):
    """
    Setter method for interface_management_leaf, mapped from YANG variable /rule/command/interface_management_leaf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_management_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_management_leaf() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_management_leaf.interface_management_leaf, is_container='container', presence=False, yang_name="interface-management-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-m'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_management_leaf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_management_leaf.interface_management_leaf, is_container='container', presence=False, yang_name="interface-management-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-m'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__interface_management_leaf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_management_leaf(self):
    self.__interface_management_leaf = YANGDynClass(base=interface_management_leaf.interface_management_leaf, is_container='container', presence=False, yang_name="interface-management-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-m'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_interface_loopback(self):
    """
    Getter method for interface_loopback, mapped from YANG variable /rule/command/interface_loopback (container)
    """
    return self.__interface_loopback
      
  def _set_interface_loopback(self, v, load=False):
    """
    Setter method for interface_loopback, mapped from YANG variable /rule/command/interface_loopback (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_loopback is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_loopback() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_loopback.interface_loopback, is_container='container', presence=False, yang_name="interface-loopback", rest_name="", parent=self, choice=(u'cmdlist', u'interface-n'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_loopback must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_loopback.interface_loopback, is_container='container', presence=False, yang_name="interface-loopback", rest_name="", parent=self, choice=(u'cmdlist', u'interface-n'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__interface_loopback = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_loopback(self):
    self.__interface_loopback = YANGDynClass(base=interface_loopback.interface_loopback, is_container='container', presence=False, yang_name="interface-loopback", rest_name="", parent=self, choice=(u'cmdlist', u'interface-n'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_interface_loopback_leaf(self):
    """
    Getter method for interface_loopback_leaf, mapped from YANG variable /rule/command/interface_loopback_leaf (container)
    """
    return self.__interface_loopback_leaf
      
  def _set_interface_loopback_leaf(self, v, load=False):
    """
    Setter method for interface_loopback_leaf, mapped from YANG variable /rule/command/interface_loopback_leaf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_loopback_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_loopback_leaf() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_loopback_leaf.interface_loopback_leaf, is_container='container', presence=False, yang_name="interface-loopback-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-o'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_loopback_leaf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_loopback_leaf.interface_loopback_leaf, is_container='container', presence=False, yang_name="interface-loopback-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-o'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__interface_loopback_leaf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_loopback_leaf(self):
    self.__interface_loopback_leaf = YANGDynClass(base=interface_loopback_leaf.interface_loopback_leaf, is_container='container', presence=False, yang_name="interface-loopback-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-o'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_interface_ve(self):
    """
    Getter method for interface_ve, mapped from YANG variable /rule/command/interface_ve (container)
    """
    return self.__interface_ve
      
  def _set_interface_ve(self, v, load=False):
    """
    Setter method for interface_ve, mapped from YANG variable /rule/command/interface_ve (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_ve is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_ve() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_ve.interface_ve, is_container='container', presence=False, yang_name="interface-ve", rest_name="", parent=self, choice=(u'cmdlist', u'interface-p'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_ve must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_ve.interface_ve, is_container='container', presence=False, yang_name="interface-ve", rest_name="", parent=self, choice=(u'cmdlist', u'interface-p'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__interface_ve = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_ve(self):
    self.__interface_ve = YANGDynClass(base=interface_ve.interface_ve, is_container='container', presence=False, yang_name="interface-ve", rest_name="", parent=self, choice=(u'cmdlist', u'interface-p'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_interface_ve_leaf(self):
    """
    Getter method for interface_ve_leaf, mapped from YANG variable /rule/command/interface_ve_leaf (container)
    """
    return self.__interface_ve_leaf
      
  def _set_interface_ve_leaf(self, v, load=False):
    """
    Setter method for interface_ve_leaf, mapped from YANG variable /rule/command/interface_ve_leaf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_ve_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_ve_leaf() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_ve_leaf.interface_ve_leaf, is_container='container', presence=False, yang_name="interface-ve-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-q'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_ve_leaf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_ve_leaf.interface_ve_leaf, is_container='container', presence=False, yang_name="interface-ve-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-q'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__interface_ve_leaf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_ve_leaf(self):
    self.__interface_ve_leaf = YANGDynClass(base=interface_ve_leaf.interface_ve_leaf, is_container='container', presence=False, yang_name="interface-ve-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-q'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_interface_fc(self):
    """
    Getter method for interface_fc, mapped from YANG variable /rule/command/interface_fc (container)
    """
    return self.__interface_fc
      
  def _set_interface_fc(self, v, load=False):
    """
    Setter method for interface_fc, mapped from YANG variable /rule/command/interface_fc (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_fc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_fc() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_fc.interface_fc, is_container='container', presence=False, yang_name="interface-fc", rest_name="", parent=self, choice=(u'cmdlist', u'interface-r'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_fc must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_fc.interface_fc, is_container='container', presence=False, yang_name="interface-fc", rest_name="", parent=self, choice=(u'cmdlist', u'interface-r'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__interface_fc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_fc(self):
    self.__interface_fc = YANGDynClass(base=interface_fc.interface_fc, is_container='container', presence=False, yang_name="interface-fc", rest_name="", parent=self, choice=(u'cmdlist', u'interface-r'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_interface_fc_leaf(self):
    """
    Getter method for interface_fc_leaf, mapped from YANG variable /rule/command/interface_fc_leaf (container)
    """
    return self.__interface_fc_leaf
      
  def _set_interface_fc_leaf(self, v, load=False):
    """
    Setter method for interface_fc_leaf, mapped from YANG variable /rule/command/interface_fc_leaf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_fc_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_fc_leaf() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_fc_leaf.interface_fc_leaf, is_container='container', presence=False, yang_name="interface-fc-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-s'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_fc_leaf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_fc_leaf.interface_fc_leaf, is_container='container', presence=False, yang_name="interface-fc-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-s'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__interface_fc_leaf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_fc_leaf(self):
    self.__interface_fc_leaf = YANGDynClass(base=interface_fc_leaf.interface_fc_leaf, is_container='container', presence=False, yang_name="interface-fc-leaf", rest_name="", parent=self, choice=(u'cmdlist', u'interface-s'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None, u'hidden': u'full'}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_copy_cp(self):
    """
    Getter method for copy_cp, mapped from YANG variable /rule/command/copy_cp (container)
    """
    return self.__copy_cp
      
  def _set_copy_cp(self, v, load=False):
    """
    Setter method for copy_cp, mapped from YANG variable /rule/command/copy_cp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_copy_cp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_copy_cp() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=copy_cp.copy_cp, is_container='container', presence=False, yang_name="copy-cp", rest_name="", parent=self, choice=(u'cmdlist', u'copy-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """copy_cp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=copy_cp.copy_cp, is_container='container', presence=False, yang_name="copy-cp", rest_name="", parent=self, choice=(u'cmdlist', u'copy-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__copy_cp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_copy_cp(self):
    self.__copy_cp = YANGDynClass(base=copy_cp.copy_cp, is_container='container', presence=False, yang_name="copy-cp", rest_name="", parent=self, choice=(u'cmdlist', u'copy-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_copy_running(self):
    """
    Getter method for copy_running, mapped from YANG variable /rule/command/copy_running (container)
    """
    return self.__copy_running
      
  def _set_copy_running(self, v, load=False):
    """
    Setter method for copy_running, mapped from YANG variable /rule/command/copy_running (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_copy_running is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_copy_running() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=copy_running.copy_running, is_container='container', presence=False, yang_name="copy-running", rest_name="", parent=self, choice=(u'cmdlist', u'copy-b'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """copy_running must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=copy_running.copy_running, is_container='container', presence=False, yang_name="copy-running", rest_name="", parent=self, choice=(u'cmdlist', u'copy-b'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__copy_running = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_copy_running(self):
    self.__copy_running = YANGDynClass(base=copy_running.copy_running, is_container='container', presence=False, yang_name="copy-running", rest_name="", parent=self, choice=(u'cmdlist', u'copy-b'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_copy_support(self):
    """
    Getter method for copy_support, mapped from YANG variable /rule/command/copy_support (container)
    """
    return self.__copy_support
      
  def _set_copy_support(self, v, load=False):
    """
    Setter method for copy_support, mapped from YANG variable /rule/command/copy_support (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_copy_support is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_copy_support() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=copy_support.copy_support, is_container='container', presence=False, yang_name="copy-support", rest_name="", parent=self, choice=(u'cmdlist', u'copy-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """copy_support must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=copy_support.copy_support, is_container='container', presence=False, yang_name="copy-support", rest_name="", parent=self, choice=(u'cmdlist', u'copy-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__copy_support = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_copy_support(self):
    self.__copy_support = YANGDynClass(base=copy_support.copy_support, is_container='container', presence=False, yang_name="copy-support", rest_name="", parent=self, choice=(u'cmdlist', u'copy-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_clear_cl(self):
    """
    Getter method for clear_cl, mapped from YANG variable /rule/command/clear_cl (container)
    """
    return self.__clear_cl
      
  def _set_clear_cl(self, v, load=False):
    """
    Setter method for clear_cl, mapped from YANG variable /rule/command/clear_cl (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_cl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_cl() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=clear_cl.clear_cl, is_container='container', presence=False, yang_name="clear-cl", rest_name="", parent=self, choice=(u'cmdlist', u'clear-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_cl must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=clear_cl.clear_cl, is_container='container', presence=False, yang_name="clear-cl", rest_name="", parent=self, choice=(u'cmdlist', u'clear-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__clear_cl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_cl(self):
    self.__clear_cl = YANGDynClass(base=clear_cl.clear_cl, is_container='container', presence=False, yang_name="clear-cl", rest_name="", parent=self, choice=(u'cmdlist', u'clear-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_clear_logging(self):
    """
    Getter method for clear_logging, mapped from YANG variable /rule/command/clear_logging (container)
    """
    return self.__clear_logging
      
  def _set_clear_logging(self, v, load=False):
    """
    Setter method for clear_logging, mapped from YANG variable /rule/command/clear_logging (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_logging is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_logging() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=clear_logging.clear_logging, is_container='container', presence=False, yang_name="clear-logging", rest_name="", parent=self, choice=(u'cmdlist', u'clear-b'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_logging must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=clear_logging.clear_logging, is_container='container', presence=False, yang_name="clear-logging", rest_name="", parent=self, choice=(u'cmdlist', u'clear-b'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__clear_logging = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_logging(self):
    self.__clear_logging = YANGDynClass(base=clear_logging.clear_logging, is_container='container', presence=False, yang_name="clear-logging", rest_name="", parent=self, choice=(u'cmdlist', u'clear-b'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_clear_support(self):
    """
    Getter method for clear_support, mapped from YANG variable /rule/command/clear_support (container)
    """
    return self.__clear_support
      
  def _set_clear_support(self, v, load=False):
    """
    Setter method for clear_support, mapped from YANG variable /rule/command/clear_support (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_support is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_support() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=clear_support.clear_support, is_container='container', presence=False, yang_name="clear-support", rest_name="", parent=self, choice=(u'cmdlist', u'clear-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_support must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=clear_support.clear_support, is_container='container', presence=False, yang_name="clear-support", rest_name="", parent=self, choice=(u'cmdlist', u'clear-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__clear_support = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_support(self):
    self.__clear_support = YANGDynClass(base=clear_support.clear_support, is_container='container', presence=False, yang_name="clear-support", rest_name="", parent=self, choice=(u'cmdlist', u'clear-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_protocol_pr(self):
    """
    Getter method for protocol_pr, mapped from YANG variable /rule/command/protocol_pr (container)
    """
    return self.__protocol_pr
      
  def _set_protocol_pr(self, v, load=False):
    """
    Setter method for protocol_pr, mapped from YANG variable /rule/command/protocol_pr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_pr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_pr() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=protocol_pr.protocol_pr, is_container='container', presence=False, yang_name="protocol-pr", rest_name="", parent=self, choice=(u'cmdlist', u'protocol-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_pr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=protocol_pr.protocol_pr, is_container='container', presence=False, yang_name="protocol-pr", rest_name="", parent=self, choice=(u'cmdlist', u'protocol-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__protocol_pr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_pr(self):
    self.__protocol_pr = YANGDynClass(base=protocol_pr.protocol_pr, is_container='container', presence=False, yang_name="protocol-pr", rest_name="", parent=self, choice=(u'cmdlist', u'protocol-a'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_protocol_spanning(self):
    """
    Getter method for protocol_spanning, mapped from YANG variable /rule/command/protocol_spanning (container)
    """
    return self.__protocol_spanning
      
  def _set_protocol_spanning(self, v, load=False):
    """
    Setter method for protocol_spanning, mapped from YANG variable /rule/command/protocol_spanning (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_spanning is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_spanning() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=protocol_spanning.protocol_spanning, is_container='container', presence=False, yang_name="protocol-spanning", rest_name="", parent=self, choice=(u'cmdlist', u'protocol-b'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_spanning must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=protocol_spanning.protocol_spanning, is_container='container', presence=False, yang_name="protocol-spanning", rest_name="", parent=self, choice=(u'cmdlist', u'protocol-b'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__protocol_spanning = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_spanning(self):
    self.__protocol_spanning = YANGDynClass(base=protocol_spanning.protocol_spanning, is_container='container', presence=False, yang_name="protocol-spanning", rest_name="", parent=self, choice=(u'cmdlist', u'protocol-b'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)


  def _get_protocol_lldp(self):
    """
    Getter method for protocol_lldp, mapped from YANG variable /rule/command/protocol_lldp (container)
    """
    return self.__protocol_lldp
      
  def _set_protocol_lldp(self, v, load=False):
    """
    Setter method for protocol_lldp, mapped from YANG variable /rule/command/protocol_lldp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_lldp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_lldp() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=protocol_lldp.protocol_lldp, is_container='container', presence=False, yang_name="protocol-lldp", rest_name="", parent=self, choice=(u'cmdlist', u'protocol-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_lldp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=protocol_lldp.protocol_lldp, is_container='container', presence=False, yang_name="protocol-lldp", rest_name="", parent=self, choice=(u'cmdlist', u'protocol-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)""",
        })

    self.__protocol_lldp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_lldp(self):
    self.__protocol_lldp = YANGDynClass(base=protocol_lldp.protocol_lldp, is_container='container', presence=False, yang_name="protocol-lldp", rest_name="", parent=self, choice=(u'cmdlist', u'protocol-c'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, namespace='urn:brocade.com:mgmt:brocade-aaa', defining_module='brocade-aaa', yang_type='container', is_config=True)

  enumList = __builtin__.property(_get_enumList, _set_enumList)
  interface_int = __builtin__.property(_get_interface_int, _set_interface_int)
  interface_eth = __builtin__.property(_get_interface_eth, _set_interface_eth)
  interface_eth_leaf = __builtin__.property(_get_interface_eth_leaf, _set_interface_eth_leaf)
  interface_mgmt = __builtin__.property(_get_interface_mgmt, _set_interface_mgmt)
  interface_pc = __builtin__.property(_get_interface_pc, _set_interface_pc)
  interface_pc_leaf = __builtin__.property(_get_interface_pc_leaf, _set_interface_pc_leaf)
  interface_vlan = __builtin__.property(_get_interface_vlan, _set_interface_vlan)
  interface_vlan_leaf = __builtin__.property(_get_interface_vlan_leaf, _set_interface_vlan_leaf)
  interface_management_leaf = __builtin__.property(_get_interface_management_leaf, _set_interface_management_leaf)
  interface_loopback = __builtin__.property(_get_interface_loopback, _set_interface_loopback)
  interface_loopback_leaf = __builtin__.property(_get_interface_loopback_leaf, _set_interface_loopback_leaf)
  interface_ve = __builtin__.property(_get_interface_ve, _set_interface_ve)
  interface_ve_leaf = __builtin__.property(_get_interface_ve_leaf, _set_interface_ve_leaf)
  interface_fc = __builtin__.property(_get_interface_fc, _set_interface_fc)
  interface_fc_leaf = __builtin__.property(_get_interface_fc_leaf, _set_interface_fc_leaf)
  copy_cp = __builtin__.property(_get_copy_cp, _set_copy_cp)
  copy_running = __builtin__.property(_get_copy_running, _set_copy_running)
  copy_support = __builtin__.property(_get_copy_support, _set_copy_support)
  clear_cl = __builtin__.property(_get_clear_cl, _set_clear_cl)
  clear_logging = __builtin__.property(_get_clear_logging, _set_clear_logging)
  clear_support = __builtin__.property(_get_clear_support, _set_clear_support)
  protocol_pr = __builtin__.property(_get_protocol_pr, _set_protocol_pr)
  protocol_spanning = __builtin__.property(_get_protocol_spanning, _set_protocol_spanning)
  protocol_lldp = __builtin__.property(_get_protocol_lldp, _set_protocol_lldp)

  __choices__ = {u'cmdlist': {u'clear-c': [u'clear_support'], u'clear-b': [u'clear_logging'], u'clear-a': [u'clear_cl'], u'interface-q': [u'interface_ve_leaf'], u'interface-p': [u'interface_ve'], u'interface-s': [u'interface_fc_leaf'], u'container-cmds': [u'enumList'], u'protocol-c': [u'protocol_lldp'], u'interface-a': [u'interface_int'], u'interface-c': [u'interface_eth'], u'protocol-b': [u'protocol_spanning'], u'interface-e': [u'interface_eth_leaf'], u'copy-c': [u'copy_support'], u'copy-a': [u'copy_cp'], u'interface-i': [u'interface_pc'], u'copy-b': [u'copy_running'], u'interface-k': [u'interface_vlan'], u'interface-j': [u'interface_pc_leaf'], u'interface-m': [u'interface_management_leaf'], u'interface-l': [u'interface_vlan_leaf'], u'interface-o': [u'interface_loopback_leaf'], u'interface-n': [u'interface_loopback'], u'interface-f': [u'interface_mgmt'], u'interface-r': [u'interface_fc'], u'protocol-a': [u'protocol_pr']}}
  _pyangbind_elements = {'enumList': enumList, 'interface_int': interface_int, 'interface_eth': interface_eth, 'interface_eth_leaf': interface_eth_leaf, 'interface_mgmt': interface_mgmt, 'interface_pc': interface_pc, 'interface_pc_leaf': interface_pc_leaf, 'interface_vlan': interface_vlan, 'interface_vlan_leaf': interface_vlan_leaf, 'interface_management_leaf': interface_management_leaf, 'interface_loopback': interface_loopback, 'interface_loopback_leaf': interface_loopback_leaf, 'interface_ve': interface_ve, 'interface_ve_leaf': interface_ve_leaf, 'interface_fc': interface_fc, 'interface_fc_leaf': interface_fc_leaf, 'copy_cp': copy_cp, 'copy_running': copy_running, 'copy_support': copy_support, 'clear_cl': clear_cl, 'clear_logging': clear_logging, 'clear_support': clear_support, 'protocol_pr': protocol_pr, 'protocol_spanning': protocol_spanning, 'protocol_lldp': protocol_lldp, }


