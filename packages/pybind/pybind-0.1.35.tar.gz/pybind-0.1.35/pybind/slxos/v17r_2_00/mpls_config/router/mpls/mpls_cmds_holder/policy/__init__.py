
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import policy_admin_group
import cspf_computation_mode
import cspf_group_computation
import rsvp_flooding_threshold
import soft_preemption
import global_auto_bandwidth
import implicit_commit
import traffic_engineering
class policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls - based on the path /mpls-config/router/mpls/mpls-cmds-holder/policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__policy_admin_group','__backup_retry_time','__cspf_computation_mode','__cspf_group_computation','__cspf_interface_constraint','__handle_isis_neighbor_down','__handle_ospf_neighbor_down','__load_interval','__retry_time','__retry_limit','__rapid_retry','__rsvp_periodic_flooding_time','__rsvp_flooding_threshold','__soft_preemption','__global_auto_bandwidth','__implicit_commit','__traffic_engineering','__qos_ttl_mode','__ingress_tunnel_accounting','__transit_session_accounting','__switchover_activation_delay','__switchover_hold_tear_delay',)

  _yang_name = 'policy'
  _rest_name = 'policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__rapid_retry = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {'value': 1}, u'disable': {'value': 0}},), is_leaf=True, yang_name="rapid-retry", rest_name="rapid-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Rapid retry', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='enable-disable', is_config=True)
    self.__handle_ospf_neighbor_down = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="handle-ospf-neighbor-down", rest_name="handle-ospf-neighbor-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure MPLS to handle OSPF neighbor down event', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    self.__rsvp_flooding_threshold = YANGDynClass(base=rsvp_flooding_threshold.rsvp_flooding_threshold, is_container='container', presence=False, yang_name="rsvp-flooding-threshold", rest_name="rsvp-flooding-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'RSVP triggered TE-LSA flooding reduction', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    self.__qos_ttl_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'pipe': {'value': 2}, u'uniform': {'value': 1}},), is_leaf=True, yang_name="qos-ttl-mode", rest_name="qos-ttl-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'MPLS ttl and qos propagation model', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='enumeration', is_config=True)
    self.__load_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'30..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="load-interval", rest_name="load-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Polling interval for MPLS LSP traffic statistics', u'hidden': u'full', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__cspf_group_computation = YANGDynClass(base=cspf_group_computation.cspf_group_computation, is_container='container', presence=False, yang_name="cspf-group-computation", rest_name="cspf-group-computation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Cspf-group info for cspf computation', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    self.__backup_retry_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="backup-retry-time", rest_name="backup-retry-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Backup retry time', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__cspf_interface_constraint = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cspf-interface-constraint", rest_name="cspf-interface-constraint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Use interface ip-addr for cspf computation', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    self.__handle_isis_neighbor_down = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="handle-isis-neighbor-down", rest_name="handle-isis-neighbor-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure MPLS to handle ISIS neighbor down event', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    self.__retry_limit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..8192', u'65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(65535), is_leaf=True, yang_name="retry-limit", rest_name="retry-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure LSP retry limit', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__switchover_activation_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="switchover-activation-delay", rest_name="activation-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Activation delay for new instance of RSVP LSPs', u'cli-full-no': None, u'alt-name': u'activation-delay'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__cspf_computation_mode = YANGDynClass(base=cspf_computation_mode.cspf_computation_mode, is_container='container', presence=False, yang_name="cspf-computation-mode", rest_name="cspf-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set cspf computation mode', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    self.__policy_admin_group = YANGDynClass(base=YANGListType("admin_group_name admin_group_number",policy_admin_group.policy_admin_group, yang_name="policy-admin-group", rest_name="admin-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='admin-group-name admin-group-number', extensions={u'tailf-common': {u'info': u'Set administrative group names', u'callpoint': u'MplsPolicyAdminGroup', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-mode': None, u'alt-name': u'admin-group'}}), is_container='list', yang_name="policy-admin-group", rest_name="admin-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set administrative group names', u'callpoint': u'MplsPolicyAdminGroup', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-mode': None, u'alt-name': u'admin-group'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)
    self.__rsvp_periodic_flooding_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0', u'30..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="rsvp-periodic-flooding-time", rest_name="rsvp-periodic-flooding-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Set the interval for RSVP TE periodic flooding', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__implicit_commit = YANGDynClass(base=implicit_commit.implicit_commit, is_container='container', presence=False, yang_name="implicit-commit", rest_name="implicit-commit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set implicit commit behavior for LSPs'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    self.__transit_session_accounting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transit-session-accounting", rest_name="transit-session-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable Traffic Statistics for transit sessions', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    self.__retry_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="retry-time", rest_name="retry-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure LSP retry time', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__ingress_tunnel_accounting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ingress-tunnel-accounting", rest_name="ingress-tunnel-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable Traffic Statistics for Tunnels', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    self.__soft_preemption = YANGDynClass(base=soft_preemption.soft_preemption, is_container='container', presence=False, yang_name="soft-preemption", rest_name="soft-preemption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Global MPLS policies for soft preemption.', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    self.__traffic_engineering = YANGDynClass(base=traffic_engineering.traffic_engineering, is_container='container', presence=False, yang_name="traffic-engineering", rest_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Select IGP for advertising traffic engineering parameters', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    self.__global_auto_bandwidth = YANGDynClass(base=global_auto_bandwidth.global_auto_bandwidth, is_container='container', presence=True, yang_name="global-auto-bandwidth", rest_name="auto-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable Auto-bandwdith feature globally', u'alt-name': u'auto-bandwidth'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    self.__switchover_hold_tear_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="switchover-hold-tear-delay", rest_name="hold-tear-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Path tear delay for old instance of RSVP LSPs', u'cli-full-no': None, u'alt-name': u'hold-tear-delay'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mpls-config', u'router', u'mpls', u'mpls-cmds-holder', u'policy']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'router', u'mpls', u'policy']

  def _get_policy_admin_group(self):
    """
    Getter method for policy_admin_group, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/policy_admin_group (list)
    """
    return self.__policy_admin_group
      
  def _set_policy_admin_group(self, v, load=False):
    """
    Setter method for policy_admin_group, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/policy_admin_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_admin_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_admin_group() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("admin_group_name admin_group_number",policy_admin_group.policy_admin_group, yang_name="policy-admin-group", rest_name="admin-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='admin-group-name admin-group-number', extensions={u'tailf-common': {u'info': u'Set administrative group names', u'callpoint': u'MplsPolicyAdminGroup', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-mode': None, u'alt-name': u'admin-group'}}), is_container='list', yang_name="policy-admin-group", rest_name="admin-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set administrative group names', u'callpoint': u'MplsPolicyAdminGroup', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-mode': None, u'alt-name': u'admin-group'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_admin_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("admin_group_name admin_group_number",policy_admin_group.policy_admin_group, yang_name="policy-admin-group", rest_name="admin-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='admin-group-name admin-group-number', extensions={u'tailf-common': {u'info': u'Set administrative group names', u'callpoint': u'MplsPolicyAdminGroup', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-mode': None, u'alt-name': u'admin-group'}}), is_container='list', yang_name="policy-admin-group", rest_name="admin-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set administrative group names', u'callpoint': u'MplsPolicyAdminGroup', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-mode': None, u'alt-name': u'admin-group'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)""",
        })

    self.__policy_admin_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_admin_group(self):
    self.__policy_admin_group = YANGDynClass(base=YANGListType("admin_group_name admin_group_number",policy_admin_group.policy_admin_group, yang_name="policy-admin-group", rest_name="admin-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='admin-group-name admin-group-number', extensions={u'tailf-common': {u'info': u'Set administrative group names', u'callpoint': u'MplsPolicyAdminGroup', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-mode': None, u'alt-name': u'admin-group'}}), is_container='list', yang_name="policy-admin-group", rest_name="admin-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set administrative group names', u'callpoint': u'MplsPolicyAdminGroup', u'cli-suppress-list-no': None, u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-suppress-mode': None, u'alt-name': u'admin-group'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='list', is_config=True)


  def _get_backup_retry_time(self):
    """
    Getter method for backup_retry_time, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/backup_retry_time (uint32)
    """
    return self.__backup_retry_time
      
  def _set_backup_retry_time(self, v, load=False):
    """
    Setter method for backup_retry_time, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/backup_retry_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_backup_retry_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_backup_retry_time() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="backup-retry-time", rest_name="backup-retry-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Backup retry time', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """backup_retry_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="backup-retry-time", rest_name="backup-retry-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Backup retry time', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__backup_retry_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_backup_retry_time(self):
    self.__backup_retry_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="backup-retry-time", rest_name="backup-retry-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Backup retry time', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_cspf_computation_mode(self):
    """
    Getter method for cspf_computation_mode, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/cspf_computation_mode (container)
    """
    return self.__cspf_computation_mode
      
  def _set_cspf_computation_mode(self, v, load=False):
    """
    Setter method for cspf_computation_mode, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/cspf_computation_mode (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cspf_computation_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cspf_computation_mode() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=cspf_computation_mode.cspf_computation_mode, is_container='container', presence=False, yang_name="cspf-computation-mode", rest_name="cspf-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set cspf computation mode', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cspf_computation_mode must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=cspf_computation_mode.cspf_computation_mode, is_container='container', presence=False, yang_name="cspf-computation-mode", rest_name="cspf-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set cspf computation mode', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)""",
        })

    self.__cspf_computation_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cspf_computation_mode(self):
    self.__cspf_computation_mode = YANGDynClass(base=cspf_computation_mode.cspf_computation_mode, is_container='container', presence=False, yang_name="cspf-computation-mode", rest_name="cspf-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set cspf computation mode', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)


  def _get_cspf_group_computation(self):
    """
    Getter method for cspf_group_computation, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/cspf_group_computation (container)
    """
    return self.__cspf_group_computation
      
  def _set_cspf_group_computation(self, v, load=False):
    """
    Setter method for cspf_group_computation, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/cspf_group_computation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cspf_group_computation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cspf_group_computation() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=cspf_group_computation.cspf_group_computation, is_container='container', presence=False, yang_name="cspf-group-computation", rest_name="cspf-group-computation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Cspf-group info for cspf computation', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cspf_group_computation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=cspf_group_computation.cspf_group_computation, is_container='container', presence=False, yang_name="cspf-group-computation", rest_name="cspf-group-computation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Cspf-group info for cspf computation', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)""",
        })

    self.__cspf_group_computation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cspf_group_computation(self):
    self.__cspf_group_computation = YANGDynClass(base=cspf_group_computation.cspf_group_computation, is_container='container', presence=False, yang_name="cspf-group-computation", rest_name="cspf-group-computation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Cspf-group info for cspf computation', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)


  def _get_cspf_interface_constraint(self):
    """
    Getter method for cspf_interface_constraint, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/cspf_interface_constraint (empty)
    """
    return self.__cspf_interface_constraint
      
  def _set_cspf_interface_constraint(self, v, load=False):
    """
    Setter method for cspf_interface_constraint, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/cspf_interface_constraint (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cspf_interface_constraint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cspf_interface_constraint() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="cspf-interface-constraint", rest_name="cspf-interface-constraint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Use interface ip-addr for cspf computation', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cspf_interface_constraint must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cspf-interface-constraint", rest_name="cspf-interface-constraint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Use interface ip-addr for cspf computation', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)""",
        })

    self.__cspf_interface_constraint = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cspf_interface_constraint(self):
    self.__cspf_interface_constraint = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cspf-interface-constraint", rest_name="cspf-interface-constraint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Use interface ip-addr for cspf computation', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)


  def _get_handle_isis_neighbor_down(self):
    """
    Getter method for handle_isis_neighbor_down, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/handle_isis_neighbor_down (empty)
    """
    return self.__handle_isis_neighbor_down
      
  def _set_handle_isis_neighbor_down(self, v, load=False):
    """
    Setter method for handle_isis_neighbor_down, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/handle_isis_neighbor_down (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_handle_isis_neighbor_down is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_handle_isis_neighbor_down() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="handle-isis-neighbor-down", rest_name="handle-isis-neighbor-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure MPLS to handle ISIS neighbor down event', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """handle_isis_neighbor_down must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="handle-isis-neighbor-down", rest_name="handle-isis-neighbor-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure MPLS to handle ISIS neighbor down event', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)""",
        })

    self.__handle_isis_neighbor_down = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_handle_isis_neighbor_down(self):
    self.__handle_isis_neighbor_down = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="handle-isis-neighbor-down", rest_name="handle-isis-neighbor-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure MPLS to handle ISIS neighbor down event', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)


  def _get_handle_ospf_neighbor_down(self):
    """
    Getter method for handle_ospf_neighbor_down, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/handle_ospf_neighbor_down (empty)
    """
    return self.__handle_ospf_neighbor_down
      
  def _set_handle_ospf_neighbor_down(self, v, load=False):
    """
    Setter method for handle_ospf_neighbor_down, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/handle_ospf_neighbor_down (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_handle_ospf_neighbor_down is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_handle_ospf_neighbor_down() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="handle-ospf-neighbor-down", rest_name="handle-ospf-neighbor-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure MPLS to handle OSPF neighbor down event', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """handle_ospf_neighbor_down must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="handle-ospf-neighbor-down", rest_name="handle-ospf-neighbor-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure MPLS to handle OSPF neighbor down event', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)""",
        })

    self.__handle_ospf_neighbor_down = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_handle_ospf_neighbor_down(self):
    self.__handle_ospf_neighbor_down = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="handle-ospf-neighbor-down", rest_name="handle-ospf-neighbor-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure MPLS to handle OSPF neighbor down event', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)


  def _get_load_interval(self):
    """
    Getter method for load_interval, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/load_interval (uint32)
    """
    return self.__load_interval
      
  def _set_load_interval(self, v, load=False):
    """
    Setter method for load_interval, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/load_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_load_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_load_interval() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'30..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="load-interval", rest_name="load-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Polling interval for MPLS LSP traffic statistics', u'hidden': u'full', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """load_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'30..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="load-interval", rest_name="load-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Polling interval for MPLS LSP traffic statistics', u'hidden': u'full', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__load_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_load_interval(self):
    self.__load_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'30..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="load-interval", rest_name="load-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Polling interval for MPLS LSP traffic statistics', u'hidden': u'full', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_retry_time(self):
    """
    Getter method for retry_time, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/retry_time (uint32)
    """
    return self.__retry_time
      
  def _set_retry_time(self, v, load=False):
    """
    Setter method for retry_time, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/retry_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retry_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retry_time() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="retry-time", rest_name="retry-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure LSP retry time', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retry_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="retry-time", rest_name="retry-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure LSP retry time', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__retry_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retry_time(self):
    self.__retry_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="retry-time", rest_name="retry-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure LSP retry time', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_retry_limit(self):
    """
    Getter method for retry_limit, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/retry_limit (uint32)
    """
    return self.__retry_limit
      
  def _set_retry_limit(self, v, load=False):
    """
    Setter method for retry_limit, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/retry_limit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retry_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retry_limit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..8192', u'65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(65535), is_leaf=True, yang_name="retry-limit", rest_name="retry-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure LSP retry limit', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retry_limit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..8192', u'65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(65535), is_leaf=True, yang_name="retry-limit", rest_name="retry-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure LSP retry limit', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__retry_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retry_limit(self):
    self.__retry_limit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..8192', u'65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(65535), is_leaf=True, yang_name="retry-limit", rest_name="retry-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure LSP retry limit', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_rapid_retry(self):
    """
    Getter method for rapid_retry, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/rapid_retry (enable-disable)
    """
    return self.__rapid_retry
      
  def _set_rapid_retry(self, v, load=False):
    """
    Setter method for rapid_retry, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/rapid_retry (enable-disable)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rapid_retry is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rapid_retry() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {'value': 1}, u'disable': {'value': 0}},), is_leaf=True, yang_name="rapid-retry", rest_name="rapid-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Rapid retry', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='enable-disable', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rapid_retry must be of a type compatible with enable-disable""",
          'defined-type': "brocade-mpls:enable-disable",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {'value': 1}, u'disable': {'value': 0}},), is_leaf=True, yang_name="rapid-retry", rest_name="rapid-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Rapid retry', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='enable-disable', is_config=True)""",
        })

    self.__rapid_retry = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rapid_retry(self):
    self.__rapid_retry = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {'value': 1}, u'disable': {'value': 0}},), is_leaf=True, yang_name="rapid-retry", rest_name="rapid-retry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Rapid retry', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='enable-disable', is_config=True)


  def _get_rsvp_periodic_flooding_time(self):
    """
    Getter method for rsvp_periodic_flooding_time, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/rsvp_periodic_flooding_time (uint32)
    """
    return self.__rsvp_periodic_flooding_time
      
  def _set_rsvp_periodic_flooding_time(self, v, load=False):
    """
    Setter method for rsvp_periodic_flooding_time, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/rsvp_periodic_flooding_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rsvp_periodic_flooding_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rsvp_periodic_flooding_time() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0', u'30..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="rsvp-periodic-flooding-time", rest_name="rsvp-periodic-flooding-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Set the interval for RSVP TE periodic flooding', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rsvp_periodic_flooding_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0', u'30..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="rsvp-periodic-flooding-time", rest_name="rsvp-periodic-flooding-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Set the interval for RSVP TE periodic flooding', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__rsvp_periodic_flooding_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rsvp_periodic_flooding_time(self):
    self.__rsvp_periodic_flooding_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0', u'30..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="rsvp-periodic-flooding-time", rest_name="rsvp-periodic-flooding-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Set the interval for RSVP TE periodic flooding', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_rsvp_flooding_threshold(self):
    """
    Getter method for rsvp_flooding_threshold, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/rsvp_flooding_threshold (container)
    """
    return self.__rsvp_flooding_threshold
      
  def _set_rsvp_flooding_threshold(self, v, load=False):
    """
    Setter method for rsvp_flooding_threshold, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/rsvp_flooding_threshold (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rsvp_flooding_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rsvp_flooding_threshold() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=rsvp_flooding_threshold.rsvp_flooding_threshold, is_container='container', presence=False, yang_name="rsvp-flooding-threshold", rest_name="rsvp-flooding-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'RSVP triggered TE-LSA flooding reduction', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rsvp_flooding_threshold must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=rsvp_flooding_threshold.rsvp_flooding_threshold, is_container='container', presence=False, yang_name="rsvp-flooding-threshold", rest_name="rsvp-flooding-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'RSVP triggered TE-LSA flooding reduction', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)""",
        })

    self.__rsvp_flooding_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rsvp_flooding_threshold(self):
    self.__rsvp_flooding_threshold = YANGDynClass(base=rsvp_flooding_threshold.rsvp_flooding_threshold, is_container='container', presence=False, yang_name="rsvp-flooding-threshold", rest_name="rsvp-flooding-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'RSVP triggered TE-LSA flooding reduction', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)


  def _get_soft_preemption(self):
    """
    Getter method for soft_preemption, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/soft_preemption (container)
    """
    return self.__soft_preemption
      
  def _set_soft_preemption(self, v, load=False):
    """
    Setter method for soft_preemption, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/soft_preemption (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_soft_preemption is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_soft_preemption() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=soft_preemption.soft_preemption, is_container='container', presence=False, yang_name="soft-preemption", rest_name="soft-preemption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Global MPLS policies for soft preemption.', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """soft_preemption must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=soft_preemption.soft_preemption, is_container='container', presence=False, yang_name="soft-preemption", rest_name="soft-preemption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Global MPLS policies for soft preemption.', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)""",
        })

    self.__soft_preemption = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_soft_preemption(self):
    self.__soft_preemption = YANGDynClass(base=soft_preemption.soft_preemption, is_container='container', presence=False, yang_name="soft-preemption", rest_name="soft-preemption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Global MPLS policies for soft preemption.', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)


  def _get_global_auto_bandwidth(self):
    """
    Getter method for global_auto_bandwidth, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/global_auto_bandwidth (container)
    """
    return self.__global_auto_bandwidth
      
  def _set_global_auto_bandwidth(self, v, load=False):
    """
    Setter method for global_auto_bandwidth, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/global_auto_bandwidth (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_auto_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_auto_bandwidth() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=global_auto_bandwidth.global_auto_bandwidth, is_container='container', presence=True, yang_name="global-auto-bandwidth", rest_name="auto-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable Auto-bandwdith feature globally', u'alt-name': u'auto-bandwidth'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_auto_bandwidth must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=global_auto_bandwidth.global_auto_bandwidth, is_container='container', presence=True, yang_name="global-auto-bandwidth", rest_name="auto-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable Auto-bandwdith feature globally', u'alt-name': u'auto-bandwidth'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)""",
        })

    self.__global_auto_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_auto_bandwidth(self):
    self.__global_auto_bandwidth = YANGDynClass(base=global_auto_bandwidth.global_auto_bandwidth, is_container='container', presence=True, yang_name="global-auto-bandwidth", rest_name="auto-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable Auto-bandwdith feature globally', u'alt-name': u'auto-bandwidth'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)


  def _get_implicit_commit(self):
    """
    Getter method for implicit_commit, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/implicit_commit (container)
    """
    return self.__implicit_commit
      
  def _set_implicit_commit(self, v, load=False):
    """
    Setter method for implicit_commit, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/implicit_commit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_implicit_commit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_implicit_commit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=implicit_commit.implicit_commit, is_container='container', presence=False, yang_name="implicit-commit", rest_name="implicit-commit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set implicit commit behavior for LSPs'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """implicit_commit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=implicit_commit.implicit_commit, is_container='container', presence=False, yang_name="implicit-commit", rest_name="implicit-commit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set implicit commit behavior for LSPs'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)""",
        })

    self.__implicit_commit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_implicit_commit(self):
    self.__implicit_commit = YANGDynClass(base=implicit_commit.implicit_commit, is_container='container', presence=False, yang_name="implicit-commit", rest_name="implicit-commit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set implicit commit behavior for LSPs'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)


  def _get_traffic_engineering(self):
    """
    Getter method for traffic_engineering, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/traffic_engineering (container)
    """
    return self.__traffic_engineering
      
  def _set_traffic_engineering(self, v, load=False):
    """
    Setter method for traffic_engineering, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/traffic_engineering (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_engineering is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_engineering() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=traffic_engineering.traffic_engineering, is_container='container', presence=False, yang_name="traffic-engineering", rest_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Select IGP for advertising traffic engineering parameters', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_engineering must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=traffic_engineering.traffic_engineering, is_container='container', presence=False, yang_name="traffic-engineering", rest_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Select IGP for advertising traffic engineering parameters', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)""",
        })

    self.__traffic_engineering = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_engineering(self):
    self.__traffic_engineering = YANGDynClass(base=traffic_engineering.traffic_engineering, is_container='container', presence=False, yang_name="traffic-engineering", rest_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Select IGP for advertising traffic engineering parameters', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='container', is_config=True)


  def _get_qos_ttl_mode(self):
    """
    Getter method for qos_ttl_mode, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/qos_ttl_mode (enumeration)
    """
    return self.__qos_ttl_mode
      
  def _set_qos_ttl_mode(self, v, load=False):
    """
    Setter method for qos_ttl_mode, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/qos_ttl_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos_ttl_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos_ttl_mode() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'pipe': {'value': 2}, u'uniform': {'value': 1}},), is_leaf=True, yang_name="qos-ttl-mode", rest_name="qos-ttl-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'MPLS ttl and qos propagation model', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos_ttl_mode must be of a type compatible with enumeration""",
          'defined-type': "brocade-mpls:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'pipe': {'value': 2}, u'uniform': {'value': 1}},), is_leaf=True, yang_name="qos-ttl-mode", rest_name="qos-ttl-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'MPLS ttl and qos propagation model', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='enumeration', is_config=True)""",
        })

    self.__qos_ttl_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos_ttl_mode(self):
    self.__qos_ttl_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'pipe': {'value': 2}, u'uniform': {'value': 1}},), is_leaf=True, yang_name="qos-ttl-mode", rest_name="qos-ttl-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'MPLS ttl and qos propagation model', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='enumeration', is_config=True)


  def _get_ingress_tunnel_accounting(self):
    """
    Getter method for ingress_tunnel_accounting, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/ingress_tunnel_accounting (empty)
    """
    return self.__ingress_tunnel_accounting
      
  def _set_ingress_tunnel_accounting(self, v, load=False):
    """
    Setter method for ingress_tunnel_accounting, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/ingress_tunnel_accounting (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ingress_tunnel_accounting is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ingress_tunnel_accounting() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ingress-tunnel-accounting", rest_name="ingress-tunnel-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable Traffic Statistics for Tunnels', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ingress_tunnel_accounting must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ingress-tunnel-accounting", rest_name="ingress-tunnel-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable Traffic Statistics for Tunnels', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)""",
        })

    self.__ingress_tunnel_accounting = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ingress_tunnel_accounting(self):
    self.__ingress_tunnel_accounting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ingress-tunnel-accounting", rest_name="ingress-tunnel-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable Traffic Statistics for Tunnels', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)


  def _get_transit_session_accounting(self):
    """
    Getter method for transit_session_accounting, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/transit_session_accounting (empty)
    """
    return self.__transit_session_accounting
      
  def _set_transit_session_accounting(self, v, load=False):
    """
    Setter method for transit_session_accounting, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/transit_session_accounting (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transit_session_accounting is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transit_session_accounting() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="transit-session-accounting", rest_name="transit-session-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable Traffic Statistics for transit sessions', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transit_session_accounting must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transit-session-accounting", rest_name="transit-session-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable Traffic Statistics for transit sessions', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)""",
        })

    self.__transit_session_accounting = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transit_session_accounting(self):
    self.__transit_session_accounting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transit-session-accounting", rest_name="transit-session-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enable Traffic Statistics for transit sessions', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='empty', is_config=True)


  def _get_switchover_activation_delay(self):
    """
    Getter method for switchover_activation_delay, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/switchover_activation_delay (uint32)
    """
    return self.__switchover_activation_delay
      
  def _set_switchover_activation_delay(self, v, load=False):
    """
    Setter method for switchover_activation_delay, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/switchover_activation_delay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_switchover_activation_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_switchover_activation_delay() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="switchover-activation-delay", rest_name="activation-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Activation delay for new instance of RSVP LSPs', u'cli-full-no': None, u'alt-name': u'activation-delay'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """switchover_activation_delay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="switchover-activation-delay", rest_name="activation-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Activation delay for new instance of RSVP LSPs', u'cli-full-no': None, u'alt-name': u'activation-delay'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__switchover_activation_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_switchover_activation_delay(self):
    self.__switchover_activation_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="switchover-activation-delay", rest_name="activation-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Activation delay for new instance of RSVP LSPs', u'cli-full-no': None, u'alt-name': u'activation-delay'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_switchover_hold_tear_delay(self):
    """
    Getter method for switchover_hold_tear_delay, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/switchover_hold_tear_delay (uint32)
    """
    return self.__switchover_hold_tear_delay
      
  def _set_switchover_hold_tear_delay(self, v, load=False):
    """
    Setter method for switchover_hold_tear_delay, mapped from YANG variable /mpls_config/router/mpls/mpls_cmds_holder/policy/switchover_hold_tear_delay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_switchover_hold_tear_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_switchover_hold_tear_delay() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="switchover-hold-tear-delay", rest_name="hold-tear-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Path tear delay for old instance of RSVP LSPs', u'cli-full-no': None, u'alt-name': u'hold-tear-delay'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """switchover_hold_tear_delay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="switchover-hold-tear-delay", rest_name="hold-tear-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Path tear delay for old instance of RSVP LSPs', u'cli-full-no': None, u'alt-name': u'hold-tear-delay'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__switchover_hold_tear_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_switchover_hold_tear_delay(self):
    self.__switchover_hold_tear_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="switchover-hold-tear-delay", rest_name="hold-tear-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Path tear delay for old instance of RSVP LSPs', u'cli-full-no': None, u'alt-name': u'hold-tear-delay'}}, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)

  policy_admin_group = __builtin__.property(_get_policy_admin_group, _set_policy_admin_group)
  backup_retry_time = __builtin__.property(_get_backup_retry_time, _set_backup_retry_time)
  cspf_computation_mode = __builtin__.property(_get_cspf_computation_mode, _set_cspf_computation_mode)
  cspf_group_computation = __builtin__.property(_get_cspf_group_computation, _set_cspf_group_computation)
  cspf_interface_constraint = __builtin__.property(_get_cspf_interface_constraint, _set_cspf_interface_constraint)
  handle_isis_neighbor_down = __builtin__.property(_get_handle_isis_neighbor_down, _set_handle_isis_neighbor_down)
  handle_ospf_neighbor_down = __builtin__.property(_get_handle_ospf_neighbor_down, _set_handle_ospf_neighbor_down)
  load_interval = __builtin__.property(_get_load_interval, _set_load_interval)
  retry_time = __builtin__.property(_get_retry_time, _set_retry_time)
  retry_limit = __builtin__.property(_get_retry_limit, _set_retry_limit)
  rapid_retry = __builtin__.property(_get_rapid_retry, _set_rapid_retry)
  rsvp_periodic_flooding_time = __builtin__.property(_get_rsvp_periodic_flooding_time, _set_rsvp_periodic_flooding_time)
  rsvp_flooding_threshold = __builtin__.property(_get_rsvp_flooding_threshold, _set_rsvp_flooding_threshold)
  soft_preemption = __builtin__.property(_get_soft_preemption, _set_soft_preemption)
  global_auto_bandwidth = __builtin__.property(_get_global_auto_bandwidth, _set_global_auto_bandwidth)
  implicit_commit = __builtin__.property(_get_implicit_commit, _set_implicit_commit)
  traffic_engineering = __builtin__.property(_get_traffic_engineering, _set_traffic_engineering)
  qos_ttl_mode = __builtin__.property(_get_qos_ttl_mode, _set_qos_ttl_mode)
  ingress_tunnel_accounting = __builtin__.property(_get_ingress_tunnel_accounting, _set_ingress_tunnel_accounting)
  transit_session_accounting = __builtin__.property(_get_transit_session_accounting, _set_transit_session_accounting)
  switchover_activation_delay = __builtin__.property(_get_switchover_activation_delay, _set_switchover_activation_delay)
  switchover_hold_tear_delay = __builtin__.property(_get_switchover_hold_tear_delay, _set_switchover_hold_tear_delay)


  _pyangbind_elements = {'policy_admin_group': policy_admin_group, 'backup_retry_time': backup_retry_time, 'cspf_computation_mode': cspf_computation_mode, 'cspf_group_computation': cspf_group_computation, 'cspf_interface_constraint': cspf_interface_constraint, 'handle_isis_neighbor_down': handle_isis_neighbor_down, 'handle_ospf_neighbor_down': handle_ospf_neighbor_down, 'load_interval': load_interval, 'retry_time': retry_time, 'retry_limit': retry_limit, 'rapid_retry': rapid_retry, 'rsvp_periodic_flooding_time': rsvp_periodic_flooding_time, 'rsvp_flooding_threshold': rsvp_flooding_threshold, 'soft_preemption': soft_preemption, 'global_auto_bandwidth': global_auto_bandwidth, 'implicit_commit': implicit_commit, 'traffic_engineering': traffic_engineering, 'qos_ttl_mode': qos_ttl_mode, 'ingress_tunnel_accounting': ingress_tunnel_accounting, 'transit_session_accounting': transit_session_accounting, 'switchover_activation_delay': switchover_activation_delay, 'switchover_hold_tear_delay': switchover_hold_tear_delay, }


