
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import active_vlan_list
import active_bd_list
import peer_info_list
import client_info_list
import config_vlan_list
import bd_list
class show_cluster(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-nsm-operational - based on the path /mct-state/show-cluster. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__cluster_id','__is_cluster_client_command','__cluster_name','__cluster_status','__client_isolation_status','__num_peers','__num_clients','__num_config_vlans','__num_active_vlans','__num_bds','__num_active_bds','__client_interfaces_shutdown','__active_vlan_list','__active_bd_list','__peer_info_list','__client_info_list','__config_vlan_list','__bd_list',)

  _yang_name = 'show-cluster'
  _rest_name = 'show-cluster'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__active_vlan_list = YANGDynClass(base=YANGListType("vlan_id",active_vlan_list.active_vlan_list, yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    self.__num_active_bds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-bds", rest_name="num-active-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__bd_list = YANGDynClass(base=YANGListType("bd_id",bd_list.bd_list, yang_name="bd-list", rest_name="bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}), is_container='list', yang_name="bd-list", rest_name="bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    self.__num_active_vlans = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-vlans", rest_name="num-active-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__peer_info_list = YANGDynClass(base=YANGListType("peer_ip_addr",peer_info_list.peer_info_list, yang_name="peer-info-list", rest_name="peer-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip-addr', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="peer-info-list", rest_name="peer-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    self.__client_isolation_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="client-isolation-status", rest_name="client-isolation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    self.__client_interfaces_shutdown = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="client-interfaces-shutdown", rest_name="client-interfaces-shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    self.__is_cluster_client_command = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-cluster-client-command", rest_name="is-cluster-client-command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    self.__num_config_vlans = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-config-vlans", rest_name="num-config-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__num_bds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-bds", rest_name="num-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__cluster_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="cluster-name", rest_name="cluster-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='string', is_config=False)
    self.__cluster_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cluster-id", rest_name="cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__cluster_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cluster-status", rest_name="cluster-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    self.__client_info_list = YANGDynClass(base=YANGListType("cluster_id client_id",client_info_list.client_info_list, yang_name="client-info-list", rest_name="client-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="client-info-list", rest_name="client-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    self.__active_bd_list = YANGDynClass(base=YANGListType("bd_id",active_bd_list.active_bd_list, yang_name="active-bd-list", rest_name="active-bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-bd-list", rest_name="active-bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    self.__num_peers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-peers", rest_name="num-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__num_clients = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-clients", rest_name="num-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    self.__config_vlan_list = YANGDynClass(base=YANGListType("vlan_id",config_vlan_list.config_vlan_list, yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}), is_container='list', yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mct-state', u'show-cluster']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'mct-state', u'show-cluster']

  def _get_cluster_id(self):
    """
    Getter method for cluster_id, mapped from YANG variable /mct_state/show_cluster/cluster_id (uint32)
    """
    return self.__cluster_id
      
  def _set_cluster_id(self, v, load=False):
    """
    Setter method for cluster_id, mapped from YANG variable /mct_state/show_cluster/cluster_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cluster_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cluster_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cluster-id", rest_name="cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cluster_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cluster-id", rest_name="cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__cluster_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cluster_id(self):
    self.__cluster_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cluster-id", rest_name="cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_is_cluster_client_command(self):
    """
    Getter method for is_cluster_client_command, mapped from YANG variable /mct_state/show_cluster/is_cluster_client_command (boolean)
    """
    return self.__is_cluster_client_command
      
  def _set_is_cluster_client_command(self, v, load=False):
    """
    Setter method for is_cluster_client_command, mapped from YANG variable /mct_state/show_cluster/is_cluster_client_command (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_cluster_client_command is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_cluster_client_command() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-cluster-client-command", rest_name="is-cluster-client-command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_cluster_client_command must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-cluster-client-command", rest_name="is-cluster-client-command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_cluster_client_command = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_cluster_client_command(self):
    self.__is_cluster_client_command = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-cluster-client-command", rest_name="is-cluster-client-command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)


  def _get_cluster_name(self):
    """
    Getter method for cluster_name, mapped from YANG variable /mct_state/show_cluster/cluster_name (string)
    """
    return self.__cluster_name
      
  def _set_cluster_name(self, v, load=False):
    """
    Setter method for cluster_name, mapped from YANG variable /mct_state/show_cluster/cluster_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cluster_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cluster_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cluster-name", rest_name="cluster-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cluster_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cluster-name", rest_name="cluster-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='string', is_config=False)""",
        })

    self.__cluster_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cluster_name(self):
    self.__cluster_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="cluster-name", rest_name="cluster-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='string', is_config=False)


  def _get_cluster_status(self):
    """
    Getter method for cluster_status, mapped from YANG variable /mct_state/show_cluster/cluster_status (boolean)
    """
    return self.__cluster_status
      
  def _set_cluster_status(self, v, load=False):
    """
    Setter method for cluster_status, mapped from YANG variable /mct_state/show_cluster/cluster_status (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cluster_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cluster_status() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="cluster-status", rest_name="cluster-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cluster_status must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cluster-status", rest_name="cluster-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)""",
        })

    self.__cluster_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cluster_status(self):
    self.__cluster_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cluster-status", rest_name="cluster-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)


  def _get_client_isolation_status(self):
    """
    Getter method for client_isolation_status, mapped from YANG variable /mct_state/show_cluster/client_isolation_status (boolean)
    """
    return self.__client_isolation_status
      
  def _set_client_isolation_status(self, v, load=False):
    """
    Setter method for client_isolation_status, mapped from YANG variable /mct_state/show_cluster/client_isolation_status (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_isolation_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_isolation_status() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="client-isolation-status", rest_name="client-isolation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_isolation_status must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="client-isolation-status", rest_name="client-isolation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)""",
        })

    self.__client_isolation_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_isolation_status(self):
    self.__client_isolation_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="client-isolation-status", rest_name="client-isolation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)


  def _get_num_peers(self):
    """
    Getter method for num_peers, mapped from YANG variable /mct_state/show_cluster/num_peers (uint32)
    """
    return self.__num_peers
      
  def _set_num_peers(self, v, load=False):
    """
    Setter method for num_peers, mapped from YANG variable /mct_state/show_cluster/num_peers (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_peers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_peers() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-peers", rest_name="num-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_peers must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-peers", rest_name="num-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_peers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_peers(self):
    self.__num_peers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-peers", rest_name="num-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_num_clients(self):
    """
    Getter method for num_clients, mapped from YANG variable /mct_state/show_cluster/num_clients (uint32)
    """
    return self.__num_clients
      
  def _set_num_clients(self, v, load=False):
    """
    Setter method for num_clients, mapped from YANG variable /mct_state/show_cluster/num_clients (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_clients is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_clients() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-clients", rest_name="num-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_clients must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-clients", rest_name="num-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_clients = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_clients(self):
    self.__num_clients = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-clients", rest_name="num-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_num_config_vlans(self):
    """
    Getter method for num_config_vlans, mapped from YANG variable /mct_state/show_cluster/num_config_vlans (uint32)
    """
    return self.__num_config_vlans
      
  def _set_num_config_vlans(self, v, load=False):
    """
    Setter method for num_config_vlans, mapped from YANG variable /mct_state/show_cluster/num_config_vlans (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_config_vlans is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_config_vlans() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-config-vlans", rest_name="num-config-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_config_vlans must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-config-vlans", rest_name="num-config-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_config_vlans = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_config_vlans(self):
    self.__num_config_vlans = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-config-vlans", rest_name="num-config-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_num_active_vlans(self):
    """
    Getter method for num_active_vlans, mapped from YANG variable /mct_state/show_cluster/num_active_vlans (uint32)
    """
    return self.__num_active_vlans
      
  def _set_num_active_vlans(self, v, load=False):
    """
    Setter method for num_active_vlans, mapped from YANG variable /mct_state/show_cluster/num_active_vlans (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_active_vlans is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_active_vlans() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-vlans", rest_name="num-active-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_active_vlans must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-vlans", rest_name="num-active-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_active_vlans = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_active_vlans(self):
    self.__num_active_vlans = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-vlans", rest_name="num-active-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_num_bds(self):
    """
    Getter method for num_bds, mapped from YANG variable /mct_state/show_cluster/num_bds (uint32)
    """
    return self.__num_bds
      
  def _set_num_bds(self, v, load=False):
    """
    Setter method for num_bds, mapped from YANG variable /mct_state/show_cluster/num_bds (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_bds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_bds() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-bds", rest_name="num-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_bds must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-bds", rest_name="num-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_bds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_bds(self):
    self.__num_bds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-bds", rest_name="num-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_num_active_bds(self):
    """
    Getter method for num_active_bds, mapped from YANG variable /mct_state/show_cluster/num_active_bds (uint32)
    """
    return self.__num_active_bds
      
  def _set_num_active_bds(self, v, load=False):
    """
    Setter method for num_active_bds, mapped from YANG variable /mct_state/show_cluster/num_active_bds (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_active_bds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_active_bds() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-bds", rest_name="num-active-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_active_bds must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-bds", rest_name="num-active-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)""",
        })

    self.__num_active_bds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_active_bds(self):
    self.__num_active_bds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num-active-bds", rest_name="num-active-bds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='uint32', is_config=False)


  def _get_client_interfaces_shutdown(self):
    """
    Getter method for client_interfaces_shutdown, mapped from YANG variable /mct_state/show_cluster/client_interfaces_shutdown (boolean)
    """
    return self.__client_interfaces_shutdown
      
  def _set_client_interfaces_shutdown(self, v, load=False):
    """
    Setter method for client_interfaces_shutdown, mapped from YANG variable /mct_state/show_cluster/client_interfaces_shutdown (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_interfaces_shutdown is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_interfaces_shutdown() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="client-interfaces-shutdown", rest_name="client-interfaces-shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_interfaces_shutdown must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="client-interfaces-shutdown", rest_name="client-interfaces-shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)""",
        })

    self.__client_interfaces_shutdown = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_interfaces_shutdown(self):
    self.__client_interfaces_shutdown = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="client-interfaces-shutdown", rest_name="client-interfaces-shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='boolean', is_config=False)


  def _get_active_vlan_list(self):
    """
    Getter method for active_vlan_list, mapped from YANG variable /mct_state/show_cluster/active_vlan_list (list)
    """
    return self.__active_vlan_list
      
  def _set_active_vlan_list(self, v, load=False):
    """
    Setter method for active_vlan_list, mapped from YANG variable /mct_state/show_cluster/active_vlan_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active_vlan_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active_vlan_list() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vlan_id",active_vlan_list.active_vlan_list, yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active_vlan_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vlan_id",active_vlan_list.active_vlan_list, yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)""",
        })

    self.__active_vlan_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active_vlan_list(self):
    self.__active_vlan_list = YANGDynClass(base=YANGListType("vlan_id",active_vlan_list.active_vlan_list, yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-vlan-list", rest_name="active-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-vlan', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)


  def _get_active_bd_list(self):
    """
    Getter method for active_bd_list, mapped from YANG variable /mct_state/show_cluster/active_bd_list (list)

    YANG Description: List of BDs Active
    """
    return self.__active_bd_list
      
  def _set_active_bd_list(self, v, load=False):
    """
    Setter method for active_bd_list, mapped from YANG variable /mct_state/show_cluster/active_bd_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active_bd_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active_bd_list() directly.

    YANG Description: List of BDs Active
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("bd_id",active_bd_list.active_bd_list, yang_name="active-bd-list", rest_name="active-bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-bd-list", rest_name="active-bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active_bd_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("bd_id",active_bd_list.active_bd_list, yang_name="active-bd-list", rest_name="active-bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-bd-list", rest_name="active-bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)""",
        })

    self.__active_bd_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active_bd_list(self):
    self.__active_bd_list = YANGDynClass(base=YANGListType("bd_id",active_bd_list.active_bd_list, yang_name="active-bd-list", rest_name="active-bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}), is_container='list', yang_name="active-bd-list", rest_name="active-bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-active-bds', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)


  def _get_peer_info_list(self):
    """
    Getter method for peer_info_list, mapped from YANG variable /mct_state/show_cluster/peer_info_list (list)

    YANG Description: Cluster Peer Info
    """
    return self.__peer_info_list
      
  def _set_peer_info_list(self, v, load=False):
    """
    Setter method for peer_info_list, mapped from YANG variable /mct_state/show_cluster/peer_info_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_info_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_info_list() directly.

    YANG Description: Cluster Peer Info
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peer_ip_addr",peer_info_list.peer_info_list, yang_name="peer-info-list", rest_name="peer-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip-addr', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="peer-info-list", rest_name="peer-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_info_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peer_ip_addr",peer_info_list.peer_info_list, yang_name="peer-info-list", rest_name="peer-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip-addr', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="peer-info-list", rest_name="peer-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)""",
        })

    self.__peer_info_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_info_list(self):
    self.__peer_info_list = YANGDynClass(base=YANGListType("peer_ip_addr",peer_info_list.peer_info_list, yang_name="peer-info-list", rest_name="peer-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip-addr', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="peer-info-list", rest_name="peer-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-peer-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)


  def _get_client_info_list(self):
    """
    Getter method for client_info_list, mapped from YANG variable /mct_state/show_cluster/client_info_list (list)

    YANG Description: Cluster Client Info
    """
    return self.__client_info_list
      
  def _set_client_info_list(self, v, load=False):
    """
    Setter method for client_info_list, mapped from YANG variable /mct_state/show_cluster/client_info_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_info_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_info_list() directly.

    YANG Description: Cluster Client Info
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("cluster_id client_id",client_info_list.client_info_list, yang_name="client-info-list", rest_name="client-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="client-info-list", rest_name="client-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_info_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("cluster_id client_id",client_info_list.client_info_list, yang_name="client-info-list", rest_name="client-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="client-info-list", rest_name="client-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)""",
        })

    self.__client_info_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_info_list(self):
    self.__client_info_list = YANGDynClass(base=YANGListType("cluster_id client_id",client_info_list.client_info_list, yang_name="client-info-list", rest_name="client-info-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cluster-id client-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}), is_container='list', yang_name="client-info-list", rest_name="client-info-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-client-info', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)


  def _get_config_vlan_list(self):
    """
    Getter method for config_vlan_list, mapped from YANG variable /mct_state/show_cluster/config_vlan_list (list)
    """
    return self.__config_vlan_list
      
  def _set_config_vlan_list(self, v, load=False):
    """
    Setter method for config_vlan_list, mapped from YANG variable /mct_state/show_cluster/config_vlan_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_vlan_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_vlan_list() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vlan_id",config_vlan_list.config_vlan_list, yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}), is_container='list', yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_vlan_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vlan_id",config_vlan_list.config_vlan_list, yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}), is_container='list', yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)""",
        })

    self.__config_vlan_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_vlan_list(self):
    self.__config_vlan_list = YANGDynClass(base=YANGListType("vlan_id",config_vlan_list.config_vlan_list, yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}), is_container='list', yang_name="config-vlan-list", rest_name="config-vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-config-vlan-config-vlan-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)


  def _get_bd_list(self):
    """
    Getter method for bd_list, mapped from YANG variable /mct_state/show_cluster/bd_list (list)
    """
    return self.__bd_list
      
  def _set_bd_list(self, v, load=False):
    """
    Setter method for bd_list, mapped from YANG variable /mct_state/show_cluster/bd_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bd_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bd_list() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("bd_id",bd_list.bd_list, yang_name="bd-list", rest_name="bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}), is_container='list', yang_name="bd-list", rest_name="bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bd_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("bd_id",bd_list.bd_list, yang_name="bd-list", rest_name="bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}), is_container='list', yang_name="bd-list", rest_name="bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)""",
        })

    self.__bd_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bd_list(self):
    self.__bd_list = YANGDynClass(base=YANGListType("bd_id",bd_list.bd_list, yang_name="bd-list", rest_name="bd-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bd-id', extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}), is_container='list', yang_name="bd-list", rest_name="bd-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'nsm-show-cluster-bds-bd-list-2'}}, namespace='urn:brocade.com:mgmt:brocade-nsm-operational', defining_module='brocade-nsm-operational', yang_type='list', is_config=False)

  cluster_id = __builtin__.property(_get_cluster_id)
  is_cluster_client_command = __builtin__.property(_get_is_cluster_client_command)
  cluster_name = __builtin__.property(_get_cluster_name)
  cluster_status = __builtin__.property(_get_cluster_status)
  client_isolation_status = __builtin__.property(_get_client_isolation_status)
  num_peers = __builtin__.property(_get_num_peers)
  num_clients = __builtin__.property(_get_num_clients)
  num_config_vlans = __builtin__.property(_get_num_config_vlans)
  num_active_vlans = __builtin__.property(_get_num_active_vlans)
  num_bds = __builtin__.property(_get_num_bds)
  num_active_bds = __builtin__.property(_get_num_active_bds)
  client_interfaces_shutdown = __builtin__.property(_get_client_interfaces_shutdown)
  active_vlan_list = __builtin__.property(_get_active_vlan_list)
  active_bd_list = __builtin__.property(_get_active_bd_list)
  peer_info_list = __builtin__.property(_get_peer_info_list)
  client_info_list = __builtin__.property(_get_client_info_list)
  config_vlan_list = __builtin__.property(_get_config_vlan_list)
  bd_list = __builtin__.property(_get_bd_list)


  _pyangbind_elements = {'cluster_id': cluster_id, 'is_cluster_client_command': is_cluster_client_command, 'cluster_name': cluster_name, 'cluster_status': cluster_status, 'client_isolation_status': client_isolation_status, 'num_peers': num_peers, 'num_clients': num_clients, 'num_config_vlans': num_config_vlans, 'num_active_vlans': num_active_vlans, 'num_bds': num_bds, 'num_active_bds': num_active_bds, 'client_interfaces_shutdown': client_interfaces_shutdown, 'active_vlan_list': active_vlan_list, 'active_bd_list': active_bd_list, 'peer_info_list': peer_info_list, 'client_info_list': client_info_list, 'config_vlan_list': config_vlan_list, 'bd_list': bd_list, }


