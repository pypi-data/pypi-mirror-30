
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class show_nameserver(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-nameserver - based on the path /brocade_nameserver_rpc/get-nameserver-detail/output/show-nameserver. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of all Nx_Ports registered in the
Name Server database of this managed
device. Each row represents a FC device
(Nx_Port) logged in and registered with the
Name Server.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__nameserver_portid','__nameserver_portname','__nameserver_nodename','__nameserver_scr','__nameserver_fc4s','__nameserver_portsymb','__nameserver_nodesymb','__nameserver_fabric_portname','__nameserver_permanent_portname','__nameserver_devicetype','__nameserver_index','__nameserver_porttype','__nameserver_cos','__nameserver_sharearea','__nameserver_redirect','__nameserver_xlatedomain','__nameserver_connected_via_ag','__nameserver_ag_base_device','__nameserver_real','__nameserver_cascaded',)

  _yang_name = 'show-nameserver'
  _rest_name = 'show-nameserver'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__nameserver_portid = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]*', 'length': [u'6']}), is_leaf=True, yang_name="nameserver-portid", rest_name="nameserver-portid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port ID'}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-portid-type', is_config=True)
    self.__nameserver_nodename = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-nodename", rest_name="nameserver-nodename", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'node name / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)
    self.__nameserver_ag_base_device = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-ag-base-device", rest_name="nameserver-ag-base-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Base AG Device'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-ag-base-device-type', is_config=True)
    self.__nameserver_permanent_portname = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-permanent-portname", rest_name="nameserver-permanent-portname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'permanent portname / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)
    self.__nameserver_portsymb = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0..256']}), is_leaf=True, yang_name="nameserver-portsymb", rest_name="nameserver-portsymb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port symbolic name'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-symbolic-name-type', is_config=True)
    self.__nameserver_redirect = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-redirect", rest_name="nameserver-redirect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Frame Redirection'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-redirect-type', is_config=True)
    self.__nameserver_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nameserver-index", rest_name="nameserver-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'index number'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='uint32', is_config=True)
    self.__nameserver_fabric_portname = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-fabric-portname", rest_name="nameserver-fabric-portname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'fabric port name / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)
    self.__nameserver_fc4s = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'none|FCP|IPFC', 'length': [u'0..16']}), is_leaf=True, yang_name="nameserver-fc4s", rest_name="nameserver-fc4s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'FC4s'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-fc4s-type', is_config=True)
    self.__nameserver_sharearea = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-sharearea", rest_name="nameserver-sharearea", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'if yes, then this is a share area'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-sharearea-type', is_config=True)
    self.__nameserver_cos = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'F|1|2|3|,', 'length': [u'0..8']}), is_leaf=True, yang_name="nameserver-cos", rest_name="nameserver-cos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'class of service'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-cos-type', is_config=True)
    self.__nameserver_porttype = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'U|N|NL|NX|F|FL|[0][x][0-9a-fA-F]*', 'length': [u'0..8']}), is_leaf=True, yang_name="nameserver-porttype", rest_name="nameserver-porttype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port type'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-porttype-type', is_config=True)
    self.__nameserver_connected_via_ag = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-connected-via-ag", rest_name="nameserver-connected-via-ag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Connected Via AG'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-connected-via-ag-type', is_config=True)
    self.__nameserver_devicetype = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Undefined|Unknown(initiator/target)|\n                    Physical Initiator|NPIV Initiator|\n                    Virtual Initiator|iSCSI Initiator|Physical Target|\n                    NPIV Target|Virtual Target|iSCSI Target|\n                    Physical Initiator+Target|NPIV Initiator+Target|\n                    Virtual Initiator+Target|iSCSI Initiator+Target', 'length': [u'0..64']}), is_leaf=True, yang_name="nameserver-devicetype", rest_name="nameserver-devicetype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'device type'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-devicetype-type', is_config=True)
    self.__nameserver_nodesymb = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0..256']}), is_leaf=True, yang_name="nameserver-nodesymb", rest_name="nameserver-nodesymb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'node symbolic name'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-symbolic-name-type', is_config=True)
    self.__nameserver_scr = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nameserver-scr", rest_name="nameserver-scr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'SCR'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='uint32', is_config=True)
    self.__nameserver_real = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-real", rest_name="nameserver-real", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Real Device'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-real-type', is_config=True)
    self.__nameserver_xlatedomain = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-xlatedomain", rest_name="nameserver-xlatedomain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Translate domain'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-xlatedomain-type', is_config=True)
    self.__nameserver_portname = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-portname", rest_name="nameserver-portname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port name / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)
    self.__nameserver_cascaded = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-cascaded", rest_name="nameserver-cascaded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Connected Via Cascaded AG'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-cascaded-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'brocade_nameserver_rpc', u'get-nameserver-detail', u'output', u'show-nameserver']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'get-nameserver-detail', u'output', u'show-nameserver']

  def _get_nameserver_portid(self):
    """
    Getter method for nameserver_portid, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_portid (nameserver-portid-type)

    YANG Description: The Fibre Channel Address Identifier
of this Nx_Port.
    """
    return self.__nameserver_portid
      
  def _set_nameserver_portid(self, v, load=False):
    """
    Setter method for nameserver_portid, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_portid (nameserver-portid-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_portid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_portid() directly.

    YANG Description: The Fibre Channel Address Identifier
of this Nx_Port.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]*', 'length': [u'6']}), is_leaf=True, yang_name="nameserver-portid", rest_name="nameserver-portid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port ID'}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-portid-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_portid must be of a type compatible with nameserver-portid-type""",
          'defined-type': "brocade-nameserver:nameserver-portid-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]*', 'length': [u'6']}), is_leaf=True, yang_name="nameserver-portid", rest_name="nameserver-portid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port ID'}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-portid-type', is_config=True)""",
        })

    self.__nameserver_portid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_portid(self):
    self.__nameserver_portid = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]*', 'length': [u'6']}), is_leaf=True, yang_name="nameserver-portid", rest_name="nameserver-portid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port ID'}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-portid-type', is_config=True)


  def _get_nameserver_portname(self):
    """
    Getter method for nameserver_portname, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_portname (common-def:wwn-type)

    YANG Description: The Port_Name (WWN) of this Nx_Port.
    """
    return self.__nameserver_portname
      
  def _set_nameserver_portname(self, v, load=False):
    """
    Setter method for nameserver_portname, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_portname (common-def:wwn-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_portname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_portname() directly.

    YANG Description: The Port_Name (WWN) of this Nx_Port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-portname", rest_name="nameserver-portname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port name / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_portname must be of a type compatible with common-def:wwn-type""",
          'defined-type': "common-def:wwn-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-portname", rest_name="nameserver-portname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port name / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)""",
        })

    self.__nameserver_portname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_portname(self):
    self.__nameserver_portname = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-portname", rest_name="nameserver-portname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port name / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)


  def _get_nameserver_nodename(self):
    """
    Getter method for nameserver_nodename, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_nodename (common-def:wwn-type)

    YANG Description: The Node_Name (WWN) of this Nx_Port.
    """
    return self.__nameserver_nodename
      
  def _set_nameserver_nodename(self, v, load=False):
    """
    Setter method for nameserver_nodename, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_nodename (common-def:wwn-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_nodename is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_nodename() directly.

    YANG Description: The Node_Name (WWN) of this Nx_Port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-nodename", rest_name="nameserver-nodename", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'node name / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_nodename must be of a type compatible with common-def:wwn-type""",
          'defined-type': "common-def:wwn-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-nodename", rest_name="nameserver-nodename", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'node name / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)""",
        })

    self.__nameserver_nodename = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_nodename(self):
    self.__nameserver_nodename = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-nodename", rest_name="nameserver-nodename", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'node name / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)


  def _get_nameserver_scr(self):
    """
    Getter method for nameserver_scr, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_scr (uint32)

    YANG Description: Indicates the state change
notifications that the device has
registered for.
    """
    return self.__nameserver_scr
      
  def _set_nameserver_scr(self, v, load=False):
    """
    Setter method for nameserver_scr, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_scr (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_scr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_scr() directly.

    YANG Description: Indicates the state change
notifications that the device has
registered for.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nameserver-scr", rest_name="nameserver-scr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'SCR'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_scr must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nameserver-scr", rest_name="nameserver-scr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'SCR'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='uint32', is_config=True)""",
        })

    self.__nameserver_scr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_scr(self):
    self.__nameserver_scr = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nameserver-scr", rest_name="nameserver-scr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'SCR'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='uint32', is_config=True)


  def _get_nameserver_fc4s(self):
    """
    Getter method for nameserver_fc4s, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_fc4s (nameserver-fc4s-type)

    YANG Description: Indicates the Fibre Channel FC4
services supported by the device.
    """
    return self.__nameserver_fc4s
      
  def _set_nameserver_fc4s(self, v, load=False):
    """
    Setter method for nameserver_fc4s, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_fc4s (nameserver-fc4s-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_fc4s is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_fc4s() directly.

    YANG Description: Indicates the Fibre Channel FC4
services supported by the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'none|FCP|IPFC', 'length': [u'0..16']}), is_leaf=True, yang_name="nameserver-fc4s", rest_name="nameserver-fc4s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'FC4s'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-fc4s-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_fc4s must be of a type compatible with nameserver-fc4s-type""",
          'defined-type': "brocade-nameserver:nameserver-fc4s-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'none|FCP|IPFC', 'length': [u'0..16']}), is_leaf=True, yang_name="nameserver-fc4s", rest_name="nameserver-fc4s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'FC4s'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-fc4s-type', is_config=True)""",
        })

    self.__nameserver_fc4s = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_fc4s(self):
    self.__nameserver_fc4s = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'none|FCP|IPFC', 'length': [u'0..16']}), is_leaf=True, yang_name="nameserver-fc4s", rest_name="nameserver-fc4s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'FC4s'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-fc4s-type', is_config=True)


  def _get_nameserver_portsymb(self):
    """
    Getter method for nameserver_portsymb, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_portsymb (nameserver-symbolic-name-type)

    YANG Description: The user-defined name of this port.
    """
    return self.__nameserver_portsymb
      
  def _set_nameserver_portsymb(self, v, load=False):
    """
    Setter method for nameserver_portsymb, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_portsymb (nameserver-symbolic-name-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_portsymb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_portsymb() directly.

    YANG Description: The user-defined name of this port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0..256']}), is_leaf=True, yang_name="nameserver-portsymb", rest_name="nameserver-portsymb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port symbolic name'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-symbolic-name-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_portsymb must be of a type compatible with nameserver-symbolic-name-type""",
          'defined-type': "brocade-nameserver:nameserver-symbolic-name-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0..256']}), is_leaf=True, yang_name="nameserver-portsymb", rest_name="nameserver-portsymb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port symbolic name'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-symbolic-name-type', is_config=True)""",
        })

    self.__nameserver_portsymb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_portsymb(self):
    self.__nameserver_portsymb = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0..256']}), is_leaf=True, yang_name="nameserver-portsymb", rest_name="nameserver-portsymb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port symbolic name'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-symbolic-name-type', is_config=True)


  def _get_nameserver_nodesymb(self):
    """
    Getter method for nameserver_nodesymb, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_nodesymb (nameserver-symbolic-name-type)

    YANG Description: The user-defined name of the node of
this port.
    """
    return self.__nameserver_nodesymb
      
  def _set_nameserver_nodesymb(self, v, load=False):
    """
    Setter method for nameserver_nodesymb, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_nodesymb (nameserver-symbolic-name-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_nodesymb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_nodesymb() directly.

    YANG Description: The user-defined name of the node of
this port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0..256']}), is_leaf=True, yang_name="nameserver-nodesymb", rest_name="nameserver-nodesymb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'node symbolic name'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-symbolic-name-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_nodesymb must be of a type compatible with nameserver-symbolic-name-type""",
          'defined-type': "brocade-nameserver:nameserver-symbolic-name-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0..256']}), is_leaf=True, yang_name="nameserver-nodesymb", rest_name="nameserver-nodesymb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'node symbolic name'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-symbolic-name-type', is_config=True)""",
        })

    self.__nameserver_nodesymb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_nodesymb(self):
    self.__nameserver_nodesymb = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0..256']}), is_leaf=True, yang_name="nameserver-nodesymb", rest_name="nameserver-nodesymb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'node symbolic name'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-symbolic-name-type', is_config=True)


  def _get_nameserver_fabric_portname(self):
    """
    Getter method for nameserver_fabric_portname, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_fabric_portname (common-def:wwn-type)

    YANG Description: Indicates the fabric port name (WWN)
of this port.
    """
    return self.__nameserver_fabric_portname
      
  def _set_nameserver_fabric_portname(self, v, load=False):
    """
    Setter method for nameserver_fabric_portname, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_fabric_portname (common-def:wwn-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_fabric_portname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_fabric_portname() directly.

    YANG Description: Indicates the fabric port name (WWN)
of this port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-fabric-portname", rest_name="nameserver-fabric-portname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'fabric port name / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_fabric_portname must be of a type compatible with common-def:wwn-type""",
          'defined-type': "common-def:wwn-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-fabric-portname", rest_name="nameserver-fabric-portname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'fabric port name / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)""",
        })

    self.__nameserver_fabric_portname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_fabric_portname(self):
    self.__nameserver_fabric_portname = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-fabric-portname", rest_name="nameserver-fabric-portname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'fabric port name / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)


  def _get_nameserver_permanent_portname(self):
    """
    Getter method for nameserver_permanent_portname, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_permanent_portname (common-def:wwn-type)

    YANG Description: Indicates the permanent port name (WWN)
of this port.
    """
    return self.__nameserver_permanent_portname
      
  def _set_nameserver_permanent_portname(self, v, load=False):
    """
    Setter method for nameserver_permanent_portname, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_permanent_portname (common-def:wwn-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_permanent_portname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_permanent_portname() directly.

    YANG Description: Indicates the permanent port name (WWN)
of this port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-permanent-portname", rest_name="nameserver-permanent-portname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'permanent portname / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_permanent_portname must be of a type compatible with common-def:wwn-type""",
          'defined-type': "common-def:wwn-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-permanent-portname", rest_name="nameserver-permanent-portname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'permanent portname / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)""",
        })

    self.__nameserver_permanent_portname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_permanent_portname(self):
    self.__nameserver_permanent_portname = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]'}), is_leaf=True, yang_name="nameserver-permanent-portname", rest_name="nameserver-permanent-portname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'permanent portname / WWN'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='common-def:wwn-type', is_config=True)


  def _get_nameserver_devicetype(self):
    """
    Getter method for nameserver_devicetype, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_devicetype (nameserver-devicetype-type)

    YANG Description: Indicates the type and role of the
device.
    """
    return self.__nameserver_devicetype
      
  def _set_nameserver_devicetype(self, v, load=False):
    """
    Setter method for nameserver_devicetype, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_devicetype (nameserver-devicetype-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_devicetype is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_devicetype() directly.

    YANG Description: Indicates the type and role of the
device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Undefined|Unknown(initiator/target)|\n                    Physical Initiator|NPIV Initiator|\n                    Virtual Initiator|iSCSI Initiator|Physical Target|\n                    NPIV Target|Virtual Target|iSCSI Target|\n                    Physical Initiator+Target|NPIV Initiator+Target|\n                    Virtual Initiator+Target|iSCSI Initiator+Target', 'length': [u'0..64']}), is_leaf=True, yang_name="nameserver-devicetype", rest_name="nameserver-devicetype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'device type'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-devicetype-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_devicetype must be of a type compatible with nameserver-devicetype-type""",
          'defined-type': "brocade-nameserver:nameserver-devicetype-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Undefined|Unknown(initiator/target)|\n                    Physical Initiator|NPIV Initiator|\n                    Virtual Initiator|iSCSI Initiator|Physical Target|\n                    NPIV Target|Virtual Target|iSCSI Target|\n                    Physical Initiator+Target|NPIV Initiator+Target|\n                    Virtual Initiator+Target|iSCSI Initiator+Target', 'length': [u'0..64']}), is_leaf=True, yang_name="nameserver-devicetype", rest_name="nameserver-devicetype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'device type'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-devicetype-type', is_config=True)""",
        })

    self.__nameserver_devicetype = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_devicetype(self):
    self.__nameserver_devicetype = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Undefined|Unknown(initiator/target)|\n                    Physical Initiator|NPIV Initiator|\n                    Virtual Initiator|iSCSI Initiator|Physical Target|\n                    NPIV Target|Virtual Target|iSCSI Target|\n                    Physical Initiator+Target|NPIV Initiator+Target|\n                    Virtual Initiator+Target|iSCSI Initiator+Target', 'length': [u'0..64']}), is_leaf=True, yang_name="nameserver-devicetype", rest_name="nameserver-devicetype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'device type'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-devicetype-type', is_config=True)


  def _get_nameserver_index(self):
    """
    Getter method for nameserver_index, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_index (uint32)

    YANG Description: Indicates the port index number.
    """
    return self.__nameserver_index
      
  def _set_nameserver_index(self, v, load=False):
    """
    Setter method for nameserver_index, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_index() directly.

    YANG Description: Indicates the port index number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nameserver-index", rest_name="nameserver-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'index number'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nameserver-index", rest_name="nameserver-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'index number'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='uint32', is_config=True)""",
        })

    self.__nameserver_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_index(self):
    self.__nameserver_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nameserver-index", rest_name="nameserver-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'index number'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='uint32', is_config=True)


  def _get_nameserver_porttype(self):
    """
    Getter method for nameserver_porttype, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_porttype (nameserver-porttype-type)

    YANG Description: Indicates the Fibre Channel port
type.
    """
    return self.__nameserver_porttype
      
  def _set_nameserver_porttype(self, v, load=False):
    """
    Setter method for nameserver_porttype, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_porttype (nameserver-porttype-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_porttype is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_porttype() directly.

    YANG Description: Indicates the Fibre Channel port
type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'U|N|NL|NX|F|FL|[0][x][0-9a-fA-F]*', 'length': [u'0..8']}), is_leaf=True, yang_name="nameserver-porttype", rest_name="nameserver-porttype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port type'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-porttype-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_porttype must be of a type compatible with nameserver-porttype-type""",
          'defined-type': "brocade-nameserver:nameserver-porttype-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'U|N|NL|NX|F|FL|[0][x][0-9a-fA-F]*', 'length': [u'0..8']}), is_leaf=True, yang_name="nameserver-porttype", rest_name="nameserver-porttype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port type'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-porttype-type', is_config=True)""",
        })

    self.__nameserver_porttype = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_porttype(self):
    self.__nameserver_porttype = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'U|N|NL|NX|F|FL|[0][x][0-9a-fA-F]*', 'length': [u'0..8']}), is_leaf=True, yang_name="nameserver-porttype", rest_name="nameserver-porttype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'port type'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-porttype-type', is_config=True)


  def _get_nameserver_cos(self):
    """
    Getter method for nameserver_cos, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_cos (nameserver-cos-type)

    YANG Description: Indicates the Fibre Channel Class of
Service supported by the device.
    """
    return self.__nameserver_cos
      
  def _set_nameserver_cos(self, v, load=False):
    """
    Setter method for nameserver_cos, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_cos (nameserver-cos-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_cos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_cos() directly.

    YANG Description: Indicates the Fibre Channel Class of
Service supported by the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'F|1|2|3|,', 'length': [u'0..8']}), is_leaf=True, yang_name="nameserver-cos", rest_name="nameserver-cos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'class of service'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-cos-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_cos must be of a type compatible with nameserver-cos-type""",
          'defined-type': "brocade-nameserver:nameserver-cos-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'F|1|2|3|,', 'length': [u'0..8']}), is_leaf=True, yang_name="nameserver-cos", rest_name="nameserver-cos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'class of service'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-cos-type', is_config=True)""",
        })

    self.__nameserver_cos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_cos(self):
    self.__nameserver_cos = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'F|1|2|3|,', 'length': [u'0..8']}), is_leaf=True, yang_name="nameserver-cos", rest_name="nameserver-cos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'class of service'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-cos-type', is_config=True)


  def _get_nameserver_sharearea(self):
    """
    Getter method for nameserver_sharearea, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_sharearea (nameserver-sharearea-type)

    YANG Description: Indicates whether or not the port
utilizes the Brocade Shared Area method
of Fibre Channel addressing.
    """
    return self.__nameserver_sharearea
      
  def _set_nameserver_sharearea(self, v, load=False):
    """
    Setter method for nameserver_sharearea, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_sharearea (nameserver-sharearea-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_sharearea is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_sharearea() directly.

    YANG Description: Indicates whether or not the port
utilizes the Brocade Shared Area method
of Fibre Channel addressing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-sharearea", rest_name="nameserver-sharearea", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'if yes, then this is a share area'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-sharearea-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_sharearea must be of a type compatible with nameserver-sharearea-type""",
          'defined-type': "brocade-nameserver:nameserver-sharearea-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-sharearea", rest_name="nameserver-sharearea", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'if yes, then this is a share area'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-sharearea-type', is_config=True)""",
        })

    self.__nameserver_sharearea = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_sharearea(self):
    self.__nameserver_sharearea = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-sharearea", rest_name="nameserver-sharearea", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'if yes, then this is a share area'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-sharearea-type', is_config=True)


  def _get_nameserver_redirect(self):
    """
    Getter method for nameserver_redirect, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_redirect (nameserver-redirect-type)

    YANG Description: Indicates whether or not the device
is involved in Brocade Frame
Redirection zoning.
    """
    return self.__nameserver_redirect
      
  def _set_nameserver_redirect(self, v, load=False):
    """
    Setter method for nameserver_redirect, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_redirect (nameserver-redirect-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_redirect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_redirect() directly.

    YANG Description: Indicates whether or not the device
is involved in Brocade Frame
Redirection zoning.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-redirect", rest_name="nameserver-redirect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Frame Redirection'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-redirect-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_redirect must be of a type compatible with nameserver-redirect-type""",
          'defined-type': "brocade-nameserver:nameserver-redirect-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-redirect", rest_name="nameserver-redirect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Frame Redirection'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-redirect-type', is_config=True)""",
        })

    self.__nameserver_redirect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_redirect(self):
    self.__nameserver_redirect = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-redirect", rest_name="nameserver-redirect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Frame Redirection'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-redirect-type', is_config=True)


  def _get_nameserver_xlatedomain(self):
    """
    Getter method for nameserver_xlatedomain, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_xlatedomain (nameserver-xlatedomain-type)

    YANG Description: Indicates whether or not the device
enters the fabric via a translate
domain.
    """
    return self.__nameserver_xlatedomain
      
  def _set_nameserver_xlatedomain(self, v, load=False):
    """
    Setter method for nameserver_xlatedomain, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_xlatedomain (nameserver-xlatedomain-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_xlatedomain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_xlatedomain() directly.

    YANG Description: Indicates whether or not the device
enters the fabric via a translate
domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-xlatedomain", rest_name="nameserver-xlatedomain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Translate domain'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-xlatedomain-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_xlatedomain must be of a type compatible with nameserver-xlatedomain-type""",
          'defined-type': "brocade-nameserver:nameserver-xlatedomain-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-xlatedomain", rest_name="nameserver-xlatedomain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Translate domain'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-xlatedomain-type', is_config=True)""",
        })

    self.__nameserver_xlatedomain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_xlatedomain(self):
    self.__nameserver_xlatedomain = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-xlatedomain", rest_name="nameserver-xlatedomain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Translate domain'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-xlatedomain-type', is_config=True)


  def _get_nameserver_connected_via_ag(self):
    """
    Getter method for nameserver_connected_via_ag, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_connected_via_ag (nameserver-connected-via-ag-type)

    YANG Description: Indicates whether or not the device
enters the fabric via Access Gateway.
    """
    return self.__nameserver_connected_via_ag
      
  def _set_nameserver_connected_via_ag(self, v, load=False):
    """
    Setter method for nameserver_connected_via_ag, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_connected_via_ag (nameserver-connected-via-ag-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_connected_via_ag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_connected_via_ag() directly.

    YANG Description: Indicates whether or not the device
enters the fabric via Access Gateway.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-connected-via-ag", rest_name="nameserver-connected-via-ag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Connected Via AG'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-connected-via-ag-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_connected_via_ag must be of a type compatible with nameserver-connected-via-ag-type""",
          'defined-type': "brocade-nameserver:nameserver-connected-via-ag-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-connected-via-ag", rest_name="nameserver-connected-via-ag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Connected Via AG'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-connected-via-ag-type', is_config=True)""",
        })

    self.__nameserver_connected_via_ag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_connected_via_ag(self):
    self.__nameserver_connected_via_ag = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-connected-via-ag", rest_name="nameserver-connected-via-ag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Connected Via AG'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-connected-via-ag-type', is_config=True)


  def _get_nameserver_ag_base_device(self):
    """
    Getter method for nameserver_ag_base_device, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_ag_base_device (nameserver-ag-base-device-type)

    YANG Description: Indicates whether or not the device  
is a Base Access Gateway Device.
    """
    return self.__nameserver_ag_base_device
      
  def _set_nameserver_ag_base_device(self, v, load=False):
    """
    Setter method for nameserver_ag_base_device, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_ag_base_device (nameserver-ag-base-device-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_ag_base_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_ag_base_device() directly.

    YANG Description: Indicates whether or not the device  
is a Base Access Gateway Device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-ag-base-device", rest_name="nameserver-ag-base-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Base AG Device'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-ag-base-device-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_ag_base_device must be of a type compatible with nameserver-ag-base-device-type""",
          'defined-type': "brocade-nameserver:nameserver-ag-base-device-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-ag-base-device", rest_name="nameserver-ag-base-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Base AG Device'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-ag-base-device-type', is_config=True)""",
        })

    self.__nameserver_ag_base_device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_ag_base_device(self):
    self.__nameserver_ag_base_device = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-ag-base-device", rest_name="nameserver-ag-base-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Base AG Device'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-ag-base-device-type', is_config=True)


  def _get_nameserver_real(self):
    """
    Getter method for nameserver_real, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_real (nameserver-real-type)

    YANG Description: Indicates whether or not the device
entered in the fabric via AG is a 
Physical Device.
    """
    return self.__nameserver_real
      
  def _set_nameserver_real(self, v, load=False):
    """
    Setter method for nameserver_real, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_real (nameserver-real-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_real is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_real() directly.

    YANG Description: Indicates whether or not the device
entered in the fabric via AG is a 
Physical Device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-real", rest_name="nameserver-real", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Real Device'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-real-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_real must be of a type compatible with nameserver-real-type""",
          'defined-type': "brocade-nameserver:nameserver-real-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-real", rest_name="nameserver-real", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Real Device'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-real-type', is_config=True)""",
        })

    self.__nameserver_real = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_real(self):
    self.__nameserver_real = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-real", rest_name="nameserver-real", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Real Device'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-real-type', is_config=True)


  def _get_nameserver_cascaded(self):
    """
    Getter method for nameserver_cascaded, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_cascaded (nameserver-cascaded-type)

    YANG Description: Indicates whether or not the device
enters the fabric via a Cascaded AG.
    """
    return self.__nameserver_cascaded
      
  def _set_nameserver_cascaded(self, v, load=False):
    """
    Setter method for nameserver_cascaded, mapped from YANG variable /brocade_nameserver_rpc/get_nameserver_detail/output/show_nameserver/nameserver_cascaded (nameserver-cascaded-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nameserver_cascaded is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nameserver_cascaded() directly.

    YANG Description: Indicates whether or not the device
enters the fabric via a Cascaded AG.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-cascaded", rest_name="nameserver-cascaded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Connected Via Cascaded AG'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-cascaded-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nameserver_cascaded must be of a type compatible with nameserver-cascaded-type""",
          'defined-type': "brocade-nameserver:nameserver-cascaded-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-cascaded", rest_name="nameserver-cascaded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Connected Via Cascaded AG'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-cascaded-type', is_config=True)""",
        })

    self.__nameserver_cascaded = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nameserver_cascaded(self):
    self.__nameserver_cascaded = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'Yes|No', 'length': [u'0..3']}), is_leaf=True, yang_name="nameserver-cascaded", rest_name="nameserver-cascaded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, extensions={u'tailf-common': {u'info': u'Connected Via Cascaded AG'}}, namespace='urn:brocade.com:mgmt:brocade-nameserver', defining_module='brocade-nameserver', yang_type='nameserver-cascaded-type', is_config=True)

  nameserver_portid = __builtin__.property(_get_nameserver_portid, _set_nameserver_portid)
  nameserver_portname = __builtin__.property(_get_nameserver_portname, _set_nameserver_portname)
  nameserver_nodename = __builtin__.property(_get_nameserver_nodename, _set_nameserver_nodename)
  nameserver_scr = __builtin__.property(_get_nameserver_scr, _set_nameserver_scr)
  nameserver_fc4s = __builtin__.property(_get_nameserver_fc4s, _set_nameserver_fc4s)
  nameserver_portsymb = __builtin__.property(_get_nameserver_portsymb, _set_nameserver_portsymb)
  nameserver_nodesymb = __builtin__.property(_get_nameserver_nodesymb, _set_nameserver_nodesymb)
  nameserver_fabric_portname = __builtin__.property(_get_nameserver_fabric_portname, _set_nameserver_fabric_portname)
  nameserver_permanent_portname = __builtin__.property(_get_nameserver_permanent_portname, _set_nameserver_permanent_portname)
  nameserver_devicetype = __builtin__.property(_get_nameserver_devicetype, _set_nameserver_devicetype)
  nameserver_index = __builtin__.property(_get_nameserver_index, _set_nameserver_index)
  nameserver_porttype = __builtin__.property(_get_nameserver_porttype, _set_nameserver_porttype)
  nameserver_cos = __builtin__.property(_get_nameserver_cos, _set_nameserver_cos)
  nameserver_sharearea = __builtin__.property(_get_nameserver_sharearea, _set_nameserver_sharearea)
  nameserver_redirect = __builtin__.property(_get_nameserver_redirect, _set_nameserver_redirect)
  nameserver_xlatedomain = __builtin__.property(_get_nameserver_xlatedomain, _set_nameserver_xlatedomain)
  nameserver_connected_via_ag = __builtin__.property(_get_nameserver_connected_via_ag, _set_nameserver_connected_via_ag)
  nameserver_ag_base_device = __builtin__.property(_get_nameserver_ag_base_device, _set_nameserver_ag_base_device)
  nameserver_real = __builtin__.property(_get_nameserver_real, _set_nameserver_real)
  nameserver_cascaded = __builtin__.property(_get_nameserver_cascaded, _set_nameserver_cascaded)


  _pyangbind_elements = {'nameserver_portid': nameserver_portid, 'nameserver_portname': nameserver_portname, 'nameserver_nodename': nameserver_nodename, 'nameserver_scr': nameserver_scr, 'nameserver_fc4s': nameserver_fc4s, 'nameserver_portsymb': nameserver_portsymb, 'nameserver_nodesymb': nameserver_nodesymb, 'nameserver_fabric_portname': nameserver_fabric_portname, 'nameserver_permanent_portname': nameserver_permanent_portname, 'nameserver_devicetype': nameserver_devicetype, 'nameserver_index': nameserver_index, 'nameserver_porttype': nameserver_porttype, 'nameserver_cos': nameserver_cos, 'nameserver_sharearea': nameserver_sharearea, 'nameserver_redirect': nameserver_redirect, 'nameserver_xlatedomain': nameserver_xlatedomain, 'nameserver_connected_via_ag': nameserver_connected_via_ag, 'nameserver_ag_base_device': nameserver_ag_base_device, 'nameserver_real': nameserver_real, 'nameserver_cascaded': nameserver_cascaded, }


