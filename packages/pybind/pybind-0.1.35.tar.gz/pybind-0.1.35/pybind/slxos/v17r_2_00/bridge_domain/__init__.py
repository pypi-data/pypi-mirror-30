
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import peer
import router_interface
import logical_interface
import ip
import mac_address
import suppress_arp
import suppress_nd
class bridge_domain(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-bridge-domain - based on the path /bridge-domain. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__bridge_domain_id','__bridge_domain_type','__vc_id_num','__description','__peer','__statistics','__router_interface','__logical_interface','__pw_profile_name','__bpdu_drop_enable','__local_switching','__ip','__mac_address','__suppress_arp','__suppress_nd',)

  _yang_name = 'bridge-domain'
  _rest_name = 'bridge-domain'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__suppress_nd = YANGDynClass(base=suppress_nd.suppress_nd, is_container='container', presence=False, yang_name="suppress-nd", rest_name="suppress-nd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure ND suppression'}}, namespace='urn:brocade.com:mgmt:brocade-ipv6-nd-ra', defining_module='brocade-ipv6-nd-ra', yang_type='container', is_config=True)
    self.__statistics = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="statistics", rest_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Statistics', u'alt-name': u'statistics'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='empty', is_config=True)
    self.__logical_interface = YANGDynClass(base=logical_interface.logical_interface, is_container='container', presence=False, yang_name="logical-interface", rest_name="logical-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Bind a logical interface to this Bridge Domain'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='container', is_config=True)
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. 63']}), is_leaf=True, yang_name="description", rest_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Bridge domain specific description', u'cli-multi-value': None}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='string', is_config=True)
    self.__vc_id_num = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..4294967295']}), is_leaf=True, yang_name="vc-id-num", rest_name="vc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VC Id under the VPLS Instance', u'alt-name': u'vc-id'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='uint32', is_config=True)
    self.__ip = YANGDynClass(base=ip.ip, is_container='container', presence=False, yang_name="ip", rest_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IP).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_INTERFACE_LEVEL_IP_CONFIG', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='container', is_config=True)
    self.__mac_address = YANGDynClass(base=mac_address.mac_address, is_container='container', presence=False, yang_name="mac-address", rest_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC Address'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='container', is_config=True)
    self.__bridge_domain_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..8191']}), is_leaf=True, yang_name="bridge-domain-id", rest_name="bridge-domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='bridge-domain-id-type', is_config=True)
    self.__router_interface = YANGDynClass(base=YANGListType("router_ve",router_interface.router_interface, yang_name="router-interface", rest_name="router-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-ve', extensions={u'tailf-common': {u'info': u'Bind a router-interface to this Bridge Domain', u'cli-full-command': None, u'callpoint': u'BDRouterVe'}}), is_container='list', yang_name="router-interface", rest_name="router-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Bind a router-interface to this Bridge Domain', u'cli-full-command': None, u'callpoint': u'BDRouterVe'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)
    self.__bpdu_drop_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bpdu-drop-enable", rest_name="bpdu-drop-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Drop BPDU packets', u'alt-name': u'bpdu-drop-enable'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='empty', is_config=True)
    self.__bridge_domain_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'p2mp': {'value': 1}, u'p2p': {'value': 2}},), is_leaf=True, yang_name="bridge-domain-type", rest_name="bridge-domain-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Set the Bridge Domain Type', u'key-default': u'p2mp'}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='enumeration', is_config=True)
    self.__peer = YANGDynClass(base=YANGListType("peer_ip",peer.peer, yang_name="peer", rest_name="peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip', extensions={u'tailf-common': {u'info': u'PW Peer related configuration', u'cli-suppress-mode': None, u'cli-compact-syntax': None, u'callpoint': u'BridgeDomainPeerCallpoint', u'cli-full-no': None}}), is_container='list', yang_name="peer", rest_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'PW Peer related configuration', u'cli-suppress-mode': None, u'cli-compact-syntax': None, u'callpoint': u'BridgeDomainPeerCallpoint', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)
    self.__pw_profile_name = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[a-zA-Z]{1}([-a-zA-Z0-9\\.\\\\\\\\@#\\+\\*\\(\\)=\\{~\\}%<>=$_\\[\\]\\|]{0,63})'}), is_leaf=True, yang_name="pw-profile-name", rest_name="pw-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Pw-profile name (Max Size - 64)', u'alt-name': u'pw-profile'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='common-def:name-string64', is_config=True)
    self.__suppress_arp = YANGDynClass(base=suppress_arp.suppress_arp, is_container='container', presence=False, yang_name="suppress-arp", rest_name="suppress-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure ARP suppression'}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='container', is_config=True)
    self.__local_switching = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="local-switching", rest_name="local-switching", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure local switching', u'alt-name': u'local-switching'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='empty', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'bridge-domain']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'bridge-domain']

  def _get_bridge_domain_id(self):
    """
    Getter method for bridge_domain_id, mapped from YANG variable /bridge_domain/bridge_domain_id (bridge-domain-id-type)

    YANG Description: The definition for specifying a bridge-domain  identifier.
    """
    return self.__bridge_domain_id
      
  def _set_bridge_domain_id(self, v, load=False):
    """
    Setter method for bridge_domain_id, mapped from YANG variable /bridge_domain/bridge_domain_id (bridge-domain-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bridge_domain_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bridge_domain_id() directly.

    YANG Description: The definition for specifying a bridge-domain  identifier.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..8191']}), is_leaf=True, yang_name="bridge-domain-id", rest_name="bridge-domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='bridge-domain-id-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bridge_domain_id must be of a type compatible with bridge-domain-id-type""",
          'defined-type': "brocade-bridge-domain:bridge-domain-id-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..8191']}), is_leaf=True, yang_name="bridge-domain-id", rest_name="bridge-domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='bridge-domain-id-type', is_config=True)""",
        })

    self.__bridge_domain_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bridge_domain_id(self):
    self.__bridge_domain_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..8191']}), is_leaf=True, yang_name="bridge-domain-id", rest_name="bridge-domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-drop-node-name': None}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='bridge-domain-id-type', is_config=True)


  def _get_bridge_domain_type(self):
    """
    Getter method for bridge_domain_type, mapped from YANG variable /bridge_domain/bridge_domain_type (enumeration)

    YANG Description: This leaf specifies Bridge Domain Type.
    """
    return self.__bridge_domain_type
      
  def _set_bridge_domain_type(self, v, load=False):
    """
    Setter method for bridge_domain_type, mapped from YANG variable /bridge_domain/bridge_domain_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bridge_domain_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bridge_domain_type() directly.

    YANG Description: This leaf specifies Bridge Domain Type.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'p2mp': {'value': 1}, u'p2p': {'value': 2}},), is_leaf=True, yang_name="bridge-domain-type", rest_name="bridge-domain-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Set the Bridge Domain Type', u'key-default': u'p2mp'}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bridge_domain_type must be of a type compatible with enumeration""",
          'defined-type': "brocade-bridge-domain:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'p2mp': {'value': 1}, u'p2p': {'value': 2}},), is_leaf=True, yang_name="bridge-domain-type", rest_name="bridge-domain-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Set the Bridge Domain Type', u'key-default': u'p2mp'}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='enumeration', is_config=True)""",
        })

    self.__bridge_domain_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bridge_domain_type(self):
    self.__bridge_domain_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'p2mp': {'value': 1}, u'p2p': {'value': 2}},), is_leaf=True, yang_name="bridge-domain-type", rest_name="bridge-domain-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Set the Bridge Domain Type', u'key-default': u'p2mp'}}, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='enumeration', is_config=True)


  def _get_vc_id_num(self):
    """
    Getter method for vc_id_num, mapped from YANG variable /bridge_domain/vc_id_num (uint32)

    YANG Description: The leaf specifies the VC-ID under bridge-domain.
    """
    return self.__vc_id_num
      
  def _set_vc_id_num(self, v, load=False):
    """
    Setter method for vc_id_num, mapped from YANG variable /bridge_domain/vc_id_num (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vc_id_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vc_id_num() directly.

    YANG Description: The leaf specifies the VC-ID under bridge-domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..4294967295']}), is_leaf=True, yang_name="vc-id-num", rest_name="vc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VC Id under the VPLS Instance', u'alt-name': u'vc-id'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vc_id_num must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..4294967295']}), is_leaf=True, yang_name="vc-id-num", rest_name="vc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VC Id under the VPLS Instance', u'alt-name': u'vc-id'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='uint32', is_config=True)""",
        })

    self.__vc_id_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vc_id_num(self):
    self.__vc_id_num = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..4294967295']}), is_leaf=True, yang_name="vc-id-num", rest_name="vc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VC Id under the VPLS Instance', u'alt-name': u'vc-id'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='uint32', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /bridge_domain/description (string)
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /bridge_domain/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. 63']}), is_leaf=True, yang_name="description", rest_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Bridge domain specific description', u'cli-multi-value': None}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. 63']}), is_leaf=True, yang_name="description", rest_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Bridge domain specific description', u'cli-multi-value': None}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. 63']}), is_leaf=True, yang_name="description", rest_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Bridge domain specific description', u'cli-multi-value': None}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='string', is_config=True)


  def _get_peer(self):
    """
    Getter method for peer, mapped from YANG variable /bridge_domain/peer (list)
    """
    return self.__peer
      
  def _set_peer(self, v, load=False):
    """
    Setter method for peer, mapped from YANG variable /bridge_domain/peer (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peer_ip",peer.peer, yang_name="peer", rest_name="peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip', extensions={u'tailf-common': {u'info': u'PW Peer related configuration', u'cli-suppress-mode': None, u'cli-compact-syntax': None, u'callpoint': u'BridgeDomainPeerCallpoint', u'cli-full-no': None}}), is_container='list', yang_name="peer", rest_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'PW Peer related configuration', u'cli-suppress-mode': None, u'cli-compact-syntax': None, u'callpoint': u'BridgeDomainPeerCallpoint', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peer_ip",peer.peer, yang_name="peer", rest_name="peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip', extensions={u'tailf-common': {u'info': u'PW Peer related configuration', u'cli-suppress-mode': None, u'cli-compact-syntax': None, u'callpoint': u'BridgeDomainPeerCallpoint', u'cli-full-no': None}}), is_container='list', yang_name="peer", rest_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'PW Peer related configuration', u'cli-suppress-mode': None, u'cli-compact-syntax': None, u'callpoint': u'BridgeDomainPeerCallpoint', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)""",
        })

    self.__peer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer(self):
    self.__peer = YANGDynClass(base=YANGListType("peer_ip",peer.peer, yang_name="peer", rest_name="peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip', extensions={u'tailf-common': {u'info': u'PW Peer related configuration', u'cli-suppress-mode': None, u'cli-compact-syntax': None, u'callpoint': u'BridgeDomainPeerCallpoint', u'cli-full-no': None}}), is_container='list', yang_name="peer", rest_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'PW Peer related configuration', u'cli-suppress-mode': None, u'cli-compact-syntax': None, u'callpoint': u'BridgeDomainPeerCallpoint', u'cli-full-no': None}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)


  def _get_statistics(self):
    """
    Getter method for statistics, mapped from YANG variable /bridge_domain/statistics (empty)

    YANG Description: Enable Statistics on Bridge-domain
    """
    return self.__statistics
      
  def _set_statistics(self, v, load=False):
    """
    Setter method for statistics, mapped from YANG variable /bridge_domain/statistics (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistics() directly.

    YANG Description: Enable Statistics on Bridge-domain
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="statistics", rest_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Statistics', u'alt-name': u'statistics'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistics must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="statistics", rest_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Statistics', u'alt-name': u'statistics'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='empty', is_config=True)""",
        })

    self.__statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistics(self):
    self.__statistics = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="statistics", rest_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure Statistics', u'alt-name': u'statistics'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='empty', is_config=True)


  def _get_router_interface(self):
    """
    Getter method for router_interface, mapped from YANG variable /bridge_domain/router_interface (list)
    """
    return self.__router_interface
      
  def _set_router_interface(self, v, load=False):
    """
    Setter method for router_interface, mapped from YANG variable /bridge_domain/router_interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_interface() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("router_ve",router_interface.router_interface, yang_name="router-interface", rest_name="router-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-ve', extensions={u'tailf-common': {u'info': u'Bind a router-interface to this Bridge Domain', u'cli-full-command': None, u'callpoint': u'BDRouterVe'}}), is_container='list', yang_name="router-interface", rest_name="router-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Bind a router-interface to this Bridge Domain', u'cli-full-command': None, u'callpoint': u'BDRouterVe'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("router_ve",router_interface.router_interface, yang_name="router-interface", rest_name="router-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-ve', extensions={u'tailf-common': {u'info': u'Bind a router-interface to this Bridge Domain', u'cli-full-command': None, u'callpoint': u'BDRouterVe'}}), is_container='list', yang_name="router-interface", rest_name="router-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Bind a router-interface to this Bridge Domain', u'cli-full-command': None, u'callpoint': u'BDRouterVe'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)""",
        })

    self.__router_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_interface(self):
    self.__router_interface = YANGDynClass(base=YANGListType("router_ve",router_interface.router_interface, yang_name="router-interface", rest_name="router-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-ve', extensions={u'tailf-common': {u'info': u'Bind a router-interface to this Bridge Domain', u'cli-full-command': None, u'callpoint': u'BDRouterVe'}}), is_container='list', yang_name="router-interface", rest_name="router-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Bind a router-interface to this Bridge Domain', u'cli-full-command': None, u'callpoint': u'BDRouterVe'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='list', is_config=True)


  def _get_logical_interface(self):
    """
    Getter method for logical_interface, mapped from YANG variable /bridge_domain/logical_interface (container)
    """
    return self.__logical_interface
      
  def _set_logical_interface(self, v, load=False):
    """
    Setter method for logical_interface, mapped from YANG variable /bridge_domain/logical_interface (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_interface() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=logical_interface.logical_interface, is_container='container', presence=False, yang_name="logical-interface", rest_name="logical-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Bind a logical interface to this Bridge Domain'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_interface must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logical_interface.logical_interface, is_container='container', presence=False, yang_name="logical-interface", rest_name="logical-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Bind a logical interface to this Bridge Domain'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='container', is_config=True)""",
        })

    self.__logical_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_interface(self):
    self.__logical_interface = YANGDynClass(base=logical_interface.logical_interface, is_container='container', presence=False, yang_name="logical-interface", rest_name="logical-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Bind a logical interface to this Bridge Domain'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='container', is_config=True)


  def _get_pw_profile_name(self):
    """
    Getter method for pw_profile_name, mapped from YANG variable /bridge_domain/pw_profile_name (common-def:name-string64)

    YANG Description: Configure PW profile name
    """
    return self.__pw_profile_name
      
  def _set_pw_profile_name(self, v, load=False):
    """
    Setter method for pw_profile_name, mapped from YANG variable /bridge_domain/pw_profile_name (common-def:name-string64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pw_profile_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pw_profile_name() directly.

    YANG Description: Configure PW profile name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[a-zA-Z]{1}([-a-zA-Z0-9\\.\\\\\\\\@#\\+\\*\\(\\)=\\{~\\}%<>=$_\\[\\]\\|]{0,63})'}), is_leaf=True, yang_name="pw-profile-name", rest_name="pw-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Pw-profile name (Max Size - 64)', u'alt-name': u'pw-profile'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='common-def:name-string64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pw_profile_name must be of a type compatible with common-def:name-string64""",
          'defined-type': "common-def:name-string64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[a-zA-Z]{1}([-a-zA-Z0-9\\.\\\\\\\\@#\\+\\*\\(\\)=\\{~\\}%<>=$_\\[\\]\\|]{0,63})'}), is_leaf=True, yang_name="pw-profile-name", rest_name="pw-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Pw-profile name (Max Size - 64)', u'alt-name': u'pw-profile'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='common-def:name-string64', is_config=True)""",
        })

    self.__pw_profile_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pw_profile_name(self):
    self.__pw_profile_name = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[a-zA-Z]{1}([-a-zA-Z0-9\\.\\\\\\\\@#\\+\\*\\(\\)=\\{~\\}%<>=$_\\[\\]\\|]{0,63})'}), is_leaf=True, yang_name="pw-profile-name", rest_name="pw-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Pw-profile name (Max Size - 64)', u'alt-name': u'pw-profile'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='common-def:name-string64', is_config=True)


  def _get_bpdu_drop_enable(self):
    """
    Getter method for bpdu_drop_enable, mapped from YANG variable /bridge_domain/bpdu_drop_enable (empty)

    YANG Description: Drop forwarding L2 protocol BPDU packets on end-points
    """
    return self.__bpdu_drop_enable
      
  def _set_bpdu_drop_enable(self, v, load=False):
    """
    Setter method for bpdu_drop_enable, mapped from YANG variable /bridge_domain/bpdu_drop_enable (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bpdu_drop_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bpdu_drop_enable() directly.

    YANG Description: Drop forwarding L2 protocol BPDU packets on end-points
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bpdu-drop-enable", rest_name="bpdu-drop-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Drop BPDU packets', u'alt-name': u'bpdu-drop-enable'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bpdu_drop_enable must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bpdu-drop-enable", rest_name="bpdu-drop-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Drop BPDU packets', u'alt-name': u'bpdu-drop-enable'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='empty', is_config=True)""",
        })

    self.__bpdu_drop_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bpdu_drop_enable(self):
    self.__bpdu_drop_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bpdu-drop-enable", rest_name="bpdu-drop-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Drop BPDU packets', u'alt-name': u'bpdu-drop-enable'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='empty', is_config=True)


  def _get_local_switching(self):
    """
    Getter method for local_switching, mapped from YANG variable /bridge_domain/local_switching (empty)

    YANG Description: Enable local switching on Bridge-domain
    """
    return self.__local_switching
      
  def _set_local_switching(self, v, load=False):
    """
    Setter method for local_switching, mapped from YANG variable /bridge_domain/local_switching (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_switching is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_switching() directly.

    YANG Description: Enable local switching on Bridge-domain
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="local-switching", rest_name="local-switching", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure local switching', u'alt-name': u'local-switching'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_switching must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="local-switching", rest_name="local-switching", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure local switching', u'alt-name': u'local-switching'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='empty', is_config=True)""",
        })

    self.__local_switching = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_switching(self):
    self.__local_switching = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="local-switching", rest_name="local-switching", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure local switching', u'alt-name': u'local-switching'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='empty', is_config=True)


  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /bridge_domain/ip (container)

    YANG Description: The IP configurations for an interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /bridge_domain/ip (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IP configurations for an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ip.ip, is_container='container', presence=False, yang_name="ip", rest_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IP).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_INTERFACE_LEVEL_IP_CONFIG', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ip.ip, is_container='container', presence=False, yang_name="ip", rest_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IP).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_INTERFACE_LEVEL_IP_CONFIG', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='container', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=ip.ip, is_container='container', presence=False, yang_name="ip", rest_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'The Internet Protocol (IP).', u'cli-incomplete-no': None, u'sort-priority': u'RUNNCFG_INTERFACE_LEVEL_IP_CONFIG', u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='container', is_config=True)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /bridge_domain/mac_address (container)

    YANG Description: MAC Address
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /bridge_domain/mac_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: MAC Address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mac_address.mac_address, is_container='container', presence=False, yang_name="mac-address", rest_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC Address'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mac_address.mac_address, is_container='container', presence=False, yang_name="mac-address", rest_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC Address'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='container', is_config=True)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=mac_address.mac_address, is_container='container', presence=False, yang_name="mac-address", rest_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'MAC Address'}}, namespace='urn:brocade.com:mgmt:brocade-bridge-domain', defining_module='brocade-bridge-domain', yang_type='container', is_config=True)


  def _get_suppress_arp(self):
    """
    Getter method for suppress_arp, mapped from YANG variable /bridge_domain/suppress_arp (container)
    """
    return self.__suppress_arp
      
  def _set_suppress_arp(self, v, load=False):
    """
    Setter method for suppress_arp, mapped from YANG variable /bridge_domain/suppress_arp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_arp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_arp() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=suppress_arp.suppress_arp, is_container='container', presence=False, yang_name="suppress-arp", rest_name="suppress-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure ARP suppression'}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_arp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=suppress_arp.suppress_arp, is_container='container', presence=False, yang_name="suppress-arp", rest_name="suppress-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure ARP suppression'}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='container', is_config=True)""",
        })

    self.__suppress_arp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_arp(self):
    self.__suppress_arp = YANGDynClass(base=suppress_arp.suppress_arp, is_container='container', presence=False, yang_name="suppress-arp", rest_name="suppress-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure ARP suppression'}}, namespace='urn:brocade.com:mgmt:brocade-arp', defining_module='brocade-arp', yang_type='container', is_config=True)


  def _get_suppress_nd(self):
    """
    Getter method for suppress_nd, mapped from YANG variable /bridge_domain/suppress_nd (container)
    """
    return self.__suppress_nd
      
  def _set_suppress_nd(self, v, load=False):
    """
    Setter method for suppress_nd, mapped from YANG variable /bridge_domain/suppress_nd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_nd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_nd() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=suppress_nd.suppress_nd, is_container='container', presence=False, yang_name="suppress-nd", rest_name="suppress-nd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure ND suppression'}}, namespace='urn:brocade.com:mgmt:brocade-ipv6-nd-ra', defining_module='brocade-ipv6-nd-ra', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_nd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=suppress_nd.suppress_nd, is_container='container', presence=False, yang_name="suppress-nd", rest_name="suppress-nd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure ND suppression'}}, namespace='urn:brocade.com:mgmt:brocade-ipv6-nd-ra', defining_module='brocade-ipv6-nd-ra', yang_type='container', is_config=True)""",
        })

    self.__suppress_nd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_nd(self):
    self.__suppress_nd = YANGDynClass(base=suppress_nd.suppress_nd, is_container='container', presence=False, yang_name="suppress-nd", rest_name="suppress-nd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure ND suppression'}}, namespace='urn:brocade.com:mgmt:brocade-ipv6-nd-ra', defining_module='brocade-ipv6-nd-ra', yang_type='container', is_config=True)

  bridge_domain_id = __builtin__.property(_get_bridge_domain_id, _set_bridge_domain_id)
  bridge_domain_type = __builtin__.property(_get_bridge_domain_type, _set_bridge_domain_type)
  vc_id_num = __builtin__.property(_get_vc_id_num, _set_vc_id_num)
  description = __builtin__.property(_get_description, _set_description)
  peer = __builtin__.property(_get_peer, _set_peer)
  statistics = __builtin__.property(_get_statistics, _set_statistics)
  router_interface = __builtin__.property(_get_router_interface, _set_router_interface)
  logical_interface = __builtin__.property(_get_logical_interface, _set_logical_interface)
  pw_profile_name = __builtin__.property(_get_pw_profile_name, _set_pw_profile_name)
  bpdu_drop_enable = __builtin__.property(_get_bpdu_drop_enable, _set_bpdu_drop_enable)
  local_switching = __builtin__.property(_get_local_switching, _set_local_switching)
  ip = __builtin__.property(_get_ip, _set_ip)
  mac_address = __builtin__.property(_get_mac_address, _set_mac_address)
  suppress_arp = __builtin__.property(_get_suppress_arp, _set_suppress_arp)
  suppress_nd = __builtin__.property(_get_suppress_nd, _set_suppress_nd)


  _pyangbind_elements = {'bridge_domain_id': bridge_domain_id, 'bridge_domain_type': bridge_domain_type, 'vc_id_num': vc_id_num, 'description': description, 'peer': peer, 'statistics': statistics, 'router_interface': router_interface, 'logical_interface': logical_interface, 'pw_profile_name': pw_profile_name, 'bpdu_drop_enable': bpdu_drop_enable, 'local_switching': local_switching, 'ip': ip, 'mac_address': mac_address, 'suppress_arp': suppress_arp, 'suppress_nd': suppress_nd, }


