
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class summary(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-RAS-operational - based on the path /mem-state/summary. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description:  Overall Memory utilization summary 
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__memory_used_percentage','__memory_total','__memory_total_used','__memory_total_free','__memory_low_free','__memory_high_free','__memory_cached',)

  _yang_name = 'summary'
  _rest_name = 'summary'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__memory_cached = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-cached", rest_name="memory-cached", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    self.__memory_used_percentage = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="memory-used-percentage", rest_name="memory-used-percentage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    self.__memory_total = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-total", rest_name="memory-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    self.__memory_total_used = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-total-used", rest_name="memory-total-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    self.__memory_low_free = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-low-free", rest_name="memory-low-free", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    self.__memory_high_free = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-high-free", rest_name="memory-high-free", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    self.__memory_total_free = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-total-free", rest_name="memory-total-free", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mem-state', u'summary']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'mem-state', u'summary']

  def _get_memory_used_percentage(self):
    """
    Getter method for memory_used_percentage, mapped from YANG variable /mem_state/summary/memory_used_percentage (decimal64)

    YANG Description: Total memory used percentage
    """
    return self.__memory_used_percentage
      
  def _set_memory_used_percentage(self, v, load=False):
    """
    Setter method for memory_used_percentage, mapped from YANG variable /mem_state/summary/memory_used_percentage (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory_used_percentage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory_used_percentage() directly.

    YANG Description: Total memory used percentage
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="memory-used-percentage", rest_name="memory-used-percentage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory_used_percentage must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="memory-used-percentage", rest_name="memory-used-percentage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)""",
        })

    self.__memory_used_percentage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory_used_percentage(self):
    self.__memory_used_percentage = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="memory-used-percentage", rest_name="memory-used-percentage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='decimal64', is_config=False)


  def _get_memory_total(self):
    """
    Getter method for memory_total, mapped from YANG variable /mem_state/summary/memory_total (uint32)

    YANG Description: Total Memory in KB
    """
    return self.__memory_total
      
  def _set_memory_total(self, v, load=False):
    """
    Setter method for memory_total, mapped from YANG variable /mem_state/summary/memory_total (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory_total is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory_total() directly.

    YANG Description: Total Memory in KB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-total", rest_name="memory-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory_total must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-total", rest_name="memory-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)""",
        })

    self.__memory_total = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory_total(self):
    self.__memory_total = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-total", rest_name="memory-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)


  def _get_memory_total_used(self):
    """
    Getter method for memory_total_used, mapped from YANG variable /mem_state/summary/memory_total_used (uint32)

    YANG Description: Total Memory used in KB
    """
    return self.__memory_total_used
      
  def _set_memory_total_used(self, v, load=False):
    """
    Setter method for memory_total_used, mapped from YANG variable /mem_state/summary/memory_total_used (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory_total_used is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory_total_used() directly.

    YANG Description: Total Memory used in KB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-total-used", rest_name="memory-total-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory_total_used must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-total-used", rest_name="memory-total-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)""",
        })

    self.__memory_total_used = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory_total_used(self):
    self.__memory_total_used = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-total-used", rest_name="memory-total-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)


  def _get_memory_total_free(self):
    """
    Getter method for memory_total_free, mapped from YANG variable /mem_state/summary/memory_total_free (uint32)

    YANG Description: Total free used in KB
    """
    return self.__memory_total_free
      
  def _set_memory_total_free(self, v, load=False):
    """
    Setter method for memory_total_free, mapped from YANG variable /mem_state/summary/memory_total_free (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory_total_free is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory_total_free() directly.

    YANG Description: Total free used in KB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-total-free", rest_name="memory-total-free", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory_total_free must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-total-free", rest_name="memory-total-free", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)""",
        })

    self.__memory_total_free = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory_total_free(self):
    self.__memory_total_free = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-total-free", rest_name="memory-total-free", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)


  def _get_memory_low_free(self):
    """
    Getter method for memory_low_free, mapped from YANG variable /mem_state/summary/memory_low_free (uint32)

    YANG Description: Low memory free in KB
    """
    return self.__memory_low_free
      
  def _set_memory_low_free(self, v, load=False):
    """
    Setter method for memory_low_free, mapped from YANG variable /mem_state/summary/memory_low_free (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory_low_free is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory_low_free() directly.

    YANG Description: Low memory free in KB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-low-free", rest_name="memory-low-free", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory_low_free must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-low-free", rest_name="memory-low-free", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)""",
        })

    self.__memory_low_free = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory_low_free(self):
    self.__memory_low_free = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-low-free", rest_name="memory-low-free", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)


  def _get_memory_high_free(self):
    """
    Getter method for memory_high_free, mapped from YANG variable /mem_state/summary/memory_high_free (uint32)

    YANG Description: High memory free in KB
    """
    return self.__memory_high_free
      
  def _set_memory_high_free(self, v, load=False):
    """
    Setter method for memory_high_free, mapped from YANG variable /mem_state/summary/memory_high_free (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory_high_free is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory_high_free() directly.

    YANG Description: High memory free in KB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-high-free", rest_name="memory-high-free", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory_high_free must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-high-free", rest_name="memory-high-free", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)""",
        })

    self.__memory_high_free = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory_high_free(self):
    self.__memory_high_free = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-high-free", rest_name="memory-high-free", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)


  def _get_memory_cached(self):
    """
    Getter method for memory_cached, mapped from YANG variable /mem_state/summary/memory_cached (uint32)

    YANG Description: Total cached memory in KB
    """
    return self.__memory_cached
      
  def _set_memory_cached(self, v, load=False):
    """
    Setter method for memory_cached, mapped from YANG variable /mem_state/summary/memory_cached (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory_cached is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory_cached() directly.

    YANG Description: Total cached memory in KB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-cached", rest_name="memory-cached", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory_cached must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-cached", rest_name="memory-cached", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)""",
        })

    self.__memory_cached = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory_cached(self):
    self.__memory_cached = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="memory-cached", rest_name="memory-cached", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-RAS-operational', defining_module='brocade-RAS-operational', yang_type='uint32', is_config=False)

  memory_used_percentage = __builtin__.property(_get_memory_used_percentage)
  memory_total = __builtin__.property(_get_memory_total)
  memory_total_used = __builtin__.property(_get_memory_total_used)
  memory_total_free = __builtin__.property(_get_memory_total_free)
  memory_low_free = __builtin__.property(_get_memory_low_free)
  memory_high_free = __builtin__.property(_get_memory_high_free)
  memory_cached = __builtin__.property(_get_memory_cached)


  _pyangbind_elements = {'memory_used_percentage': memory_used_percentage, 'memory_total': memory_total, 'memory_total_used': memory_total_used, 'memory_total_free': memory_total_free, 'memory_low_free': memory_low_free, 'memory_high_free': memory_high_free, 'memory_cached': memory_cached, }


