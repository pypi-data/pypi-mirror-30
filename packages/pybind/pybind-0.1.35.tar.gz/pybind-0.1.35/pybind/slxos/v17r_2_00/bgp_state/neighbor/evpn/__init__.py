
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import update_source
import last_update_time
import neighbor_nlri_negotiation
import neighbor_configured_routes
import distribute_list
import filter_list
import prefix_list
import route_map
import msg_sent
import msg_received
class evpn(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-bgp-operational - based on the path /bgp-state/neighbor/evpn. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: BGP EVPN neighbor information
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__remote_as','__router_id','__vrf','__local_as','__no_prepend','__description','__bgp_state','__bgp_state_time','__keep_alive_time','__hold_time','__keep_alive_time_expire','__hold_time_expire','__min_advertisement_interval','__peer_group','__multihop_ebgp_ttl','__multihop_btsh','__md5_password','__next_hop_self','__remove_private_as','__soft_inbound_reconfig','__refresh_capability_received','__gr_capability_received','__gr_restart_time_received','__gr_restart_bit_received','__afi','__safi','__forwarding_bit','__gr_capability_sent','__gr_restart_time_sent','__gr_restart_bit_sent','__stale_state','__stale_state_time_left_to_reconnect','__restarting_state','__restarting_time_left_to_converge','__restarting_start_stale_timer','__restarting_stale_timer_left_to_converge','__purge_time','__cooperative_filtering_capability_sent','__cooperative_filtering_capability_received','__route_reflector_client','__send_community','__peer_as_check','__send_ext_community','__default_originate','__default_originate_sent','__max_prefix_limit','__unsuppress_route_map','__last_conn_reset_reason','__notification_sent_code','__notification_received_code','__update_source','__last_update_time','__neighbor_nlri_negotiation','__neighbor_configured_routes','__distribute_list','__filter_list','__prefix_list','__route_map','__msg_sent','__msg_received','__remote_address',)

  _yang_name = 'evpn'
  _rest_name = 'evpn'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__last_update_time = YANGDynClass(base=last_update_time.last_update_time, is_container='container', presence=False, yang_name="last-update-time", rest_name="last-update-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-last-update-time-tx-rx', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    self.__default_originate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-originate", rest_name="default-originate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__distribute_list = YANGDynClass(base=distribute_list.distribute_list, is_container='container', presence=False, yang_name="distribute-list", rest_name="distribute-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-distribute-list-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    self.__route_reflector_client = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="route-reflector-client", rest_name="route-reflector-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__notification_sent_code = YANGDynClass(base=unicode, is_leaf=True, yang_name="notification-sent-code", rest_name="notification-sent-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__bgp_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'established': {'value': 6}, u'open-sent': {'value': 4}, u'no-state': {'value': 0}, u'idle': {'value': 1}, u'active': {'value': 3}, u'connect-state': {'value': 2}, u'open-confirm': {'value': 5}},), is_leaf=True, yang_name="bgp-state", rest_name="bgp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='bgp-states', is_config=False)
    self.__refresh_capability_received = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="refresh-capability-received", rest_name="refresh-capability-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__send_ext_community = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="send-ext-community", rest_name="send-ext-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__multihop_ebgp_ttl = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="multihop-ebgp-ttl", rest_name="multihop-ebgp-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__neighbor_nlri_negotiation = YANGDynClass(base=neighbor_nlri_negotiation.neighbor_nlri_negotiation, is_container='container', presence=False, yang_name="neighbor-nlri-negotiation", rest_name="neighbor-nlri-negotiation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-peer-negotiations', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    self.__gr_capability_received = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-capability-received", rest_name="gr-capability-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__restarting_start_stale_timer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="restarting-start-stale-timer", rest_name="restarting-start-stale-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__cooperative_filtering_capability_sent = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cooperative-filtering-capability-sent", rest_name="cooperative-filtering-capability-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__remove_private_as = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="remove-private-as", rest_name="remove-private-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__send_community = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="send-community", rest_name="send-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__bgp_state_time = YANGDynClass(base=unicode, is_leaf=True, yang_name="bgp-state-time", rest_name="bgp-state-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__remote_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="remote-as", rest_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)
    self.__hold_time_expire = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="hold-time-expire", rest_name="hold-time-expire", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__md5_password = YANGDynClass(base=unicode, is_leaf=True, yang_name="md5-password", rest_name="md5-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__route_map = YANGDynClass(base=route_map.route_map, is_container='container', presence=False, yang_name="route-map", rest_name="route-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-route-map-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    self.__last_conn_reset_reason = YANGDynClass(base=unicode, is_leaf=True, yang_name="last-conn-reset-reason", rest_name="last-conn-reset-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__forwarding_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="forwarding-bit", rest_name="forwarding-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__gr_restart_time_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-time-sent", rest_name="gr-restart-time-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__peer_group = YANGDynClass(base=unicode, is_leaf=True, yang_name="peer-group", rest_name="peer-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__update_source = YANGDynClass(base=update_source.update_source, is_container='container', presence=False, yang_name="update-source", rest_name="update-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-update-source', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    self.__restarting_stale_timer_left_to_converge = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="restarting-stale-timer-left-to-converge", rest_name="restarting-stale-timer-left-to-converge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__prefix_list = YANGDynClass(base=prefix_list.prefix_list, is_container='container', presence=False, yang_name="prefix-list", rest_name="prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-prefix-list-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    self.__soft_inbound_reconfig = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="soft-inbound-reconfig", rest_name="soft-inbound-reconfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__neighbor_configured_routes = YANGDynClass(base=neighbor_configured_routes.neighbor_configured_routes, is_container='container', presence=False, yang_name="neighbor-configured-routes", rest_name="neighbor-configured-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-peer-configurations', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="router-id", rest_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)
    self.__unsuppress_route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="unsuppress-route-map", rest_name="unsuppress-route-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__gr_capability_sent = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-capability-sent", rest_name="gr-capability-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", rest_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__safi = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="safi", rest_name="safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__keep_alive_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="keep-alive-time", rest_name="keep-alive-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__local_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-as", rest_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)
    self.__gr_restart_time_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-time-received", rest_name="gr-restart-time-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__remote_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="remote-address", rest_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)
    self.__no_prepend = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-prepend", rest_name="no-prepend", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__vrf = YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf", rest_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__msg_received = YANGDynClass(base=msg_received.msg_received, is_container='container', presence=False, yang_name="msg-received", rest_name="msg-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-bgp-message-msg-received-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    self.__purge_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="purge-time", rest_name="purge-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__restarting_time_left_to_converge = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="restarting-time-left-to-converge", rest_name="restarting-time-left-to-converge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__next_hop_self = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="next-hop-self", rest_name="next-hop-self", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__max_prefix_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="max-prefix-limit", rest_name="max-prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__gr_restart_bit_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-bit-sent", rest_name="gr-restart-bit-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__hold_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="hold-time", rest_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__afi = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="afi", rest_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__default_originate_sent = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-originate-sent", rest_name="default-originate-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__cooperative_filtering_capability_received = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cooperative-filtering-capability-received", rest_name="cooperative-filtering-capability-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__stale_state_time_left_to_reconnect = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="stale-state-time-left-to-reconnect", rest_name="stale-state-time-left-to-reconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__min_advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="min-advertisement-interval", rest_name="min-advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__restarting_state = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="restarting-state", rest_name="restarting-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__keep_alive_time_expire = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="keep-alive-time-expire", rest_name="keep-alive-time-expire", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__filter_list = YANGDynClass(base=filter_list.filter_list, is_container='container', presence=False, yang_name="filter-list", rest_name="filter-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-filter-list-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    self.__msg_sent = YANGDynClass(base=msg_sent.msg_sent, is_container='container', presence=False, yang_name="msg-sent", rest_name="msg-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-bgp-message-msg-sent-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    self.__stale_state = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="stale-state", rest_name="stale-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__multihop_btsh = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multihop-btsh", rest_name="multihop-btsh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__notification_received_code = YANGDynClass(base=unicode, is_leaf=True, yang_name="notification-received-code", rest_name="notification-received-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__gr_restart_bit_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-bit-received", rest_name="gr-restart-bit-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__peer_as_check = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="peer-as-check", rest_name="peer-as-check", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'bgp-state', u'neighbor', u'evpn']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'bgp-state', u'neighbor', u'evpn']

  def _get_remote_as(self):
    """
    Getter method for remote_as, mapped from YANG variable /bgp_state/neighbor/evpn/remote_as (uint32)

    YANG Description: Remote AS number
    """
    return self.__remote_as
      
  def _set_remote_as(self, v, load=False):
    """
    Setter method for remote_as, mapped from YANG variable /bgp_state/neighbor/evpn/remote_as (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_as() directly.

    YANG Description: Remote AS number
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="remote-as", rest_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_as must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="remote-as", rest_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)""",
        })

    self.__remote_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_as(self):
    self.__remote_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="remote-as", rest_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)


  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /bgp_state/neighbor/evpn/router_id (inet:ipv4-address)

    YANG Description: Router identifier
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /bgp_state/neighbor/evpn/router_id (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: Router identifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="router-id", rest_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="router-id", rest_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="router-id", rest_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)


  def _get_vrf(self):
    """
    Getter method for vrf, mapped from YANG variable /bgp_state/neighbor/evpn/vrf (string)

    YANG Description: VRF Name
    """
    return self.__vrf
      
  def _set_vrf(self, v, load=False):
    """
    Setter method for vrf, mapped from YANG variable /bgp_state/neighbor/evpn/vrf (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf() directly.

    YANG Description: VRF Name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vrf", rest_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf", rest_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__vrf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf(self):
    self.__vrf = YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf", rest_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_local_as(self):
    """
    Getter method for local_as, mapped from YANG variable /bgp_state/neighbor/evpn/local_as (uint32)

    YANG Description: Local AS Number
    """
    return self.__local_as
      
  def _set_local_as(self, v, load=False):
    """
    Setter method for local_as, mapped from YANG variable /bgp_state/neighbor/evpn/local_as (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_as() directly.

    YANG Description: Local AS Number
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-as", rest_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_as must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-as", rest_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)""",
        })

    self.__local_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_as(self):
    self.__local_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-as", rest_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)


  def _get_no_prepend(self):
    """
    Getter method for no_prepend, mapped from YANG variable /bgp_state/neighbor/evpn/no_prepend (boolean)

    YANG Description: Don't prepend Local AS number
    """
    return self.__no_prepend
      
  def _set_no_prepend(self, v, load=False):
    """
    Setter method for no_prepend, mapped from YANG variable /bgp_state/neighbor/evpn/no_prepend (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_prepend is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_prepend() directly.

    YANG Description: Don't prepend Local AS number
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="no-prepend", rest_name="no-prepend", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_prepend must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-prepend", rest_name="no-prepend", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__no_prepend = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_prepend(self):
    self.__no_prepend = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-prepend", rest_name="no-prepend", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /bgp_state/neighbor/evpn/description (string)

    YANG Description: Neighbor Description
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /bgp_state/neighbor/evpn/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Neighbor Description
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", rest_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", rest_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", rest_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_bgp_state(self):
    """
    Getter method for bgp_state, mapped from YANG variable /bgp_state/neighbor/evpn/bgp_state (bgp-states)

    YANG Description: BGP state
    """
    return self.__bgp_state
      
  def _set_bgp_state(self, v, load=False):
    """
    Setter method for bgp_state, mapped from YANG variable /bgp_state/neighbor/evpn/bgp_state (bgp-states)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp_state() directly.

    YANG Description: BGP state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'established': {'value': 6}, u'open-sent': {'value': 4}, u'no-state': {'value': 0}, u'idle': {'value': 1}, u'active': {'value': 3}, u'connect-state': {'value': 2}, u'open-confirm': {'value': 5}},), is_leaf=True, yang_name="bgp-state", rest_name="bgp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='bgp-states', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp_state must be of a type compatible with bgp-states""",
          'defined-type': "brocade-bgp-operational:bgp-states",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'established': {'value': 6}, u'open-sent': {'value': 4}, u'no-state': {'value': 0}, u'idle': {'value': 1}, u'active': {'value': 3}, u'connect-state': {'value': 2}, u'open-confirm': {'value': 5}},), is_leaf=True, yang_name="bgp-state", rest_name="bgp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='bgp-states', is_config=False)""",
        })

    self.__bgp_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp_state(self):
    self.__bgp_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'established': {'value': 6}, u'open-sent': {'value': 4}, u'no-state': {'value': 0}, u'idle': {'value': 1}, u'active': {'value': 3}, u'connect-state': {'value': 2}, u'open-confirm': {'value': 5}},), is_leaf=True, yang_name="bgp-state", rest_name="bgp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='bgp-states', is_config=False)


  def _get_bgp_state_time(self):
    """
    Getter method for bgp_state_time, mapped from YANG variable /bgp_state/neighbor/evpn/bgp_state_time (string)

    YANG Description: BGP state time
    """
    return self.__bgp_state_time
      
  def _set_bgp_state_time(self, v, load=False):
    """
    Setter method for bgp_state_time, mapped from YANG variable /bgp_state/neighbor/evpn/bgp_state_time (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp_state_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp_state_time() directly.

    YANG Description: BGP state time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="bgp-state-time", rest_name="bgp-state-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp_state_time must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="bgp-state-time", rest_name="bgp-state-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__bgp_state_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp_state_time(self):
    self.__bgp_state_time = YANGDynClass(base=unicode, is_leaf=True, yang_name="bgp-state-time", rest_name="bgp-state-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_keep_alive_time(self):
    """
    Getter method for keep_alive_time, mapped from YANG variable /bgp_state/neighbor/evpn/keep_alive_time (int32)

    YANG Description: Keep alive time
    """
    return self.__keep_alive_time
      
  def _set_keep_alive_time(self, v, load=False):
    """
    Setter method for keep_alive_time, mapped from YANG variable /bgp_state/neighbor/evpn/keep_alive_time (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keep_alive_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keep_alive_time() directly.

    YANG Description: Keep alive time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="keep-alive-time", rest_name="keep-alive-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keep_alive_time must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="keep-alive-time", rest_name="keep-alive-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__keep_alive_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keep_alive_time(self):
    self.__keep_alive_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="keep-alive-time", rest_name="keep-alive-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_hold_time(self):
    """
    Getter method for hold_time, mapped from YANG variable /bgp_state/neighbor/evpn/hold_time (int32)

    YANG Description: Hold time
    """
    return self.__hold_time
      
  def _set_hold_time(self, v, load=False):
    """
    Setter method for hold_time, mapped from YANG variable /bgp_state/neighbor/evpn/hold_time (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_time() directly.

    YANG Description: Hold time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="hold-time", rest_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_time must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="hold-time", rest_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__hold_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_time(self):
    self.__hold_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="hold-time", rest_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_keep_alive_time_expire(self):
    """
    Getter method for keep_alive_time_expire, mapped from YANG variable /bgp_state/neighbor/evpn/keep_alive_time_expire (int32)

    YANG Description: Seconds left for the keep alive timer to expire
    """
    return self.__keep_alive_time_expire
      
  def _set_keep_alive_time_expire(self, v, load=False):
    """
    Setter method for keep_alive_time_expire, mapped from YANG variable /bgp_state/neighbor/evpn/keep_alive_time_expire (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keep_alive_time_expire is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keep_alive_time_expire() directly.

    YANG Description: Seconds left for the keep alive timer to expire
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="keep-alive-time-expire", rest_name="keep-alive-time-expire", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keep_alive_time_expire must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="keep-alive-time-expire", rest_name="keep-alive-time-expire", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__keep_alive_time_expire = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keep_alive_time_expire(self):
    self.__keep_alive_time_expire = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="keep-alive-time-expire", rest_name="keep-alive-time-expire", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_hold_time_expire(self):
    """
    Getter method for hold_time_expire, mapped from YANG variable /bgp_state/neighbor/evpn/hold_time_expire (int32)

    YANG Description: Seconds left for the hold timeer to expire
    """
    return self.__hold_time_expire
      
  def _set_hold_time_expire(self, v, load=False):
    """
    Setter method for hold_time_expire, mapped from YANG variable /bgp_state/neighbor/evpn/hold_time_expire (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_time_expire is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_time_expire() directly.

    YANG Description: Seconds left for the hold timeer to expire
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="hold-time-expire", rest_name="hold-time-expire", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_time_expire must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="hold-time-expire", rest_name="hold-time-expire", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__hold_time_expire = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_time_expire(self):
    self.__hold_time_expire = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="hold-time-expire", rest_name="hold-time-expire", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_min_advertisement_interval(self):
    """
    Getter method for min_advertisement_interval, mapped from YANG variable /bgp_state/neighbor/evpn/min_advertisement_interval (int32)

    YANG Description: Minimal route advertisement interval in seconds
    """
    return self.__min_advertisement_interval
      
  def _set_min_advertisement_interval(self, v, load=False):
    """
    Setter method for min_advertisement_interval, mapped from YANG variable /bgp_state/neighbor/evpn/min_advertisement_interval (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_advertisement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_advertisement_interval() directly.

    YANG Description: Minimal route advertisement interval in seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="min-advertisement-interval", rest_name="min-advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_advertisement_interval must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="min-advertisement-interval", rest_name="min-advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__min_advertisement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_advertisement_interval(self):
    self.__min_advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="min-advertisement-interval", rest_name="min-advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_peer_group(self):
    """
    Getter method for peer_group, mapped from YANG variable /bgp_state/neighbor/evpn/peer_group (string)

    YANG Description: Peer group name
    """
    return self.__peer_group
      
  def _set_peer_group(self, v, load=False):
    """
    Setter method for peer_group, mapped from YANG variable /bgp_state/neighbor/evpn/peer_group (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_group() directly.

    YANG Description: Peer group name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="peer-group", rest_name="peer-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_group must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="peer-group", rest_name="peer-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__peer_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_group(self):
    self.__peer_group = YANGDynClass(base=unicode, is_leaf=True, yang_name="peer-group", rest_name="peer-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_multihop_ebgp_ttl(self):
    """
    Getter method for multihop_ebgp_ttl, mapped from YANG variable /bgp_state/neighbor/evpn/multihop_ebgp_ttl (int32)

    YANG Description: Peer group name
    """
    return self.__multihop_ebgp_ttl
      
  def _set_multihop_ebgp_ttl(self, v, load=False):
    """
    Setter method for multihop_ebgp_ttl, mapped from YANG variable /bgp_state/neighbor/evpn/multihop_ebgp_ttl (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multihop_ebgp_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multihop_ebgp_ttl() directly.

    YANG Description: Peer group name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="multihop-ebgp-ttl", rest_name="multihop-ebgp-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multihop_ebgp_ttl must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="multihop-ebgp-ttl", rest_name="multihop-ebgp-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__multihop_ebgp_ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multihop_ebgp_ttl(self):
    self.__multihop_ebgp_ttl = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="multihop-ebgp-ttl", rest_name="multihop-ebgp-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_multihop_btsh(self):
    """
    Getter method for multihop_btsh, mapped from YANG variable /bgp_state/neighbor/evpn/multihop_btsh (boolean)

    YANG Description: Multi hop BTSH
    """
    return self.__multihop_btsh
      
  def _set_multihop_btsh(self, v, load=False):
    """
    Setter method for multihop_btsh, mapped from YANG variable /bgp_state/neighbor/evpn/multihop_btsh (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multihop_btsh is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multihop_btsh() directly.

    YANG Description: Multi hop BTSH
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="multihop-btsh", rest_name="multihop-btsh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multihop_btsh must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multihop-btsh", rest_name="multihop-btsh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__multihop_btsh = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multihop_btsh(self):
    self.__multihop_btsh = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multihop-btsh", rest_name="multihop-btsh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_md5_password(self):
    """
    Getter method for md5_password, mapped from YANG variable /bgp_state/neighbor/evpn/md5_password (string)

    YANG Description: MD5 password
    """
    return self.__md5_password
      
  def _set_md5_password(self, v, load=False):
    """
    Setter method for md5_password, mapped from YANG variable /bgp_state/neighbor/evpn/md5_password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_md5_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_md5_password() directly.

    YANG Description: MD5 password
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="md5-password", rest_name="md5-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """md5_password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="md5-password", rest_name="md5-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__md5_password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_md5_password(self):
    self.__md5_password = YANGDynClass(base=unicode, is_leaf=True, yang_name="md5-password", rest_name="md5-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_next_hop_self(self):
    """
    Getter method for next_hop_self, mapped from YANG variable /bgp_state/neighbor/evpn/next_hop_self (boolean)

    YANG Description: Next hop self
    """
    return self.__next_hop_self
      
  def _set_next_hop_self(self, v, load=False):
    """
    Setter method for next_hop_self, mapped from YANG variable /bgp_state/neighbor/evpn/next_hop_self (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_self is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_self() directly.

    YANG Description: Next hop self
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="next-hop-self", rest_name="next-hop-self", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_self must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="next-hop-self", rest_name="next-hop-self", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__next_hop_self = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_self(self):
    self.__next_hop_self = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="next-hop-self", rest_name="next-hop-self", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_remove_private_as(self):
    """
    Getter method for remove_private_as, mapped from YANG variable /bgp_state/neighbor/evpn/remove_private_as (boolean)

    YANG Description: Remove Private AS
    """
    return self.__remove_private_as
      
  def _set_remove_private_as(self, v, load=False):
    """
    Setter method for remove_private_as, mapped from YANG variable /bgp_state/neighbor/evpn/remove_private_as (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remove_private_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remove_private_as() directly.

    YANG Description: Remove Private AS
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="remove-private-as", rest_name="remove-private-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remove_private_as must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="remove-private-as", rest_name="remove-private-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__remove_private_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remove_private_as(self):
    self.__remove_private_as = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="remove-private-as", rest_name="remove-private-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_soft_inbound_reconfig(self):
    """
    Getter method for soft_inbound_reconfig, mapped from YANG variable /bgp_state/neighbor/evpn/soft_inbound_reconfig (boolean)

    YANG Description: SoftInboundReconfiguration
    """
    return self.__soft_inbound_reconfig
      
  def _set_soft_inbound_reconfig(self, v, load=False):
    """
    Setter method for soft_inbound_reconfig, mapped from YANG variable /bgp_state/neighbor/evpn/soft_inbound_reconfig (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_soft_inbound_reconfig is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_soft_inbound_reconfig() directly.

    YANG Description: SoftInboundReconfiguration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="soft-inbound-reconfig", rest_name="soft-inbound-reconfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """soft_inbound_reconfig must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="soft-inbound-reconfig", rest_name="soft-inbound-reconfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__soft_inbound_reconfig = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_soft_inbound_reconfig(self):
    self.__soft_inbound_reconfig = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="soft-inbound-reconfig", rest_name="soft-inbound-reconfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_refresh_capability_received(self):
    """
    Getter method for refresh_capability_received, mapped from YANG variable /bgp_state/neighbor/evpn/refresh_capability_received (boolean)

    YANG Description: RefreshCapability received
    """
    return self.__refresh_capability_received
      
  def _set_refresh_capability_received(self, v, load=False):
    """
    Setter method for refresh_capability_received, mapped from YANG variable /bgp_state/neighbor/evpn/refresh_capability_received (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_refresh_capability_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_refresh_capability_received() directly.

    YANG Description: RefreshCapability received
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="refresh-capability-received", rest_name="refresh-capability-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """refresh_capability_received must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="refresh-capability-received", rest_name="refresh-capability-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__refresh_capability_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_refresh_capability_received(self):
    self.__refresh_capability_received = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="refresh-capability-received", rest_name="refresh-capability-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_gr_capability_received(self):
    """
    Getter method for gr_capability_received, mapped from YANG variable /bgp_state/neighbor/evpn/gr_capability_received (boolean)

    YANG Description: Graceful restart capability received
    """
    return self.__gr_capability_received
      
  def _set_gr_capability_received(self, v, load=False):
    """
    Setter method for gr_capability_received, mapped from YANG variable /bgp_state/neighbor/evpn/gr_capability_received (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_capability_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_capability_received() directly.

    YANG Description: Graceful restart capability received
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="gr-capability-received", rest_name="gr-capability-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_capability_received must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-capability-received", rest_name="gr-capability-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__gr_capability_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_capability_received(self):
    self.__gr_capability_received = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-capability-received", rest_name="gr-capability-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_gr_restart_time_received(self):
    """
    Getter method for gr_restart_time_received, mapped from YANG variable /bgp_state/neighbor/evpn/gr_restart_time_received (int32)

    YANG Description: Restart time in seconds
    """
    return self.__gr_restart_time_received
      
  def _set_gr_restart_time_received(self, v, load=False):
    """
    Setter method for gr_restart_time_received, mapped from YANG variable /bgp_state/neighbor/evpn/gr_restart_time_received (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_restart_time_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_restart_time_received() directly.

    YANG Description: Restart time in seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-time-received", rest_name="gr-restart-time-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_restart_time_received must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-time-received", rest_name="gr-restart-time-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__gr_restart_time_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_restart_time_received(self):
    self.__gr_restart_time_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-time-received", rest_name="gr-restart-time-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_gr_restart_bit_received(self):
    """
    Getter method for gr_restart_bit_received, mapped from YANG variable /bgp_state/neighbor/evpn/gr_restart_bit_received (int32)

    YANG Description: Restart bit
    """
    return self.__gr_restart_bit_received
      
  def _set_gr_restart_bit_received(self, v, load=False):
    """
    Setter method for gr_restart_bit_received, mapped from YANG variable /bgp_state/neighbor/evpn/gr_restart_bit_received (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_restart_bit_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_restart_bit_received() directly.

    YANG Description: Restart bit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-bit-received", rest_name="gr-restart-bit-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_restart_bit_received must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-bit-received", rest_name="gr-restart-bit-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__gr_restart_bit_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_restart_bit_received(self):
    self.__gr_restart_bit_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-bit-received", rest_name="gr-restart-bit-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_afi(self):
    """
    Getter method for afi, mapped from YANG variable /bgp_state/neighbor/evpn/afi (int32)

    YANG Description: Address Identifier
    """
    return self.__afi
      
  def _set_afi(self, v, load=False):
    """
    Setter method for afi, mapped from YANG variable /bgp_state/neighbor/evpn/afi (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi() directly.

    YANG Description: Address Identifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="afi", rest_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="afi", rest_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__afi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi(self):
    self.__afi = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="afi", rest_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_safi(self):
    """
    Getter method for safi, mapped from YANG variable /bgp_state/neighbor/evpn/safi (int32)

    YANG Description: Subsequent address identifier
    """
    return self.__safi
      
  def _set_safi(self, v, load=False):
    """
    Setter method for safi, mapped from YANG variable /bgp_state/neighbor/evpn/safi (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_safi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_safi() directly.

    YANG Description: Subsequent address identifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="safi", rest_name="safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """safi must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="safi", rest_name="safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__safi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_safi(self):
    self.__safi = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="safi", rest_name="safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_forwarding_bit(self):
    """
    Getter method for forwarding_bit, mapped from YANG variable /bgp_state/neighbor/evpn/forwarding_bit (int32)

    YANG Description: Forwarding bit
    """
    return self.__forwarding_bit
      
  def _set_forwarding_bit(self, v, load=False):
    """
    Setter method for forwarding_bit, mapped from YANG variable /bgp_state/neighbor/evpn/forwarding_bit (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_forwarding_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_forwarding_bit() directly.

    YANG Description: Forwarding bit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="forwarding-bit", rest_name="forwarding-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """forwarding_bit must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="forwarding-bit", rest_name="forwarding-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__forwarding_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_forwarding_bit(self):
    self.__forwarding_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="forwarding-bit", rest_name="forwarding-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_gr_capability_sent(self):
    """
    Getter method for gr_capability_sent, mapped from YANG variable /bgp_state/neighbor/evpn/gr_capability_sent (boolean)

    YANG Description: Graceful restart capability sent
    """
    return self.__gr_capability_sent
      
  def _set_gr_capability_sent(self, v, load=False):
    """
    Setter method for gr_capability_sent, mapped from YANG variable /bgp_state/neighbor/evpn/gr_capability_sent (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_capability_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_capability_sent() directly.

    YANG Description: Graceful restart capability sent
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="gr-capability-sent", rest_name="gr-capability-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_capability_sent must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-capability-sent", rest_name="gr-capability-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__gr_capability_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_capability_sent(self):
    self.__gr_capability_sent = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-capability-sent", rest_name="gr-capability-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_gr_restart_time_sent(self):
    """
    Getter method for gr_restart_time_sent, mapped from YANG variable /bgp_state/neighbor/evpn/gr_restart_time_sent (int32)

    YANG Description: Restart time in seconds
    """
    return self.__gr_restart_time_sent
      
  def _set_gr_restart_time_sent(self, v, load=False):
    """
    Setter method for gr_restart_time_sent, mapped from YANG variable /bgp_state/neighbor/evpn/gr_restart_time_sent (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_restart_time_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_restart_time_sent() directly.

    YANG Description: Restart time in seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-time-sent", rest_name="gr-restart-time-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_restart_time_sent must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-time-sent", rest_name="gr-restart-time-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__gr_restart_time_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_restart_time_sent(self):
    self.__gr_restart_time_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-time-sent", rest_name="gr-restart-time-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_gr_restart_bit_sent(self):
    """
    Getter method for gr_restart_bit_sent, mapped from YANG variable /bgp_state/neighbor/evpn/gr_restart_bit_sent (int32)

    YANG Description: Restart bit
    """
    return self.__gr_restart_bit_sent
      
  def _set_gr_restart_bit_sent(self, v, load=False):
    """
    Setter method for gr_restart_bit_sent, mapped from YANG variable /bgp_state/neighbor/evpn/gr_restart_bit_sent (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_restart_bit_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_restart_bit_sent() directly.

    YANG Description: Restart bit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-bit-sent", rest_name="gr-restart-bit-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_restart_bit_sent must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-bit-sent", rest_name="gr-restart-bit-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__gr_restart_bit_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_restart_bit_sent(self):
    self.__gr_restart_bit_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="gr-restart-bit-sent", rest_name="gr-restart-bit-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_stale_state(self):
    """
    Getter method for stale_state, mapped from YANG variable /bgp_state/neighbor/evpn/stale_state (boolean)

    YANG Description: Neighbor is in stale state
    """
    return self.__stale_state
      
  def _set_stale_state(self, v, load=False):
    """
    Setter method for stale_state, mapped from YANG variable /bgp_state/neighbor/evpn/stale_state (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stale_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stale_state() directly.

    YANG Description: Neighbor is in stale state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="stale-state", rest_name="stale-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stale_state must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="stale-state", rest_name="stale-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__stale_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stale_state(self):
    self.__stale_state = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="stale-state", rest_name="stale-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_stale_state_time_left_to_reconnect(self):
    """
    Getter method for stale_state_time_left_to_reconnect, mapped from YANG variable /bgp_state/neighbor/evpn/stale_state_time_left_to_reconnect (int32)

    YANG Description: Neighbor in stale state, restart-timer left to reconnect in secs
    """
    return self.__stale_state_time_left_to_reconnect
      
  def _set_stale_state_time_left_to_reconnect(self, v, load=False):
    """
    Setter method for stale_state_time_left_to_reconnect, mapped from YANG variable /bgp_state/neighbor/evpn/stale_state_time_left_to_reconnect (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stale_state_time_left_to_reconnect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stale_state_time_left_to_reconnect() directly.

    YANG Description: Neighbor in stale state, restart-timer left to reconnect in secs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="stale-state-time-left-to-reconnect", rest_name="stale-state-time-left-to-reconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stale_state_time_left_to_reconnect must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="stale-state-time-left-to-reconnect", rest_name="stale-state-time-left-to-reconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__stale_state_time_left_to_reconnect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stale_state_time_left_to_reconnect(self):
    self.__stale_state_time_left_to_reconnect = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="stale-state-time-left-to-reconnect", rest_name="stale-state-time-left-to-reconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_restarting_state(self):
    """
    Getter method for restarting_state, mapped from YANG variable /bgp_state/neighbor/evpn/restarting_state (boolean)

    YANG Description: Neighbor is in restarting state
    """
    return self.__restarting_state
      
  def _set_restarting_state(self, v, load=False):
    """
    Setter method for restarting_state, mapped from YANG variable /bgp_state/neighbor/evpn/restarting_state (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restarting_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restarting_state() directly.

    YANG Description: Neighbor is in restarting state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="restarting-state", rest_name="restarting-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restarting_state must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="restarting-state", rest_name="restarting-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__restarting_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restarting_state(self):
    self.__restarting_state = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="restarting-state", rest_name="restarting-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_restarting_time_left_to_converge(self):
    """
    Getter method for restarting_time_left_to_converge, mapped from YANG variable /bgp_state/neighbor/evpn/restarting_time_left_to_converge (int32)

    YANG Description: Neighbor restarted, timer left to converge in secs
    """
    return self.__restarting_time_left_to_converge
      
  def _set_restarting_time_left_to_converge(self, v, load=False):
    """
    Setter method for restarting_time_left_to_converge, mapped from YANG variable /bgp_state/neighbor/evpn/restarting_time_left_to_converge (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restarting_time_left_to_converge is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restarting_time_left_to_converge() directly.

    YANG Description: Neighbor restarted, timer left to converge in secs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="restarting-time-left-to-converge", rest_name="restarting-time-left-to-converge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restarting_time_left_to_converge must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="restarting-time-left-to-converge", rest_name="restarting-time-left-to-converge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__restarting_time_left_to_converge = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restarting_time_left_to_converge(self):
    self.__restarting_time_left_to_converge = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="restarting-time-left-to-converge", rest_name="restarting-time-left-to-converge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_restarting_start_stale_timer(self):
    """
    Getter method for restarting_start_stale_timer, mapped from YANG variable /bgp_state/neighbor/evpn/restarting_start_stale_timer (boolean)

    YANG Description: Neighbor in restart state, Start stale-timer after bgp connections establish
    """
    return self.__restarting_start_stale_timer
      
  def _set_restarting_start_stale_timer(self, v, load=False):
    """
    Setter method for restarting_start_stale_timer, mapped from YANG variable /bgp_state/neighbor/evpn/restarting_start_stale_timer (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restarting_start_stale_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restarting_start_stale_timer() directly.

    YANG Description: Neighbor in restart state, Start stale-timer after bgp connections establish
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="restarting-start-stale-timer", rest_name="restarting-start-stale-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restarting_start_stale_timer must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="restarting-start-stale-timer", rest_name="restarting-start-stale-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__restarting_start_stale_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restarting_start_stale_timer(self):
    self.__restarting_start_stale_timer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="restarting-start-stale-timer", rest_name="restarting-start-stale-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_restarting_stale_timer_left_to_converge(self):
    """
    Getter method for restarting_stale_timer_left_to_converge, mapped from YANG variable /bgp_state/neighbor/evpn/restarting_stale_timer_left_to_converge (int32)

    YANG Description: Neighbor in restart state, stale-timer left to converge in secs
    """
    return self.__restarting_stale_timer_left_to_converge
      
  def _set_restarting_stale_timer_left_to_converge(self, v, load=False):
    """
    Setter method for restarting_stale_timer_left_to_converge, mapped from YANG variable /bgp_state/neighbor/evpn/restarting_stale_timer_left_to_converge (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restarting_stale_timer_left_to_converge is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restarting_stale_timer_left_to_converge() directly.

    YANG Description: Neighbor in restart state, stale-timer left to converge in secs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="restarting-stale-timer-left-to-converge", rest_name="restarting-stale-timer-left-to-converge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restarting_stale_timer_left_to_converge must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="restarting-stale-timer-left-to-converge", rest_name="restarting-stale-timer-left-to-converge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__restarting_stale_timer_left_to_converge = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restarting_stale_timer_left_to_converge(self):
    self.__restarting_stale_timer_left_to_converge = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="restarting-stale-timer-left-to-converge", rest_name="restarting-stale-timer-left-to-converge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_purge_time(self):
    """
    Getter method for purge_time, mapped from YANG variable /bgp_state/neighbor/evpn/purge_time (int32)

    YANG Description: Purge-timer started and expired in secs
    """
    return self.__purge_time
      
  def _set_purge_time(self, v, load=False):
    """
    Setter method for purge_time, mapped from YANG variable /bgp_state/neighbor/evpn/purge_time (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_purge_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_purge_time() directly.

    YANG Description: Purge-timer started and expired in secs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="purge-time", rest_name="purge-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """purge_time must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="purge-time", rest_name="purge-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__purge_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_purge_time(self):
    self.__purge_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="purge-time", rest_name="purge-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_cooperative_filtering_capability_sent(self):
    """
    Getter method for cooperative_filtering_capability_sent, mapped from YANG variable /bgp_state/neighbor/evpn/cooperative_filtering_capability_sent (boolean)

    YANG Description: CooperativeFilteringCapability: Sent
    """
    return self.__cooperative_filtering_capability_sent
      
  def _set_cooperative_filtering_capability_sent(self, v, load=False):
    """
    Setter method for cooperative_filtering_capability_sent, mapped from YANG variable /bgp_state/neighbor/evpn/cooperative_filtering_capability_sent (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cooperative_filtering_capability_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cooperative_filtering_capability_sent() directly.

    YANG Description: CooperativeFilteringCapability: Sent
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="cooperative-filtering-capability-sent", rest_name="cooperative-filtering-capability-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cooperative_filtering_capability_sent must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cooperative-filtering-capability-sent", rest_name="cooperative-filtering-capability-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__cooperative_filtering_capability_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cooperative_filtering_capability_sent(self):
    self.__cooperative_filtering_capability_sent = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cooperative-filtering-capability-sent", rest_name="cooperative-filtering-capability-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_cooperative_filtering_capability_received(self):
    """
    Getter method for cooperative_filtering_capability_received, mapped from YANG variable /bgp_state/neighbor/evpn/cooperative_filtering_capability_received (boolean)

    YANG Description: CooperativeFilteringCapability: Received
    """
    return self.__cooperative_filtering_capability_received
      
  def _set_cooperative_filtering_capability_received(self, v, load=False):
    """
    Setter method for cooperative_filtering_capability_received, mapped from YANG variable /bgp_state/neighbor/evpn/cooperative_filtering_capability_received (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cooperative_filtering_capability_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cooperative_filtering_capability_received() directly.

    YANG Description: CooperativeFilteringCapability: Received
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="cooperative-filtering-capability-received", rest_name="cooperative-filtering-capability-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cooperative_filtering_capability_received must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cooperative-filtering-capability-received", rest_name="cooperative-filtering-capability-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__cooperative_filtering_capability_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cooperative_filtering_capability_received(self):
    self.__cooperative_filtering_capability_received = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cooperative-filtering-capability-received", rest_name="cooperative-filtering-capability-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_route_reflector_client(self):
    """
    Getter method for route_reflector_client, mapped from YANG variable /bgp_state/neighbor/evpn/route_reflector_client (boolean)

    YANG Description: RouteReflectorClient
    """
    return self.__route_reflector_client
      
  def _set_route_reflector_client(self, v, load=False):
    """
    Setter method for route_reflector_client, mapped from YANG variable /bgp_state/neighbor/evpn/route_reflector_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector_client() directly.

    YANG Description: RouteReflectorClient
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="route-reflector-client", rest_name="route-reflector-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="route-reflector-client", rest_name="route-reflector-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__route_reflector_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector_client(self):
    self.__route_reflector_client = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="route-reflector-client", rest_name="route-reflector-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_send_community(self):
    """
    Getter method for send_community, mapped from YANG variable /bgp_state/neighbor/evpn/send_community (boolean)

    YANG Description: Send community
    """
    return self.__send_community
      
  def _set_send_community(self, v, load=False):
    """
    Setter method for send_community, mapped from YANG variable /bgp_state/neighbor/evpn/send_community (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_community is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_community() directly.

    YANG Description: Send community
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="send-community", rest_name="send-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_community must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="send-community", rest_name="send-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__send_community = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_community(self):
    self.__send_community = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="send-community", rest_name="send-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_peer_as_check(self):
    """
    Getter method for peer_as_check, mapped from YANG variable /bgp_state/neighbor/evpn/peer_as_check (boolean)

    YANG Description: Peer AS check
    """
    return self.__peer_as_check
      
  def _set_peer_as_check(self, v, load=False):
    """
    Setter method for peer_as_check, mapped from YANG variable /bgp_state/neighbor/evpn/peer_as_check (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_as_check is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_as_check() directly.

    YANG Description: Peer AS check
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="peer-as-check", rest_name="peer-as-check", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_as_check must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="peer-as-check", rest_name="peer-as-check", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__peer_as_check = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_as_check(self):
    self.__peer_as_check = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="peer-as-check", rest_name="peer-as-check", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_send_ext_community(self):
    """
    Getter method for send_ext_community, mapped from YANG variable /bgp_state/neighbor/evpn/send_ext_community (boolean)

    YANG Description: Send extended community
    """
    return self.__send_ext_community
      
  def _set_send_ext_community(self, v, load=False):
    """
    Setter method for send_ext_community, mapped from YANG variable /bgp_state/neighbor/evpn/send_ext_community (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_ext_community is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_ext_community() directly.

    YANG Description: Send extended community
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="send-ext-community", rest_name="send-ext-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_ext_community must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="send-ext-community", rest_name="send-ext-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__send_ext_community = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_ext_community(self):
    self.__send_ext_community = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="send-ext-community", rest_name="send-ext-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_default_originate(self):
    """
    Getter method for default_originate, mapped from YANG variable /bgp_state/neighbor/evpn/default_originate (boolean)

    YANG Description: Default Originate
    """
    return self.__default_originate
      
  def _set_default_originate(self, v, load=False):
    """
    Setter method for default_originate, mapped from YANG variable /bgp_state/neighbor/evpn/default_originate (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_originate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_originate() directly.

    YANG Description: Default Originate
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="default-originate", rest_name="default-originate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_originate must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-originate", rest_name="default-originate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__default_originate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_originate(self):
    self.__default_originate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-originate", rest_name="default-originate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_default_originate_sent(self):
    """
    Getter method for default_originate_sent, mapped from YANG variable /bgp_state/neighbor/evpn/default_originate_sent (boolean)

    YANG Description: Indicates if default originate is sent or not
    """
    return self.__default_originate_sent
      
  def _set_default_originate_sent(self, v, load=False):
    """
    Setter method for default_originate_sent, mapped from YANG variable /bgp_state/neighbor/evpn/default_originate_sent (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_originate_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_originate_sent() directly.

    YANG Description: Indicates if default originate is sent or not
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="default-originate-sent", rest_name="default-originate-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_originate_sent must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-originate-sent", rest_name="default-originate-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__default_originate_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_originate_sent(self):
    self.__default_originate_sent = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-originate-sent", rest_name="default-originate-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_max_prefix_limit(self):
    """
    Getter method for max_prefix_limit, mapped from YANG variable /bgp_state/neighbor/evpn/max_prefix_limit (int32)

    YANG Description: Maximum prefix
    """
    return self.__max_prefix_limit
      
  def _set_max_prefix_limit(self, v, load=False):
    """
    Setter method for max_prefix_limit, mapped from YANG variable /bgp_state/neighbor/evpn/max_prefix_limit (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefix_limit() directly.

    YANG Description: Maximum prefix
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="max-prefix-limit", rest_name="max-prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefix_limit must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="max-prefix-limit", rest_name="max-prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__max_prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefix_limit(self):
    self.__max_prefix_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="max-prefix-limit", rest_name="max-prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_unsuppress_route_map(self):
    """
    Getter method for unsuppress_route_map, mapped from YANG variable /bgp_state/neighbor/evpn/unsuppress_route_map (string)

    YANG Description: Unsuppress route map
    """
    return self.__unsuppress_route_map
      
  def _set_unsuppress_route_map(self, v, load=False):
    """
    Setter method for unsuppress_route_map, mapped from YANG variable /bgp_state/neighbor/evpn/unsuppress_route_map (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unsuppress_route_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unsuppress_route_map() directly.

    YANG Description: Unsuppress route map
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="unsuppress-route-map", rest_name="unsuppress-route-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unsuppress_route_map must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="unsuppress-route-map", rest_name="unsuppress-route-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__unsuppress_route_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unsuppress_route_map(self):
    self.__unsuppress_route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="unsuppress-route-map", rest_name="unsuppress-route-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_last_conn_reset_reason(self):
    """
    Getter method for last_conn_reset_reason, mapped from YANG variable /bgp_state/neighbor/evpn/last_conn_reset_reason (string)

    YANG Description: Last connection reset reason
    """
    return self.__last_conn_reset_reason
      
  def _set_last_conn_reset_reason(self, v, load=False):
    """
    Setter method for last_conn_reset_reason, mapped from YANG variable /bgp_state/neighbor/evpn/last_conn_reset_reason (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_conn_reset_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_conn_reset_reason() directly.

    YANG Description: Last connection reset reason
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="last-conn-reset-reason", rest_name="last-conn-reset-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_conn_reset_reason must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="last-conn-reset-reason", rest_name="last-conn-reset-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__last_conn_reset_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_conn_reset_reason(self):
    self.__last_conn_reset_reason = YANGDynClass(base=unicode, is_leaf=True, yang_name="last-conn-reset-reason", rest_name="last-conn-reset-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_notification_sent_code(self):
    """
    Getter method for notification_sent_code, mapped from YANG variable /bgp_state/neighbor/evpn/notification_sent_code (string)

    YANG Description: Notification sent code
    """
    return self.__notification_sent_code
      
  def _set_notification_sent_code(self, v, load=False):
    """
    Setter method for notification_sent_code, mapped from YANG variable /bgp_state/neighbor/evpn/notification_sent_code (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_notification_sent_code is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_notification_sent_code() directly.

    YANG Description: Notification sent code
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="notification-sent-code", rest_name="notification-sent-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """notification_sent_code must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="notification-sent-code", rest_name="notification-sent-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__notification_sent_code = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_notification_sent_code(self):
    self.__notification_sent_code = YANGDynClass(base=unicode, is_leaf=True, yang_name="notification-sent-code", rest_name="notification-sent-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_notification_received_code(self):
    """
    Getter method for notification_received_code, mapped from YANG variable /bgp_state/neighbor/evpn/notification_received_code (string)

    YANG Description: Notification received code
    """
    return self.__notification_received_code
      
  def _set_notification_received_code(self, v, load=False):
    """
    Setter method for notification_received_code, mapped from YANG variable /bgp_state/neighbor/evpn/notification_received_code (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_notification_received_code is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_notification_received_code() directly.

    YANG Description: Notification received code
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="notification-received-code", rest_name="notification-received-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """notification_received_code must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="notification-received-code", rest_name="notification-received-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__notification_received_code = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_notification_received_code(self):
    self.__notification_received_code = YANGDynClass(base=unicode, is_leaf=True, yang_name="notification-received-code", rest_name="notification-received-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_update_source(self):
    """
    Getter method for update_source, mapped from YANG variable /bgp_state/neighbor/evpn/update_source (container)

    YANG Description: Update source information
    """
    return self.__update_source
      
  def _set_update_source(self, v, load=False):
    """
    Setter method for update_source, mapped from YANG variable /bgp_state/neighbor/evpn/update_source (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_update_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_update_source() directly.

    YANG Description: Update source information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=update_source.update_source, is_container='container', presence=False, yang_name="update-source", rest_name="update-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-update-source', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """update_source must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=update_source.update_source, is_container='container', presence=False, yang_name="update-source", rest_name="update-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-update-source', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)""",
        })

    self.__update_source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_update_source(self):
    self.__update_source = YANGDynClass(base=update_source.update_source, is_container='container', presence=False, yang_name="update-source", rest_name="update-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-update-source', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)


  def _get_last_update_time(self):
    """
    Getter method for last_update_time, mapped from YANG variable /bgp_state/neighbor/evpn/last_update_time (container)

    YANG Description: Last update time
    """
    return self.__last_update_time
      
  def _set_last_update_time(self, v, load=False):
    """
    Setter method for last_update_time, mapped from YANG variable /bgp_state/neighbor/evpn/last_update_time (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_update_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_update_time() directly.

    YANG Description: Last update time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=last_update_time.last_update_time, is_container='container', presence=False, yang_name="last-update-time", rest_name="last-update-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-last-update-time-tx-rx', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_update_time must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=last_update_time.last_update_time, is_container='container', presence=False, yang_name="last-update-time", rest_name="last-update-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-last-update-time-tx-rx', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)""",
        })

    self.__last_update_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_update_time(self):
    self.__last_update_time = YANGDynClass(base=last_update_time.last_update_time, is_container='container', presence=False, yang_name="last-update-time", rest_name="last-update-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-last-update-time-tx-rx', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)


  def _get_neighbor_nlri_negotiation(self):
    """
    Getter method for neighbor_nlri_negotiation, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_nlri_negotiation (container)

    YANG Description: Peer negotiations
    """
    return self.__neighbor_nlri_negotiation
      
  def _set_neighbor_nlri_negotiation(self, v, load=False):
    """
    Setter method for neighbor_nlri_negotiation, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_nlri_negotiation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_nlri_negotiation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_nlri_negotiation() directly.

    YANG Description: Peer negotiations
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=neighbor_nlri_negotiation.neighbor_nlri_negotiation, is_container='container', presence=False, yang_name="neighbor-nlri-negotiation", rest_name="neighbor-nlri-negotiation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-peer-negotiations', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_nlri_negotiation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=neighbor_nlri_negotiation.neighbor_nlri_negotiation, is_container='container', presence=False, yang_name="neighbor-nlri-negotiation", rest_name="neighbor-nlri-negotiation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-peer-negotiations', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)""",
        })

    self.__neighbor_nlri_negotiation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_nlri_negotiation(self):
    self.__neighbor_nlri_negotiation = YANGDynClass(base=neighbor_nlri_negotiation.neighbor_nlri_negotiation, is_container='container', presence=False, yang_name="neighbor-nlri-negotiation", rest_name="neighbor-nlri-negotiation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-peer-negotiations', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)


  def _get_neighbor_configured_routes(self):
    """
    Getter method for neighbor_configured_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes (container)

    YANG Description: Peer ocnfigurations
    """
    return self.__neighbor_configured_routes
      
  def _set_neighbor_configured_routes(self, v, load=False):
    """
    Setter method for neighbor_configured_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_configured_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_configured_routes() directly.

    YANG Description: Peer ocnfigurations
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=neighbor_configured_routes.neighbor_configured_routes, is_container='container', presence=False, yang_name="neighbor-configured-routes", rest_name="neighbor-configured-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-peer-configurations', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_configured_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=neighbor_configured_routes.neighbor_configured_routes, is_container='container', presence=False, yang_name="neighbor-configured-routes", rest_name="neighbor-configured-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-peer-configurations', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)""",
        })

    self.__neighbor_configured_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_configured_routes(self):
    self.__neighbor_configured_routes = YANGDynClass(base=neighbor_configured_routes.neighbor_configured_routes, is_container='container', presence=False, yang_name="neighbor-configured-routes", rest_name="neighbor-configured-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-peer-configurations', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)


  def _get_distribute_list(self):
    """
    Getter method for distribute_list, mapped from YANG variable /bgp_state/neighbor/evpn/distribute_list (container)
    """
    return self.__distribute_list
      
  def _set_distribute_list(self, v, load=False):
    """
    Setter method for distribute_list, mapped from YANG variable /bgp_state/neighbor/evpn/distribute_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_distribute_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_distribute_list() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=distribute_list.distribute_list, is_container='container', presence=False, yang_name="distribute-list", rest_name="distribute-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-distribute-list-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """distribute_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=distribute_list.distribute_list, is_container='container', presence=False, yang_name="distribute-list", rest_name="distribute-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-distribute-list-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)""",
        })

    self.__distribute_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_distribute_list(self):
    self.__distribute_list = YANGDynClass(base=distribute_list.distribute_list, is_container='container', presence=False, yang_name="distribute-list", rest_name="distribute-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-distribute-list-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)


  def _get_filter_list(self):
    """
    Getter method for filter_list, mapped from YANG variable /bgp_state/neighbor/evpn/filter_list (container)
    """
    return self.__filter_list
      
  def _set_filter_list(self, v, load=False):
    """
    Setter method for filter_list, mapped from YANG variable /bgp_state/neighbor/evpn/filter_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filter_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filter_list() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=filter_list.filter_list, is_container='container', presence=False, yang_name="filter-list", rest_name="filter-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-filter-list-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filter_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=filter_list.filter_list, is_container='container', presence=False, yang_name="filter-list", rest_name="filter-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-filter-list-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)""",
        })

    self.__filter_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filter_list(self):
    self.__filter_list = YANGDynClass(base=filter_list.filter_list, is_container='container', presence=False, yang_name="filter-list", rest_name="filter-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-filter-list-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)


  def _get_prefix_list(self):
    """
    Getter method for prefix_list, mapped from YANG variable /bgp_state/neighbor/evpn/prefix_list (container)
    """
    return self.__prefix_list
      
  def _set_prefix_list(self, v, load=False):
    """
    Setter method for prefix_list, mapped from YANG variable /bgp_state/neighbor/evpn/prefix_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_list() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=prefix_list.prefix_list, is_container='container', presence=False, yang_name="prefix-list", rest_name="prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-prefix-list-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=prefix_list.prefix_list, is_container='container', presence=False, yang_name="prefix-list", rest_name="prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-prefix-list-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)""",
        })

    self.__prefix_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_list(self):
    self.__prefix_list = YANGDynClass(base=prefix_list.prefix_list, is_container='container', presence=False, yang_name="prefix-list", rest_name="prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-prefix-list-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)


  def _get_route_map(self):
    """
    Getter method for route_map, mapped from YANG variable /bgp_state/neighbor/evpn/route_map (container)
    """
    return self.__route_map
      
  def _set_route_map(self, v, load=False):
    """
    Setter method for route_map, mapped from YANG variable /bgp_state/neighbor/evpn/route_map (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_map() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=route_map.route_map, is_container='container', presence=False, yang_name="route-map", rest_name="route-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-route-map-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_map must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=route_map.route_map, is_container='container', presence=False, yang_name="route-map", rest_name="route-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-route-map-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)""",
        })

    self.__route_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_map(self):
    self.__route_map = YANGDynClass(base=route_map.route_map, is_container='container', presence=False, yang_name="route-map", rest_name="route-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-access-list-route-map-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)


  def _get_msg_sent(self):
    """
    Getter method for msg_sent, mapped from YANG variable /bgp_state/neighbor/evpn/msg_sent (container)
    """
    return self.__msg_sent
      
  def _set_msg_sent(self, v, load=False):
    """
    Setter method for msg_sent, mapped from YANG variable /bgp_state/neighbor/evpn/msg_sent (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_msg_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_msg_sent() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=msg_sent.msg_sent, is_container='container', presence=False, yang_name="msg-sent", rest_name="msg-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-bgp-message-msg-sent-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """msg_sent must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=msg_sent.msg_sent, is_container='container', presence=False, yang_name="msg-sent", rest_name="msg-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-bgp-message-msg-sent-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)""",
        })

    self.__msg_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_msg_sent(self):
    self.__msg_sent = YANGDynClass(base=msg_sent.msg_sent, is_container='container', presence=False, yang_name="msg-sent", rest_name="msg-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-bgp-message-msg-sent-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)


  def _get_msg_received(self):
    """
    Getter method for msg_received, mapped from YANG variable /bgp_state/neighbor/evpn/msg_received (container)
    """
    return self.__msg_received
      
  def _set_msg_received(self, v, load=False):
    """
    Setter method for msg_received, mapped from YANG variable /bgp_state/neighbor/evpn/msg_received (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_msg_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_msg_received() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=msg_received.msg_received, is_container='container', presence=False, yang_name="msg-received", rest_name="msg-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-bgp-message-msg-received-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """msg_received must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=msg_received.msg_received, is_container='container', presence=False, yang_name="msg-received", rest_name="msg-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-bgp-message-msg-received-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)""",
        })

    self.__msg_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_msg_received(self):
    self.__msg_received = YANGDynClass(base=msg_received.msg_received, is_container='container', presence=False, yang_name="msg-received", rest_name="msg-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'bgp-bgp-message-msg-received-1'}}, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='container', is_config=False)


  def _get_remote_address(self):
    """
    Getter method for remote_address, mapped from YANG variable /bgp_state/neighbor/evpn/remote_address (inet:ipv4-address)

    YANG Description: Remote Address
    """
    return self.__remote_address
      
  def _set_remote_address(self, v, load=False):
    """
    Setter method for remote_address, mapped from YANG variable /bgp_state/neighbor/evpn/remote_address (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_address() directly.

    YANG Description: Remote Address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="remote-address", rest_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_address must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="remote-address", rest_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)""",
        })

    self.__remote_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_address(self):
    self.__remote_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="remote-address", rest_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)

  remote_as = __builtin__.property(_get_remote_as)
  router_id = __builtin__.property(_get_router_id)
  vrf = __builtin__.property(_get_vrf)
  local_as = __builtin__.property(_get_local_as)
  no_prepend = __builtin__.property(_get_no_prepend)
  description = __builtin__.property(_get_description)
  bgp_state = __builtin__.property(_get_bgp_state)
  bgp_state_time = __builtin__.property(_get_bgp_state_time)
  keep_alive_time = __builtin__.property(_get_keep_alive_time)
  hold_time = __builtin__.property(_get_hold_time)
  keep_alive_time_expire = __builtin__.property(_get_keep_alive_time_expire)
  hold_time_expire = __builtin__.property(_get_hold_time_expire)
  min_advertisement_interval = __builtin__.property(_get_min_advertisement_interval)
  peer_group = __builtin__.property(_get_peer_group)
  multihop_ebgp_ttl = __builtin__.property(_get_multihop_ebgp_ttl)
  multihop_btsh = __builtin__.property(_get_multihop_btsh)
  md5_password = __builtin__.property(_get_md5_password)
  next_hop_self = __builtin__.property(_get_next_hop_self)
  remove_private_as = __builtin__.property(_get_remove_private_as)
  soft_inbound_reconfig = __builtin__.property(_get_soft_inbound_reconfig)
  refresh_capability_received = __builtin__.property(_get_refresh_capability_received)
  gr_capability_received = __builtin__.property(_get_gr_capability_received)
  gr_restart_time_received = __builtin__.property(_get_gr_restart_time_received)
  gr_restart_bit_received = __builtin__.property(_get_gr_restart_bit_received)
  afi = __builtin__.property(_get_afi)
  safi = __builtin__.property(_get_safi)
  forwarding_bit = __builtin__.property(_get_forwarding_bit)
  gr_capability_sent = __builtin__.property(_get_gr_capability_sent)
  gr_restart_time_sent = __builtin__.property(_get_gr_restart_time_sent)
  gr_restart_bit_sent = __builtin__.property(_get_gr_restart_bit_sent)
  stale_state = __builtin__.property(_get_stale_state)
  stale_state_time_left_to_reconnect = __builtin__.property(_get_stale_state_time_left_to_reconnect)
  restarting_state = __builtin__.property(_get_restarting_state)
  restarting_time_left_to_converge = __builtin__.property(_get_restarting_time_left_to_converge)
  restarting_start_stale_timer = __builtin__.property(_get_restarting_start_stale_timer)
  restarting_stale_timer_left_to_converge = __builtin__.property(_get_restarting_stale_timer_left_to_converge)
  purge_time = __builtin__.property(_get_purge_time)
  cooperative_filtering_capability_sent = __builtin__.property(_get_cooperative_filtering_capability_sent)
  cooperative_filtering_capability_received = __builtin__.property(_get_cooperative_filtering_capability_received)
  route_reflector_client = __builtin__.property(_get_route_reflector_client)
  send_community = __builtin__.property(_get_send_community)
  peer_as_check = __builtin__.property(_get_peer_as_check)
  send_ext_community = __builtin__.property(_get_send_ext_community)
  default_originate = __builtin__.property(_get_default_originate)
  default_originate_sent = __builtin__.property(_get_default_originate_sent)
  max_prefix_limit = __builtin__.property(_get_max_prefix_limit)
  unsuppress_route_map = __builtin__.property(_get_unsuppress_route_map)
  last_conn_reset_reason = __builtin__.property(_get_last_conn_reset_reason)
  notification_sent_code = __builtin__.property(_get_notification_sent_code)
  notification_received_code = __builtin__.property(_get_notification_received_code)
  update_source = __builtin__.property(_get_update_source)
  last_update_time = __builtin__.property(_get_last_update_time)
  neighbor_nlri_negotiation = __builtin__.property(_get_neighbor_nlri_negotiation)
  neighbor_configured_routes = __builtin__.property(_get_neighbor_configured_routes)
  distribute_list = __builtin__.property(_get_distribute_list)
  filter_list = __builtin__.property(_get_filter_list)
  prefix_list = __builtin__.property(_get_prefix_list)
  route_map = __builtin__.property(_get_route_map)
  msg_sent = __builtin__.property(_get_msg_sent)
  msg_received = __builtin__.property(_get_msg_received)
  remote_address = __builtin__.property(_get_remote_address)


  _pyangbind_elements = {'remote_as': remote_as, 'router_id': router_id, 'vrf': vrf, 'local_as': local_as, 'no_prepend': no_prepend, 'description': description, 'bgp_state': bgp_state, 'bgp_state_time': bgp_state_time, 'keep_alive_time': keep_alive_time, 'hold_time': hold_time, 'keep_alive_time_expire': keep_alive_time_expire, 'hold_time_expire': hold_time_expire, 'min_advertisement_interval': min_advertisement_interval, 'peer_group': peer_group, 'multihop_ebgp_ttl': multihop_ebgp_ttl, 'multihop_btsh': multihop_btsh, 'md5_password': md5_password, 'next_hop_self': next_hop_self, 'remove_private_as': remove_private_as, 'soft_inbound_reconfig': soft_inbound_reconfig, 'refresh_capability_received': refresh_capability_received, 'gr_capability_received': gr_capability_received, 'gr_restart_time_received': gr_restart_time_received, 'gr_restart_bit_received': gr_restart_bit_received, 'afi': afi, 'safi': safi, 'forwarding_bit': forwarding_bit, 'gr_capability_sent': gr_capability_sent, 'gr_restart_time_sent': gr_restart_time_sent, 'gr_restart_bit_sent': gr_restart_bit_sent, 'stale_state': stale_state, 'stale_state_time_left_to_reconnect': stale_state_time_left_to_reconnect, 'restarting_state': restarting_state, 'restarting_time_left_to_converge': restarting_time_left_to_converge, 'restarting_start_stale_timer': restarting_start_stale_timer, 'restarting_stale_timer_left_to_converge': restarting_stale_timer_left_to_converge, 'purge_time': purge_time, 'cooperative_filtering_capability_sent': cooperative_filtering_capability_sent, 'cooperative_filtering_capability_received': cooperative_filtering_capability_received, 'route_reflector_client': route_reflector_client, 'send_community': send_community, 'peer_as_check': peer_as_check, 'send_ext_community': send_ext_community, 'default_originate': default_originate, 'default_originate_sent': default_originate_sent, 'max_prefix_limit': max_prefix_limit, 'unsuppress_route_map': unsuppress_route_map, 'last_conn_reset_reason': last_conn_reset_reason, 'notification_sent_code': notification_sent_code, 'notification_received_code': notification_received_code, 'update_source': update_source, 'last_update_time': last_update_time, 'neighbor_nlri_negotiation': neighbor_nlri_negotiation, 'neighbor_configured_routes': neighbor_configured_routes, 'distribute_list': distribute_list, 'filter_list': filter_list, 'prefix_list': prefix_list, 'route_map': route_map, 'msg_sent': msg_sent, 'msg_received': msg_received, 'remote_address': remote_address, }


