
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class auto_discovery(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-bgp-operational - based on the path /bgp-state/route/evpn/auto-discovery. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: EVPN Routes type auto-discovery information
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__prefix','__status','__age','__next_hop','__next_hop_learned_from_peer','__next_hop_metric','__rd','__vrf_label_direction','__local_preference','__med','__origin','__weight','__as_path','__communities','__extended_community','__atomic_aggregate_set','__aggregator','__originator','__cluster_list','__adj_rib_out_count','__admin_distance','__tag','__l3_label','__l2_label','__esi','__rmac','__source_rd','__vrf_label','__esi_value','__ethernet_tag',)

  _yang_name = 'auto-discovery'
  _rest_name = 'auto-discovery'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__origin = YANGDynClass(base=unicode, is_leaf=True, yang_name="origin", rest_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__originator = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="originator", rest_name="originator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)
    self.__weight = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="weight", rest_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__atomic_aggregate_set = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="atomic-aggregate-set", rest_name="atomic-aggregate-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__rmac = YANGDynClass(base=unicode, is_leaf=True, yang_name="rmac", rest_name="rmac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__as_path = YANGDynClass(base=unicode, is_leaf=True, yang_name="as-path", rest_name="as-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__admin_distance = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="admin-distance", rest_name="admin-distance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__ethernet_tag = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ethernet-tag", rest_name="ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", rest_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-prefix', is_config=False)
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tag", rest_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__esi_value = YANGDynClass(base=unicode, is_leaf=True, yang_name="esi-value", rest_name="esi-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__vrf_label = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="vrf-label", rest_name="vrf-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)
    self.__extended_community = YANGDynClass(base=unicode, is_leaf=True, yang_name="extended-community", rest_name="extended-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__aggregator = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="aggregator", rest_name="aggregator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)
    self.__rd = YANGDynClass(base=unicode, is_leaf=True, yang_name="rd", rest_name="rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__local_preference = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-preference", rest_name="local-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__next_hop_metric = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="next-hop-metric", rest_name="next-hop-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)
    self.__esi = YANGDynClass(base=unicode, is_leaf=True, yang_name="esi", rest_name="esi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__status = YANGDynClass(base=unicode, is_leaf=True, yang_name="status", rest_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__med = YANGDynClass(base=unicode, is_leaf=True, yang_name="med", rest_name="med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__l3_label = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="l3-label", rest_name="l3-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__cluster_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="cluster-list", rest_name="cluster-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__next_hop = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="next-hop", rest_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)
    self.__next_hop_learned_from_peer = YANGDynClass(base=unicode, is_leaf=True, yang_name="next-hop-learned-from-peer", rest_name="next-hop-learned-from-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__communities = YANGDynClass(base=unicode, is_leaf=True, yang_name="communities", rest_name="communities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__adj_rib_out_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="adj-rib-out-count", rest_name="adj-rib-out-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    self.__age = YANGDynClass(base=unicode, is_leaf=True, yang_name="age", rest_name="age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__vrf_label_direction = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {'value': 1}, u'in': {'value': 0}},), is_leaf=True, yang_name="vrf-label-direction", rest_name="vrf-label-direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='direction', is_config=False)
    self.__source_rd = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-rd", rest_name="source-rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    self.__l2_label = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="l2-label", rest_name="l2-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'bgp-state', u'route', u'evpn', u'auto-discovery']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'bgp-state', u'route', u'evpn', u'auto-discovery']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/prefix (inet:ipv4-prefix)

    YANG Description: Network Prefix
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/prefix (inet:ipv4-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Network Prefix
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", rest_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-prefix', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with inet:ipv4-prefix""",
          'defined-type': "inet:ipv4-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", rest_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-prefix', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", rest_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-prefix', is_config=False)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/status (string)

    YANG Description: Status
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/status (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="status", rest_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="status", rest_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=unicode, is_leaf=True, yang_name="status", rest_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_age(self):
    """
    Getter method for age, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/age (string)

    YANG Description: Age
    """
    return self.__age
      
  def _set_age(self, v, load=False):
    """
    Setter method for age, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/age (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_age is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_age() directly.

    YANG Description: Age
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="age", rest_name="age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """age must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="age", rest_name="age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__age = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_age(self):
    self.__age = YANGDynClass(base=unicode, is_leaf=True, yang_name="age", rest_name="age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/next_hop (inet:ipv4-address)

    YANG Description: Next hop address
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/next_hop (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Next hop address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="next-hop", rest_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="next-hop", rest_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="next-hop", rest_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)


  def _get_next_hop_learned_from_peer(self):
    """
    Getter method for next_hop_learned_from_peer, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/next_hop_learned_from_peer (string)

    YANG Description: Next hop address learned from peer
    """
    return self.__next_hop_learned_from_peer
      
  def _set_next_hop_learned_from_peer(self, v, load=False):
    """
    Setter method for next_hop_learned_from_peer, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/next_hop_learned_from_peer (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_learned_from_peer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_learned_from_peer() directly.

    YANG Description: Next hop address learned from peer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="next-hop-learned-from-peer", rest_name="next-hop-learned-from-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_learned_from_peer must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="next-hop-learned-from-peer", rest_name="next-hop-learned-from-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__next_hop_learned_from_peer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_learned_from_peer(self):
    self.__next_hop_learned_from_peer = YANGDynClass(base=unicode, is_leaf=True, yang_name="next-hop-learned-from-peer", rest_name="next-hop-learned-from-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_next_hop_metric(self):
    """
    Getter method for next_hop_metric, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/next_hop_metric (uint32)

    YANG Description: Next hop metric
    """
    return self.__next_hop_metric
      
  def _set_next_hop_metric(self, v, load=False):
    """
    Setter method for next_hop_metric, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/next_hop_metric (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_metric() directly.

    YANG Description: Next hop metric
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="next-hop-metric", rest_name="next-hop-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_metric must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="next-hop-metric", rest_name="next-hop-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)""",
        })

    self.__next_hop_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_metric(self):
    self.__next_hop_metric = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="next-hop-metric", rest_name="next-hop-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)


  def _get_rd(self):
    """
    Getter method for rd, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/rd (string)

    YANG Description: Route distinguisher
    """
    return self.__rd
      
  def _set_rd(self, v, load=False):
    """
    Setter method for rd, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/rd (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rd() directly.

    YANG Description: Route distinguisher
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="rd", rest_name="rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rd must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="rd", rest_name="rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__rd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rd(self):
    self.__rd = YANGDynClass(base=unicode, is_leaf=True, yang_name="rd", rest_name="rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_vrf_label_direction(self):
    """
    Getter method for vrf_label_direction, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/vrf_label_direction (direction)

    YANG Description: VRF label direction
    """
    return self.__vrf_label_direction
      
  def _set_vrf_label_direction(self, v, load=False):
    """
    Setter method for vrf_label_direction, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/vrf_label_direction (direction)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_label_direction is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_label_direction() directly.

    YANG Description: VRF label direction
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {'value': 1}, u'in': {'value': 0}},), is_leaf=True, yang_name="vrf-label-direction", rest_name="vrf-label-direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='direction', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_label_direction must be of a type compatible with direction""",
          'defined-type': "brocade-bgp-operational:direction",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {'value': 1}, u'in': {'value': 0}},), is_leaf=True, yang_name="vrf-label-direction", rest_name="vrf-label-direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='direction', is_config=False)""",
        })

    self.__vrf_label_direction = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_label_direction(self):
    self.__vrf_label_direction = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {'value': 1}, u'in': {'value': 0}},), is_leaf=True, yang_name="vrf-label-direction", rest_name="vrf-label-direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='direction', is_config=False)


  def _get_local_preference(self):
    """
    Getter method for local_preference, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/local_preference (string)

    YANG Description: Local Preference
    """
    return self.__local_preference
      
  def _set_local_preference(self, v, load=False):
    """
    Setter method for local_preference, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/local_preference (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_preference() directly.

    YANG Description: Local Preference
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="local-preference", rest_name="local-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_preference must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="local-preference", rest_name="local-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__local_preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_preference(self):
    self.__local_preference = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-preference", rest_name="local-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_med(self):
    """
    Getter method for med, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/med (string)

    YANG Description: Multi exit discriminator
    """
    return self.__med
      
  def _set_med(self, v, load=False):
    """
    Setter method for med, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/med (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_med is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_med() directly.

    YANG Description: Multi exit discriminator
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="med", rest_name="med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """med must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="med", rest_name="med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__med = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_med(self):
    self.__med = YANGDynClass(base=unicode, is_leaf=True, yang_name="med", rest_name="med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/origin (string)

    YANG Description: Origin
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/origin (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: Origin
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="origin", rest_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="origin", rest_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=unicode, is_leaf=True, yang_name="origin", rest_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_weight(self):
    """
    Getter method for weight, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/weight (int32)

    YANG Description: weight
    """
    return self.__weight
      
  def _set_weight(self, v, load=False):
    """
    Setter method for weight, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/weight (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_weight is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_weight() directly.

    YANG Description: weight
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="weight", rest_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """weight must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="weight", rest_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__weight = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_weight(self):
    self.__weight = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="weight", rest_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_as_path(self):
    """
    Getter method for as_path, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/as_path (string)

    YANG Description: As Path
    """
    return self.__as_path
      
  def _set_as_path(self, v, load=False):
    """
    Setter method for as_path, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/as_path (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_path() directly.

    YANG Description: As Path
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="as-path", rest_name="as-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_path must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="as-path", rest_name="as-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__as_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_path(self):
    self.__as_path = YANGDynClass(base=unicode, is_leaf=True, yang_name="as-path", rest_name="as-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_communities(self):
    """
    Getter method for communities, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/communities (string)

    YANG Description: Communities
    """
    return self.__communities
      
  def _set_communities(self, v, load=False):
    """
    Setter method for communities, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/communities (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_communities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_communities() directly.

    YANG Description: Communities
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="communities", rest_name="communities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """communities must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="communities", rest_name="communities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__communities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_communities(self):
    self.__communities = YANGDynClass(base=unicode, is_leaf=True, yang_name="communities", rest_name="communities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_extended_community(self):
    """
    Getter method for extended_community, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/extended_community (string)

    YANG Description: Communities
    """
    return self.__extended_community
      
  def _set_extended_community(self, v, load=False):
    """
    Setter method for extended_community, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/extended_community (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended_community is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended_community() directly.

    YANG Description: Communities
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="extended-community", rest_name="extended-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended_community must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="extended-community", rest_name="extended-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__extended_community = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended_community(self):
    self.__extended_community = YANGDynClass(base=unicode, is_leaf=True, yang_name="extended-community", rest_name="extended-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_atomic_aggregate_set(self):
    """
    Getter method for atomic_aggregate_set, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/atomic_aggregate_set (boolean)

    YANG Description: Atomic aggregate set
    """
    return self.__atomic_aggregate_set
      
  def _set_atomic_aggregate_set(self, v, load=False):
    """
    Setter method for atomic_aggregate_set, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/atomic_aggregate_set (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_atomic_aggregate_set is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_atomic_aggregate_set() directly.

    YANG Description: Atomic aggregate set
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="atomic-aggregate-set", rest_name="atomic-aggregate-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """atomic_aggregate_set must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="atomic-aggregate-set", rest_name="atomic-aggregate-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__atomic_aggregate_set = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_atomic_aggregate_set(self):
    self.__atomic_aggregate_set = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="atomic-aggregate-set", rest_name="atomic-aggregate-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_aggregator(self):
    """
    Getter method for aggregator, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/aggregator (inet:ipv4-address)

    YANG Description: Aggregator
    """
    return self.__aggregator
      
  def _set_aggregator(self, v, load=False):
    """
    Setter method for aggregator, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/aggregator (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregator() directly.

    YANG Description: Aggregator
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="aggregator", rest_name="aggregator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggregator must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="aggregator", rest_name="aggregator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)""",
        })

    self.__aggregator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggregator(self):
    self.__aggregator = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="aggregator", rest_name="aggregator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)


  def _get_originator(self):
    """
    Getter method for originator, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/originator (inet:ipv4-address)

    YANG Description: Originator Id
    """
    return self.__originator
      
  def _set_originator(self, v, load=False):
    """
    Setter method for originator, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/originator (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_originator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_originator() directly.

    YANG Description: Originator Id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="originator", rest_name="originator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """originator must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="originator", rest_name="originator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)""",
        })

    self.__originator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_originator(self):
    self.__originator = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="originator", rest_name="originator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='inet:ipv4-address', is_config=False)


  def _get_cluster_list(self):
    """
    Getter method for cluster_list, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/cluster_list (string)

    YANG Description: Cluster list
    """
    return self.__cluster_list
      
  def _set_cluster_list(self, v, load=False):
    """
    Setter method for cluster_list, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/cluster_list (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cluster_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cluster_list() directly.

    YANG Description: Cluster list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cluster-list", rest_name="cluster-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cluster_list must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cluster-list", rest_name="cluster-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__cluster_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cluster_list(self):
    self.__cluster_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="cluster-list", rest_name="cluster-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_adj_rib_out_count(self):
    """
    Getter method for adj_rib_out_count, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/adj_rib_out_count (int32)

    YANG Description: Adj RIB out count
    """
    return self.__adj_rib_out_count
      
  def _set_adj_rib_out_count(self, v, load=False):
    """
    Setter method for adj_rib_out_count, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/adj_rib_out_count (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adj_rib_out_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adj_rib_out_count() directly.

    YANG Description: Adj RIB out count
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="adj-rib-out-count", rest_name="adj-rib-out-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adj_rib_out_count must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="adj-rib-out-count", rest_name="adj-rib-out-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__adj_rib_out_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adj_rib_out_count(self):
    self.__adj_rib_out_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="adj-rib-out-count", rest_name="adj-rib-out-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_admin_distance(self):
    """
    Getter method for admin_distance, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/admin_distance (int32)

    YANG Description: Admin Distance
    """
    return self.__admin_distance
      
  def _set_admin_distance(self, v, load=False):
    """
    Setter method for admin_distance, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/admin_distance (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_distance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_distance() directly.

    YANG Description: Admin Distance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="admin-distance", rest_name="admin-distance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_distance must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="admin-distance", rest_name="admin-distance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__admin_distance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_distance(self):
    self.__admin_distance = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="admin-distance", rest_name="admin-distance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/tag (int32)

    YANG Description: Tag
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/tag (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Tag
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tag", rest_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tag", rest_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tag", rest_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_l3_label(self):
    """
    Getter method for l3_label, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/l3_label (int32)

    YANG Description: L3 Label
    """
    return self.__l3_label
      
  def _set_l3_label(self, v, load=False):
    """
    Setter method for l3_label, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/l3_label (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3_label() directly.

    YANG Description: L3 Label
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="l3-label", rest_name="l3-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3_label must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="l3-label", rest_name="l3-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__l3_label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3_label(self):
    self.__l3_label = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="l3-label", rest_name="l3-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_l2_label(self):
    """
    Getter method for l2_label, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/l2_label (int32)

    YANG Description: L2 Label
    """
    return self.__l2_label
      
  def _set_l2_label(self, v, load=False):
    """
    Setter method for l2_label, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/l2_label (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_label() directly.

    YANG Description: L2 Label
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="l2-label", rest_name="l2-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2_label must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="l2-label", rest_name="l2-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)""",
        })

    self.__l2_label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2_label(self):
    self.__l2_label = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="l2-label", rest_name="l2-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='int32', is_config=False)


  def _get_esi(self):
    """
    Getter method for esi, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/esi (string)

    YANG Description: ESI
    """
    return self.__esi
      
  def _set_esi(self, v, load=False):
    """
    Setter method for esi, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/esi (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esi() directly.

    YANG Description: ESI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="esi", rest_name="esi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esi must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="esi", rest_name="esi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__esi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esi(self):
    self.__esi = YANGDynClass(base=unicode, is_leaf=True, yang_name="esi", rest_name="esi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_rmac(self):
    """
    Getter method for rmac, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/rmac (string)

    YANG Description: Router Mac
    """
    return self.__rmac
      
  def _set_rmac(self, v, load=False):
    """
    Setter method for rmac, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/rmac (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rmac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rmac() directly.

    YANG Description: Router Mac
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="rmac", rest_name="rmac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rmac must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="rmac", rest_name="rmac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__rmac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rmac(self):
    self.__rmac = YANGDynClass(base=unicode, is_leaf=True, yang_name="rmac", rest_name="rmac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_source_rd(self):
    """
    Getter method for source_rd, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/source_rd (string)

    YANG Description: Source Route distinguisher
    """
    return self.__source_rd
      
  def _set_source_rd(self, v, load=False):
    """
    Setter method for source_rd, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/source_rd (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_rd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_rd() directly.

    YANG Description: Source Route distinguisher
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="source-rd", rest_name="source-rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_rd must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="source-rd", rest_name="source-rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__source_rd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_rd(self):
    self.__source_rd = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-rd", rest_name="source-rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_vrf_label(self):
    """
    Getter method for vrf_label, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/vrf_label (uint32)

    YANG Description: VRF Label
    """
    return self.__vrf_label
      
  def _set_vrf_label(self, v, load=False):
    """
    Setter method for vrf_label, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/vrf_label (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_label() directly.

    YANG Description: VRF Label
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="vrf-label", rest_name="vrf-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_label must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="vrf-label", rest_name="vrf-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)""",
        })

    self.__vrf_label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_label(self):
    self.__vrf_label = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="vrf-label", rest_name="vrf-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)


  def _get_esi_value(self):
    """
    Getter method for esi_value, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/esi_value (string)

    YANG Description: ESI value
    """
    return self.__esi_value
      
  def _set_esi_value(self, v, load=False):
    """
    Setter method for esi_value, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/esi_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esi_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esi_value() directly.

    YANG Description: ESI value
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="esi-value", rest_name="esi-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esi_value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="esi-value", rest_name="esi-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)""",
        })

    self.__esi_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esi_value(self):
    self.__esi_value = YANGDynClass(base=unicode, is_leaf=True, yang_name="esi-value", rest_name="esi-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='string', is_config=False)


  def _get_ethernet_tag(self):
    """
    Getter method for ethernet_tag, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/ethernet_tag (uint32)

    YANG Description: Ethernet Tag
    """
    return self.__ethernet_tag
      
  def _set_ethernet_tag(self, v, load=False):
    """
    Setter method for ethernet_tag, mapped from YANG variable /bgp_state/route/evpn/auto_discovery/ethernet_tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet_tag() directly.

    YANG Description: Ethernet Tag
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ethernet-tag", rest_name="ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet_tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ethernet-tag", rest_name="ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)""",
        })

    self.__ethernet_tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet_tag(self):
    self.__ethernet_tag = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ethernet-tag", rest_name="ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='uint32', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  status = __builtin__.property(_get_status)
  age = __builtin__.property(_get_age)
  next_hop = __builtin__.property(_get_next_hop)
  next_hop_learned_from_peer = __builtin__.property(_get_next_hop_learned_from_peer)
  next_hop_metric = __builtin__.property(_get_next_hop_metric)
  rd = __builtin__.property(_get_rd)
  vrf_label_direction = __builtin__.property(_get_vrf_label_direction)
  local_preference = __builtin__.property(_get_local_preference)
  med = __builtin__.property(_get_med)
  origin = __builtin__.property(_get_origin)
  weight = __builtin__.property(_get_weight)
  as_path = __builtin__.property(_get_as_path)
  communities = __builtin__.property(_get_communities)
  extended_community = __builtin__.property(_get_extended_community)
  atomic_aggregate_set = __builtin__.property(_get_atomic_aggregate_set)
  aggregator = __builtin__.property(_get_aggregator)
  originator = __builtin__.property(_get_originator)
  cluster_list = __builtin__.property(_get_cluster_list)
  adj_rib_out_count = __builtin__.property(_get_adj_rib_out_count)
  admin_distance = __builtin__.property(_get_admin_distance)
  tag = __builtin__.property(_get_tag)
  l3_label = __builtin__.property(_get_l3_label)
  l2_label = __builtin__.property(_get_l2_label)
  esi = __builtin__.property(_get_esi)
  rmac = __builtin__.property(_get_rmac)
  source_rd = __builtin__.property(_get_source_rd)
  vrf_label = __builtin__.property(_get_vrf_label)
  esi_value = __builtin__.property(_get_esi_value)
  ethernet_tag = __builtin__.property(_get_ethernet_tag)


  _pyangbind_elements = {'prefix': prefix, 'status': status, 'age': age, 'next_hop': next_hop, 'next_hop_learned_from_peer': next_hop_learned_from_peer, 'next_hop_metric': next_hop_metric, 'rd': rd, 'vrf_label_direction': vrf_label_direction, 'local_preference': local_preference, 'med': med, 'origin': origin, 'weight': weight, 'as_path': as_path, 'communities': communities, 'extended_community': extended_community, 'atomic_aggregate_set': atomic_aggregate_set, 'aggregator': aggregator, 'originator': originator, 'cluster_list': cluster_list, 'adj_rib_out_count': adj_rib_out_count, 'admin_distance': admin_distance, 'tag': tag, 'l3_label': l3_label, 'l2_label': l2_label, 'esi': esi, 'rmac': rmac, 'source_rd': source_rd, 'vrf_label': vrf_label, 'esi_value': esi_value, 'ethernet_tag': ethernet_tag, }


