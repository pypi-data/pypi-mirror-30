
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class neighbor_configured_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-bgp-operational - based on the path /bgp-state/neighbor/evpn/neighbor-configured-routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Peer ocnfigurations
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__ipv4_ucast_mcast_routes','__ipv4_mcast_routes','__ipv4_ucast_routes','__vpnv4_ucast_routes','__vpnv6_ucast_routes','__l2vpn_vpls','__l2vpn_evpn','__ipv6_ucast_mcast_routes','__ipv6_mcast_routes','__ipv6_ucast_routes','__ipv6_mpls_label_capability','__as4_capability',)

  _yang_name = 'neighbor-configured-routes'
  _rest_name = 'neighbor-configured-routes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__l2vpn_evpn = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="l2vpn-evpn", rest_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__as4_capability = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="as4-capability", rest_name="as4-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__ipv4_ucast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv4-ucast-routes", rest_name="ipv4-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__ipv4_ucast_mcast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv4-ucast-mcast-routes", rest_name="ipv4-ucast-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__ipv4_mcast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv4-mcast-routes", rest_name="ipv4-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__vpnv6_ucast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vpnv6-ucast-routes", rest_name="vpnv6-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__ipv6_ucast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ucast-routes", rest_name="ipv6-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__vpnv4_ucast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vpnv4-ucast-routes", rest_name="vpnv4-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__ipv6_ucast_mcast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ucast-mcast-routes", rest_name="ipv6-ucast-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__l2vpn_vpls = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="l2vpn-vpls", rest_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__ipv6_mpls_label_capability = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-mpls-label-capability", rest_name="ipv6-mpls-label-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    self.__ipv6_mcast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-mcast-routes", rest_name="ipv6-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'bgp-state', u'neighbor', u'evpn', u'neighbor-configured-routes']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'bgp-state', u'neighbor', u'evpn', u'neighbor-configured-routes']

  def _get_ipv4_ucast_mcast_routes(self):
    """
    Getter method for ipv4_ucast_mcast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/ipv4_ucast_mcast_routes (boolean)

    YANG Description: IPV4  unicast and multicast  routes
    """
    return self.__ipv4_ucast_mcast_routes
      
  def _set_ipv4_ucast_mcast_routes(self, v, load=False):
    """
    Setter method for ipv4_ucast_mcast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/ipv4_ucast_mcast_routes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_ucast_mcast_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_ucast_mcast_routes() directly.

    YANG Description: IPV4  unicast and multicast  routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ipv4-ucast-mcast-routes", rest_name="ipv4-ucast-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_ucast_mcast_routes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv4-ucast-mcast-routes", rest_name="ipv4-ucast-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__ipv4_ucast_mcast_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_ucast_mcast_routes(self):
    self.__ipv4_ucast_mcast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv4-ucast-mcast-routes", rest_name="ipv4-ucast-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_ipv4_mcast_routes(self):
    """
    Getter method for ipv4_mcast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/ipv4_mcast_routes (boolean)

    YANG Description: IPV4 multicast  routes
    """
    return self.__ipv4_mcast_routes
      
  def _set_ipv4_mcast_routes(self, v, load=False):
    """
    Setter method for ipv4_mcast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/ipv4_mcast_routes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_mcast_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_mcast_routes() directly.

    YANG Description: IPV4 multicast  routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ipv4-mcast-routes", rest_name="ipv4-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_mcast_routes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv4-mcast-routes", rest_name="ipv4-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__ipv4_mcast_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_mcast_routes(self):
    self.__ipv4_mcast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv4-mcast-routes", rest_name="ipv4-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_ipv4_ucast_routes(self):
    """
    Getter method for ipv4_ucast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/ipv4_ucast_routes (boolean)

    YANG Description: IPV4 unicast routes
    """
    return self.__ipv4_ucast_routes
      
  def _set_ipv4_ucast_routes(self, v, load=False):
    """
    Setter method for ipv4_ucast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/ipv4_ucast_routes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_ucast_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_ucast_routes() directly.

    YANG Description: IPV4 unicast routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ipv4-ucast-routes", rest_name="ipv4-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_ucast_routes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv4-ucast-routes", rest_name="ipv4-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__ipv4_ucast_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_ucast_routes(self):
    self.__ipv4_ucast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv4-ucast-routes", rest_name="ipv4-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_vpnv4_ucast_routes(self):
    """
    Getter method for vpnv4_ucast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/vpnv4_ucast_routes (boolean)

    YANG Description: VPNv4 unicast routes
    """
    return self.__vpnv4_ucast_routes
      
  def _set_vpnv4_ucast_routes(self, v, load=False):
    """
    Setter method for vpnv4_ucast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/vpnv4_ucast_routes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpnv4_ucast_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpnv4_ucast_routes() directly.

    YANG Description: VPNv4 unicast routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="vpnv4-ucast-routes", rest_name="vpnv4-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpnv4_ucast_routes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vpnv4-ucast-routes", rest_name="vpnv4-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__vpnv4_ucast_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpnv4_ucast_routes(self):
    self.__vpnv4_ucast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vpnv4-ucast-routes", rest_name="vpnv4-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_vpnv6_ucast_routes(self):
    """
    Getter method for vpnv6_ucast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/vpnv6_ucast_routes (boolean)

    YANG Description: VPNv6 unicast routes
    """
    return self.__vpnv6_ucast_routes
      
  def _set_vpnv6_ucast_routes(self, v, load=False):
    """
    Setter method for vpnv6_ucast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/vpnv6_ucast_routes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpnv6_ucast_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpnv6_ucast_routes() directly.

    YANG Description: VPNv6 unicast routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="vpnv6-ucast-routes", rest_name="vpnv6-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpnv6_ucast_routes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vpnv6-ucast-routes", rest_name="vpnv6-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__vpnv6_ucast_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpnv6_ucast_routes(self):
    self.__vpnv6_ucast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vpnv6-ucast-routes", rest_name="vpnv6-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_l2vpn_vpls(self):
    """
    Getter method for l2vpn_vpls, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/l2vpn_vpls (boolean)

    YANG Description: L2VPN VPLS address family
    """
    return self.__l2vpn_vpls
      
  def _set_l2vpn_vpls(self, v, load=False):
    """
    Setter method for l2vpn_vpls, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/l2vpn_vpls (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2vpn_vpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2vpn_vpls() directly.

    YANG Description: L2VPN VPLS address family
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="l2vpn-vpls", rest_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2vpn_vpls must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="l2vpn-vpls", rest_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__l2vpn_vpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2vpn_vpls(self):
    self.__l2vpn_vpls = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="l2vpn-vpls", rest_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_l2vpn_evpn(self):
    """
    Getter method for l2vpn_evpn, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/l2vpn_evpn (boolean)

    YANG Description: L2VPN EVPN address family
    """
    return self.__l2vpn_evpn
      
  def _set_l2vpn_evpn(self, v, load=False):
    """
    Setter method for l2vpn_evpn, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/l2vpn_evpn (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2vpn_evpn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2vpn_evpn() directly.

    YANG Description: L2VPN EVPN address family
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="l2vpn-evpn", rest_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2vpn_evpn must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="l2vpn-evpn", rest_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__l2vpn_evpn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2vpn_evpn(self):
    self.__l2vpn_evpn = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="l2vpn-evpn", rest_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_ipv6_ucast_mcast_routes(self):
    """
    Getter method for ipv6_ucast_mcast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/ipv6_ucast_mcast_routes (boolean)

    YANG Description: IPV6  unicast and multicast  routes
    """
    return self.__ipv6_ucast_mcast_routes
      
  def _set_ipv6_ucast_mcast_routes(self, v, load=False):
    """
    Setter method for ipv6_ucast_mcast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/ipv6_ucast_mcast_routes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_ucast_mcast_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_ucast_mcast_routes() directly.

    YANG Description: IPV6  unicast and multicast  routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ipv6-ucast-mcast-routes", rest_name="ipv6-ucast-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_ucast_mcast_routes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ucast-mcast-routes", rest_name="ipv6-ucast-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__ipv6_ucast_mcast_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_ucast_mcast_routes(self):
    self.__ipv6_ucast_mcast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ucast-mcast-routes", rest_name="ipv6-ucast-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_ipv6_mcast_routes(self):
    """
    Getter method for ipv6_mcast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/ipv6_mcast_routes (boolean)

    YANG Description: IPV6 multicast  routes
    """
    return self.__ipv6_mcast_routes
      
  def _set_ipv6_mcast_routes(self, v, load=False):
    """
    Setter method for ipv6_mcast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/ipv6_mcast_routes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_mcast_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_mcast_routes() directly.

    YANG Description: IPV6 multicast  routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ipv6-mcast-routes", rest_name="ipv6-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_mcast_routes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-mcast-routes", rest_name="ipv6-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__ipv6_mcast_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_mcast_routes(self):
    self.__ipv6_mcast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-mcast-routes", rest_name="ipv6-mcast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_ipv6_ucast_routes(self):
    """
    Getter method for ipv6_ucast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/ipv6_ucast_routes (boolean)

    YANG Description: IPV6 unicast routes
    """
    return self.__ipv6_ucast_routes
      
  def _set_ipv6_ucast_routes(self, v, load=False):
    """
    Setter method for ipv6_ucast_routes, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/ipv6_ucast_routes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_ucast_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_ucast_routes() directly.

    YANG Description: IPV6 unicast routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ipv6-ucast-routes", rest_name="ipv6-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_ucast_routes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ucast-routes", rest_name="ipv6-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__ipv6_ucast_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_ucast_routes(self):
    self.__ipv6_ucast_routes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ucast-routes", rest_name="ipv6-ucast-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_ipv6_mpls_label_capability(self):
    """
    Getter method for ipv6_mpls_label_capability, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/ipv6_mpls_label_capability (boolean)

    YANG Description: IPV6 MPLS label capability
    """
    return self.__ipv6_mpls_label_capability
      
  def _set_ipv6_mpls_label_capability(self, v, load=False):
    """
    Setter method for ipv6_mpls_label_capability, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/ipv6_mpls_label_capability (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_mpls_label_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_mpls_label_capability() directly.

    YANG Description: IPV6 MPLS label capability
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ipv6-mpls-label-capability", rest_name="ipv6-mpls-label-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_mpls_label_capability must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-mpls-label-capability", rest_name="ipv6-mpls-label-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__ipv6_mpls_label_capability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_mpls_label_capability(self):
    self.__ipv6_mpls_label_capability = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-mpls-label-capability", rest_name="ipv6-mpls-label-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)


  def _get_as4_capability(self):
    """
    Getter method for as4_capability, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/as4_capability (boolean)

    YANG Description: AS4 capability
    """
    return self.__as4_capability
      
  def _set_as4_capability(self, v, load=False):
    """
    Setter method for as4_capability, mapped from YANG variable /bgp_state/neighbor/evpn/neighbor_configured_routes/as4_capability (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as4_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as4_capability() directly.

    YANG Description: AS4 capability
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="as4-capability", rest_name="as4-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as4_capability must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="as4-capability", rest_name="as4-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)""",
        })

    self.__as4_capability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as4_capability(self):
    self.__as4_capability = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="as4-capability", rest_name="as4-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-bgp-operational', defining_module='brocade-bgp-operational', yang_type='boolean', is_config=False)

  ipv4_ucast_mcast_routes = __builtin__.property(_get_ipv4_ucast_mcast_routes)
  ipv4_mcast_routes = __builtin__.property(_get_ipv4_mcast_routes)
  ipv4_ucast_routes = __builtin__.property(_get_ipv4_ucast_routes)
  vpnv4_ucast_routes = __builtin__.property(_get_vpnv4_ucast_routes)
  vpnv6_ucast_routes = __builtin__.property(_get_vpnv6_ucast_routes)
  l2vpn_vpls = __builtin__.property(_get_l2vpn_vpls)
  l2vpn_evpn = __builtin__.property(_get_l2vpn_evpn)
  ipv6_ucast_mcast_routes = __builtin__.property(_get_ipv6_ucast_mcast_routes)
  ipv6_mcast_routes = __builtin__.property(_get_ipv6_mcast_routes)
  ipv6_ucast_routes = __builtin__.property(_get_ipv6_ucast_routes)
  ipv6_mpls_label_capability = __builtin__.property(_get_ipv6_mpls_label_capability)
  as4_capability = __builtin__.property(_get_as4_capability)


  _pyangbind_elements = {'ipv4_ucast_mcast_routes': ipv4_ucast_mcast_routes, 'ipv4_mcast_routes': ipv4_mcast_routes, 'ipv4_ucast_routes': ipv4_ucast_routes, 'vpnv4_ucast_routes': vpnv4_ucast_routes, 'vpnv6_ucast_routes': vpnv6_ucast_routes, 'l2vpn_vpls': l2vpn_vpls, 'l2vpn_evpn': l2vpn_evpn, 'ipv6_ucast_mcast_routes': ipv6_ucast_mcast_routes, 'ipv6_mcast_routes': ipv6_mcast_routes, 'ipv6_ucast_routes': ipv6_ucast_routes, 'ipv6_mpls_label_capability': ipv6_mpls_label_capability, 'as4_capability': as4_capability, }


