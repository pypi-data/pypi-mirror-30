
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import portfast
import edgeport
import guard
import vlan
import instance
class spanning_tree(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-interface - based on the path /interface/ethernet/spanning-tree. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__autoedge','__cost','__portfast','__edgeport','__guard','__bpdu_mac','__link_type','__priority','__restricted_role','__restricted_tcn','__shutdown','__vlan','__instance',)

  _yang_name = 'spanning-tree'
  _rest_name = 'spanning-tree'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__bpdu_mac = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'0100.0ccc.cccd': {}, u'0304.0800.0700': {}},), is_leaf=True, yang_name="bpdu-mac", rest_name="bpdu-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure VLAN spanning-tree control MAC', u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='enumeration', is_config=True)
    self.__restricted_tcn = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="restricted-tcn", rest_name="restricted-tcn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Restrict propagation of topology change and received topology change notifications', u'display-when': u'(/protocol/spanning-tree/mstp) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)
    self.__vlan = YANGDynClass(base=YANGListType("id",vlan.vlan, yang_name="vlan", rest_name="vlan", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions={u'tailf-common': {u'info': u'VLAN ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))', u'callpoint': u'phy-vlan-stp-config'}}), is_container='list', yang_name="vlan", rest_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VLAN ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))', u'callpoint': u'phy-vlan-stp-config'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='list', is_config=True)
    self.__autoedge = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="autoedge", rest_name="autoedge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Autoedge - enable automatic edge detection', u'display-when': u'((/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..240']}), is_leaf=True, yang_name="priority", rest_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u"Change an interface's spanning tree port priority", u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/stp) or(/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='uint32', is_config=True)
    self.__instance = YANGDynClass(base=YANGListType("id",instance.instance, yang_name="instance", rest_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions={u'tailf-common': {u'info': u'Instance ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/mstp))', u'callpoint': u'phy-inst-stp-config'}}), is_container='list', yang_name="instance", rest_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Instance ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/mstp))', u'callpoint': u'phy-inst-stp-config'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='list', is_config=True)
    self.__guard = YANGDynClass(base=guard.guard, is_container='container', presence=False, yang_name="guard", rest_name="guard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u"Change an interface's spanning tree guard mode", u'display-when': u'((/protocol/spanning-tree/stp) or (/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='container', is_config=True)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..200000000']}), is_leaf=True, yang_name="cost", rest_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u"Change an interface's spanning tree port path cost", u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/stp) or(/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='uint32', is_config=True)
    self.__shutdown = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="shutdown", rest_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'cli-run-template': u'$(.?$(../../switchport-basic/basic?spanning-tree shutdown\n:\\r):\\r)', u'info': u'Turn off the spanning-tree protocol'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)
    self.__restricted_role = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="restricted-role", rest_name="restricted-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Restrict the role of the port', u'display-when': u'(/protocol/spanning-tree/mstp) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)
    self.__edgeport = YANGDynClass(base=edgeport.edgeport, is_container='container', presence=False, yang_name="edgeport", rest_name="edgeport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Edgeport', u'display-when': u'((/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='container', is_config=True)
    self.__link_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'shared': {}, u'point-to-point': {}},), is_leaf=True, yang_name="link-type", rest_name="link-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Specify a link type for spanning tree protocol', u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/stp) or(/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='enumeration', is_config=True)
    self.__portfast = YANGDynClass(base=portfast.portfast, is_container='container', presence=False, yang_name="portfast", rest_name="portfast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable an interface to move directly to forwarding on link up', u'display-when': u' ((/protocol/spanning-tree/stp) or (/protocol/spanning-tree/pvst))'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'interface', u'ethernet', u'spanning-tree']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'interface', u'Ethernet', u'spanning-tree']

  def _get_autoedge(self):
    """
    Getter method for autoedge, mapped from YANG variable /interface/ethernet/spanning_tree/autoedge (empty)
    """
    return self.__autoedge
      
  def _set_autoedge(self, v, load=False):
    """
    Setter method for autoedge, mapped from YANG variable /interface/ethernet/spanning_tree/autoedge (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_autoedge is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_autoedge() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="autoedge", rest_name="autoedge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Autoedge - enable automatic edge detection', u'display-when': u'((/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """autoedge must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="autoedge", rest_name="autoedge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Autoedge - enable automatic edge detection', u'display-when': u'((/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)""",
        })

    self.__autoedge = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_autoedge(self):
    self.__autoedge = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="autoedge", rest_name="autoedge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Autoedge - enable automatic edge detection', u'display-when': u'((/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /interface/ethernet/spanning_tree/cost (uint32)
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /interface/ethernet/spanning_tree/cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..200000000']}), is_leaf=True, yang_name="cost", rest_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u"Change an interface's spanning tree port path cost", u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/stp) or(/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..200000000']}), is_leaf=True, yang_name="cost", rest_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u"Change an interface's spanning tree port path cost", u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/stp) or(/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='uint32', is_config=True)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..200000000']}), is_leaf=True, yang_name="cost", rest_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u"Change an interface's spanning tree port path cost", u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/stp) or(/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='uint32', is_config=True)


  def _get_portfast(self):
    """
    Getter method for portfast, mapped from YANG variable /interface/ethernet/spanning_tree/portfast (container)
    """
    return self.__portfast
      
  def _set_portfast(self, v, load=False):
    """
    Setter method for portfast, mapped from YANG variable /interface/ethernet/spanning_tree/portfast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_portfast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_portfast() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=portfast.portfast, is_container='container', presence=False, yang_name="portfast", rest_name="portfast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable an interface to move directly to forwarding on link up', u'display-when': u' ((/protocol/spanning-tree/stp) or (/protocol/spanning-tree/pvst))'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """portfast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=portfast.portfast, is_container='container', presence=False, yang_name="portfast", rest_name="portfast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable an interface to move directly to forwarding on link up', u'display-when': u' ((/protocol/spanning-tree/stp) or (/protocol/spanning-tree/pvst))'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='container', is_config=True)""",
        })

    self.__portfast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_portfast(self):
    self.__portfast = YANGDynClass(base=portfast.portfast, is_container='container', presence=False, yang_name="portfast", rest_name="portfast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Enable an interface to move directly to forwarding on link up', u'display-when': u' ((/protocol/spanning-tree/stp) or (/protocol/spanning-tree/pvst))'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='container', is_config=True)


  def _get_edgeport(self):
    """
    Getter method for edgeport, mapped from YANG variable /interface/ethernet/spanning_tree/edgeport (container)
    """
    return self.__edgeport
      
  def _set_edgeport(self, v, load=False):
    """
    Setter method for edgeport, mapped from YANG variable /interface/ethernet/spanning_tree/edgeport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_edgeport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_edgeport() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=edgeport.edgeport, is_container='container', presence=False, yang_name="edgeport", rest_name="edgeport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Edgeport', u'display-when': u'((/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """edgeport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=edgeport.edgeport, is_container='container', presence=False, yang_name="edgeport", rest_name="edgeport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Edgeport', u'display-when': u'((/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='container', is_config=True)""",
        })

    self.__edgeport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_edgeport(self):
    self.__edgeport = YANGDynClass(base=edgeport.edgeport, is_container='container', presence=False, yang_name="edgeport", rest_name="edgeport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Edgeport', u'display-when': u'((/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='container', is_config=True)


  def _get_guard(self):
    """
    Getter method for guard, mapped from YANG variable /interface/ethernet/spanning_tree/guard (container)
    """
    return self.__guard
      
  def _set_guard(self, v, load=False):
    """
    Setter method for guard, mapped from YANG variable /interface/ethernet/spanning_tree/guard (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_guard is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_guard() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=guard.guard, is_container='container', presence=False, yang_name="guard", rest_name="guard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u"Change an interface's spanning tree guard mode", u'display-when': u'((/protocol/spanning-tree/stp) or (/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """guard must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=guard.guard, is_container='container', presence=False, yang_name="guard", rest_name="guard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u"Change an interface's spanning tree guard mode", u'display-when': u'((/protocol/spanning-tree/stp) or (/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='container', is_config=True)""",
        })

    self.__guard = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_guard(self):
    self.__guard = YANGDynClass(base=guard.guard, is_container='container', presence=False, yang_name="guard", rest_name="guard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u"Change an interface's spanning tree guard mode", u'display-when': u'((/protocol/spanning-tree/stp) or (/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='container', is_config=True)


  def _get_bpdu_mac(self):
    """
    Getter method for bpdu_mac, mapped from YANG variable /interface/ethernet/spanning_tree/bpdu_mac (enumeration)
    """
    return self.__bpdu_mac
      
  def _set_bpdu_mac(self, v, load=False):
    """
    Setter method for bpdu_mac, mapped from YANG variable /interface/ethernet/spanning_tree/bpdu_mac (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bpdu_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bpdu_mac() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'0100.0ccc.cccd': {}, u'0304.0800.0700': {}},), is_leaf=True, yang_name="bpdu-mac", rest_name="bpdu-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure VLAN spanning-tree control MAC', u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bpdu_mac must be of a type compatible with enumeration""",
          'defined-type': "brocade-xstp:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'0100.0ccc.cccd': {}, u'0304.0800.0700': {}},), is_leaf=True, yang_name="bpdu-mac", rest_name="bpdu-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure VLAN spanning-tree control MAC', u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='enumeration', is_config=True)""",
        })

    self.__bpdu_mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bpdu_mac(self):
    self.__bpdu_mac = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'0100.0ccc.cccd': {}, u'0304.0800.0700': {}},), is_leaf=True, yang_name="bpdu-mac", rest_name="bpdu-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure VLAN spanning-tree control MAC', u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='enumeration', is_config=True)


  def _get_link_type(self):
    """
    Getter method for link_type, mapped from YANG variable /interface/ethernet/spanning_tree/link_type (enumeration)
    """
    return self.__link_type
      
  def _set_link_type(self, v, load=False):
    """
    Setter method for link_type, mapped from YANG variable /interface/ethernet/spanning_tree/link_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'shared': {}, u'point-to-point': {}},), is_leaf=True, yang_name="link-type", rest_name="link-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Specify a link type for spanning tree protocol', u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/stp) or(/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_type must be of a type compatible with enumeration""",
          'defined-type': "brocade-xstp:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'shared': {}, u'point-to-point': {}},), is_leaf=True, yang_name="link-type", rest_name="link-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Specify a link type for spanning tree protocol', u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/stp) or(/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='enumeration', is_config=True)""",
        })

    self.__link_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_type(self):
    self.__link_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'shared': {}, u'point-to-point': {}},), is_leaf=True, yang_name="link-type", rest_name="link-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Specify a link type for spanning tree protocol', u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/stp) or(/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='enumeration', is_config=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /interface/ethernet/spanning_tree/priority (uint32)
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /interface/ethernet/spanning_tree/priority (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..240']}), is_leaf=True, yang_name="priority", rest_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u"Change an interface's spanning tree port priority", u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/stp) or(/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..240']}), is_leaf=True, yang_name="priority", rest_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u"Change an interface's spanning tree port priority", u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/stp) or(/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='uint32', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..240']}), is_leaf=True, yang_name="priority", rest_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u"Change an interface's spanning tree port priority", u'cli-full-no': None, u'display-when': u'((/protocol/spanning-tree/stp) or(/protocol/spanning-tree/rstp) or (/protocol/spanning-tree/mstp) or (/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst)) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='uint32', is_config=True)


  def _get_restricted_role(self):
    """
    Getter method for restricted_role, mapped from YANG variable /interface/ethernet/spanning_tree/restricted_role (empty)
    """
    return self.__restricted_role
      
  def _set_restricted_role(self, v, load=False):
    """
    Setter method for restricted_role, mapped from YANG variable /interface/ethernet/spanning_tree/restricted_role (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restricted_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restricted_role() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="restricted-role", rest_name="restricted-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Restrict the role of the port', u'display-when': u'(/protocol/spanning-tree/mstp) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restricted_role must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="restricted-role", rest_name="restricted-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Restrict the role of the port', u'display-when': u'(/protocol/spanning-tree/mstp) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)""",
        })

    self.__restricted_role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restricted_role(self):
    self.__restricted_role = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="restricted-role", rest_name="restricted-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Restrict the role of the port', u'display-when': u'(/protocol/spanning-tree/mstp) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)


  def _get_restricted_tcn(self):
    """
    Getter method for restricted_tcn, mapped from YANG variable /interface/ethernet/spanning_tree/restricted_tcn (empty)
    """
    return self.__restricted_tcn
      
  def _set_restricted_tcn(self, v, load=False):
    """
    Setter method for restricted_tcn, mapped from YANG variable /interface/ethernet/spanning_tree/restricted_tcn (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restricted_tcn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restricted_tcn() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="restricted-tcn", rest_name="restricted-tcn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Restrict propagation of topology change and received topology change notifications', u'display-when': u'(/protocol/spanning-tree/mstp) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restricted_tcn must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="restricted-tcn", rest_name="restricted-tcn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Restrict propagation of topology change and received topology change notifications', u'display-when': u'(/protocol/spanning-tree/mstp) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)""",
        })

    self.__restricted_tcn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restricted_tcn(self):
    self.__restricted_tcn = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="restricted-tcn", rest_name="restricted-tcn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Restrict propagation of topology change and received topology change notifications', u'display-when': u'(/protocol/spanning-tree/mstp) '}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)


  def _get_shutdown(self):
    """
    Getter method for shutdown, mapped from YANG variable /interface/ethernet/spanning_tree/shutdown (empty)
    """
    return self.__shutdown
      
  def _set_shutdown(self, v, load=False):
    """
    Setter method for shutdown, mapped from YANG variable /interface/ethernet/spanning_tree/shutdown (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="shutdown", rest_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'cli-run-template': u'$(.?$(../../switchport-basic/basic?spanning-tree shutdown\n:\\r):\\r)', u'info': u'Turn off the spanning-tree protocol'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="shutdown", rest_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'cli-run-template': u'$(.?$(../../switchport-basic/basic?spanning-tree shutdown\n:\\r):\\r)', u'info': u'Turn off the spanning-tree protocol'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)""",
        })

    self.__shutdown = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown(self):
    self.__shutdown = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="shutdown", rest_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'cli-run-template': u'$(.?$(../../switchport-basic/basic?spanning-tree shutdown\n:\\r):\\r)', u'info': u'Turn off the spanning-tree protocol'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='empty', is_config=True)


  def _get_vlan(self):
    """
    Getter method for vlan, mapped from YANG variable /interface/ethernet/spanning_tree/vlan (list)
    """
    return self.__vlan
      
  def _set_vlan(self, v, load=False):
    """
    Setter method for vlan, mapped from YANG variable /interface/ethernet/spanning_tree/vlan (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",vlan.vlan, yang_name="vlan", rest_name="vlan", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions={u'tailf-common': {u'info': u'VLAN ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))', u'callpoint': u'phy-vlan-stp-config'}}), is_container='list', yang_name="vlan", rest_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VLAN ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))', u'callpoint': u'phy-vlan-stp-config'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",vlan.vlan, yang_name="vlan", rest_name="vlan", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions={u'tailf-common': {u'info': u'VLAN ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))', u'callpoint': u'phy-vlan-stp-config'}}), is_container='list', yang_name="vlan", rest_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VLAN ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))', u'callpoint': u'phy-vlan-stp-config'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='list', is_config=True)""",
        })

    self.__vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan(self):
    self.__vlan = YANGDynClass(base=YANGListType("id",vlan.vlan, yang_name="vlan", rest_name="vlan", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions={u'tailf-common': {u'info': u'VLAN ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))', u'callpoint': u'phy-vlan-stp-config'}}), is_container='list', yang_name="vlan", rest_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'VLAN ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/pvst) or (/protocol/spanning-tree/rpvst))', u'callpoint': u'phy-vlan-stp-config'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='list', is_config=True)


  def _get_instance(self):
    """
    Getter method for instance, mapped from YANG variable /interface/ethernet/spanning_tree/instance (list)
    """
    return self.__instance
      
  def _set_instance(self, v, load=False):
    """
    Setter method for instance, mapped from YANG variable /interface/ethernet/spanning_tree/instance (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instance() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",instance.instance, yang_name="instance", rest_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions={u'tailf-common': {u'info': u'Instance ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/mstp))', u'callpoint': u'phy-inst-stp-config'}}), is_container='list', yang_name="instance", rest_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Instance ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/mstp))', u'callpoint': u'phy-inst-stp-config'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instance must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",instance.instance, yang_name="instance", rest_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions={u'tailf-common': {u'info': u'Instance ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/mstp))', u'callpoint': u'phy-inst-stp-config'}}), is_container='list', yang_name="instance", rest_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Instance ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/mstp))', u'callpoint': u'phy-inst-stp-config'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='list', is_config=True)""",
        })

    self.__instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instance(self):
    self.__instance = YANGDynClass(base=YANGListType("id",instance.instance, yang_name="instance", rest_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions={u'tailf-common': {u'info': u'Instance ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/mstp))', u'callpoint': u'phy-inst-stp-config'}}), is_container='list', yang_name="instance", rest_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Instance ID', u'cli-suppress-mode': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None, u'display-when': u'((/protocol/spanning-tree/mstp))', u'callpoint': u'phy-inst-stp-config'}}, namespace='urn:brocade.com:mgmt:brocade-xstp', defining_module='brocade-xstp', yang_type='list', is_config=True)

  autoedge = __builtin__.property(_get_autoedge, _set_autoedge)
  cost = __builtin__.property(_get_cost, _set_cost)
  portfast = __builtin__.property(_get_portfast, _set_portfast)
  edgeport = __builtin__.property(_get_edgeport, _set_edgeport)
  guard = __builtin__.property(_get_guard, _set_guard)
  bpdu_mac = __builtin__.property(_get_bpdu_mac, _set_bpdu_mac)
  link_type = __builtin__.property(_get_link_type, _set_link_type)
  priority = __builtin__.property(_get_priority, _set_priority)
  restricted_role = __builtin__.property(_get_restricted_role, _set_restricted_role)
  restricted_tcn = __builtin__.property(_get_restricted_tcn, _set_restricted_tcn)
  shutdown = __builtin__.property(_get_shutdown, _set_shutdown)
  vlan = __builtin__.property(_get_vlan, _set_vlan)
  instance = __builtin__.property(_get_instance, _set_instance)


  _pyangbind_elements = {'autoedge': autoedge, 'cost': cost, 'portfast': portfast, 'edgeport': edgeport, 'guard': guard, 'bpdu_mac': bpdu_mac, 'link_type': link_type, 'priority': priority, 'restricted_role': restricted_role, 'restricted_tcn': restricted_tcn, 'shutdown': shutdown, 'vlan': vlan, 'instance': instance, }


