
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import error_counters
import packet_counters
class interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls-operational - based on the path /mpls-state/rsvp/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: MPLS RSVP interface information
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__interface_name','__interface_type','__interface_index','__admin_status','__oper_status','__is_tunnel_interface','__hello_interval','__hello_tolerance','__hello_status','__is_md5_auth_enabled','__reliable_messages','__bundle_messages','__summary_refresh','__active_outsegs','__inactive_outsegs','__bandwith_resv_outsegs','__active_backup_outsegs','__inactive_backup_outsegs','__interface_preempts','__interface_resv_soft_preempts','__interface_flooding_up_threshold','__interface_flooding_down_threshold','__duplicate_preempts_dropped','__bypass_interface','__interface_tunnel_name','__bypass_tunnel_interface_name','__interface_te_up_thresholds','__interface_te_down_thresholds','__error_counters','__packet_counters',)

  _yang_name = 'interfaces'
  _rest_name = 'interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__reliable_messages = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="reliable-messages", rest_name="reliable-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)
    self.__summary_refresh = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="summary-refresh", rest_name="summary-refresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)
    self.__bypass_interface = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-interface", rest_name="bypass-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__interface_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dcm-interface-type-unknown': {'value': 1}, u'dcm-interface-type-loopback': {'value': 7}, u'dcm-interface-type-ve': {'value': 6}, u'dcm-interface-type-ethernet': {'value': 2}, u'dcm-interface-type-fiber-channel': {'value': 8}, u'dcm-interface-type-port-channel': {'value': 5}},), is_leaf=True, yang_name="interface-type", rest_name="interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='dcm-interface-type', is_config=False)
    self.__hello_tolerance = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-tolerance", rest_name="hello-tolerance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__inactive_outsegs = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inactive-outsegs", rest_name="inactive-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval", rest_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__is_md5_auth_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-md5-auth-enabled", rest_name="is-md5-auth-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__bandwith_resv_outsegs = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwith-resv-outsegs", rest_name="bandwith-resv-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__active_outsegs = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="active-outsegs", rest_name="active-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__inactive_backup_outsegs = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inactive-backup-outsegs", rest_name="inactive-backup-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__interface_tunnel_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="interface-tunnel-name", rest_name="interface-tunnel-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__interface_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-index", rest_name="interface-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__bundle_messages = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="bundle-messages", rest_name="bundle-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)
    self.__hello_status = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="hello-status", rest_name="hello-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)
    self.__is_tunnel_interface = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-tunnel-interface", rest_name="is-tunnel-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__interface_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="interface-name", rest_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__packet_counters = YANGDynClass(base=packet_counters.packet_counters, is_container='container', presence=False, yang_name="packet-counters", rest_name="packet-counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-packet-counters-packet-counters-2'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    self.__bypass_tunnel_interface_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-tunnel-interface-name", rest_name="bypass-tunnel-interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__admin_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="admin-status", rest_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__interface_te_down_thresholds = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="interface-te-down-thresholds", rest_name="interface-te-down-thresholds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__interface_flooding_up_threshold = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'local-config': {'value': 2}, u'default-config': {'value': 3}, u'global-config': {'value': 1}},), is_leaf=True, yang_name="interface-flooding-up-threshold", rest_name="interface-flooding-up-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-source', is_config=False)
    self.__error_counters = YANGDynClass(base=error_counters.error_counters, is_container='container', presence=False, yang_name="error-counters", rest_name="error-counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-interface-error-counters', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    self.__interface_flooding_down_threshold = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'local-config': {'value': 2}, u'default-config': {'value': 3}, u'global-config': {'value': 1}},), is_leaf=True, yang_name="interface-flooding-down-threshold", rest_name="interface-flooding-down-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-source', is_config=False)
    self.__interface_preempts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-preempts", rest_name="interface-preempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__oper_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="oper-status", rest_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__interface_resv_soft_preempts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-resv-soft-preempts", rest_name="interface-resv-soft-preempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__interface_te_up_thresholds = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="interface-te-up-thresholds", rest_name="interface-te-up-thresholds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__active_backup_outsegs = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="active-backup-outsegs", rest_name="active-backup-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__duplicate_preempts_dropped = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duplicate-preempts-dropped", rest_name="duplicate-preempts-dropped", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mpls-state', u'rsvp', u'interfaces']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'mpls-state', u'rsvp', u'interfaces']

  def _get_interface_name(self):
    """
    Getter method for interface_name, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_name (string)

    YANG Description: MPLS RSVP interface name
    """
    return self.__interface_name
      
  def _set_interface_name(self, v, load=False):
    """
    Setter method for interface_name, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_name() directly.

    YANG Description: MPLS RSVP interface name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="interface-name", rest_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="interface-name", rest_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__interface_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_name(self):
    self.__interface_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="interface-name", rest_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_interface_type(self):
    """
    Getter method for interface_type, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_type (dcm-interface-type)

    YANG Description: MPLS RSVP interface type
    """
    return self.__interface_type
      
  def _set_interface_type(self, v, load=False):
    """
    Setter method for interface_type, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_type (dcm-interface-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_type() directly.

    YANG Description: MPLS RSVP interface type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dcm-interface-type-unknown': {'value': 1}, u'dcm-interface-type-loopback': {'value': 7}, u'dcm-interface-type-ve': {'value': 6}, u'dcm-interface-type-ethernet': {'value': 2}, u'dcm-interface-type-fiber-channel': {'value': 8}, u'dcm-interface-type-port-channel': {'value': 5}},), is_leaf=True, yang_name="interface-type", rest_name="interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='dcm-interface-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_type must be of a type compatible with dcm-interface-type""",
          'defined-type': "brocade-mpls-operational:dcm-interface-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dcm-interface-type-unknown': {'value': 1}, u'dcm-interface-type-loopback': {'value': 7}, u'dcm-interface-type-ve': {'value': 6}, u'dcm-interface-type-ethernet': {'value': 2}, u'dcm-interface-type-fiber-channel': {'value': 8}, u'dcm-interface-type-port-channel': {'value': 5}},), is_leaf=True, yang_name="interface-type", rest_name="interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='dcm-interface-type', is_config=False)""",
        })

    self.__interface_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_type(self):
    self.__interface_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dcm-interface-type-unknown': {'value': 1}, u'dcm-interface-type-loopback': {'value': 7}, u'dcm-interface-type-ve': {'value': 6}, u'dcm-interface-type-ethernet': {'value': 2}, u'dcm-interface-type-fiber-channel': {'value': 8}, u'dcm-interface-type-port-channel': {'value': 5}},), is_leaf=True, yang_name="interface-type", rest_name="interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='dcm-interface-type', is_config=False)


  def _get_interface_index(self):
    """
    Getter method for interface_index, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_index (uint32)

    YANG Description: MPLS RSVP interface ID
    """
    return self.__interface_index
      
  def _set_interface_index(self, v, load=False):
    """
    Setter method for interface_index, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_index() directly.

    YANG Description: MPLS RSVP interface ID
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-index", rest_name="interface-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-index", rest_name="interface-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__interface_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_index(self):
    self.__interface_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-index", rest_name="interface-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /mpls_state/rsvp/interfaces/admin_status (boolean)

    YANG Description: MPLS RSVP interface admin status
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /mpls_state/rsvp/interfaces/admin_status (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: MPLS RSVP interface admin status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="admin-status", rest_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="admin-status", rest_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="admin-status", rest_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /mpls_state/rsvp/interfaces/oper_status (boolean)

    YANG Description: MPLS RSVP interface operational status
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /mpls_state/rsvp/interfaces/oper_status (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: MPLS RSVP interface operational status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="oper-status", rest_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="oper-status", rest_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="oper-status", rest_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_is_tunnel_interface(self):
    """
    Getter method for is_tunnel_interface, mapped from YANG variable /mpls_state/rsvp/interfaces/is_tunnel_interface (boolean)

    YANG Description: Is this a tunnle interface
    """
    return self.__is_tunnel_interface
      
  def _set_is_tunnel_interface(self, v, load=False):
    """
    Setter method for is_tunnel_interface, mapped from YANG variable /mpls_state/rsvp/interfaces/is_tunnel_interface (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_tunnel_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_tunnel_interface() directly.

    YANG Description: Is this a tunnle interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-tunnel-interface", rest_name="is-tunnel-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_tunnel_interface must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-tunnel-interface", rest_name="is-tunnel-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_tunnel_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_tunnel_interface(self):
    self.__is_tunnel_interface = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-tunnel-interface", rest_name="is-tunnel-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_hello_interval(self):
    """
    Getter method for hello_interval, mapped from YANG variable /mpls_state/rsvp/interfaces/hello_interval (uint32)

    YANG Description: MPLS RSVP interface hello interval
    """
    return self.__hello_interval
      
  def _set_hello_interval(self, v, load=False):
    """
    Setter method for hello_interval, mapped from YANG variable /mpls_state/rsvp/interfaces/hello_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval() directly.

    YANG Description: MPLS RSVP interface hello interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval", rest_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval", rest_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__hello_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval(self):
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval", rest_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_hello_tolerance(self):
    """
    Getter method for hello_tolerance, mapped from YANG variable /mpls_state/rsvp/interfaces/hello_tolerance (uint32)

    YANG Description: MPLS RSVP interface hello tolerance
    """
    return self.__hello_tolerance
      
  def _set_hello_tolerance(self, v, load=False):
    """
    Setter method for hello_tolerance, mapped from YANG variable /mpls_state/rsvp/interfaces/hello_tolerance (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_tolerance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_tolerance() directly.

    YANG Description: MPLS RSVP interface hello tolerance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-tolerance", rest_name="hello-tolerance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_tolerance must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-tolerance", rest_name="hello-tolerance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__hello_tolerance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_tolerance(self):
    self.__hello_tolerance = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-tolerance", rest_name="hello-tolerance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_hello_status(self):
    """
    Getter method for hello_status, mapped from YANG variable /mpls_state/rsvp/interfaces/hello_status (feature-config-status)

    YANG Description: 1
    """
    return self.__hello_status
      
  def _set_hello_status(self, v, load=False):
    """
    Setter method for hello_status, mapped from YANG variable /mpls_state/rsvp/interfaces/hello_status (feature-config-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_status() directly.

    YANG Description: 1
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="hello-status", rest_name="hello-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_status must be of a type compatible with feature-config-status""",
          'defined-type': "brocade-mpls-operational:feature-config-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="hello-status", rest_name="hello-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)""",
        })

    self.__hello_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_status(self):
    self.__hello_status = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="hello-status", rest_name="hello-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)


  def _get_is_md5_auth_enabled(self):
    """
    Getter method for is_md5_auth_enabled, mapped from YANG variable /mpls_state/rsvp/interfaces/is_md5_auth_enabled (boolean)

    YANG Description: Is MD5 authentication enabled on the interface
    """
    return self.__is_md5_auth_enabled
      
  def _set_is_md5_auth_enabled(self, v, load=False):
    """
    Setter method for is_md5_auth_enabled, mapped from YANG variable /mpls_state/rsvp/interfaces/is_md5_auth_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_md5_auth_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_md5_auth_enabled() directly.

    YANG Description: Is MD5 authentication enabled on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-md5-auth-enabled", rest_name="is-md5-auth-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_md5_auth_enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-md5-auth-enabled", rest_name="is-md5-auth-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__is_md5_auth_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_md5_auth_enabled(self):
    self.__is_md5_auth_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-md5-auth-enabled", rest_name="is-md5-auth-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_reliable_messages(self):
    """
    Getter method for reliable_messages, mapped from YANG variable /mpls_state/rsvp/interfaces/reliable_messages (feature-config-status)

    YANG Description: Reliable messaging config on interface
    """
    return self.__reliable_messages
      
  def _set_reliable_messages(self, v, load=False):
    """
    Setter method for reliable_messages, mapped from YANG variable /mpls_state/rsvp/interfaces/reliable_messages (feature-config-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reliable_messages is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reliable_messages() directly.

    YANG Description: Reliable messaging config on interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="reliable-messages", rest_name="reliable-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reliable_messages must be of a type compatible with feature-config-status""",
          'defined-type': "brocade-mpls-operational:feature-config-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="reliable-messages", rest_name="reliable-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)""",
        })

    self.__reliable_messages = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reliable_messages(self):
    self.__reliable_messages = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="reliable-messages", rest_name="reliable-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)


  def _get_bundle_messages(self):
    """
    Getter method for bundle_messages, mapped from YANG variable /mpls_state/rsvp/interfaces/bundle_messages (feature-config-status)

    YANG Description: Bundle messaging config on interface
    """
    return self.__bundle_messages
      
  def _set_bundle_messages(self, v, load=False):
    """
    Setter method for bundle_messages, mapped from YANG variable /mpls_state/rsvp/interfaces/bundle_messages (feature-config-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bundle_messages is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bundle_messages() directly.

    YANG Description: Bundle messaging config on interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="bundle-messages", rest_name="bundle-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bundle_messages must be of a type compatible with feature-config-status""",
          'defined-type': "brocade-mpls-operational:feature-config-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="bundle-messages", rest_name="bundle-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)""",
        })

    self.__bundle_messages = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bundle_messages(self):
    self.__bundle_messages = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="bundle-messages", rest_name="bundle-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)


  def _get_summary_refresh(self):
    """
    Getter method for summary_refresh, mapped from YANG variable /mpls_state/rsvp/interfaces/summary_refresh (feature-config-status)

    YANG Description: Summary refresh config on interface
    """
    return self.__summary_refresh
      
  def _set_summary_refresh(self, v, load=False):
    """
    Setter method for summary_refresh, mapped from YANG variable /mpls_state/rsvp/interfaces/summary_refresh (feature-config-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_summary_refresh is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_summary_refresh() directly.

    YANG Description: Summary refresh config on interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="summary-refresh", rest_name="summary-refresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """summary_refresh must be of a type compatible with feature-config-status""",
          'defined-type': "brocade-mpls-operational:feature-config-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="summary-refresh", rest_name="summary-refresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)""",
        })

    self.__summary_refresh = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_summary_refresh(self):
    self.__summary_refresh = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {'value': 0}, u'enabled-local': {'value': 2}, u'disabled-global': {'value': 3}, u'disabled-local': {'value': 4}, u'enabled-global': {'value': 1}},), is_leaf=True, yang_name="summary-refresh", rest_name="summary-refresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-status', is_config=False)


  def _get_active_outsegs(self):
    """
    Getter method for active_outsegs, mapped from YANG variable /mpls_state/rsvp/interfaces/active_outsegs (uint32)

    YANG Description: 1
    """
    return self.__active_outsegs
      
  def _set_active_outsegs(self, v, load=False):
    """
    Setter method for active_outsegs, mapped from YANG variable /mpls_state/rsvp/interfaces/active_outsegs (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active_outsegs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active_outsegs() directly.

    YANG Description: 1
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="active-outsegs", rest_name="active-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active_outsegs must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="active-outsegs", rest_name="active-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__active_outsegs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active_outsegs(self):
    self.__active_outsegs = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="active-outsegs", rest_name="active-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_inactive_outsegs(self):
    """
    Getter method for inactive_outsegs, mapped from YANG variable /mpls_state/rsvp/interfaces/inactive_outsegs (uint32)

    YANG Description: 1
    """
    return self.__inactive_outsegs
      
  def _set_inactive_outsegs(self, v, load=False):
    """
    Setter method for inactive_outsegs, mapped from YANG variable /mpls_state/rsvp/interfaces/inactive_outsegs (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inactive_outsegs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inactive_outsegs() directly.

    YANG Description: 1
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inactive-outsegs", rest_name="inactive-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inactive_outsegs must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inactive-outsegs", rest_name="inactive-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__inactive_outsegs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inactive_outsegs(self):
    self.__inactive_outsegs = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inactive-outsegs", rest_name="inactive-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_bandwith_resv_outsegs(self):
    """
    Getter method for bandwith_resv_outsegs, mapped from YANG variable /mpls_state/rsvp/interfaces/bandwith_resv_outsegs (uint32)

    YANG Description: 1
    """
    return self.__bandwith_resv_outsegs
      
  def _set_bandwith_resv_outsegs(self, v, load=False):
    """
    Setter method for bandwith_resv_outsegs, mapped from YANG variable /mpls_state/rsvp/interfaces/bandwith_resv_outsegs (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwith_resv_outsegs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwith_resv_outsegs() directly.

    YANG Description: 1
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwith-resv-outsegs", rest_name="bandwith-resv-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwith_resv_outsegs must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwith-resv-outsegs", rest_name="bandwith-resv-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__bandwith_resv_outsegs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwith_resv_outsegs(self):
    self.__bandwith_resv_outsegs = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwith-resv-outsegs", rest_name="bandwith-resv-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_active_backup_outsegs(self):
    """
    Getter method for active_backup_outsegs, mapped from YANG variable /mpls_state/rsvp/interfaces/active_backup_outsegs (uint32)

    YANG Description: 1
    """
    return self.__active_backup_outsegs
      
  def _set_active_backup_outsegs(self, v, load=False):
    """
    Setter method for active_backup_outsegs, mapped from YANG variable /mpls_state/rsvp/interfaces/active_backup_outsegs (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active_backup_outsegs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active_backup_outsegs() directly.

    YANG Description: 1
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="active-backup-outsegs", rest_name="active-backup-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active_backup_outsegs must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="active-backup-outsegs", rest_name="active-backup-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__active_backup_outsegs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active_backup_outsegs(self):
    self.__active_backup_outsegs = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="active-backup-outsegs", rest_name="active-backup-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_inactive_backup_outsegs(self):
    """
    Getter method for inactive_backup_outsegs, mapped from YANG variable /mpls_state/rsvp/interfaces/inactive_backup_outsegs (uint32)

    YANG Description: 1
    """
    return self.__inactive_backup_outsegs
      
  def _set_inactive_backup_outsegs(self, v, load=False):
    """
    Setter method for inactive_backup_outsegs, mapped from YANG variable /mpls_state/rsvp/interfaces/inactive_backup_outsegs (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inactive_backup_outsegs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inactive_backup_outsegs() directly.

    YANG Description: 1
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inactive-backup-outsegs", rest_name="inactive-backup-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inactive_backup_outsegs must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inactive-backup-outsegs", rest_name="inactive-backup-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__inactive_backup_outsegs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inactive_backup_outsegs(self):
    self.__inactive_backup_outsegs = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inactive-backup-outsegs", rest_name="inactive-backup-outsegs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_interface_preempts(self):
    """
    Getter method for interface_preempts, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_preempts (uint32)

    YANG Description: 1
    """
    return self.__interface_preempts
      
  def _set_interface_preempts(self, v, load=False):
    """
    Setter method for interface_preempts, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_preempts (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_preempts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_preempts() directly.

    YANG Description: 1
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-preempts", rest_name="interface-preempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_preempts must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-preempts", rest_name="interface-preempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__interface_preempts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_preempts(self):
    self.__interface_preempts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-preempts", rest_name="interface-preempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_interface_resv_soft_preempts(self):
    """
    Getter method for interface_resv_soft_preempts, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_resv_soft_preempts (uint32)

    YANG Description: 1
    """
    return self.__interface_resv_soft_preempts
      
  def _set_interface_resv_soft_preempts(self, v, load=False):
    """
    Setter method for interface_resv_soft_preempts, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_resv_soft_preempts (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_resv_soft_preempts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_resv_soft_preempts() directly.

    YANG Description: 1
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-resv-soft-preempts", rest_name="interface-resv-soft-preempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_resv_soft_preempts must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-resv-soft-preempts", rest_name="interface-resv-soft-preempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__interface_resv_soft_preempts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_resv_soft_preempts(self):
    self.__interface_resv_soft_preempts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-resv-soft-preempts", rest_name="interface-resv-soft-preempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_interface_flooding_up_threshold(self):
    """
    Getter method for interface_flooding_up_threshold, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_flooding_up_threshold (feature-config-source)

    YANG Description: Interface flood up threshold is taken from global, local or default settings
    """
    return self.__interface_flooding_up_threshold
      
  def _set_interface_flooding_up_threshold(self, v, load=False):
    """
    Setter method for interface_flooding_up_threshold, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_flooding_up_threshold (feature-config-source)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_flooding_up_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_flooding_up_threshold() directly.

    YANG Description: Interface flood up threshold is taken from global, local or default settings
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'local-config': {'value': 2}, u'default-config': {'value': 3}, u'global-config': {'value': 1}},), is_leaf=True, yang_name="interface-flooding-up-threshold", rest_name="interface-flooding-up-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-source', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_flooding_up_threshold must be of a type compatible with feature-config-source""",
          'defined-type': "brocade-mpls-operational:feature-config-source",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'local-config': {'value': 2}, u'default-config': {'value': 3}, u'global-config': {'value': 1}},), is_leaf=True, yang_name="interface-flooding-up-threshold", rest_name="interface-flooding-up-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-source', is_config=False)""",
        })

    self.__interface_flooding_up_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_flooding_up_threshold(self):
    self.__interface_flooding_up_threshold = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'local-config': {'value': 2}, u'default-config': {'value': 3}, u'global-config': {'value': 1}},), is_leaf=True, yang_name="interface-flooding-up-threshold", rest_name="interface-flooding-up-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-source', is_config=False)


  def _get_interface_flooding_down_threshold(self):
    """
    Getter method for interface_flooding_down_threshold, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_flooding_down_threshold (feature-config-source)

    YANG Description: Interface flood down threshold is taken from global, local or default settings
    """
    return self.__interface_flooding_down_threshold
      
  def _set_interface_flooding_down_threshold(self, v, load=False):
    """
    Setter method for interface_flooding_down_threshold, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_flooding_down_threshold (feature-config-source)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_flooding_down_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_flooding_down_threshold() directly.

    YANG Description: Interface flood down threshold is taken from global, local or default settings
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'local-config': {'value': 2}, u'default-config': {'value': 3}, u'global-config': {'value': 1}},), is_leaf=True, yang_name="interface-flooding-down-threshold", rest_name="interface-flooding-down-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-source', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_flooding_down_threshold must be of a type compatible with feature-config-source""",
          'defined-type': "brocade-mpls-operational:feature-config-source",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'local-config': {'value': 2}, u'default-config': {'value': 3}, u'global-config': {'value': 1}},), is_leaf=True, yang_name="interface-flooding-down-threshold", rest_name="interface-flooding-down-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-source', is_config=False)""",
        })

    self.__interface_flooding_down_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_flooding_down_threshold(self):
    self.__interface_flooding_down_threshold = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'local-config': {'value': 2}, u'default-config': {'value': 3}, u'global-config': {'value': 1}},), is_leaf=True, yang_name="interface-flooding-down-threshold", rest_name="interface-flooding-down-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='feature-config-source', is_config=False)


  def _get_duplicate_preempts_dropped(self):
    """
    Getter method for duplicate_preempts_dropped, mapped from YANG variable /mpls_state/rsvp/interfaces/duplicate_preempts_dropped (uint32)

    YANG Description: MPLS RSVP interface duplicate preempts dropped
    """
    return self.__duplicate_preempts_dropped
      
  def _set_duplicate_preempts_dropped(self, v, load=False):
    """
    Setter method for duplicate_preempts_dropped, mapped from YANG variable /mpls_state/rsvp/interfaces/duplicate_preempts_dropped (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_duplicate_preempts_dropped is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_duplicate_preempts_dropped() directly.

    YANG Description: MPLS RSVP interface duplicate preempts dropped
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duplicate-preempts-dropped", rest_name="duplicate-preempts-dropped", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """duplicate_preempts_dropped must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duplicate-preempts-dropped", rest_name="duplicate-preempts-dropped", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__duplicate_preempts_dropped = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_duplicate_preempts_dropped(self):
    self.__duplicate_preempts_dropped = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duplicate-preempts-dropped", rest_name="duplicate-preempts-dropped", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_bypass_interface(self):
    """
    Getter method for bypass_interface, mapped from YANG variable /mpls_state/rsvp/interfaces/bypass_interface (boolean)

    YANG Description: Bypass interface present
    """
    return self.__bypass_interface
      
  def _set_bypass_interface(self, v, load=False):
    """
    Setter method for bypass_interface, mapped from YANG variable /mpls_state/rsvp/interfaces/bypass_interface (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_interface() directly.

    YANG Description: Bypass interface present
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bypass-interface", rest_name="bypass-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_interface must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-interface", rest_name="bypass-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__bypass_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_interface(self):
    self.__bypass_interface = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bypass-interface", rest_name="bypass-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_interface_tunnel_name(self):
    """
    Getter method for interface_tunnel_name, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_tunnel_name (string)

    YANG Description: Interface tunnel name (if this is a tunnel interface)
    """
    return self.__interface_tunnel_name
      
  def _set_interface_tunnel_name(self, v, load=False):
    """
    Setter method for interface_tunnel_name, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_tunnel_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_tunnel_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_tunnel_name() directly.

    YANG Description: Interface tunnel name (if this is a tunnel interface)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="interface-tunnel-name", rest_name="interface-tunnel-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_tunnel_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="interface-tunnel-name", rest_name="interface-tunnel-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__interface_tunnel_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_tunnel_name(self):
    self.__interface_tunnel_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="interface-tunnel-name", rest_name="interface-tunnel-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_bypass_tunnel_interface_name(self):
    """
    Getter method for bypass_tunnel_interface_name, mapped from YANG variable /mpls_state/rsvp/interfaces/bypass_tunnel_interface_name (string)

    YANG Description: Bypass tunnel interface name
    """
    return self.__bypass_tunnel_interface_name
      
  def _set_bypass_tunnel_interface_name(self, v, load=False):
    """
    Setter method for bypass_tunnel_interface_name, mapped from YANG variable /mpls_state/rsvp/interfaces/bypass_tunnel_interface_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_tunnel_interface_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_tunnel_interface_name() directly.

    YANG Description: Bypass tunnel interface name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="bypass-tunnel-interface-name", rest_name="bypass-tunnel-interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_tunnel_interface_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-tunnel-interface-name", rest_name="bypass-tunnel-interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__bypass_tunnel_interface_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_tunnel_interface_name(self):
    self.__bypass_tunnel_interface_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="bypass-tunnel-interface-name", rest_name="bypass-tunnel-interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_interface_te_up_thresholds(self):
    """
    Getter method for interface_te_up_thresholds, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_te_up_thresholds (uint32)

    YANG Description: 1
    """
    return self.__interface_te_up_thresholds
      
  def _set_interface_te_up_thresholds(self, v, load=False):
    """
    Setter method for interface_te_up_thresholds, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_te_up_thresholds (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_te_up_thresholds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_te_up_thresholds() directly.

    YANG Description: 1
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="interface-te-up-thresholds", rest_name="interface-te-up-thresholds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_te_up_thresholds must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="interface-te-up-thresholds", rest_name="interface-te-up-thresholds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__interface_te_up_thresholds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_te_up_thresholds(self):
    self.__interface_te_up_thresholds = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="interface-te-up-thresholds", rest_name="interface-te-up-thresholds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_interface_te_down_thresholds(self):
    """
    Getter method for interface_te_down_thresholds, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_te_down_thresholds (uint32)

    YANG Description: 1
    """
    return self.__interface_te_down_thresholds
      
  def _set_interface_te_down_thresholds(self, v, load=False):
    """
    Setter method for interface_te_down_thresholds, mapped from YANG variable /mpls_state/rsvp/interfaces/interface_te_down_thresholds (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_te_down_thresholds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_te_down_thresholds() directly.

    YANG Description: 1
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="interface-te-down-thresholds", rest_name="interface-te-down-thresholds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_te_down_thresholds must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="interface-te-down-thresholds", rest_name="interface-te-down-thresholds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__interface_te_down_thresholds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_te_down_thresholds(self):
    self.__interface_te_down_thresholds = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="interface-te-down-thresholds", rest_name="interface-te-down-thresholds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_error_counters(self):
    """
    Getter method for error_counters, mapped from YANG variable /mpls_state/rsvp/interfaces/error_counters (container)

    YANG Description: RSVP interface error counters
    """
    return self.__error_counters
      
  def _set_error_counters(self, v, load=False):
    """
    Setter method for error_counters, mapped from YANG variable /mpls_state/rsvp/interfaces/error_counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_counters() directly.

    YANG Description: RSVP interface error counters
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=error_counters.error_counters, is_container='container', presence=False, yang_name="error-counters", rest_name="error-counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-interface-error-counters', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=error_counters.error_counters, is_container='container', presence=False, yang_name="error-counters", rest_name="error-counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-interface-error-counters', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)""",
        })

    self.__error_counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_counters(self):
    self.__error_counters = YANGDynClass(base=error_counters.error_counters, is_container='container', presence=False, yang_name="error-counters", rest_name="error-counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-interface-error-counters', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)


  def _get_packet_counters(self):
    """
    Getter method for packet_counters, mapped from YANG variable /mpls_state/rsvp/interfaces/packet_counters (container)
    """
    return self.__packet_counters
      
  def _set_packet_counters(self, v, load=False):
    """
    Setter method for packet_counters, mapped from YANG variable /mpls_state/rsvp/interfaces/packet_counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_counters() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=packet_counters.packet_counters, is_container='container', presence=False, yang_name="packet-counters", rest_name="packet-counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-packet-counters-packet-counters-2'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=packet_counters.packet_counters, is_container='container', presence=False, yang_name="packet-counters", rest_name="packet-counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-packet-counters-packet-counters-2'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)""",
        })

    self.__packet_counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_counters(self):
    self.__packet_counters = YANGDynClass(base=packet_counters.packet_counters, is_container='container', presence=False, yang_name="packet-counters", rest_name="packet-counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-rsvp-packet-counters-packet-counters-2'}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)

  interface_name = __builtin__.property(_get_interface_name)
  interface_type = __builtin__.property(_get_interface_type)
  interface_index = __builtin__.property(_get_interface_index)
  admin_status = __builtin__.property(_get_admin_status)
  oper_status = __builtin__.property(_get_oper_status)
  is_tunnel_interface = __builtin__.property(_get_is_tunnel_interface)
  hello_interval = __builtin__.property(_get_hello_interval)
  hello_tolerance = __builtin__.property(_get_hello_tolerance)
  hello_status = __builtin__.property(_get_hello_status)
  is_md5_auth_enabled = __builtin__.property(_get_is_md5_auth_enabled)
  reliable_messages = __builtin__.property(_get_reliable_messages)
  bundle_messages = __builtin__.property(_get_bundle_messages)
  summary_refresh = __builtin__.property(_get_summary_refresh)
  active_outsegs = __builtin__.property(_get_active_outsegs)
  inactive_outsegs = __builtin__.property(_get_inactive_outsegs)
  bandwith_resv_outsegs = __builtin__.property(_get_bandwith_resv_outsegs)
  active_backup_outsegs = __builtin__.property(_get_active_backup_outsegs)
  inactive_backup_outsegs = __builtin__.property(_get_inactive_backup_outsegs)
  interface_preempts = __builtin__.property(_get_interface_preempts)
  interface_resv_soft_preempts = __builtin__.property(_get_interface_resv_soft_preempts)
  interface_flooding_up_threshold = __builtin__.property(_get_interface_flooding_up_threshold)
  interface_flooding_down_threshold = __builtin__.property(_get_interface_flooding_down_threshold)
  duplicate_preempts_dropped = __builtin__.property(_get_duplicate_preempts_dropped)
  bypass_interface = __builtin__.property(_get_bypass_interface)
  interface_tunnel_name = __builtin__.property(_get_interface_tunnel_name)
  bypass_tunnel_interface_name = __builtin__.property(_get_bypass_tunnel_interface_name)
  interface_te_up_thresholds = __builtin__.property(_get_interface_te_up_thresholds)
  interface_te_down_thresholds = __builtin__.property(_get_interface_te_down_thresholds)
  error_counters = __builtin__.property(_get_error_counters)
  packet_counters = __builtin__.property(_get_packet_counters)


  _pyangbind_elements = {'interface_name': interface_name, 'interface_type': interface_type, 'interface_index': interface_index, 'admin_status': admin_status, 'oper_status': oper_status, 'is_tunnel_interface': is_tunnel_interface, 'hello_interval': hello_interval, 'hello_tolerance': hello_tolerance, 'hello_status': hello_status, 'is_md5_auth_enabled': is_md5_auth_enabled, 'reliable_messages': reliable_messages, 'bundle_messages': bundle_messages, 'summary_refresh': summary_refresh, 'active_outsegs': active_outsegs, 'inactive_outsegs': inactive_outsegs, 'bandwith_resv_outsegs': bandwith_resv_outsegs, 'active_backup_outsegs': active_backup_outsegs, 'inactive_backup_outsegs': inactive_backup_outsegs, 'interface_preempts': interface_preempts, 'interface_resv_soft_preempts': interface_resv_soft_preempts, 'interface_flooding_up_threshold': interface_flooding_up_threshold, 'interface_flooding_down_threshold': interface_flooding_down_threshold, 'duplicate_preempts_dropped': duplicate_preempts_dropped, 'bypass_interface': bypass_interface, 'interface_tunnel_name': interface_tunnel_name, 'bypass_tunnel_interface_name': bypass_tunnel_interface_name, 'interface_te_up_thresholds': interface_te_up_thresholds, 'interface_te_down_thresholds': interface_te_down_thresholds, 'error_counters': error_counters, 'packet_counters': packet_counters, }


