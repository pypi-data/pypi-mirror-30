
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import ldp_session_summary
import tunnels
import statistics
import ldp_fec_statistics
import interface
import ldp_database
import targeted_peer
import path
import ldp_neighbors
import ldp_session
import ldp_fec_prefix
import ldp_fec_vc
class ldp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls-operational - based on the path /mpls-state/ldp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: LDP Operational Information
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__ldp_initialized','__lsr_id','__lsr_id_configured','__loopback','__hello_interval_link','__hello_interval_target','__hold_time_sent_link','__hold_time_sent_target','__ka_interval','__ka_multiple','__ka_timeout','__ka_timeout_default','__load_sharing','__advertise_fecs_for_prefix_list','__advertise_fecs_for_prefix_list_exists','__inbound_fecs_filtering_prefix_list','__inbound_fecs_filtering_prefix_list_exists','__outbound_fecs_filtering_prefix_list','__outbound_fecs_filtering_prefix_list_exists','__tunnel_metric','__fec_128_used_for_auto_disc_current','__fec_128_used_for_auto_disc_configured','__end_of_lib','__eol_notification_time','__tx_silence_time','__rx_silence_time','__gr_enable','__gr_helper','__gr_reconnect_time','__gr_max_peer_reconnect_time','__gr_recovery_time','__gr_max_peer_recovery_time','__forwarding_state_timer_running','__forwarding_state_timer_remaining','__lwd_delay','__lwd_default','__ldp_session_summary','__tunnels','__statistics','__ldp_fec_statistics','__interface','__ldp_database','__targeted_peer','__path','__ldp_neighbors','__ldp_session','__ldp_fec_prefix','__ldp_fec_vc',)

  _yang_name = 'ldp'
  _rest_name = 'ldp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__forwarding_state_timer_remaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="forwarding-state-timer-remaining", rest_name="forwarding-state-timer-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__fec_128_used_for_auto_disc_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-configured", rest_name="fec-128-used-for-auto-disc-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__fec_128_used_for_auto_disc_current = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-current", rest_name="fec-128-used-for-auto-disc-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__gr_max_peer_recovery_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-recovery-time", rest_name="gr-max-peer-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__gr_max_peer_reconnect_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-reconnect-time", rest_name="gr-max-peer-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__hold_time_sent_target = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-target", rest_name="hold-time-sent-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__advertise_fecs_for_prefix_list_exists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-fecs-for-prefix-list-exists", rest_name="advertise-fecs-for-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__end_of_lib = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="end-of-lib", rest_name="end-of-lib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__lsr_id_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsr-id-configured", rest_name="lsr-id-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__lsr_id = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="lsr-id", rest_name="lsr-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='inet:ipv4-address', is_config=False)
    self.__ka_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-timeout", rest_name="ka-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__ka_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-interval", rest_name="ka-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__ldp_session = YANGDynClass(base=YANGListType("peer_ldp_id peer_label_space_id",ldp_session.ldp_session, yang_name="ldp-session", rest_name="ldp-session", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ldp-id peer-label-space-id', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-session', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-session", rest_name="ldp-session", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-session', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__inbound_fecs_filtering_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list", rest_name="inbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__hello_interval_link = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-link", rest_name="hello-interval-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__ldp_session_summary = YANGDynClass(base=ldp_session_summary.ldp_session_summary, is_container='container', presence=False, yang_name="ldp-session-summary", rest_name="ldp-session-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-session-summary', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    self.__lwd_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lwd-delay", rest_name="lwd-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__gr_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-enable", rest_name="gr-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__loopback = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="loopback", rest_name="loopback", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__ldp_fec_statistics = YANGDynClass(base=ldp_fec_statistics.ldp_fec_statistics, is_container='container', presence=False, yang_name="ldp-fec-statistics", rest_name="ldp-fec-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    self.__ldp_database = YANGDynClass(base=YANGListType("peer_ip own_ip",ldp_database.ldp_database, yang_name="ldp-database", rest_name="ldp-database", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip own-ip', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-database', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-database", rest_name="ldp-database", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-database', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__outbound_fecs_filtering_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list", rest_name="outbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    self.__outbound_fecs_filtering_prefix_list_exists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list-exists", rest_name="outbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__ldp_fec_vc = YANGDynClass(base=YANGListType("vc_id",ldp_fec_vc.ldp_fec_vc, yang_name="ldp-fec-vc", rest_name="ldp-fec-vc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vc-id', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-vc', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-fec-vc", rest_name="ldp-fec-vc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-vc', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__tunnels = YANGDynClass(base=tunnels.tunnels, is_container='container', presence=False, yang_name="tunnels", rest_name="tunnels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-tunnels', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    self.__inbound_fecs_filtering_prefix_list_exists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list-exists", rest_name="inbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__ldp_neighbors = YANGDynClass(base=YANGListType("neighbor_ldpid labelspaceid",ldp_neighbors.ldp_neighbors, yang_name="ldp-neighbors", rest_name="ldp-neighbors", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbor-ldpid labelspaceid', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-neighbor', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-neighbors", rest_name="ldp-neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-neighbor', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__ldp_initialized = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ldp-initialized", rest_name="ldp-initialized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__statistics = YANGDynClass(base=statistics.statistics, is_container='container', presence=False, yang_name="statistics", rest_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-global-ldp-stats', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    self.__interface = YANGDynClass(base=YANGListType("interface_name",interface.interface, yang_name="interface", rest_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__load_sharing = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="load-sharing", rest_name="load-sharing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    self.__gr_reconnect_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-reconnect-time", rest_name="gr-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__eol_notification_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time", rest_name="eol-notification-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__ldp_fec_prefix = YANGDynClass(base=YANGListType("destination",ldp_fec_prefix.ldp_fec_prefix, yang_name="ldp-fec-prefix", rest_name="ldp-fec-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-fec-prefix", rest_name="ldp-fec-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__gr_recovery_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-recovery-time", rest_name="gr-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__tx_silence_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-silence-time", rest_name="tx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__rx_silence_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rx-silence-time", rest_name="rx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__gr_helper = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-helper", rest_name="gr-helper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__tunnel_metric = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-metric", rest_name="tunnel-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    self.__hello_interval_target = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-target", rest_name="hello-interval-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__hold_time_sent_link = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-link", rest_name="hold-time-sent-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__ka_timeout_default = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ka-timeout-default", rest_name="ka-timeout-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__targeted_peer = YANGDynClass(base=YANGListType("mpls_ldp_targeted_peer_id",targeted_peer.targeted_peer, yang_name="targeted-peer", rest_name="targeted-peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mpls-ldp-targeted-peer-id', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-targeted-peer', u'cli-suppress-show-path': None}}), is_container='list', yang_name="targeted-peer", rest_name="targeted-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-targeted-peer', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__ka_multiple = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-multiple", rest_name="ka-multiple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__path = YANGDynClass(base=YANGListType("path_key",path.path, yang_name="path", rest_name="path", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='path-key', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-path', u'cli-suppress-show-path': None}}), is_container='list', yang_name="path", rest_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-path', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    self.__forwarding_state_timer_running = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="forwarding-state-timer-running", rest_name="forwarding-state-timer-running", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__lwd_default = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lwd-default", rest_name="lwd-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__advertise_fecs_for_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="advertise-fecs-for-prefix-list", rest_name="advertise-fecs-for-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mpls-state', u'ldp']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'mpls-state', u'ldp']

  def _get_ldp_initialized(self):
    """
    Getter method for ldp_initialized, mapped from YANG variable /mpls_state/ldp/ldp_initialized (boolean)

    YANG Description: ldp_initialized
    """
    return self.__ldp_initialized
      
  def _set_ldp_initialized(self, v, load=False):
    """
    Setter method for ldp_initialized, mapped from YANG variable /mpls_state/ldp/ldp_initialized (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_initialized is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_initialized() directly.

    YANG Description: ldp_initialized
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ldp-initialized", rest_name="ldp-initialized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_initialized must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ldp-initialized", rest_name="ldp-initialized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__ldp_initialized = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_initialized(self):
    self.__ldp_initialized = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ldp-initialized", rest_name="ldp-initialized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_lsr_id(self):
    """
    Getter method for lsr_id, mapped from YANG variable /mpls_state/ldp/lsr_id (inet:ipv4-address)

    YANG Description: lsr_id
    """
    return self.__lsr_id
      
  def _set_lsr_id(self, v, load=False):
    """
    Setter method for lsr_id, mapped from YANG variable /mpls_state/ldp/lsr_id (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsr_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsr_id() directly.

    YANG Description: lsr_id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="lsr-id", rest_name="lsr-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsr_id must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="lsr-id", rest_name="lsr-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='inet:ipv4-address', is_config=False)""",
        })

    self.__lsr_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsr_id(self):
    self.__lsr_id = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="lsr-id", rest_name="lsr-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='inet:ipv4-address', is_config=False)


  def _get_lsr_id_configured(self):
    """
    Getter method for lsr_id_configured, mapped from YANG variable /mpls_state/ldp/lsr_id_configured (boolean)

    YANG Description: lsr_id_configured
    """
    return self.__lsr_id_configured
      
  def _set_lsr_id_configured(self, v, load=False):
    """
    Setter method for lsr_id_configured, mapped from YANG variable /mpls_state/ldp/lsr_id_configured (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsr_id_configured is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsr_id_configured() directly.

    YANG Description: lsr_id_configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lsr-id-configured", rest_name="lsr-id-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsr_id_configured must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsr-id-configured", rest_name="lsr-id-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__lsr_id_configured = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsr_id_configured(self):
    self.__lsr_id_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lsr-id-configured", rest_name="lsr-id-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_loopback(self):
    """
    Getter method for loopback, mapped from YANG variable /mpls_state/ldp/loopback (uint8)

    YANG Description: loopback
    """
    return self.__loopback
      
  def _set_loopback(self, v, load=False):
    """
    Setter method for loopback, mapped from YANG variable /mpls_state/ldp/loopback (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loopback is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loopback() directly.

    YANG Description: loopback
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="loopback", rest_name="loopback", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loopback must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="loopback", rest_name="loopback", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__loopback = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loopback(self):
    self.__loopback = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="loopback", rest_name="loopback", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_hello_interval_link(self):
    """
    Getter method for hello_interval_link, mapped from YANG variable /mpls_state/ldp/hello_interval_link (uint32)

    YANG Description: hello_interval_link
    """
    return self.__hello_interval_link
      
  def _set_hello_interval_link(self, v, load=False):
    """
    Setter method for hello_interval_link, mapped from YANG variable /mpls_state/ldp/hello_interval_link (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval_link is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval_link() directly.

    YANG Description: hello_interval_link
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-link", rest_name="hello-interval-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval_link must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-link", rest_name="hello-interval-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__hello_interval_link = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval_link(self):
    self.__hello_interval_link = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-link", rest_name="hello-interval-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_hello_interval_target(self):
    """
    Getter method for hello_interval_target, mapped from YANG variable /mpls_state/ldp/hello_interval_target (uint32)

    YANG Description: hello_interval_target
    """
    return self.__hello_interval_target
      
  def _set_hello_interval_target(self, v, load=False):
    """
    Setter method for hello_interval_target, mapped from YANG variable /mpls_state/ldp/hello_interval_target (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval_target() directly.

    YANG Description: hello_interval_target
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-target", rest_name="hello-interval-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval_target must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-target", rest_name="hello-interval-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__hello_interval_target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval_target(self):
    self.__hello_interval_target = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval-target", rest_name="hello-interval-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_hold_time_sent_link(self):
    """
    Getter method for hold_time_sent_link, mapped from YANG variable /mpls_state/ldp/hold_time_sent_link (uint32)

    YANG Description: hold_time_sent_link
    """
    return self.__hold_time_sent_link
      
  def _set_hold_time_sent_link(self, v, load=False):
    """
    Setter method for hold_time_sent_link, mapped from YANG variable /mpls_state/ldp/hold_time_sent_link (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_time_sent_link is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_time_sent_link() directly.

    YANG Description: hold_time_sent_link
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-link", rest_name="hold-time-sent-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_time_sent_link must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-link", rest_name="hold-time-sent-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__hold_time_sent_link = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_time_sent_link(self):
    self.__hold_time_sent_link = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-link", rest_name="hold-time-sent-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_hold_time_sent_target(self):
    """
    Getter method for hold_time_sent_target, mapped from YANG variable /mpls_state/ldp/hold_time_sent_target (uint32)

    YANG Description: hold_time_sent_target
    """
    return self.__hold_time_sent_target
      
  def _set_hold_time_sent_target(self, v, load=False):
    """
    Setter method for hold_time_sent_target, mapped from YANG variable /mpls_state/ldp/hold_time_sent_target (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_time_sent_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_time_sent_target() directly.

    YANG Description: hold_time_sent_target
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-target", rest_name="hold-time-sent-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_time_sent_target must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-target", rest_name="hold-time-sent-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__hold_time_sent_target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_time_sent_target(self):
    self.__hold_time_sent_target = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-sent-target", rest_name="hold-time-sent-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_ka_interval(self):
    """
    Getter method for ka_interval, mapped from YANG variable /mpls_state/ldp/ka_interval (uint32)

    YANG Description: ka_interval
    """
    return self.__ka_interval
      
  def _set_ka_interval(self, v, load=False):
    """
    Setter method for ka_interval, mapped from YANG variable /mpls_state/ldp/ka_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ka_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ka_interval() directly.

    YANG Description: ka_interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-interval", rest_name="ka-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ka_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-interval", rest_name="ka-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__ka_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ka_interval(self):
    self.__ka_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-interval", rest_name="ka-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_ka_multiple(self):
    """
    Getter method for ka_multiple, mapped from YANG variable /mpls_state/ldp/ka_multiple (uint32)

    YANG Description: ka_multiple
    """
    return self.__ka_multiple
      
  def _set_ka_multiple(self, v, load=False):
    """
    Setter method for ka_multiple, mapped from YANG variable /mpls_state/ldp/ka_multiple (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ka_multiple is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ka_multiple() directly.

    YANG Description: ka_multiple
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-multiple", rest_name="ka-multiple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ka_multiple must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-multiple", rest_name="ka-multiple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__ka_multiple = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ka_multiple(self):
    self.__ka_multiple = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-multiple", rest_name="ka-multiple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_ka_timeout(self):
    """
    Getter method for ka_timeout, mapped from YANG variable /mpls_state/ldp/ka_timeout (uint32)

    YANG Description: ka_timeout
    """
    return self.__ka_timeout
      
  def _set_ka_timeout(self, v, load=False):
    """
    Setter method for ka_timeout, mapped from YANG variable /mpls_state/ldp/ka_timeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ka_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ka_timeout() directly.

    YANG Description: ka_timeout
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-timeout", rest_name="ka-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ka_timeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-timeout", rest_name="ka-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__ka_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ka_timeout(self):
    self.__ka_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ka-timeout", rest_name="ka-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_ka_timeout_default(self):
    """
    Getter method for ka_timeout_default, mapped from YANG variable /mpls_state/ldp/ka_timeout_default (boolean)

    YANG Description: ka_timeout_default
    """
    return self.__ka_timeout_default
      
  def _set_ka_timeout_default(self, v, load=False):
    """
    Setter method for ka_timeout_default, mapped from YANG variable /mpls_state/ldp/ka_timeout_default (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ka_timeout_default is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ka_timeout_default() directly.

    YANG Description: ka_timeout_default
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ka-timeout-default", rest_name="ka-timeout-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ka_timeout_default must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ka-timeout-default", rest_name="ka-timeout-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__ka_timeout_default = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ka_timeout_default(self):
    self.__ka_timeout_default = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ka-timeout-default", rest_name="ka-timeout-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_load_sharing(self):
    """
    Getter method for load_sharing, mapped from YANG variable /mpls_state/ldp/load_sharing (uint8)

    YANG Description: load_sharing
    """
    return self.__load_sharing
      
  def _set_load_sharing(self, v, load=False):
    """
    Setter method for load_sharing, mapped from YANG variable /mpls_state/ldp/load_sharing (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_load_sharing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_load_sharing() directly.

    YANG Description: load_sharing
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="load-sharing", rest_name="load-sharing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """load_sharing must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="load-sharing", rest_name="load-sharing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)""",
        })

    self.__load_sharing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_load_sharing(self):
    self.__load_sharing = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="load-sharing", rest_name="load-sharing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint8', is_config=False)


  def _get_advertise_fecs_for_prefix_list(self):
    """
    Getter method for advertise_fecs_for_prefix_list, mapped from YANG variable /mpls_state/ldp/advertise_fecs_for_prefix_list (string)

    YANG Description: advertise_fecs_for_prefix_list
    """
    return self.__advertise_fecs_for_prefix_list
      
  def _set_advertise_fecs_for_prefix_list(self, v, load=False):
    """
    Setter method for advertise_fecs_for_prefix_list, mapped from YANG variable /mpls_state/ldp/advertise_fecs_for_prefix_list (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_fecs_for_prefix_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_fecs_for_prefix_list() directly.

    YANG Description: advertise_fecs_for_prefix_list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="advertise-fecs-for-prefix-list", rest_name="advertise-fecs-for-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_fecs_for_prefix_list must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="advertise-fecs-for-prefix-list", rest_name="advertise-fecs-for-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__advertise_fecs_for_prefix_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_fecs_for_prefix_list(self):
    self.__advertise_fecs_for_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="advertise-fecs-for-prefix-list", rest_name="advertise-fecs-for-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_advertise_fecs_for_prefix_list_exists(self):
    """
    Getter method for advertise_fecs_for_prefix_list_exists, mapped from YANG variable /mpls_state/ldp/advertise_fecs_for_prefix_list_exists (boolean)

    YANG Description: advertise_fecs_for_prefix_list_exists
    """
    return self.__advertise_fecs_for_prefix_list_exists
      
  def _set_advertise_fecs_for_prefix_list_exists(self, v, load=False):
    """
    Setter method for advertise_fecs_for_prefix_list_exists, mapped from YANG variable /mpls_state/ldp/advertise_fecs_for_prefix_list_exists (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_fecs_for_prefix_list_exists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_fecs_for_prefix_list_exists() directly.

    YANG Description: advertise_fecs_for_prefix_list_exists
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="advertise-fecs-for-prefix-list-exists", rest_name="advertise-fecs-for-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_fecs_for_prefix_list_exists must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-fecs-for-prefix-list-exists", rest_name="advertise-fecs-for-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__advertise_fecs_for_prefix_list_exists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_fecs_for_prefix_list_exists(self):
    self.__advertise_fecs_for_prefix_list_exists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-fecs-for-prefix-list-exists", rest_name="advertise-fecs-for-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_inbound_fecs_filtering_prefix_list(self):
    """
    Getter method for inbound_fecs_filtering_prefix_list, mapped from YANG variable /mpls_state/ldp/inbound_fecs_filtering_prefix_list (string)

    YANG Description: inbound_fecs_filtering_prefix_list
    """
    return self.__inbound_fecs_filtering_prefix_list
      
  def _set_inbound_fecs_filtering_prefix_list(self, v, load=False):
    """
    Setter method for inbound_fecs_filtering_prefix_list, mapped from YANG variable /mpls_state/ldp/inbound_fecs_filtering_prefix_list (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inbound_fecs_filtering_prefix_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inbound_fecs_filtering_prefix_list() directly.

    YANG Description: inbound_fecs_filtering_prefix_list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list", rest_name="inbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inbound_fecs_filtering_prefix_list must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list", rest_name="inbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__inbound_fecs_filtering_prefix_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inbound_fecs_filtering_prefix_list(self):
    self.__inbound_fecs_filtering_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list", rest_name="inbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_inbound_fecs_filtering_prefix_list_exists(self):
    """
    Getter method for inbound_fecs_filtering_prefix_list_exists, mapped from YANG variable /mpls_state/ldp/inbound_fecs_filtering_prefix_list_exists (boolean)

    YANG Description: inbound_fecs_filtering_prefix_list_exists
    """
    return self.__inbound_fecs_filtering_prefix_list_exists
      
  def _set_inbound_fecs_filtering_prefix_list_exists(self, v, load=False):
    """
    Setter method for inbound_fecs_filtering_prefix_list_exists, mapped from YANG variable /mpls_state/ldp/inbound_fecs_filtering_prefix_list_exists (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inbound_fecs_filtering_prefix_list_exists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inbound_fecs_filtering_prefix_list_exists() directly.

    YANG Description: inbound_fecs_filtering_prefix_list_exists
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list-exists", rest_name="inbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inbound_fecs_filtering_prefix_list_exists must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list-exists", rest_name="inbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__inbound_fecs_filtering_prefix_list_exists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inbound_fecs_filtering_prefix_list_exists(self):
    self.__inbound_fecs_filtering_prefix_list_exists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="inbound-fecs-filtering-prefix-list-exists", rest_name="inbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_outbound_fecs_filtering_prefix_list(self):
    """
    Getter method for outbound_fecs_filtering_prefix_list, mapped from YANG variable /mpls_state/ldp/outbound_fecs_filtering_prefix_list (string)

    YANG Description: outbound_fecs_filtering_prefix_list
    """
    return self.__outbound_fecs_filtering_prefix_list
      
  def _set_outbound_fecs_filtering_prefix_list(self, v, load=False):
    """
    Setter method for outbound_fecs_filtering_prefix_list, mapped from YANG variable /mpls_state/ldp/outbound_fecs_filtering_prefix_list (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outbound_fecs_filtering_prefix_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outbound_fecs_filtering_prefix_list() directly.

    YANG Description: outbound_fecs_filtering_prefix_list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list", rest_name="outbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outbound_fecs_filtering_prefix_list must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list", rest_name="outbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__outbound_fecs_filtering_prefix_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outbound_fecs_filtering_prefix_list(self):
    self.__outbound_fecs_filtering_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list", rest_name="outbound-fecs-filtering-prefix-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_outbound_fecs_filtering_prefix_list_exists(self):
    """
    Getter method for outbound_fecs_filtering_prefix_list_exists, mapped from YANG variable /mpls_state/ldp/outbound_fecs_filtering_prefix_list_exists (boolean)

    YANG Description: outbound_fecs_filtering_prefix_list_exists
    """
    return self.__outbound_fecs_filtering_prefix_list_exists
      
  def _set_outbound_fecs_filtering_prefix_list_exists(self, v, load=False):
    """
    Setter method for outbound_fecs_filtering_prefix_list_exists, mapped from YANG variable /mpls_state/ldp/outbound_fecs_filtering_prefix_list_exists (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outbound_fecs_filtering_prefix_list_exists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outbound_fecs_filtering_prefix_list_exists() directly.

    YANG Description: outbound_fecs_filtering_prefix_list_exists
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list-exists", rest_name="outbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outbound_fecs_filtering_prefix_list_exists must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list-exists", rest_name="outbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__outbound_fecs_filtering_prefix_list_exists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outbound_fecs_filtering_prefix_list_exists(self):
    self.__outbound_fecs_filtering_prefix_list_exists = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="outbound-fecs-filtering-prefix-list-exists", rest_name="outbound-fecs-filtering-prefix-list-exists", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_tunnel_metric(self):
    """
    Getter method for tunnel_metric, mapped from YANG variable /mpls_state/ldp/tunnel_metric (uint16)

    YANG Description: tunnel_metric
    """
    return self.__tunnel_metric
      
  def _set_tunnel_metric(self, v, load=False):
    """
    Setter method for tunnel_metric, mapped from YANG variable /mpls_state/ldp/tunnel_metric (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_metric() directly.

    YANG Description: tunnel_metric
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-metric", rest_name="tunnel-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_metric must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-metric", rest_name="tunnel-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)""",
        })

    self.__tunnel_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_metric(self):
    self.__tunnel_metric = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-metric", rest_name="tunnel-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint16', is_config=False)


  def _get_fec_128_used_for_auto_disc_current(self):
    """
    Getter method for fec_128_used_for_auto_disc_current, mapped from YANG variable /mpls_state/ldp/fec_128_used_for_auto_disc_current (boolean)

    YANG Description: fec_128_used_for_auto_disc_current
    """
    return self.__fec_128_used_for_auto_disc_current
      
  def _set_fec_128_used_for_auto_disc_current(self, v, load=False):
    """
    Setter method for fec_128_used_for_auto_disc_current, mapped from YANG variable /mpls_state/ldp/fec_128_used_for_auto_disc_current (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_128_used_for_auto_disc_current is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_128_used_for_auto_disc_current() directly.

    YANG Description: fec_128_used_for_auto_disc_current
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-current", rest_name="fec-128-used-for-auto-disc-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_128_used_for_auto_disc_current must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-current", rest_name="fec-128-used-for-auto-disc-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__fec_128_used_for_auto_disc_current = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_128_used_for_auto_disc_current(self):
    self.__fec_128_used_for_auto_disc_current = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-current", rest_name="fec-128-used-for-auto-disc-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_fec_128_used_for_auto_disc_configured(self):
    """
    Getter method for fec_128_used_for_auto_disc_configured, mapped from YANG variable /mpls_state/ldp/fec_128_used_for_auto_disc_configured (boolean)

    YANG Description: fec_128_used_for_auto_disc_configured
    """
    return self.__fec_128_used_for_auto_disc_configured
      
  def _set_fec_128_used_for_auto_disc_configured(self, v, load=False):
    """
    Setter method for fec_128_used_for_auto_disc_configured, mapped from YANG variable /mpls_state/ldp/fec_128_used_for_auto_disc_configured (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_128_used_for_auto_disc_configured is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_128_used_for_auto_disc_configured() directly.

    YANG Description: fec_128_used_for_auto_disc_configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-configured", rest_name="fec-128-used-for-auto-disc-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_128_used_for_auto_disc_configured must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-configured", rest_name="fec-128-used-for-auto-disc-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__fec_128_used_for_auto_disc_configured = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_128_used_for_auto_disc_configured(self):
    self.__fec_128_used_for_auto_disc_configured = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fec-128-used-for-auto-disc-configured", rest_name="fec-128-used-for-auto-disc-configured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_end_of_lib(self):
    """
    Getter method for end_of_lib, mapped from YANG variable /mpls_state/ldp/end_of_lib (boolean)

    YANG Description: end_of_lib
    """
    return self.__end_of_lib
      
  def _set_end_of_lib(self, v, load=False):
    """
    Setter method for end_of_lib, mapped from YANG variable /mpls_state/ldp/end_of_lib (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_of_lib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_of_lib() directly.

    YANG Description: end_of_lib
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="end-of-lib", rest_name="end-of-lib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_of_lib must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="end-of-lib", rest_name="end-of-lib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__end_of_lib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_of_lib(self):
    self.__end_of_lib = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="end-of-lib", rest_name="end-of-lib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_eol_notification_time(self):
    """
    Getter method for eol_notification_time, mapped from YANG variable /mpls_state/ldp/eol_notification_time (uint32)

    YANG Description: eol_notification_time
    """
    return self.__eol_notification_time
      
  def _set_eol_notification_time(self, v, load=False):
    """
    Setter method for eol_notification_time, mapped from YANG variable /mpls_state/ldp/eol_notification_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eol_notification_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eol_notification_time() directly.

    YANG Description: eol_notification_time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time", rest_name="eol-notification-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eol_notification_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time", rest_name="eol-notification-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__eol_notification_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eol_notification_time(self):
    self.__eol_notification_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="eol-notification-time", rest_name="eol-notification-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_tx_silence_time(self):
    """
    Getter method for tx_silence_time, mapped from YANG variable /mpls_state/ldp/tx_silence_time (uint32)

    YANG Description: tx_silence_time
    """
    return self.__tx_silence_time
      
  def _set_tx_silence_time(self, v, load=False):
    """
    Setter method for tx_silence_time, mapped from YANG variable /mpls_state/ldp/tx_silence_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_silence_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_silence_time() directly.

    YANG Description: tx_silence_time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-silence-time", rest_name="tx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_silence_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-silence-time", rest_name="tx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__tx_silence_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_silence_time(self):
    self.__tx_silence_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-silence-time", rest_name="tx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_rx_silence_time(self):
    """
    Getter method for rx_silence_time, mapped from YANG variable /mpls_state/ldp/rx_silence_time (uint32)

    YANG Description: rx_silence_time
    """
    return self.__rx_silence_time
      
  def _set_rx_silence_time(self, v, load=False):
    """
    Setter method for rx_silence_time, mapped from YANG variable /mpls_state/ldp/rx_silence_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_silence_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_silence_time() directly.

    YANG Description: rx_silence_time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rx-silence-time", rest_name="rx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_silence_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rx-silence-time", rest_name="rx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__rx_silence_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_silence_time(self):
    self.__rx_silence_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rx-silence-time", rest_name="rx-silence-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_gr_enable(self):
    """
    Getter method for gr_enable, mapped from YANG variable /mpls_state/ldp/gr_enable (boolean)

    YANG Description: gr_enable
    """
    return self.__gr_enable
      
  def _set_gr_enable(self, v, load=False):
    """
    Setter method for gr_enable, mapped from YANG variable /mpls_state/ldp/gr_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_enable() directly.

    YANG Description: gr_enable
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="gr-enable", rest_name="gr-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-enable", rest_name="gr-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__gr_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_enable(self):
    self.__gr_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-enable", rest_name="gr-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_gr_helper(self):
    """
    Getter method for gr_helper, mapped from YANG variable /mpls_state/ldp/gr_helper (boolean)

    YANG Description: gr_helper
    """
    return self.__gr_helper
      
  def _set_gr_helper(self, v, load=False):
    """
    Setter method for gr_helper, mapped from YANG variable /mpls_state/ldp/gr_helper (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_helper is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_helper() directly.

    YANG Description: gr_helper
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="gr-helper", rest_name="gr-helper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_helper must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-helper", rest_name="gr-helper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__gr_helper = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_helper(self):
    self.__gr_helper = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gr-helper", rest_name="gr-helper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_gr_reconnect_time(self):
    """
    Getter method for gr_reconnect_time, mapped from YANG variable /mpls_state/ldp/gr_reconnect_time (uint32)

    YANG Description: gr_reconnect_time
    """
    return self.__gr_reconnect_time
      
  def _set_gr_reconnect_time(self, v, load=False):
    """
    Setter method for gr_reconnect_time, mapped from YANG variable /mpls_state/ldp/gr_reconnect_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_reconnect_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_reconnect_time() directly.

    YANG Description: gr_reconnect_time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-reconnect-time", rest_name="gr-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_reconnect_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-reconnect-time", rest_name="gr-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__gr_reconnect_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_reconnect_time(self):
    self.__gr_reconnect_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-reconnect-time", rest_name="gr-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_gr_max_peer_reconnect_time(self):
    """
    Getter method for gr_max_peer_reconnect_time, mapped from YANG variable /mpls_state/ldp/gr_max_peer_reconnect_time (uint32)

    YANG Description: gr_max_peer_reconnect_time
    """
    return self.__gr_max_peer_reconnect_time
      
  def _set_gr_max_peer_reconnect_time(self, v, load=False):
    """
    Setter method for gr_max_peer_reconnect_time, mapped from YANG variable /mpls_state/ldp/gr_max_peer_reconnect_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_max_peer_reconnect_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_max_peer_reconnect_time() directly.

    YANG Description: gr_max_peer_reconnect_time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-reconnect-time", rest_name="gr-max-peer-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_max_peer_reconnect_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-reconnect-time", rest_name="gr-max-peer-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__gr_max_peer_reconnect_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_max_peer_reconnect_time(self):
    self.__gr_max_peer_reconnect_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-reconnect-time", rest_name="gr-max-peer-reconnect-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_gr_recovery_time(self):
    """
    Getter method for gr_recovery_time, mapped from YANG variable /mpls_state/ldp/gr_recovery_time (uint32)

    YANG Description: gr_recovery_time
    """
    return self.__gr_recovery_time
      
  def _set_gr_recovery_time(self, v, load=False):
    """
    Setter method for gr_recovery_time, mapped from YANG variable /mpls_state/ldp/gr_recovery_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_recovery_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_recovery_time() directly.

    YANG Description: gr_recovery_time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-recovery-time", rest_name="gr-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_recovery_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-recovery-time", rest_name="gr-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__gr_recovery_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_recovery_time(self):
    self.__gr_recovery_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-recovery-time", rest_name="gr-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_gr_max_peer_recovery_time(self):
    """
    Getter method for gr_max_peer_recovery_time, mapped from YANG variable /mpls_state/ldp/gr_max_peer_recovery_time (uint32)

    YANG Description: gr_max_peer_recovery_time
    """
    return self.__gr_max_peer_recovery_time
      
  def _set_gr_max_peer_recovery_time(self, v, load=False):
    """
    Setter method for gr_max_peer_recovery_time, mapped from YANG variable /mpls_state/ldp/gr_max_peer_recovery_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_max_peer_recovery_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_max_peer_recovery_time() directly.

    YANG Description: gr_max_peer_recovery_time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-recovery-time", rest_name="gr-max-peer-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_max_peer_recovery_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-recovery-time", rest_name="gr-max-peer-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__gr_max_peer_recovery_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_max_peer_recovery_time(self):
    self.__gr_max_peer_recovery_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-max-peer-recovery-time", rest_name="gr-max-peer-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_forwarding_state_timer_running(self):
    """
    Getter method for forwarding_state_timer_running, mapped from YANG variable /mpls_state/ldp/forwarding_state_timer_running (boolean)

    YANG Description: forwarding_state_timer_running
    """
    return self.__forwarding_state_timer_running
      
  def _set_forwarding_state_timer_running(self, v, load=False):
    """
    Setter method for forwarding_state_timer_running, mapped from YANG variable /mpls_state/ldp/forwarding_state_timer_running (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_forwarding_state_timer_running is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_forwarding_state_timer_running() directly.

    YANG Description: forwarding_state_timer_running
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="forwarding-state-timer-running", rest_name="forwarding-state-timer-running", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """forwarding_state_timer_running must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="forwarding-state-timer-running", rest_name="forwarding-state-timer-running", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__forwarding_state_timer_running = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_forwarding_state_timer_running(self):
    self.__forwarding_state_timer_running = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="forwarding-state-timer-running", rest_name="forwarding-state-timer-running", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_forwarding_state_timer_remaining(self):
    """
    Getter method for forwarding_state_timer_remaining, mapped from YANG variable /mpls_state/ldp/forwarding_state_timer_remaining (uint32)

    YANG Description: forwarding_state_timer_remaining
    """
    return self.__forwarding_state_timer_remaining
      
  def _set_forwarding_state_timer_remaining(self, v, load=False):
    """
    Setter method for forwarding_state_timer_remaining, mapped from YANG variable /mpls_state/ldp/forwarding_state_timer_remaining (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_forwarding_state_timer_remaining is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_forwarding_state_timer_remaining() directly.

    YANG Description: forwarding_state_timer_remaining
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="forwarding-state-timer-remaining", rest_name="forwarding-state-timer-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """forwarding_state_timer_remaining must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="forwarding-state-timer-remaining", rest_name="forwarding-state-timer-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__forwarding_state_timer_remaining = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_forwarding_state_timer_remaining(self):
    self.__forwarding_state_timer_remaining = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="forwarding-state-timer-remaining", rest_name="forwarding-state-timer-remaining", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_lwd_delay(self):
    """
    Getter method for lwd_delay, mapped from YANG variable /mpls_state/ldp/lwd_delay (uint32)

    YANG Description: lwd_delay
    """
    return self.__lwd_delay
      
  def _set_lwd_delay(self, v, load=False):
    """
    Setter method for lwd_delay, mapped from YANG variable /mpls_state/ldp/lwd_delay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lwd_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lwd_delay() directly.

    YANG Description: lwd_delay
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lwd-delay", rest_name="lwd-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lwd_delay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lwd-delay", rest_name="lwd-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__lwd_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lwd_delay(self):
    self.__lwd_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lwd-delay", rest_name="lwd-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_lwd_default(self):
    """
    Getter method for lwd_default, mapped from YANG variable /mpls_state/ldp/lwd_default (boolean)

    YANG Description: lwd_default
    """
    return self.__lwd_default
      
  def _set_lwd_default(self, v, load=False):
    """
    Setter method for lwd_default, mapped from YANG variable /mpls_state/ldp/lwd_default (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lwd_default is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lwd_default() directly.

    YANG Description: lwd_default
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lwd-default", rest_name="lwd-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lwd_default must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lwd-default", rest_name="lwd-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__lwd_default = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lwd_default(self):
    self.__lwd_default = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lwd-default", rest_name="lwd-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)


  def _get_ldp_session_summary(self):
    """
    Getter method for ldp_session_summary, mapped from YANG variable /mpls_state/ldp/ldp_session_summary (container)
    """
    return self.__ldp_session_summary
      
  def _set_ldp_session_summary(self, v, load=False):
    """
    Setter method for ldp_session_summary, mapped from YANG variable /mpls_state/ldp/ldp_session_summary (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_session_summary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_session_summary() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ldp_session_summary.ldp_session_summary, is_container='container', presence=False, yang_name="ldp-session-summary", rest_name="ldp-session-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-session-summary', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_session_summary must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ldp_session_summary.ldp_session_summary, is_container='container', presence=False, yang_name="ldp-session-summary", rest_name="ldp-session-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-session-summary', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)""",
        })

    self.__ldp_session_summary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_session_summary(self):
    self.__ldp_session_summary = YANGDynClass(base=ldp_session_summary.ldp_session_summary, is_container='container', presence=False, yang_name="ldp-session-summary", rest_name="ldp-session-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-session-summary', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)


  def _get_tunnels(self):
    """
    Getter method for tunnels, mapped from YANG variable /mpls_state/ldp/tunnels (container)

    YANG Description: LDP Tunnels
    """
    return self.__tunnels
      
  def _set_tunnels(self, v, load=False):
    """
    Setter method for tunnels, mapped from YANG variable /mpls_state/ldp/tunnels (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnels() directly.

    YANG Description: LDP Tunnels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=tunnels.tunnels, is_container='container', presence=False, yang_name="tunnels", rest_name="tunnels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-tunnels', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnels must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tunnels.tunnels, is_container='container', presence=False, yang_name="tunnels", rest_name="tunnels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-tunnels', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)""",
        })

    self.__tunnels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnels(self):
    self.__tunnels = YANGDynClass(base=tunnels.tunnels, is_container='container', presence=False, yang_name="tunnels", rest_name="tunnels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-tunnels', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)


  def _get_statistics(self):
    """
    Getter method for statistics, mapped from YANG variable /mpls_state/ldp/statistics (container)

    YANG Description: Global LDP stats
    """
    return self.__statistics
      
  def _set_statistics(self, v, load=False):
    """
    Setter method for statistics, mapped from YANG variable /mpls_state/ldp/statistics (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistics() directly.

    YANG Description: Global LDP stats
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=statistics.statistics, is_container='container', presence=False, yang_name="statistics", rest_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-global-ldp-stats', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistics must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=statistics.statistics, is_container='container', presence=False, yang_name="statistics", rest_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-global-ldp-stats', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)""",
        })

    self.__statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistics(self):
    self.__statistics = YANGDynClass(base=statistics.statistics, is_container='container', presence=False, yang_name="statistics", rest_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-global-ldp-stats', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)


  def _get_ldp_fec_statistics(self):
    """
    Getter method for ldp_fec_statistics, mapped from YANG variable /mpls_state/ldp/ldp_fec_statistics (container)

    YANG Description: LDP FEC statistics
    """
    return self.__ldp_fec_statistics
      
  def _set_ldp_fec_statistics(self, v, load=False):
    """
    Setter method for ldp_fec_statistics, mapped from YANG variable /mpls_state/ldp/ldp_fec_statistics (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_fec_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_fec_statistics() directly.

    YANG Description: LDP FEC statistics
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ldp_fec_statistics.ldp_fec_statistics, is_container='container', presence=False, yang_name="ldp-fec-statistics", rest_name="ldp-fec-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_fec_statistics must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ldp_fec_statistics.ldp_fec_statistics, is_container='container', presence=False, yang_name="ldp-fec-statistics", rest_name="ldp-fec-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)""",
        })

    self.__ldp_fec_statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_fec_statistics(self):
    self.__ldp_fec_statistics = YANGDynClass(base=ldp_fec_statistics.ldp_fec_statistics, is_container='container', presence=False, yang_name="ldp-fec-statistics", rest_name="ldp-fec-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-statistics', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='container', is_config=False)


  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /mpls_state/ldp/interface (list)

    YANG Description:  LDP interface
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /mpls_state/ldp/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description:  LDP interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("interface_name",interface.interface, yang_name="interface", rest_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("interface_name",interface.interface, yang_name="interface", rest_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("interface_name",interface.interface, yang_name="interface", rest_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-interface', u'cli-suppress-show-path': None}}), is_container='list', yang_name="interface", rest_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-interface', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)


  def _get_ldp_database(self):
    """
    Getter method for ldp_database, mapped from YANG variable /mpls_state/ldp/ldp_database (list)

    YANG Description: LDP database operational Information
    """
    return self.__ldp_database
      
  def _set_ldp_database(self, v, load=False):
    """
    Setter method for ldp_database, mapped from YANG variable /mpls_state/ldp/ldp_database (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_database is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_database() directly.

    YANG Description: LDP database operational Information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peer_ip own_ip",ldp_database.ldp_database, yang_name="ldp-database", rest_name="ldp-database", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip own-ip', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-database', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-database", rest_name="ldp-database", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-database', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_database must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peer_ip own_ip",ldp_database.ldp_database, yang_name="ldp-database", rest_name="ldp-database", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip own-ip', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-database', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-database", rest_name="ldp-database", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-database', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__ldp_database = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_database(self):
    self.__ldp_database = YANGDynClass(base=YANGListType("peer_ip own_ip",ldp_database.ldp_database, yang_name="ldp-database", rest_name="ldp-database", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip own-ip', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-database', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-database", rest_name="ldp-database", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-database', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)


  def _get_targeted_peer(self):
    """
    Getter method for targeted_peer, mapped from YANG variable /mpls_state/ldp/targeted_peer (list)

    YANG Description:  LDP Targeted Peer
    """
    return self.__targeted_peer
      
  def _set_targeted_peer(self, v, load=False):
    """
    Setter method for targeted_peer, mapped from YANG variable /mpls_state/ldp/targeted_peer (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_targeted_peer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_targeted_peer() directly.

    YANG Description:  LDP Targeted Peer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("mpls_ldp_targeted_peer_id",targeted_peer.targeted_peer, yang_name="targeted-peer", rest_name="targeted-peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mpls-ldp-targeted-peer-id', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-targeted-peer', u'cli-suppress-show-path': None}}), is_container='list', yang_name="targeted-peer", rest_name="targeted-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-targeted-peer', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """targeted_peer must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("mpls_ldp_targeted_peer_id",targeted_peer.targeted_peer, yang_name="targeted-peer", rest_name="targeted-peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mpls-ldp-targeted-peer-id', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-targeted-peer', u'cli-suppress-show-path': None}}), is_container='list', yang_name="targeted-peer", rest_name="targeted-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-targeted-peer', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__targeted_peer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_targeted_peer(self):
    self.__targeted_peer = YANGDynClass(base=YANGListType("mpls_ldp_targeted_peer_id",targeted_peer.targeted_peer, yang_name="targeted-peer", rest_name="targeted-peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mpls-ldp-targeted-peer-id', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-targeted-peer', u'cli-suppress-show-path': None}}), is_container='list', yang_name="targeted-peer", rest_name="targeted-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-targeted-peer', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)


  def _get_path(self):
    """
    Getter method for path, mapped from YANG variable /mpls_state/ldp/path (list)

    YANG Description:  LDP Path information
    """
    return self.__path
      
  def _set_path(self, v, load=False):
    """
    Setter method for path, mapped from YANG variable /mpls_state/ldp/path (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path() directly.

    YANG Description:  LDP Path information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("path_key",path.path, yang_name="path", rest_name="path", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='path-key', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-path', u'cli-suppress-show-path': None}}), is_container='list', yang_name="path", rest_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-path', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("path_key",path.path, yang_name="path", rest_name="path", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='path-key', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-path', u'cli-suppress-show-path': None}}), is_container='list', yang_name="path", rest_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-path', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path(self):
    self.__path = YANGDynClass(base=YANGListType("path_key",path.path, yang_name="path", rest_name="path", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='path-key', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-path', u'cli-suppress-show-path': None}}), is_container='list', yang_name="path", rest_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-path', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)


  def _get_ldp_neighbors(self):
    """
    Getter method for ldp_neighbors, mapped from YANG variable /mpls_state/ldp/ldp_neighbors (list)

    YANG Description: LDP neighbor details
    """
    return self.__ldp_neighbors
      
  def _set_ldp_neighbors(self, v, load=False):
    """
    Setter method for ldp_neighbors, mapped from YANG variable /mpls_state/ldp/ldp_neighbors (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_neighbors() directly.

    YANG Description: LDP neighbor details
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("neighbor_ldpid labelspaceid",ldp_neighbors.ldp_neighbors, yang_name="ldp-neighbors", rest_name="ldp-neighbors", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbor-ldpid labelspaceid', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-neighbor', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-neighbors", rest_name="ldp-neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-neighbor', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_neighbors must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("neighbor_ldpid labelspaceid",ldp_neighbors.ldp_neighbors, yang_name="ldp-neighbors", rest_name="ldp-neighbors", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbor-ldpid labelspaceid', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-neighbor', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-neighbors", rest_name="ldp-neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-neighbor', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__ldp_neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_neighbors(self):
    self.__ldp_neighbors = YANGDynClass(base=YANGListType("neighbor_ldpid labelspaceid",ldp_neighbors.ldp_neighbors, yang_name="ldp-neighbors", rest_name="ldp-neighbors", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbor-ldpid labelspaceid', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-neighbor', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-neighbors", rest_name="ldp-neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-neighbor', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)


  def _get_ldp_session(self):
    """
    Getter method for ldp_session, mapped from YANG variable /mpls_state/ldp/ldp_session (list)
    """
    return self.__ldp_session
      
  def _set_ldp_session(self, v, load=False):
    """
    Setter method for ldp_session, mapped from YANG variable /mpls_state/ldp/ldp_session (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_session is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_session() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peer_ldp_id peer_label_space_id",ldp_session.ldp_session, yang_name="ldp-session", rest_name="ldp-session", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ldp-id peer-label-space-id', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-session', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-session", rest_name="ldp-session", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-session', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_session must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peer_ldp_id peer_label_space_id",ldp_session.ldp_session, yang_name="ldp-session", rest_name="ldp-session", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ldp-id peer-label-space-id', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-session', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-session", rest_name="ldp-session", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-session', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__ldp_session = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_session(self):
    self.__ldp_session = YANGDynClass(base=YANGListType("peer_ldp_id peer_label_space_id",ldp_session.ldp_session, yang_name="ldp-session", rest_name="ldp-session", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ldp-id peer-label-space-id', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-session', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-session", rest_name="ldp-session", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-session', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)


  def _get_ldp_fec_prefix(self):
    """
    Getter method for ldp_fec_prefix, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix (list)

    YANG Description: LDP Prefix FEC information
    """
    return self.__ldp_fec_prefix
      
  def _set_ldp_fec_prefix(self, v, load=False):
    """
    Setter method for ldp_fec_prefix, mapped from YANG variable /mpls_state/ldp/ldp_fec_prefix (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_fec_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_fec_prefix() directly.

    YANG Description: LDP Prefix FEC information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("destination",ldp_fec_prefix.ldp_fec_prefix, yang_name="ldp-fec-prefix", rest_name="ldp-fec-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-fec-prefix", rest_name="ldp-fec-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_fec_prefix must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("destination",ldp_fec_prefix.ldp_fec_prefix, yang_name="ldp-fec-prefix", rest_name="ldp-fec-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-fec-prefix", rest_name="ldp-fec-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__ldp_fec_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_fec_prefix(self):
    self.__ldp_fec_prefix = YANGDynClass(base=YANGListType("destination",ldp_fec_prefix.ldp_fec_prefix, yang_name="ldp-fec-prefix", rest_name="ldp-fec-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-fec-prefix", rest_name="ldp-fec-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-prefix', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)


  def _get_ldp_fec_vc(self):
    """
    Getter method for ldp_fec_vc, mapped from YANG variable /mpls_state/ldp/ldp_fec_vc (list)

    YANG Description: LDP VC FEC information
    """
    return self.__ldp_fec_vc
      
  def _set_ldp_fec_vc(self, v, load=False):
    """
    Setter method for ldp_fec_vc, mapped from YANG variable /mpls_state/ldp/ldp_fec_vc (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_fec_vc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_fec_vc() directly.

    YANG Description: LDP VC FEC information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vc_id",ldp_fec_vc.ldp_fec_vc, yang_name="ldp-fec-vc", rest_name="ldp-fec-vc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vc-id', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-vc', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-fec-vc", rest_name="ldp-fec-vc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-vc', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_fec_vc must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vc_id",ldp_fec_vc.ldp_fec_vc, yang_name="ldp-fec-vc", rest_name="ldp-fec-vc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vc-id', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-vc', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-fec-vc", rest_name="ldp-fec-vc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-vc', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)""",
        })

    self.__ldp_fec_vc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_fec_vc(self):
    self.__ldp_fec_vc = YANGDynClass(base=YANGListType("vc_id",ldp_fec_vc.ldp_fec_vc, yang_name="ldp-fec-vc", rest_name="ldp-fec-vc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vc-id', extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-vc', u'cli-suppress-show-path': None}}), is_container='list', yang_name="ldp-fec-vc", rest_name="ldp-fec-vc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'mpls-ldp-fec-vc', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='list', is_config=False)

  ldp_initialized = __builtin__.property(_get_ldp_initialized)
  lsr_id = __builtin__.property(_get_lsr_id)
  lsr_id_configured = __builtin__.property(_get_lsr_id_configured)
  loopback = __builtin__.property(_get_loopback)
  hello_interval_link = __builtin__.property(_get_hello_interval_link)
  hello_interval_target = __builtin__.property(_get_hello_interval_target)
  hold_time_sent_link = __builtin__.property(_get_hold_time_sent_link)
  hold_time_sent_target = __builtin__.property(_get_hold_time_sent_target)
  ka_interval = __builtin__.property(_get_ka_interval)
  ka_multiple = __builtin__.property(_get_ka_multiple)
  ka_timeout = __builtin__.property(_get_ka_timeout)
  ka_timeout_default = __builtin__.property(_get_ka_timeout_default)
  load_sharing = __builtin__.property(_get_load_sharing)
  advertise_fecs_for_prefix_list = __builtin__.property(_get_advertise_fecs_for_prefix_list)
  advertise_fecs_for_prefix_list_exists = __builtin__.property(_get_advertise_fecs_for_prefix_list_exists)
  inbound_fecs_filtering_prefix_list = __builtin__.property(_get_inbound_fecs_filtering_prefix_list)
  inbound_fecs_filtering_prefix_list_exists = __builtin__.property(_get_inbound_fecs_filtering_prefix_list_exists)
  outbound_fecs_filtering_prefix_list = __builtin__.property(_get_outbound_fecs_filtering_prefix_list)
  outbound_fecs_filtering_prefix_list_exists = __builtin__.property(_get_outbound_fecs_filtering_prefix_list_exists)
  tunnel_metric = __builtin__.property(_get_tunnel_metric)
  fec_128_used_for_auto_disc_current = __builtin__.property(_get_fec_128_used_for_auto_disc_current)
  fec_128_used_for_auto_disc_configured = __builtin__.property(_get_fec_128_used_for_auto_disc_configured)
  end_of_lib = __builtin__.property(_get_end_of_lib)
  eol_notification_time = __builtin__.property(_get_eol_notification_time)
  tx_silence_time = __builtin__.property(_get_tx_silence_time)
  rx_silence_time = __builtin__.property(_get_rx_silence_time)
  gr_enable = __builtin__.property(_get_gr_enable)
  gr_helper = __builtin__.property(_get_gr_helper)
  gr_reconnect_time = __builtin__.property(_get_gr_reconnect_time)
  gr_max_peer_reconnect_time = __builtin__.property(_get_gr_max_peer_reconnect_time)
  gr_recovery_time = __builtin__.property(_get_gr_recovery_time)
  gr_max_peer_recovery_time = __builtin__.property(_get_gr_max_peer_recovery_time)
  forwarding_state_timer_running = __builtin__.property(_get_forwarding_state_timer_running)
  forwarding_state_timer_remaining = __builtin__.property(_get_forwarding_state_timer_remaining)
  lwd_delay = __builtin__.property(_get_lwd_delay)
  lwd_default = __builtin__.property(_get_lwd_default)
  ldp_session_summary = __builtin__.property(_get_ldp_session_summary)
  tunnels = __builtin__.property(_get_tunnels)
  statistics = __builtin__.property(_get_statistics)
  ldp_fec_statistics = __builtin__.property(_get_ldp_fec_statistics)
  interface = __builtin__.property(_get_interface)
  ldp_database = __builtin__.property(_get_ldp_database)
  targeted_peer = __builtin__.property(_get_targeted_peer)
  path = __builtin__.property(_get_path)
  ldp_neighbors = __builtin__.property(_get_ldp_neighbors)
  ldp_session = __builtin__.property(_get_ldp_session)
  ldp_fec_prefix = __builtin__.property(_get_ldp_fec_prefix)
  ldp_fec_vc = __builtin__.property(_get_ldp_fec_vc)


  _pyangbind_elements = {'ldp_initialized': ldp_initialized, 'lsr_id': lsr_id, 'lsr_id_configured': lsr_id_configured, 'loopback': loopback, 'hello_interval_link': hello_interval_link, 'hello_interval_target': hello_interval_target, 'hold_time_sent_link': hold_time_sent_link, 'hold_time_sent_target': hold_time_sent_target, 'ka_interval': ka_interval, 'ka_multiple': ka_multiple, 'ka_timeout': ka_timeout, 'ka_timeout_default': ka_timeout_default, 'load_sharing': load_sharing, 'advertise_fecs_for_prefix_list': advertise_fecs_for_prefix_list, 'advertise_fecs_for_prefix_list_exists': advertise_fecs_for_prefix_list_exists, 'inbound_fecs_filtering_prefix_list': inbound_fecs_filtering_prefix_list, 'inbound_fecs_filtering_prefix_list_exists': inbound_fecs_filtering_prefix_list_exists, 'outbound_fecs_filtering_prefix_list': outbound_fecs_filtering_prefix_list, 'outbound_fecs_filtering_prefix_list_exists': outbound_fecs_filtering_prefix_list_exists, 'tunnel_metric': tunnel_metric, 'fec_128_used_for_auto_disc_current': fec_128_used_for_auto_disc_current, 'fec_128_used_for_auto_disc_configured': fec_128_used_for_auto_disc_configured, 'end_of_lib': end_of_lib, 'eol_notification_time': eol_notification_time, 'tx_silence_time': tx_silence_time, 'rx_silence_time': rx_silence_time, 'gr_enable': gr_enable, 'gr_helper': gr_helper, 'gr_reconnect_time': gr_reconnect_time, 'gr_max_peer_reconnect_time': gr_max_peer_reconnect_time, 'gr_recovery_time': gr_recovery_time, 'gr_max_peer_recovery_time': gr_max_peer_recovery_time, 'forwarding_state_timer_running': forwarding_state_timer_running, 'forwarding_state_timer_remaining': forwarding_state_timer_remaining, 'lwd_delay': lwd_delay, 'lwd_default': lwd_default, 'ldp_session_summary': ldp_session_summary, 'tunnels': tunnels, 'statistics': statistics, 'ldp_fec_statistics': ldp_fec_statistics, 'interface': interface, 'ldp_database': ldp_database, 'targeted_peer': targeted_peer, 'path': path, 'ldp_neighbors': ldp_neighbors, 'ldp_session': ldp_session, 'ldp_fec_prefix': ldp_fec_prefix, 'ldp_fec_vc': ldp_fec_vc, }


