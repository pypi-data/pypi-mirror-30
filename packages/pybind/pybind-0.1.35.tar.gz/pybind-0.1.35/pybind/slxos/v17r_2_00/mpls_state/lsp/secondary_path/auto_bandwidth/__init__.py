
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class auto_bandwidth(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls-operational - based on the path /mpls-state/lsp/secondary-path/auto-bandwidth. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__config_template','__adjustment_interval','__adjustment_threshold','__maximum_bandwidth','__minimum_bandwidth','__overflow_limit','__underflow_limit','__mode','__sample_recording',)

  _yang_name = 'auto-bandwidth'
  _rest_name = 'auto-bandwidth'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__adjustment_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-threshold", rest_name="adjustment-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__overflow_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="overflow-limit", rest_name="overflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__maximum_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-bandwidth", rest_name="maximum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__minimum_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minimum-bandwidth", rest_name="minimum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__adjustment_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-interval", rest_name="adjustment-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'monitor-and-signal': {'value': 0}, u'monitor-only': {'value': 1}},), is_leaf=True, yang_name="mode", rest_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='autobw-mode', is_config=False)
    self.__sample_recording = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sample-recording", rest_name="sample-recording", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    self.__underflow_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="underflow-limit", rest_name="underflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    self.__config_template = YANGDynClass(base=unicode, is_leaf=True, yang_name="config-template", rest_name="config-template", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'mpls-state', u'lsp', u'secondary-path', u'auto-bandwidth']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'mpls-state', u'lsp', u'secondary-path', u'auto-bandwidth']

  def _get_config_template(self):
    """
    Getter method for config_template, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/config_template (string)

    YANG Description: Template used for Auto Bandwidth parameters
    """
    return self.__config_template
      
  def _set_config_template(self, v, load=False):
    """
    Setter method for config_template, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/config_template (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_template is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_template() directly.

    YANG Description: Template used for Auto Bandwidth parameters
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="config-template", rest_name="config-template", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_template must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="config-template", rest_name="config-template", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)""",
        })

    self.__config_template = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_template(self):
    self.__config_template = YANGDynClass(base=unicode, is_leaf=True, yang_name="config-template", rest_name="config-template", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='string', is_config=False)


  def _get_adjustment_interval(self):
    """
    Getter method for adjustment_interval, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/adjustment_interval (uint32)

    YANG Description: Periodic Interval at which adjustment is done 
    """
    return self.__adjustment_interval
      
  def _set_adjustment_interval(self, v, load=False):
    """
    Setter method for adjustment_interval, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/adjustment_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjustment_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjustment_interval() directly.

    YANG Description: Periodic Interval at which adjustment is done 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-interval", rest_name="adjustment-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjustment_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-interval", rest_name="adjustment-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__adjustment_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjustment_interval(self):
    self.__adjustment_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-interval", rest_name="adjustment-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_adjustment_threshold(self):
    """
    Getter method for adjustment_threshold, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/adjustment_threshold (uint32)

    YANG Description: mpls_adjustmentThreshold
    """
    return self.__adjustment_threshold
      
  def _set_adjustment_threshold(self, v, load=False):
    """
    Setter method for adjustment_threshold, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/adjustment_threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjustment_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjustment_threshold() directly.

    YANG Description: mpls_adjustmentThreshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-threshold", rest_name="adjustment-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjustment_threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-threshold", rest_name="adjustment-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__adjustment_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjustment_threshold(self):
    self.__adjustment_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adjustment-threshold", rest_name="adjustment-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_maximum_bandwidth(self):
    """
    Getter method for maximum_bandwidth, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/maximum_bandwidth (uint32)

    YANG Description: Maximum bandwidth value
    """
    return self.__maximum_bandwidth
      
  def _set_maximum_bandwidth(self, v, load=False):
    """
    Setter method for maximum_bandwidth, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/maximum_bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_bandwidth() directly.

    YANG Description: Maximum bandwidth value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-bandwidth", rest_name="maximum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-bandwidth", rest_name="maximum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__maximum_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_bandwidth(self):
    self.__maximum_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-bandwidth", rest_name="maximum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_minimum_bandwidth(self):
    """
    Getter method for minimum_bandwidth, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/minimum_bandwidth (uint32)

    YANG Description: Minimum bandiwdth value
    """
    return self.__minimum_bandwidth
      
  def _set_minimum_bandwidth(self, v, load=False):
    """
    Setter method for minimum_bandwidth, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/minimum_bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minimum_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minimum_bandwidth() directly.

    YANG Description: Minimum bandiwdth value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minimum-bandwidth", rest_name="minimum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minimum_bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minimum-bandwidth", rest_name="minimum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__minimum_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minimum_bandwidth(self):
    self.__minimum_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minimum-bandwidth", rest_name="minimum-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_overflow_limit(self):
    """
    Getter method for overflow_limit, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/overflow_limit (uint32)

    YANG Description: Minimum number of overflow to trigger adjustment
    """
    return self.__overflow_limit
      
  def _set_overflow_limit(self, v, load=False):
    """
    Setter method for overflow_limit, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/overflow_limit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overflow_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overflow_limit() directly.

    YANG Description: Minimum number of overflow to trigger adjustment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="overflow-limit", rest_name="overflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overflow_limit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="overflow-limit", rest_name="overflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__overflow_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overflow_limit(self):
    self.__overflow_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="overflow-limit", rest_name="overflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_underflow_limit(self):
    """
    Getter method for underflow_limit, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/underflow_limit (uint32)

    YANG Description: Minimum number of underflow to trigger adjustment
    """
    return self.__underflow_limit
      
  def _set_underflow_limit(self, v, load=False):
    """
    Setter method for underflow_limit, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/underflow_limit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_underflow_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_underflow_limit() directly.

    YANG Description: Minimum number of underflow to trigger adjustment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="underflow-limit", rest_name="underflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """underflow_limit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="underflow-limit", rest_name="underflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)""",
        })

    self.__underflow_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_underflow_limit(self):
    self.__underflow_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="underflow-limit", rest_name="underflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='uint32', is_config=False)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/mode (autobw-mode)

    YANG Description: Monitor only or Monitor and Signal
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/mode (autobw-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: Monitor only or Monitor and Signal
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'monitor-and-signal': {'value': 0}, u'monitor-only': {'value': 1}},), is_leaf=True, yang_name="mode", rest_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='autobw-mode', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with autobw-mode""",
          'defined-type': "brocade-mpls-operational:autobw-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'monitor-and-signal': {'value': 0}, u'monitor-only': {'value': 1}},), is_leaf=True, yang_name="mode", rest_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='autobw-mode', is_config=False)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'monitor-and-signal': {'value': 0}, u'monitor-only': {'value': 1}},), is_leaf=True, yang_name="mode", rest_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='autobw-mode', is_config=False)


  def _get_sample_recording(self):
    """
    Getter method for sample_recording, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/sample_recording (boolean)

    YANG Description: Enable logging history of rate samples
    """
    return self.__sample_recording
      
  def _set_sample_recording(self, v, load=False):
    """
    Setter method for sample_recording, mapped from YANG variable /mpls_state/lsp/secondary_path/auto_bandwidth/sample_recording (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sample_recording is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sample_recording() directly.

    YANG Description: Enable logging history of rate samples
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="sample-recording", rest_name="sample-recording", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sample_recording must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sample-recording", rest_name="sample-recording", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)""",
        })

    self.__sample_recording = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sample_recording(self):
    self.__sample_recording = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sample-recording", rest_name="sample-recording", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-mpls-operational', defining_module='brocade-mpls-operational', yang_type='boolean', is_config=False)

  config_template = __builtin__.property(_get_config_template)
  adjustment_interval = __builtin__.property(_get_adjustment_interval)
  adjustment_threshold = __builtin__.property(_get_adjustment_threshold)
  maximum_bandwidth = __builtin__.property(_get_maximum_bandwidth)
  minimum_bandwidth = __builtin__.property(_get_minimum_bandwidth)
  overflow_limit = __builtin__.property(_get_overflow_limit)
  underflow_limit = __builtin__.property(_get_underflow_limit)
  mode = __builtin__.property(_get_mode)
  sample_recording = __builtin__.property(_get_sample_recording)


  _pyangbind_elements = {'config_template': config_template, 'adjustment_interval': adjustment_interval, 'adjustment_threshold': adjustment_threshold, 'maximum_bandwidth': maximum_bandwidth, 'minimum_bandwidth': minimum_bandwidth, 'overflow_limit': overflow_limit, 'underflow_limit': underflow_limit, 'mode': mode, 'sample_recording': sample_recording, }


