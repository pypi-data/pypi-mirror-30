
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class mpls_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls - based on the path /brocade_mpls_rpc/show-mpls-policy/output/mpls-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__policy_cspf_interface_constraint','__policy_cspf_group_computation_mode','__policy_use_bypass_metric','__policy_use_bypass_liberal','__policy_implicite_commit','__policy_label_propagate_ttl','__policy_vrf_propagate_ttl','__policy_propagate_ttl','__policy_rtm_route_filter_enabled','__policy_rtm_route_filter_all_ibgp_enabled','__policy_load_interval','__policy_ingress_tnnl_accounting','__policy_te_policy_ospf','__policy_te_policy_isis','__policy_ospf_area_defined','__policy_ospf_area','__policy_handle_ospf_nbr_dn','__policy_handle_isis_nbr_dn','__policy_lsp_fast_retry_on','__policy_max_lsp_retries','__policy_lsp_retry_interval','__policy_frr_bkup_retry_interval','__policy_auto_bw_enabled','__policy_auto_bw_sample_interval','__policy_soft_preempt_cleanup_timer','__policy_rsvp_periodic_flooding_timer',)

  _yang_name = 'mpls-policy'
  _rest_name = 'mpls-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__policy_lsp_fast_retry_on = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-lsp-fast-retry-on", rest_name="policy-lsp-fast-retry-on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_te_policy_ospf = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-te-policy-ospf", rest_name="policy-te-policy-ospf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_implicite_commit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-implicite-commit", rest_name="policy-implicite-commit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__policy_label_propagate_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-label-propagate-ttl", rest_name="policy-label-propagate-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_rtm_route_filter_all_ibgp_enabled = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-rtm-route-filter-all-ibgp-enabled", rest_name="policy-rtm-route-filter-all-ibgp-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_frr_bkup_retry_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-frr-bkup-retry-interval", rest_name="policy-frr-bkup-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__policy_propagate_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-propagate-ttl", rest_name="policy-propagate-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_use_bypass_metric = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-use-bypass-metric", rest_name="policy-use-bypass-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_cspf_interface_constraint = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-cspf-interface-constraint", rest_name="policy-cspf-interface-constraint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_max_lsp_retries = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-max-lsp-retries", rest_name="policy-max-lsp-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)
    self.__policy_lsp_retry_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-lsp-retry-interval", rest_name="policy-lsp-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)
    self.__policy_cspf_group_computation_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-cspf-group-computation-mode", rest_name="policy-cspf-group-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_vrf_propagate_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-vrf-propagate-ttl", rest_name="policy-vrf-propagate-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_load_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-load-interval", rest_name="policy-load-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)
    self.__policy_te_policy_isis = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-te-policy-isis", rest_name="policy-te-policy-isis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_ospf_area = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-ospf-area", rest_name="policy-ospf-area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__policy_ingress_tnnl_accounting = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-ingress-tnnl-accounting", rest_name="policy-ingress-tnnl-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_auto_bw_enabled = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-auto-bw-enabled", rest_name="policy-auto-bw-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_rsvp_periodic_flooding_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-rsvp-periodic-flooding-timer", rest_name="policy-rsvp-periodic-flooding-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)
    self.__policy_auto_bw_sample_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-auto-bw-sample-interval", rest_name="policy-auto-bw-sample-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__policy_use_bypass_liberal = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-use-bypass-liberal", rest_name="policy-use-bypass-liberal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_handle_isis_nbr_dn = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-handle-isis-nbr-dn", rest_name="policy-handle-isis-nbr-dn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_handle_ospf_nbr_dn = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-handle-ospf-nbr-dn", rest_name="policy-handle-ospf-nbr-dn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_ospf_area_defined = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-ospf-area-defined", rest_name="policy-ospf-area-defined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_rtm_route_filter_enabled = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-rtm-route-filter-enabled", rest_name="policy-rtm-route-filter-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__policy_soft_preempt_cleanup_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-soft-preempt-cleanup-timer", rest_name="policy-soft-preempt-cleanup-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'brocade_mpls_rpc', u'show-mpls-policy', u'output', u'mpls-policy']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'show-mpls-policy', u'output', u'mpls-policy']

  def _get_policy_cspf_interface_constraint(self):
    """
    Getter method for policy_cspf_interface_constraint, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_cspf_interface_constraint (uint8)

    YANG Description: CSPF Interface constraint
    """
    return self.__policy_cspf_interface_constraint
      
  def _set_policy_cspf_interface_constraint(self, v, load=False):
    """
    Setter method for policy_cspf_interface_constraint, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_cspf_interface_constraint (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_cspf_interface_constraint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_cspf_interface_constraint() directly.

    YANG Description: CSPF Interface constraint
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-cspf-interface-constraint", rest_name="policy-cspf-interface-constraint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_cspf_interface_constraint must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-cspf-interface-constraint", rest_name="policy-cspf-interface-constraint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_cspf_interface_constraint = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_cspf_interface_constraint(self):
    self.__policy_cspf_interface_constraint = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-cspf-interface-constraint", rest_name="policy-cspf-interface-constraint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_cspf_group_computation_mode(self):
    """
    Getter method for policy_cspf_group_computation_mode, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_cspf_group_computation_mode (uint8)

    YANG Description: CSPF group computation mpde
    """
    return self.__policy_cspf_group_computation_mode
      
  def _set_policy_cspf_group_computation_mode(self, v, load=False):
    """
    Setter method for policy_cspf_group_computation_mode, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_cspf_group_computation_mode (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_cspf_group_computation_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_cspf_group_computation_mode() directly.

    YANG Description: CSPF group computation mpde
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-cspf-group-computation-mode", rest_name="policy-cspf-group-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_cspf_group_computation_mode must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-cspf-group-computation-mode", rest_name="policy-cspf-group-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_cspf_group_computation_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_cspf_group_computation_mode(self):
    self.__policy_cspf_group_computation_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-cspf-group-computation-mode", rest_name="policy-cspf-group-computation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_use_bypass_metric(self):
    """
    Getter method for policy_use_bypass_metric, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_use_bypass_metric (uint8)

    YANG Description: CSPF computation-mode use bypass metric
    """
    return self.__policy_use_bypass_metric
      
  def _set_policy_use_bypass_metric(self, v, load=False):
    """
    Setter method for policy_use_bypass_metric, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_use_bypass_metric (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_use_bypass_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_use_bypass_metric() directly.

    YANG Description: CSPF computation-mode use bypass metric
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-use-bypass-metric", rest_name="policy-use-bypass-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_use_bypass_metric must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-use-bypass-metric", rest_name="policy-use-bypass-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_use_bypass_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_use_bypass_metric(self):
    self.__policy_use_bypass_metric = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-use-bypass-metric", rest_name="policy-use-bypass-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_use_bypass_liberal(self):
    """
    Getter method for policy_use_bypass_liberal, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_use_bypass_liberal (uint8)

    YANG Description: CSPF computation-mode use bypass liberal
    """
    return self.__policy_use_bypass_liberal
      
  def _set_policy_use_bypass_liberal(self, v, load=False):
    """
    Setter method for policy_use_bypass_liberal, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_use_bypass_liberal (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_use_bypass_liberal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_use_bypass_liberal() directly.

    YANG Description: CSPF computation-mode use bypass liberal
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-use-bypass-liberal", rest_name="policy-use-bypass-liberal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_use_bypass_liberal must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-use-bypass-liberal", rest_name="policy-use-bypass-liberal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_use_bypass_liberal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_use_bypass_liberal(self):
    self.__policy_use_bypass_liberal = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-use-bypass-liberal", rest_name="policy-use-bypass-liberal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_implicite_commit(self):
    """
    Getter method for policy_implicite_commit, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_implicite_commit (uint32)

    YANG Description: MPLS implicite commit flags
    """
    return self.__policy_implicite_commit
      
  def _set_policy_implicite_commit(self, v, load=False):
    """
    Setter method for policy_implicite_commit, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_implicite_commit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_implicite_commit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_implicite_commit() directly.

    YANG Description: MPLS implicite commit flags
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-implicite-commit", rest_name="policy-implicite-commit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_implicite_commit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-implicite-commit", rest_name="policy-implicite-commit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__policy_implicite_commit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_implicite_commit(self):
    self.__policy_implicite_commit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-implicite-commit", rest_name="policy-implicite-commit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_policy_label_propagate_ttl(self):
    """
    Getter method for policy_label_propagate_ttl, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_label_propagate_ttl (uint8)

    YANG Description: TTL propagation for MPLS label
    """
    return self.__policy_label_propagate_ttl
      
  def _set_policy_label_propagate_ttl(self, v, load=False):
    """
    Setter method for policy_label_propagate_ttl, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_label_propagate_ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_label_propagate_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_label_propagate_ttl() directly.

    YANG Description: TTL propagation for MPLS label
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-label-propagate-ttl", rest_name="policy-label-propagate-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_label_propagate_ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-label-propagate-ttl", rest_name="policy-label-propagate-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_label_propagate_ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_label_propagate_ttl(self):
    self.__policy_label_propagate_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-label-propagate-ttl", rest_name="policy-label-propagate-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_vrf_propagate_ttl(self):
    """
    Getter method for policy_vrf_propagate_ttl, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_vrf_propagate_ttl (uint8)

    YANG Description: TTL propagation for MPLS label for IPVPN
    """
    return self.__policy_vrf_propagate_ttl
      
  def _set_policy_vrf_propagate_ttl(self, v, load=False):
    """
    Setter method for policy_vrf_propagate_ttl, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_vrf_propagate_ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_vrf_propagate_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_vrf_propagate_ttl() directly.

    YANG Description: TTL propagation for MPLS label for IPVPN
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-vrf-propagate-ttl", rest_name="policy-vrf-propagate-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_vrf_propagate_ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-vrf-propagate-ttl", rest_name="policy-vrf-propagate-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_vrf_propagate_ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_vrf_propagate_ttl(self):
    self.__policy_vrf_propagate_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-vrf-propagate-ttl", rest_name="policy-vrf-propagate-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_propagate_ttl(self):
    """
    Getter method for policy_propagate_ttl, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_propagate_ttl (uint8)

    YANG Description: TTL propagation for IPoMPLS
    """
    return self.__policy_propagate_ttl
      
  def _set_policy_propagate_ttl(self, v, load=False):
    """
    Setter method for policy_propagate_ttl, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_propagate_ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_propagate_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_propagate_ttl() directly.

    YANG Description: TTL propagation for IPoMPLS
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-propagate-ttl", rest_name="policy-propagate-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_propagate_ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-propagate-ttl", rest_name="policy-propagate-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_propagate_ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_propagate_ttl(self):
    self.__policy_propagate_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-propagate-ttl", rest_name="policy-propagate-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_rtm_route_filter_enabled(self):
    """
    Getter method for policy_rtm_route_filter_enabled, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_rtm_route_filter_enabled (uint8)

    YANG Description: Inter-AS route filtering
    """
    return self.__policy_rtm_route_filter_enabled
      
  def _set_policy_rtm_route_filter_enabled(self, v, load=False):
    """
    Setter method for policy_rtm_route_filter_enabled, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_rtm_route_filter_enabled (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_rtm_route_filter_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_rtm_route_filter_enabled() directly.

    YANG Description: Inter-AS route filtering
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-rtm-route-filter-enabled", rest_name="policy-rtm-route-filter-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_rtm_route_filter_enabled must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-rtm-route-filter-enabled", rest_name="policy-rtm-route-filter-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_rtm_route_filter_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_rtm_route_filter_enabled(self):
    self.__policy_rtm_route_filter_enabled = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-rtm-route-filter-enabled", rest_name="policy-rtm-route-filter-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_rtm_route_filter_all_ibgp_enabled(self):
    """
    Getter method for policy_rtm_route_filter_all_ibgp_enabled, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_rtm_route_filter_all_ibgp_enabled (uint8)

    YANG Description: Intra-AS iBGP route filtering
    """
    return self.__policy_rtm_route_filter_all_ibgp_enabled
      
  def _set_policy_rtm_route_filter_all_ibgp_enabled(self, v, load=False):
    """
    Setter method for policy_rtm_route_filter_all_ibgp_enabled, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_rtm_route_filter_all_ibgp_enabled (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_rtm_route_filter_all_ibgp_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_rtm_route_filter_all_ibgp_enabled() directly.

    YANG Description: Intra-AS iBGP route filtering
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-rtm-route-filter-all-ibgp-enabled", rest_name="policy-rtm-route-filter-all-ibgp-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_rtm_route_filter_all_ibgp_enabled must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-rtm-route-filter-all-ibgp-enabled", rest_name="policy-rtm-route-filter-all-ibgp-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_rtm_route_filter_all_ibgp_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_rtm_route_filter_all_ibgp_enabled(self):
    self.__policy_rtm_route_filter_all_ibgp_enabled = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-rtm-route-filter-all-ibgp-enabled", rest_name="policy-rtm-route-filter-all-ibgp-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_load_interval(self):
    """
    Getter method for policy_load_interval, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_load_interval (uint16)

    YANG Description:  Polling interval for MPLS LSP traffic statistics in seconds
    """
    return self.__policy_load_interval
      
  def _set_policy_load_interval(self, v, load=False):
    """
    Setter method for policy_load_interval, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_load_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_load_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_load_interval() directly.

    YANG Description:  Polling interval for MPLS LSP traffic statistics in seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-load-interval", rest_name="policy-load-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_load_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-load-interval", rest_name="policy-load-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)""",
        })

    self.__policy_load_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_load_interval(self):
    self.__policy_load_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-load-interval", rest_name="policy-load-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)


  def _get_policy_ingress_tnnl_accounting(self):
    """
    Getter method for policy_ingress_tnnl_accounting, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_ingress_tnnl_accounting (uint8)

    YANG Description: Ingress tunnel accounting
    """
    return self.__policy_ingress_tnnl_accounting
      
  def _set_policy_ingress_tnnl_accounting(self, v, load=False):
    """
    Setter method for policy_ingress_tnnl_accounting, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_ingress_tnnl_accounting (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_ingress_tnnl_accounting is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_ingress_tnnl_accounting() directly.

    YANG Description: Ingress tunnel accounting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-ingress-tnnl-accounting", rest_name="policy-ingress-tnnl-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_ingress_tnnl_accounting must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-ingress-tnnl-accounting", rest_name="policy-ingress-tnnl-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_ingress_tnnl_accounting = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_ingress_tnnl_accounting(self):
    self.__policy_ingress_tnnl_accounting = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-ingress-tnnl-accounting", rest_name="policy-ingress-tnnl-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_te_policy_ospf(self):
    """
    Getter method for policy_te_policy_ospf, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_te_policy_ospf (uint8)

    YANG Description: MPLS TE is OSPF
    """
    return self.__policy_te_policy_ospf
      
  def _set_policy_te_policy_ospf(self, v, load=False):
    """
    Setter method for policy_te_policy_ospf, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_te_policy_ospf (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_te_policy_ospf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_te_policy_ospf() directly.

    YANG Description: MPLS TE is OSPF
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-te-policy-ospf", rest_name="policy-te-policy-ospf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_te_policy_ospf must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-te-policy-ospf", rest_name="policy-te-policy-ospf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_te_policy_ospf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_te_policy_ospf(self):
    self.__policy_te_policy_ospf = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-te-policy-ospf", rest_name="policy-te-policy-ospf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_te_policy_isis(self):
    """
    Getter method for policy_te_policy_isis, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_te_policy_isis (uint8)

    YANG Description: MPLS TE 's level
    """
    return self.__policy_te_policy_isis
      
  def _set_policy_te_policy_isis(self, v, load=False):
    """
    Setter method for policy_te_policy_isis, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_te_policy_isis (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_te_policy_isis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_te_policy_isis() directly.

    YANG Description: MPLS TE 's level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-te-policy-isis", rest_name="policy-te-policy-isis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_te_policy_isis must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-te-policy-isis", rest_name="policy-te-policy-isis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_te_policy_isis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_te_policy_isis(self):
    self.__policy_te_policy_isis = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-te-policy-isis", rest_name="policy-te-policy-isis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_ospf_area_defined(self):
    """
    Getter method for policy_ospf_area_defined, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_ospf_area_defined (uint8)

    YANG Description: MPLS TE ospf area defined
    """
    return self.__policy_ospf_area_defined
      
  def _set_policy_ospf_area_defined(self, v, load=False):
    """
    Setter method for policy_ospf_area_defined, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_ospf_area_defined (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_ospf_area_defined is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_ospf_area_defined() directly.

    YANG Description: MPLS TE ospf area defined
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-ospf-area-defined", rest_name="policy-ospf-area-defined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_ospf_area_defined must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-ospf-area-defined", rest_name="policy-ospf-area-defined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_ospf_area_defined = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_ospf_area_defined(self):
    self.__policy_ospf_area_defined = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-ospf-area-defined", rest_name="policy-ospf-area-defined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_ospf_area(self):
    """
    Getter method for policy_ospf_area, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_ospf_area (uint32)

    YANG Description: MPLS TE ospf area
    """
    return self.__policy_ospf_area
      
  def _set_policy_ospf_area(self, v, load=False):
    """
    Setter method for policy_ospf_area, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_ospf_area (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_ospf_area is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_ospf_area() directly.

    YANG Description: MPLS TE ospf area
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-ospf-area", rest_name="policy-ospf-area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_ospf_area must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-ospf-area", rest_name="policy-ospf-area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__policy_ospf_area = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_ospf_area(self):
    self.__policy_ospf_area = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-ospf-area", rest_name="policy-ospf-area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_policy_handle_ospf_nbr_dn(self):
    """
    Getter method for policy_handle_ospf_nbr_dn, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_handle_ospf_nbr_dn (uint8)

    YANG Description: Handle IGP OSPF neighbor down event
    """
    return self.__policy_handle_ospf_nbr_dn
      
  def _set_policy_handle_ospf_nbr_dn(self, v, load=False):
    """
    Setter method for policy_handle_ospf_nbr_dn, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_handle_ospf_nbr_dn (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_handle_ospf_nbr_dn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_handle_ospf_nbr_dn() directly.

    YANG Description: Handle IGP OSPF neighbor down event
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-handle-ospf-nbr-dn", rest_name="policy-handle-ospf-nbr-dn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_handle_ospf_nbr_dn must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-handle-ospf-nbr-dn", rest_name="policy-handle-ospf-nbr-dn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_handle_ospf_nbr_dn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_handle_ospf_nbr_dn(self):
    self.__policy_handle_ospf_nbr_dn = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-handle-ospf-nbr-dn", rest_name="policy-handle-ospf-nbr-dn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_handle_isis_nbr_dn(self):
    """
    Getter method for policy_handle_isis_nbr_dn, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_handle_isis_nbr_dn (uint8)

    YANG Description: Handle IGP ISIS neighbor down event
    """
    return self.__policy_handle_isis_nbr_dn
      
  def _set_policy_handle_isis_nbr_dn(self, v, load=False):
    """
    Setter method for policy_handle_isis_nbr_dn, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_handle_isis_nbr_dn (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_handle_isis_nbr_dn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_handle_isis_nbr_dn() directly.

    YANG Description: Handle IGP ISIS neighbor down event
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-handle-isis-nbr-dn", rest_name="policy-handle-isis-nbr-dn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_handle_isis_nbr_dn must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-handle-isis-nbr-dn", rest_name="policy-handle-isis-nbr-dn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_handle_isis_nbr_dn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_handle_isis_nbr_dn(self):
    self.__policy_handle_isis_nbr_dn = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-handle-isis-nbr-dn", rest_name="policy-handle-isis-nbr-dn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_lsp_fast_retry_on(self):
    """
    Getter method for policy_lsp_fast_retry_on, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_lsp_fast_retry_on (uint8)

    YANG Description: LSP rapid retry
    """
    return self.__policy_lsp_fast_retry_on
      
  def _set_policy_lsp_fast_retry_on(self, v, load=False):
    """
    Setter method for policy_lsp_fast_retry_on, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_lsp_fast_retry_on (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_lsp_fast_retry_on is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_lsp_fast_retry_on() directly.

    YANG Description: LSP rapid retry
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-lsp-fast-retry-on", rest_name="policy-lsp-fast-retry-on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_lsp_fast_retry_on must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-lsp-fast-retry-on", rest_name="policy-lsp-fast-retry-on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_lsp_fast_retry_on = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_lsp_fast_retry_on(self):
    self.__policy_lsp_fast_retry_on = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-lsp-fast-retry-on", rest_name="policy-lsp-fast-retry-on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_max_lsp_retries(self):
    """
    Getter method for policy_max_lsp_retries, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_max_lsp_retries (uint16)

    YANG Description: maximum number of retries
    """
    return self.__policy_max_lsp_retries
      
  def _set_policy_max_lsp_retries(self, v, load=False):
    """
    Setter method for policy_max_lsp_retries, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_max_lsp_retries (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_max_lsp_retries is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_max_lsp_retries() directly.

    YANG Description: maximum number of retries
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-max-lsp-retries", rest_name="policy-max-lsp-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_max_lsp_retries must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-max-lsp-retries", rest_name="policy-max-lsp-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)""",
        })

    self.__policy_max_lsp_retries = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_max_lsp_retries(self):
    self.__policy_max_lsp_retries = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-max-lsp-retries", rest_name="policy-max-lsp-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)


  def _get_policy_lsp_retry_interval(self):
    """
    Getter method for policy_lsp_retry_interval, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_lsp_retry_interval (uint16)

    YANG Description: LSP periodic retry time
    """
    return self.__policy_lsp_retry_interval
      
  def _set_policy_lsp_retry_interval(self, v, load=False):
    """
    Setter method for policy_lsp_retry_interval, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_lsp_retry_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_lsp_retry_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_lsp_retry_interval() directly.

    YANG Description: LSP periodic retry time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-lsp-retry-interval", rest_name="policy-lsp-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_lsp_retry_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-lsp-retry-interval", rest_name="policy-lsp-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)""",
        })

    self.__policy_lsp_retry_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_lsp_retry_interval(self):
    self.__policy_lsp_retry_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-lsp-retry-interval", rest_name="policy-lsp-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)


  def _get_policy_frr_bkup_retry_interval(self):
    """
    Getter method for policy_frr_bkup_retry_interval, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_frr_bkup_retry_interval (uint32)

    YANG Description: FRR backup/detour retry time in seconds
    """
    return self.__policy_frr_bkup_retry_interval
      
  def _set_policy_frr_bkup_retry_interval(self, v, load=False):
    """
    Setter method for policy_frr_bkup_retry_interval, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_frr_bkup_retry_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_frr_bkup_retry_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_frr_bkup_retry_interval() directly.

    YANG Description: FRR backup/detour retry time in seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-frr-bkup-retry-interval", rest_name="policy-frr-bkup-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_frr_bkup_retry_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-frr-bkup-retry-interval", rest_name="policy-frr-bkup-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__policy_frr_bkup_retry_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_frr_bkup_retry_interval(self):
    self.__policy_frr_bkup_retry_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-frr-bkup-retry-interval", rest_name="policy-frr-bkup-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_policy_auto_bw_enabled(self):
    """
    Getter method for policy_auto_bw_enabled, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_auto_bw_enabled (uint8)

    YANG Description: Auto-bandwidth enabled
    """
    return self.__policy_auto_bw_enabled
      
  def _set_policy_auto_bw_enabled(self, v, load=False):
    """
    Setter method for policy_auto_bw_enabled, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_auto_bw_enabled (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_auto_bw_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_auto_bw_enabled() directly.

    YANG Description: Auto-bandwidth enabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-auto-bw-enabled", rest_name="policy-auto-bw-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_auto_bw_enabled must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-auto-bw-enabled", rest_name="policy-auto-bw-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__policy_auto_bw_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_auto_bw_enabled(self):
    self.__policy_auto_bw_enabled = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="policy-auto-bw-enabled", rest_name="policy-auto-bw-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_policy_auto_bw_sample_interval(self):
    """
    Getter method for policy_auto_bw_sample_interval, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_auto_bw_sample_interval (uint32)

    YANG Description: Auto-bandwidth sample interval in seconds
    """
    return self.__policy_auto_bw_sample_interval
      
  def _set_policy_auto_bw_sample_interval(self, v, load=False):
    """
    Setter method for policy_auto_bw_sample_interval, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_auto_bw_sample_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_auto_bw_sample_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_auto_bw_sample_interval() directly.

    YANG Description: Auto-bandwidth sample interval in seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-auto-bw-sample-interval", rest_name="policy-auto-bw-sample-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_auto_bw_sample_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-auto-bw-sample-interval", rest_name="policy-auto-bw-sample-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__policy_auto_bw_sample_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_auto_bw_sample_interval(self):
    self.__policy_auto_bw_sample_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="policy-auto-bw-sample-interval", rest_name="policy-auto-bw-sample-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_policy_soft_preempt_cleanup_timer(self):
    """
    Getter method for policy_soft_preempt_cleanup_timer, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_soft_preempt_cleanup_timer (uint16)

    YANG Description: Soft preemption cleanup-timer in seconds
    """
    return self.__policy_soft_preempt_cleanup_timer
      
  def _set_policy_soft_preempt_cleanup_timer(self, v, load=False):
    """
    Setter method for policy_soft_preempt_cleanup_timer, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_soft_preempt_cleanup_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_soft_preempt_cleanup_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_soft_preempt_cleanup_timer() directly.

    YANG Description: Soft preemption cleanup-timer in seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-soft-preempt-cleanup-timer", rest_name="policy-soft-preempt-cleanup-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_soft_preempt_cleanup_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-soft-preempt-cleanup-timer", rest_name="policy-soft-preempt-cleanup-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)""",
        })

    self.__policy_soft_preempt_cleanup_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_soft_preempt_cleanup_timer(self):
    self.__policy_soft_preempt_cleanup_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-soft-preempt-cleanup-timer", rest_name="policy-soft-preempt-cleanup-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)


  def _get_policy_rsvp_periodic_flooding_timer(self):
    """
    Getter method for policy_rsvp_periodic_flooding_timer, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_rsvp_periodic_flooding_timer (uint16)

    YANG Description: MPLS TE Periodic Flooding Timer in seconds
    """
    return self.__policy_rsvp_periodic_flooding_timer
      
  def _set_policy_rsvp_periodic_flooding_timer(self, v, load=False):
    """
    Setter method for policy_rsvp_periodic_flooding_timer, mapped from YANG variable /brocade_mpls_rpc/show_mpls_policy/output/mpls_policy/policy_rsvp_periodic_flooding_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_rsvp_periodic_flooding_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_rsvp_periodic_flooding_timer() directly.

    YANG Description: MPLS TE Periodic Flooding Timer in seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-rsvp-periodic-flooding-timer", rest_name="policy-rsvp-periodic-flooding-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_rsvp_periodic_flooding_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-rsvp-periodic-flooding-timer", rest_name="policy-rsvp-periodic-flooding-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)""",
        })

    self.__policy_rsvp_periodic_flooding_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_rsvp_periodic_flooding_timer(self):
    self.__policy_rsvp_periodic_flooding_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="policy-rsvp-periodic-flooding-timer", rest_name="policy-rsvp-periodic-flooding-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint16', is_config=True)

  policy_cspf_interface_constraint = __builtin__.property(_get_policy_cspf_interface_constraint, _set_policy_cspf_interface_constraint)
  policy_cspf_group_computation_mode = __builtin__.property(_get_policy_cspf_group_computation_mode, _set_policy_cspf_group_computation_mode)
  policy_use_bypass_metric = __builtin__.property(_get_policy_use_bypass_metric, _set_policy_use_bypass_metric)
  policy_use_bypass_liberal = __builtin__.property(_get_policy_use_bypass_liberal, _set_policy_use_bypass_liberal)
  policy_implicite_commit = __builtin__.property(_get_policy_implicite_commit, _set_policy_implicite_commit)
  policy_label_propagate_ttl = __builtin__.property(_get_policy_label_propagate_ttl, _set_policy_label_propagate_ttl)
  policy_vrf_propagate_ttl = __builtin__.property(_get_policy_vrf_propagate_ttl, _set_policy_vrf_propagate_ttl)
  policy_propagate_ttl = __builtin__.property(_get_policy_propagate_ttl, _set_policy_propagate_ttl)
  policy_rtm_route_filter_enabled = __builtin__.property(_get_policy_rtm_route_filter_enabled, _set_policy_rtm_route_filter_enabled)
  policy_rtm_route_filter_all_ibgp_enabled = __builtin__.property(_get_policy_rtm_route_filter_all_ibgp_enabled, _set_policy_rtm_route_filter_all_ibgp_enabled)
  policy_load_interval = __builtin__.property(_get_policy_load_interval, _set_policy_load_interval)
  policy_ingress_tnnl_accounting = __builtin__.property(_get_policy_ingress_tnnl_accounting, _set_policy_ingress_tnnl_accounting)
  policy_te_policy_ospf = __builtin__.property(_get_policy_te_policy_ospf, _set_policy_te_policy_ospf)
  policy_te_policy_isis = __builtin__.property(_get_policy_te_policy_isis, _set_policy_te_policy_isis)
  policy_ospf_area_defined = __builtin__.property(_get_policy_ospf_area_defined, _set_policy_ospf_area_defined)
  policy_ospf_area = __builtin__.property(_get_policy_ospf_area, _set_policy_ospf_area)
  policy_handle_ospf_nbr_dn = __builtin__.property(_get_policy_handle_ospf_nbr_dn, _set_policy_handle_ospf_nbr_dn)
  policy_handle_isis_nbr_dn = __builtin__.property(_get_policy_handle_isis_nbr_dn, _set_policy_handle_isis_nbr_dn)
  policy_lsp_fast_retry_on = __builtin__.property(_get_policy_lsp_fast_retry_on, _set_policy_lsp_fast_retry_on)
  policy_max_lsp_retries = __builtin__.property(_get_policy_max_lsp_retries, _set_policy_max_lsp_retries)
  policy_lsp_retry_interval = __builtin__.property(_get_policy_lsp_retry_interval, _set_policy_lsp_retry_interval)
  policy_frr_bkup_retry_interval = __builtin__.property(_get_policy_frr_bkup_retry_interval, _set_policy_frr_bkup_retry_interval)
  policy_auto_bw_enabled = __builtin__.property(_get_policy_auto_bw_enabled, _set_policy_auto_bw_enabled)
  policy_auto_bw_sample_interval = __builtin__.property(_get_policy_auto_bw_sample_interval, _set_policy_auto_bw_sample_interval)
  policy_soft_preempt_cleanup_timer = __builtin__.property(_get_policy_soft_preempt_cleanup_timer, _set_policy_soft_preempt_cleanup_timer)
  policy_rsvp_periodic_flooding_timer = __builtin__.property(_get_policy_rsvp_periodic_flooding_timer, _set_policy_rsvp_periodic_flooding_timer)


  _pyangbind_elements = {'policy_cspf_interface_constraint': policy_cspf_interface_constraint, 'policy_cspf_group_computation_mode': policy_cspf_group_computation_mode, 'policy_use_bypass_metric': policy_use_bypass_metric, 'policy_use_bypass_liberal': policy_use_bypass_liberal, 'policy_implicite_commit': policy_implicite_commit, 'policy_label_propagate_ttl': policy_label_propagate_ttl, 'policy_vrf_propagate_ttl': policy_vrf_propagate_ttl, 'policy_propagate_ttl': policy_propagate_ttl, 'policy_rtm_route_filter_enabled': policy_rtm_route_filter_enabled, 'policy_rtm_route_filter_all_ibgp_enabled': policy_rtm_route_filter_all_ibgp_enabled, 'policy_load_interval': policy_load_interval, 'policy_ingress_tnnl_accounting': policy_ingress_tnnl_accounting, 'policy_te_policy_ospf': policy_te_policy_ospf, 'policy_te_policy_isis': policy_te_policy_isis, 'policy_ospf_area_defined': policy_ospf_area_defined, 'policy_ospf_area': policy_ospf_area, 'policy_handle_ospf_nbr_dn': policy_handle_ospf_nbr_dn, 'policy_handle_isis_nbr_dn': policy_handle_isis_nbr_dn, 'policy_lsp_fast_retry_on': policy_lsp_fast_retry_on, 'policy_max_lsp_retries': policy_max_lsp_retries, 'policy_lsp_retry_interval': policy_lsp_retry_interval, 'policy_frr_bkup_retry_interval': policy_frr_bkup_retry_interval, 'policy_auto_bw_enabled': policy_auto_bw_enabled, 'policy_auto_bw_sample_interval': policy_auto_bw_sample_interval, 'policy_soft_preempt_cleanup_timer': policy_soft_preempt_cleanup_timer, 'policy_rsvp_periodic_flooding_timer': policy_rsvp_periodic_flooding_timer, }


