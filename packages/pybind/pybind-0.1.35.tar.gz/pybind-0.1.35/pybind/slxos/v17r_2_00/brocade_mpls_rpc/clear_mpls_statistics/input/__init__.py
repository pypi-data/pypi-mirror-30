
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-mpls - based on the path /brocade_mpls_rpc/clear-mpls-statistics/input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__mpls_clear_statistics_type','__protocol','__fec_prefix','__prefix_address','__prefix_mask','__label','__in_label','__tunnel_id_present','__tunnel_id','__bypass','__tunnel_name','__tunnel_dest',)

  _yang_name = 'input'
  _rest_name = 'input'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__in_label = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-label", rest_name="in-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__fec_prefix = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="fec-prefix", rest_name="fec-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-prefix', is_config=True)
    self.__protocol = YANGDynClass(base=unicode, is_leaf=True, yang_name="protocol", rest_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    self.__mpls_clear_statistics_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-clear-statistics-type", rest_name="mpls-clear-statistics-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__tunnel_id_present = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tunnel-id-present", rest_name="tunnel-id-present", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__label = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="label", rest_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__tunnel_dest = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="tunnel-dest", rest_name="tunnel-dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-address', is_config=True)
    self.__prefix_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="prefix-address", rest_name="prefix-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-address', is_config=True)
    self.__bypass = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bypass", rest_name="bypass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    self.__tunnel_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-id", rest_name="tunnel-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    self.__prefix_mask = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="prefix-mask", rest_name="prefix-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-subnet-mask', is_config=True)
    self.__tunnel_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="tunnel-name", rest_name="tunnel-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'brocade_mpls_rpc', u'clear-mpls-statistics', u'input']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'clear-mpls-statistics', u'input']

  def _get_mpls_clear_statistics_type(self):
    """
    Getter method for mpls_clear_statistics_type, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/mpls_clear_statistics_type (uint8)

    YANG Description: 1=OAM, 2=Transit, 3=Tunnel
    """
    return self.__mpls_clear_statistics_type
      
  def _set_mpls_clear_statistics_type(self, v, load=False):
    """
    Setter method for mpls_clear_statistics_type, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/mpls_clear_statistics_type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_clear_statistics_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_clear_statistics_type() directly.

    YANG Description: 1=OAM, 2=Transit, 3=Tunnel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-clear-statistics-type", rest_name="mpls-clear-statistics-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_clear_statistics_type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-clear-statistics-type", rest_name="mpls-clear-statistics-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__mpls_clear_statistics_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_clear_statistics_type(self):
    self.__mpls_clear_statistics_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-clear-statistics-type", rest_name="mpls-clear-statistics-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/protocol (string)

    YANG Description: ldp or rsvp
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/protocol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: ldp or rsvp
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="protocol", rest_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="protocol", rest_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=unicode, is_leaf=True, yang_name="protocol", rest_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_fec_prefix(self):
    """
    Getter method for fec_prefix, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/fec_prefix (mpls-ipv4-prefix)

    YANG Description: fec prefix
    """
    return self.__fec_prefix
      
  def _set_fec_prefix(self, v, load=False):
    """
    Setter method for fec_prefix, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/fec_prefix (mpls-ipv4-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_prefix() directly.

    YANG Description: fec prefix
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="fec-prefix", rest_name="fec-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_prefix must be of a type compatible with mpls-ipv4-prefix""",
          'defined-type': "brocade-mpls:mpls-ipv4-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="fec-prefix", rest_name="fec-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-prefix', is_config=True)""",
        })

    self.__fec_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_prefix(self):
    self.__fec_prefix = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="fec-prefix", rest_name="fec-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-prefix', is_config=True)


  def _get_prefix_address(self):
    """
    Getter method for prefix_address, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/prefix_address (mpls-ipv4-address)

    YANG Description: prefix address
    """
    return self.__prefix_address
      
  def _set_prefix_address(self, v, load=False):
    """
    Setter method for prefix_address, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/prefix_address (mpls-ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_address() directly.

    YANG Description: prefix address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="prefix-address", rest_name="prefix-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_address must be of a type compatible with mpls-ipv4-address""",
          'defined-type': "brocade-mpls:mpls-ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="prefix-address", rest_name="prefix-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-address', is_config=True)""",
        })

    self.__prefix_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_address(self):
    self.__prefix_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="prefix-address", rest_name="prefix-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-address', is_config=True)


  def _get_prefix_mask(self):
    """
    Getter method for prefix_mask, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/prefix_mask (mpls-ipv4-subnet-mask)

    YANG Description: prefix mask
    """
    return self.__prefix_mask
      
  def _set_prefix_mask(self, v, load=False):
    """
    Setter method for prefix_mask, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/prefix_mask (mpls-ipv4-subnet-mask)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_mask() directly.

    YANG Description: prefix mask
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="prefix-mask", rest_name="prefix-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-subnet-mask', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_mask must be of a type compatible with mpls-ipv4-subnet-mask""",
          'defined-type': "brocade-mpls:mpls-ipv4-subnet-mask",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="prefix-mask", rest_name="prefix-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-subnet-mask', is_config=True)""",
        })

    self.__prefix_mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_mask(self):
    self.__prefix_mask = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="prefix-mask", rest_name="prefix-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-subnet-mask', is_config=True)


  def _get_label(self):
    """
    Getter method for label, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/label (uint8)

    YANG Description: giving label as filter
    """
    return self.__label
      
  def _set_label(self, v, load=False):
    """
    Setter method for label, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/label (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label() directly.

    YANG Description: giving label as filter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="label", rest_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """label must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="label", rest_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label(self):
    self.__label = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="label", rest_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_in_label(self):
    """
    Getter method for in_label, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/in_label (uint32)

    YANG Description: Value of in-label
    """
    return self.__in_label
      
  def _set_in_label(self, v, load=False):
    """
    Setter method for in_label, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/in_label (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_label() directly.

    YANG Description: Value of in-label
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-label", rest_name="in-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_label must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-label", rest_name="in-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__in_label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_label(self):
    self.__in_label = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-label", rest_name="in-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_tunnel_id_present(self):
    """
    Getter method for tunnel_id_present, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/tunnel_id_present (uint8)

    YANG Description: giving tunnel-id as filter
    """
    return self.__tunnel_id_present
      
  def _set_tunnel_id_present(self, v, load=False):
    """
    Setter method for tunnel_id_present, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/tunnel_id_present (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_id_present is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_id_present() directly.

    YANG Description: giving tunnel-id as filter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tunnel-id-present", rest_name="tunnel-id-present", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_id_present must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tunnel-id-present", rest_name="tunnel-id-present", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__tunnel_id_present = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_id_present(self):
    self.__tunnel_id_present = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tunnel-id-present", rest_name="tunnel-id-present", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_tunnel_id(self):
    """
    Getter method for tunnel_id, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/tunnel_id (uint32)

    YANG Description: Value of tunnel-id
    """
    return self.__tunnel_id
      
  def _set_tunnel_id(self, v, load=False):
    """
    Setter method for tunnel_id, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/tunnel_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_id() directly.

    YANG Description: Value of tunnel-id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-id", rest_name="tunnel-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-id", rest_name="tunnel-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)""",
        })

    self.__tunnel_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_id(self):
    self.__tunnel_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-id", rest_name="tunnel-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint32', is_config=True)


  def _get_bypass(self):
    """
    Getter method for bypass, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/bypass (uint8)

    YANG Description: giving bypass as filter
    """
    return self.__bypass
      
  def _set_bypass(self, v, load=False):
    """
    Setter method for bypass, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/bypass (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass() directly.

    YANG Description: giving bypass as filter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bypass", rest_name="bypass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bypass", rest_name="bypass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)""",
        })

    self.__bypass = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass(self):
    self.__bypass = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bypass", rest_name="bypass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='uint8', is_config=True)


  def _get_tunnel_name(self):
    """
    Getter method for tunnel_name, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/tunnel_name (string)

    YANG Description: Tunnel Name
    """
    return self.__tunnel_name
      
  def _set_tunnel_name(self, v, load=False):
    """
    Setter method for tunnel_name, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/tunnel_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_name() directly.

    YANG Description: Tunnel Name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tunnel-name", rest_name="tunnel-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tunnel-name", rest_name="tunnel-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)""",
        })

    self.__tunnel_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_name(self):
    self.__tunnel_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="tunnel-name", rest_name="tunnel-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='string', is_config=True)


  def _get_tunnel_dest(self):
    """
    Getter method for tunnel_dest, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/tunnel_dest (mpls-ipv4-address)

    YANG Description: Tunnel Destination
    """
    return self.__tunnel_dest
      
  def _set_tunnel_dest(self, v, load=False):
    """
    Setter method for tunnel_dest, mapped from YANG variable /brocade_mpls_rpc/clear_mpls_statistics/input/tunnel_dest (mpls-ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_dest is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_dest() directly.

    YANG Description: Tunnel Destination
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="tunnel-dest", rest_name="tunnel-dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_dest must be of a type compatible with mpls-ipv4-address""",
          'defined-type': "brocade-mpls:mpls-ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="tunnel-dest", rest_name="tunnel-dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-address', is_config=True)""",
        })

    self.__tunnel_dest = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_dest(self):
    self.__tunnel_dest = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="tunnel-dest", rest_name="tunnel-dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='urn:brocade.com:mgmt:brocade-mpls', defining_module='brocade-mpls', yang_type='mpls-ipv4-address', is_config=True)

  mpls_clear_statistics_type = __builtin__.property(_get_mpls_clear_statistics_type, _set_mpls_clear_statistics_type)
  protocol = __builtin__.property(_get_protocol, _set_protocol)
  fec_prefix = __builtin__.property(_get_fec_prefix, _set_fec_prefix)
  prefix_address = __builtin__.property(_get_prefix_address, _set_prefix_address)
  prefix_mask = __builtin__.property(_get_prefix_mask, _set_prefix_mask)
  label = __builtin__.property(_get_label, _set_label)
  in_label = __builtin__.property(_get_in_label, _set_in_label)
  tunnel_id_present = __builtin__.property(_get_tunnel_id_present, _set_tunnel_id_present)
  tunnel_id = __builtin__.property(_get_tunnel_id, _set_tunnel_id)
  bypass = __builtin__.property(_get_bypass, _set_bypass)
  tunnel_name = __builtin__.property(_get_tunnel_name, _set_tunnel_name)
  tunnel_dest = __builtin__.property(_get_tunnel_dest, _set_tunnel_dest)


  _pyangbind_elements = {'mpls_clear_statistics_type': mpls_clear_statistics_type, 'protocol': protocol, 'fec_prefix': fec_prefix, 'prefix_address': prefix_address, 'prefix_mask': prefix_mask, 'label': label, 'in_label': in_label, 'tunnel_id_present': tunnel_id_present, 'tunnel_id': tunnel_id, 'bypass': bypass, 'tunnel_name': tunnel_name, 'tunnel_dest': tunnel_dest, }


