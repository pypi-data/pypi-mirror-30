
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import interfaces
class pim_global_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-pim-operational - based on the path /pim-global-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: PIMSM Global Configuration Parameters
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__vrf_name','__enable_status','__max_mcache','__current_count','__hello_interval','__nbr_timeout','__jp_interval','__inact_interval','__hw_drop_status','__prune_wait_interval','__reg_suppress_time','__reg_probe_time','__reg_stop_delay','__reg_suppress_interval','__ssm_status','__spt_threshold','__ssm_default_prefix','__ssm_prefix_name','__route_precedence','__interfaces',)

  _yang_name = 'pim-global-state'
  _rest_name = 'pim-global-state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__nbr_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="nbr-timeout", rest_name="nbr-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)
    self.__max_mcache = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-mcache", rest_name="max-mcache", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)
    self.__prune_wait_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="prune-wait-interval", rest_name="prune-wait-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint8', is_config=False)
    self.__spt_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spt-threshold", rest_name="spt-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)
    self.__reg_probe_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-probe-time", rest_name="reg-probe-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)
    self.__interfaces = YANGDynClass(base=YANGListType("vrf_name",interfaces.interfaces, yang_name="interfaces", rest_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'callpoint': u'pim-pim-interfaces', u'cli-suppress-show-path': None}}), is_container='list', yang_name="interfaces", rest_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-interfaces', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=False)
    self.__current_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="current-count", rest_name="current-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)
    self.__ssm_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ssm-status", rest_name="ssm-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='boolean', is_config=False)
    self.__inact_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="inact-interval", rest_name="inact-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)
    self.__ssm_prefix_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="ssm-prefix-name", rest_name="ssm-prefix-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)
    self.__jp_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="jp-interval", rest_name="jp-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)
    self.__ssm_default_prefix = YANGDynClass(base=unicode, is_leaf=True, yang_name="ssm-default-prefix", rest_name="ssm-default-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)
    self.__reg_stop_delay = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-stop-delay", rest_name="reg-stop-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)
    self.__vrf_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf-name", rest_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)
    self.__reg_suppress_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-suppress-time", rest_name="reg-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="hello-interval", rest_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)
    self.__enable_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-status", rest_name="enable-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='boolean', is_config=False)
    self.__hw_drop_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hw-drop-status", rest_name="hw-drop-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='boolean', is_config=False)
    self.__reg_suppress_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-suppress-interval", rest_name="reg-suppress-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)
    self.__route_precedence = YANGDynClass(base=unicode, is_leaf=True, yang_name="route-precedence", rest_name="route-precedence", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'pim-global-state']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'pim-global-state']

  def _get_vrf_name(self):
    """
    Getter method for vrf_name, mapped from YANG variable /pim_global_state/vrf_name (string)

    YANG Description: vrf name
    """
    return self.__vrf_name
      
  def _set_vrf_name(self, v, load=False):
    """
    Setter method for vrf_name, mapped from YANG variable /pim_global_state/vrf_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_name() directly.

    YANG Description: vrf name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vrf-name", rest_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf-name", rest_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)""",
        })

    self.__vrf_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_name(self):
    self.__vrf_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf-name", rest_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)


  def _get_enable_status(self):
    """
    Getter method for enable_status, mapped from YANG variable /pim_global_state/enable_status (boolean)

    YANG Description: Global PIMSM configuration status
    """
    return self.__enable_status
      
  def _set_enable_status(self, v, load=False):
    """
    Setter method for enable_status, mapped from YANG variable /pim_global_state/enable_status (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_status() directly.

    YANG Description: Global PIMSM configuration status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable-status", rest_name="enable-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_status must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-status", rest_name="enable-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='boolean', is_config=False)""",
        })

    self.__enable_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_status(self):
    self.__enable_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-status", rest_name="enable-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='boolean', is_config=False)


  def _get_max_mcache(self):
    """
    Getter method for max_mcache, mapped from YANG variable /pim_global_state/max_mcache (uint32)

    YANG Description: Maximum routes in Multicast Cache
    """
    return self.__max_mcache
      
  def _set_max_mcache(self, v, load=False):
    """
    Setter method for max_mcache, mapped from YANG variable /pim_global_state/max_mcache (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_mcache is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_mcache() directly.

    YANG Description: Maximum routes in Multicast Cache
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-mcache", rest_name="max-mcache", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_mcache must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-mcache", rest_name="max-mcache", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)""",
        })

    self.__max_mcache = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_mcache(self):
    self.__max_mcache = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-mcache", rest_name="max-mcache", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)


  def _get_current_count(self):
    """
    Getter method for current_count, mapped from YANG variable /pim_global_state/current_count (uint32)

    YANG Description: Present entry count
    """
    return self.__current_count
      
  def _set_current_count(self, v, load=False):
    """
    Setter method for current_count, mapped from YANG variable /pim_global_state/current_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_count() directly.

    YANG Description: Present entry count
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="current-count", rest_name="current-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="current-count", rest_name="current-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)""",
        })

    self.__current_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_count(self):
    self.__current_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="current-count", rest_name="current-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)


  def _get_hello_interval(self):
    """
    Getter method for hello_interval, mapped from YANG variable /pim_global_state/hello_interval (uint16)

    YANG Description: Interval to send Helloes to neighbors
    """
    return self.__hello_interval
      
  def _set_hello_interval(self, v, load=False):
    """
    Setter method for hello_interval, mapped from YANG variable /pim_global_state/hello_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval() directly.

    YANG Description: Interval to send Helloes to neighbors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="hello-interval", rest_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="hello-interval", rest_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)""",
        })

    self.__hello_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval(self):
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="hello-interval", rest_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)


  def _get_nbr_timeout(self):
    """
    Getter method for nbr_timeout, mapped from YANG variable /pim_global_state/nbr_timeout (uint16)

    YANG Description: Neighbor Timeout value
    """
    return self.__nbr_timeout
      
  def _set_nbr_timeout(self, v, load=False):
    """
    Setter method for nbr_timeout, mapped from YANG variable /pim_global_state/nbr_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nbr_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nbr_timeout() directly.

    YANG Description: Neighbor Timeout value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="nbr-timeout", rest_name="nbr-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nbr_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="nbr-timeout", rest_name="nbr-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)""",
        })

    self.__nbr_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nbr_timeout(self):
    self.__nbr_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="nbr-timeout", rest_name="nbr-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)


  def _get_jp_interval(self):
    """
    Getter method for jp_interval, mapped from YANG variable /pim_global_state/jp_interval (uint32)

    YANG Description: Join Prune Interval value
    """
    return self.__jp_interval
      
  def _set_jp_interval(self, v, load=False):
    """
    Setter method for jp_interval, mapped from YANG variable /pim_global_state/jp_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_jp_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_jp_interval() directly.

    YANG Description: Join Prune Interval value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="jp-interval", rest_name="jp-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """jp_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="jp-interval", rest_name="jp-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)""",
        })

    self.__jp_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_jp_interval(self):
    self.__jp_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="jp-interval", rest_name="jp-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)


  def _get_inact_interval(self):
    """
    Getter method for inact_interval, mapped from YANG variable /pim_global_state/inact_interval (uint16)

    YANG Description: Inactivity Interval value
    """
    return self.__inact_interval
      
  def _set_inact_interval(self, v, load=False):
    """
    Setter method for inact_interval, mapped from YANG variable /pim_global_state/inact_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inact_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inact_interval() directly.

    YANG Description: Inactivity Interval value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="inact-interval", rest_name="inact-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inact_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="inact-interval", rest_name="inact-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)""",
        })

    self.__inact_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inact_interval(self):
    self.__inact_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="inact-interval", rest_name="inact-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)


  def _get_hw_drop_status(self):
    """
    Getter method for hw_drop_status, mapped from YANG variable /pim_global_state/hw_drop_status (boolean)

    YANG Description: Hardware Drop Status
    """
    return self.__hw_drop_status
      
  def _set_hw_drop_status(self, v, load=False):
    """
    Setter method for hw_drop_status, mapped from YANG variable /pim_global_state/hw_drop_status (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hw_drop_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hw_drop_status() directly.

    YANG Description: Hardware Drop Status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="hw-drop-status", rest_name="hw-drop-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hw_drop_status must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hw-drop-status", rest_name="hw-drop-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='boolean', is_config=False)""",
        })

    self.__hw_drop_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hw_drop_status(self):
    self.__hw_drop_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hw-drop-status", rest_name="hw-drop-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='boolean', is_config=False)


  def _get_prune_wait_interval(self):
    """
    Getter method for prune_wait_interval, mapped from YANG variable /pim_global_state/prune_wait_interval (uint8)

    YANG Description: Prune Wait Interval value
    """
    return self.__prune_wait_interval
      
  def _set_prune_wait_interval(self, v, load=False):
    """
    Setter method for prune_wait_interval, mapped from YANG variable /pim_global_state/prune_wait_interval (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prune_wait_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prune_wait_interval() directly.

    YANG Description: Prune Wait Interval value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="prune-wait-interval", rest_name="prune-wait-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prune_wait_interval must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="prune-wait-interval", rest_name="prune-wait-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint8', is_config=False)""",
        })

    self.__prune_wait_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prune_wait_interval(self):
    self.__prune_wait_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="prune-wait-interval", rest_name="prune-wait-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint8', is_config=False)


  def _get_reg_suppress_time(self):
    """
    Getter method for reg_suppress_time, mapped from YANG variable /pim_global_state/reg_suppress_time (uint16)

    YANG Description: Register Suppression Time
    """
    return self.__reg_suppress_time
      
  def _set_reg_suppress_time(self, v, load=False):
    """
    Setter method for reg_suppress_time, mapped from YANG variable /pim_global_state/reg_suppress_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reg_suppress_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reg_suppress_time() directly.

    YANG Description: Register Suppression Time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-suppress-time", rest_name="reg-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reg_suppress_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-suppress-time", rest_name="reg-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)""",
        })

    self.__reg_suppress_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reg_suppress_time(self):
    self.__reg_suppress_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-suppress-time", rest_name="reg-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)


  def _get_reg_probe_time(self):
    """
    Getter method for reg_probe_time, mapped from YANG variable /pim_global_state/reg_probe_time (uint16)

    YANG Description: Register Probe Time
    """
    return self.__reg_probe_time
      
  def _set_reg_probe_time(self, v, load=False):
    """
    Setter method for reg_probe_time, mapped from YANG variable /pim_global_state/reg_probe_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reg_probe_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reg_probe_time() directly.

    YANG Description: Register Probe Time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-probe-time", rest_name="reg-probe-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reg_probe_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-probe-time", rest_name="reg-probe-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)""",
        })

    self.__reg_probe_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reg_probe_time(self):
    self.__reg_probe_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-probe-time", rest_name="reg-probe-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)


  def _get_reg_stop_delay(self):
    """
    Getter method for reg_stop_delay, mapped from YANG variable /pim_global_state/reg_stop_delay (uint16)

    YANG Description: Register Stop delay time
    """
    return self.__reg_stop_delay
      
  def _set_reg_stop_delay(self, v, load=False):
    """
    Setter method for reg_stop_delay, mapped from YANG variable /pim_global_state/reg_stop_delay (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reg_stop_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reg_stop_delay() directly.

    YANG Description: Register Stop delay time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-stop-delay", rest_name="reg-stop-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reg_stop_delay must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-stop-delay", rest_name="reg-stop-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)""",
        })

    self.__reg_stop_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reg_stop_delay(self):
    self.__reg_stop_delay = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-stop-delay", rest_name="reg-stop-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)


  def _get_reg_suppress_interval(self):
    """
    Getter method for reg_suppress_interval, mapped from YANG variable /pim_global_state/reg_suppress_interval (uint16)

    YANG Description: Register suppression Interval
    """
    return self.__reg_suppress_interval
      
  def _set_reg_suppress_interval(self, v, load=False):
    """
    Setter method for reg_suppress_interval, mapped from YANG variable /pim_global_state/reg_suppress_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reg_suppress_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reg_suppress_interval() directly.

    YANG Description: Register suppression Interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-suppress-interval", rest_name="reg-suppress-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reg_suppress_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-suppress-interval", rest_name="reg-suppress-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)""",
        })

    self.__reg_suppress_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reg_suppress_interval(self):
    self.__reg_suppress_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reg-suppress-interval", rest_name="reg-suppress-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint16', is_config=False)


  def _get_ssm_status(self):
    """
    Getter method for ssm_status, mapped from YANG variable /pim_global_state/ssm_status (boolean)

    YANG Description: PIM SSM enable status
    """
    return self.__ssm_status
      
  def _set_ssm_status(self, v, load=False):
    """
    Setter method for ssm_status, mapped from YANG variable /pim_global_state/ssm_status (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssm_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssm_status() directly.

    YANG Description: PIM SSM enable status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ssm-status", rest_name="ssm-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssm_status must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ssm-status", rest_name="ssm-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='boolean', is_config=False)""",
        })

    self.__ssm_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssm_status(self):
    self.__ssm_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ssm-status", rest_name="ssm-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='boolean', is_config=False)


  def _get_spt_threshold(self):
    """
    Getter method for spt_threshold, mapped from YANG variable /pim_global_state/spt_threshold (uint32)

    YANG Description: SPT Threshold value
    """
    return self.__spt_threshold
      
  def _set_spt_threshold(self, v, load=False):
    """
    Setter method for spt_threshold, mapped from YANG variable /pim_global_state/spt_threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spt_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spt_threshold() directly.

    YANG Description: SPT Threshold value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spt-threshold", rest_name="spt-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spt_threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spt-threshold", rest_name="spt-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)""",
        })

    self.__spt_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spt_threshold(self):
    self.__spt_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spt-threshold", rest_name="spt-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='uint32', is_config=False)


  def _get_ssm_default_prefix(self):
    """
    Getter method for ssm_default_prefix, mapped from YANG variable /pim_global_state/ssm_default_prefix (string)

    YANG Description: ssm default IP prefix
    """
    return self.__ssm_default_prefix
      
  def _set_ssm_default_prefix(self, v, load=False):
    """
    Setter method for ssm_default_prefix, mapped from YANG variable /pim_global_state/ssm_default_prefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssm_default_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssm_default_prefix() directly.

    YANG Description: ssm default IP prefix
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="ssm-default-prefix", rest_name="ssm-default-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssm_default_prefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="ssm-default-prefix", rest_name="ssm-default-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)""",
        })

    self.__ssm_default_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssm_default_prefix(self):
    self.__ssm_default_prefix = YANGDynClass(base=unicode, is_leaf=True, yang_name="ssm-default-prefix", rest_name="ssm-default-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)


  def _get_ssm_prefix_name(self):
    """
    Getter method for ssm_prefix_name, mapped from YANG variable /pim_global_state/ssm_prefix_name (string)

    YANG Description: SSM Prefix name
    """
    return self.__ssm_prefix_name
      
  def _set_ssm_prefix_name(self, v, load=False):
    """
    Setter method for ssm_prefix_name, mapped from YANG variable /pim_global_state/ssm_prefix_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssm_prefix_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssm_prefix_name() directly.

    YANG Description: SSM Prefix name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="ssm-prefix-name", rest_name="ssm-prefix-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssm_prefix_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="ssm-prefix-name", rest_name="ssm-prefix-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)""",
        })

    self.__ssm_prefix_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssm_prefix_name(self):
    self.__ssm_prefix_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="ssm-prefix-name", rest_name="ssm-prefix-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)


  def _get_route_precedence(self):
    """
    Getter method for route_precedence, mapped from YANG variable /pim_global_state/route_precedence (string)

    YANG Description: PIM Route Precedence status
    """
    return self.__route_precedence
      
  def _set_route_precedence(self, v, load=False):
    """
    Setter method for route_precedence, mapped from YANG variable /pim_global_state/route_precedence (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_precedence is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_precedence() directly.

    YANG Description: PIM Route Precedence status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="route-precedence", rest_name="route-precedence", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_precedence must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="route-precedence", rest_name="route-precedence", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)""",
        })

    self.__route_precedence = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_precedence(self):
    self.__route_precedence = YANGDynClass(base=unicode, is_leaf=True, yang_name="route-precedence", rest_name="route-precedence", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='string', is_config=False)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /pim_global_state/interfaces (list)

    YANG Description: PIM enabled interfaces
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /pim_global_state/interfaces (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: PIM enabled interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vrf_name",interfaces.interfaces, yang_name="interfaces", rest_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'callpoint': u'pim-pim-interfaces', u'cli-suppress-show-path': None}}), is_container='list', yang_name="interfaces", rest_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-interfaces', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vrf_name",interfaces.interfaces, yang_name="interfaces", rest_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'callpoint': u'pim-pim-interfaces', u'cli-suppress-show-path': None}}), is_container='list', yang_name="interfaces", rest_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-interfaces', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=False)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=YANGListType("vrf_name",interfaces.interfaces, yang_name="interfaces", rest_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrf-name', extensions={u'tailf-common': {u'callpoint': u'pim-pim-interfaces', u'cli-suppress-show-path': None}}), is_container='list', yang_name="interfaces", rest_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'pim-pim-interfaces', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-pim-operational', defining_module='brocade-pim-operational', yang_type='list', is_config=False)

  vrf_name = __builtin__.property(_get_vrf_name)
  enable_status = __builtin__.property(_get_enable_status)
  max_mcache = __builtin__.property(_get_max_mcache)
  current_count = __builtin__.property(_get_current_count)
  hello_interval = __builtin__.property(_get_hello_interval)
  nbr_timeout = __builtin__.property(_get_nbr_timeout)
  jp_interval = __builtin__.property(_get_jp_interval)
  inact_interval = __builtin__.property(_get_inact_interval)
  hw_drop_status = __builtin__.property(_get_hw_drop_status)
  prune_wait_interval = __builtin__.property(_get_prune_wait_interval)
  reg_suppress_time = __builtin__.property(_get_reg_suppress_time)
  reg_probe_time = __builtin__.property(_get_reg_probe_time)
  reg_stop_delay = __builtin__.property(_get_reg_stop_delay)
  reg_suppress_interval = __builtin__.property(_get_reg_suppress_interval)
  ssm_status = __builtin__.property(_get_ssm_status)
  spt_threshold = __builtin__.property(_get_spt_threshold)
  ssm_default_prefix = __builtin__.property(_get_ssm_default_prefix)
  ssm_prefix_name = __builtin__.property(_get_ssm_prefix_name)
  route_precedence = __builtin__.property(_get_route_precedence)
  interfaces = __builtin__.property(_get_interfaces)


  _pyangbind_elements = {'vrf_name': vrf_name, 'enable_status': enable_status, 'max_mcache': max_mcache, 'current_count': current_count, 'hello_interval': hello_interval, 'nbr_timeout': nbr_timeout, 'jp_interval': jp_interval, 'inact_interval': inact_interval, 'hw_drop_status': hw_drop_status, 'prune_wait_interval': prune_wait_interval, 'reg_suppress_time': reg_suppress_time, 'reg_probe_time': reg_probe_time, 'reg_stop_delay': reg_stop_delay, 'reg_suppress_interval': reg_suppress_interval, 'ssm_status': ssm_status, 'spt_threshold': spt_threshold, 'ssm_default_prefix': ssm_default_prefix, 'ssm_prefix_name': ssm_prefix_name, 'route_precedence': route_precedence, 'interfaces': interfaces, }


