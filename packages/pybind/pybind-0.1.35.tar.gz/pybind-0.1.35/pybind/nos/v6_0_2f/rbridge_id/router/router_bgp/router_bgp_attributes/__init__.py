
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import cluster_id
import distance
import capability
import maxas_limit
import timers
import confederation
import bfd
import neighbor
class router_bgp_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-rbridge - based on the path /rbridge-id/router/router-bgp/router-bgp-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__local_as','__always_compare_med','__compare_med_empty_aspath','__med_missing_as_worst','__as_path_ignore','__compare_routerid','__install_igp_cost','__cluster_id','__default_local_preference','__distance','__capability','__maxas_limit','__enforce_first_as','__fast_external_fallover','__timers','__log_dampening_debug','__confederation','__bfd','__neighbor',)

  _yang_name = 'router-bgp-attributes'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__distance = YANGDynClass(base=distance.distance, is_container='container', presence=False, yang_name="distance", rest_name="distance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-compact-syntax': None, u'info': u'Define an administrative distance', u'cli-sequence-commands': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)
    self.__compare_med_empty_aspath = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="compare-med-empty-aspath", rest_name="compare-med-empty-aspath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Allow comparing MED from different neighbors even with empty as-path\nattribute'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    self.__default_local_preference = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="default-local-preference", rest_name="default-local-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure default local preference value'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='local-preference-number', is_config=True)
    self.__med_missing_as_worst = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="med-missing-as-worst", rest_name="med-missing-as-worst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Consider routes missing MED attribute as least desirable'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    self.__bfd = YANGDynClass(base=bfd.bfd, is_container='container', presence=False, yang_name="bfd", rest_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set BFD global parameters for BGP', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)
    self.__enforce_first_as = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enforce-first-as", rest_name="enforce-first-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enforce the first AS for EBGP routes'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    self.__always_compare_med = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="always-compare-med", rest_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Allow comparing MED from different neighbors'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    self.__local_as = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((([0-9][0-9]{0,3})|([1-5][0-9]{4})|(6[0-4][0-9]{3})|(65[0-4][0-9]{2})|(655[0-2][0-9])|(6553[0-5]))\\.(([0-9][0-9]{0,3})|([1-5][0-9]{4})|(6[0-4][0-9]{3})|(65[0-4][0-9]{2})|(655[0-2][0-9])|(6553[0-5])))|([1-9][0-9]{0,8})|([1-3][0-9]{9})|(4[0-1][0-9]{8})|(42[0-8][0-9]{7})|(429[0-3][0-9]{6})|(4294[0-8][0-9]{5})|(42949[0-5][0-9]{4})|(429496[0-6][0-9]{3})|(4294967[0-1][0-9]{2})|(42949672[0-8][0-9])|(429496729[0-5])'}), is_leaf=True, yang_name="local-as", rest_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure local AS number'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='local-as-type', is_config=True)
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', presence=False, yang_name="timers", rest_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Adjust routing timers', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)
    self.__log_dampening_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-dampening-debug", rest_name="log-dampening-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Log dampening debug messages'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    self.__install_igp_cost = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="install-igp-cost", rest_name="install-igp-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Install igp cost to nexthop instead of MED value as BGP route cost'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    self.__fast_external_fallover = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fast-external-fallover", rest_name="fast-external-fallover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Reset session if link to EBGP peer goes down'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    self.__cluster_id = YANGDynClass(base=cluster_id.cluster_id, is_container='container', presence=False, yang_name="cluster-id", rest_name="cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Route-Reflector Cluster-ID'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)
    self.__neighbor = YANGDynClass(base=neighbor.neighbor, is_container='container', presence=False, yang_name="neighbor", rest_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Specify a neighbor router', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)
    self.__compare_routerid = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="compare-routerid", rest_name="compare-routerid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Compare router-id for identical BGP paths'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    self.__capability = YANGDynClass(base=capability.capability, is_container='container', presence=False, yang_name="capability", rest_name="capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set capability', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)
    self.__as_path_ignore = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="as-path-ignore", rest_name="as-path-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Ignore AS_PATH length for best route selection'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    self.__confederation = YANGDynClass(base=confederation.confederation, is_container='container', presence=False, yang_name="confederation", rest_name="confederation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure AS confederation parameters', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)
    self.__maxas_limit = YANGDynClass(base=maxas_limit.maxas_limit, is_container='container', presence=False, yang_name="maxas-limit", rest_name="maxas-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Impose limit on number of ASes in AS-PATH attribute', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'rbridge-id', u'router', u'router-bgp', u'router-bgp-attributes']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'rbridge-id', u'router', u'bgp']

  def _get_local_as(self):
    """
    Getter method for local_as, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/local_as (local-as-type)
    """
    return self.__local_as
      
  def _set_local_as(self, v, load=False):
    """
    Setter method for local_as, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/local_as (local-as-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_as() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((([0-9][0-9]{0,3})|([1-5][0-9]{4})|(6[0-4][0-9]{3})|(65[0-4][0-9]{2})|(655[0-2][0-9])|(6553[0-5]))\\.(([0-9][0-9]{0,3})|([1-5][0-9]{4})|(6[0-4][0-9]{3})|(65[0-4][0-9]{2})|(655[0-2][0-9])|(6553[0-5])))|([1-9][0-9]{0,8})|([1-3][0-9]{9})|(4[0-1][0-9]{8})|(42[0-8][0-9]{7})|(429[0-3][0-9]{6})|(4294[0-8][0-9]{5})|(42949[0-5][0-9]{4})|(429496[0-6][0-9]{3})|(4294967[0-1][0-9]{2})|(42949672[0-8][0-9])|(429496729[0-5])'}), is_leaf=True, yang_name="local-as", rest_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure local AS number'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='local-as-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_as must be of a type compatible with local-as-type""",
          'defined-type': "brocade-bgp:local-as-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((([0-9][0-9]{0,3})|([1-5][0-9]{4})|(6[0-4][0-9]{3})|(65[0-4][0-9]{2})|(655[0-2][0-9])|(6553[0-5]))\\.(([0-9][0-9]{0,3})|([1-5][0-9]{4})|(6[0-4][0-9]{3})|(65[0-4][0-9]{2})|(655[0-2][0-9])|(6553[0-5])))|([1-9][0-9]{0,8})|([1-3][0-9]{9})|(4[0-1][0-9]{8})|(42[0-8][0-9]{7})|(429[0-3][0-9]{6})|(4294[0-8][0-9]{5})|(42949[0-5][0-9]{4})|(429496[0-6][0-9]{3})|(4294967[0-1][0-9]{2})|(42949672[0-8][0-9])|(429496729[0-5])'}), is_leaf=True, yang_name="local-as", rest_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure local AS number'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='local-as-type', is_config=True)""",
        })

    self.__local_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_as(self):
    self.__local_as = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((([0-9][0-9]{0,3})|([1-5][0-9]{4})|(6[0-4][0-9]{3})|(65[0-4][0-9]{2})|(655[0-2][0-9])|(6553[0-5]))\\.(([0-9][0-9]{0,3})|([1-5][0-9]{4})|(6[0-4][0-9]{3})|(65[0-4][0-9]{2})|(655[0-2][0-9])|(6553[0-5])))|([1-9][0-9]{0,8})|([1-3][0-9]{9})|(4[0-1][0-9]{8})|(42[0-8][0-9]{7})|(429[0-3][0-9]{6})|(4294[0-8][0-9]{5})|(42949[0-5][0-9]{4})|(429496[0-6][0-9]{3})|(4294967[0-1][0-9]{2})|(42949672[0-8][0-9])|(429496729[0-5])'}), is_leaf=True, yang_name="local-as", rest_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure local AS number'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='local-as-type', is_config=True)


  def _get_always_compare_med(self):
    """
    Getter method for always_compare_med, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/always_compare_med (empty)
    """
    return self.__always_compare_med
      
  def _set_always_compare_med(self, v, load=False):
    """
    Setter method for always_compare_med, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/always_compare_med (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_always_compare_med is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_always_compare_med() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="always-compare-med", rest_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Allow comparing MED from different neighbors'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """always_compare_med must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="always-compare-med", rest_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Allow comparing MED from different neighbors'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)""",
        })

    self.__always_compare_med = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_always_compare_med(self):
    self.__always_compare_med = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="always-compare-med", rest_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Allow comparing MED from different neighbors'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)


  def _get_compare_med_empty_aspath(self):
    """
    Getter method for compare_med_empty_aspath, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/compare_med_empty_aspath (empty)
    """
    return self.__compare_med_empty_aspath
      
  def _set_compare_med_empty_aspath(self, v, load=False):
    """
    Setter method for compare_med_empty_aspath, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/compare_med_empty_aspath (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_compare_med_empty_aspath is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_compare_med_empty_aspath() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="compare-med-empty-aspath", rest_name="compare-med-empty-aspath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Allow comparing MED from different neighbors even with empty as-path\nattribute'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """compare_med_empty_aspath must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="compare-med-empty-aspath", rest_name="compare-med-empty-aspath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Allow comparing MED from different neighbors even with empty as-path\nattribute'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)""",
        })

    self.__compare_med_empty_aspath = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_compare_med_empty_aspath(self):
    self.__compare_med_empty_aspath = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="compare-med-empty-aspath", rest_name="compare-med-empty-aspath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Allow comparing MED from different neighbors even with empty as-path\nattribute'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)


  def _get_med_missing_as_worst(self):
    """
    Getter method for med_missing_as_worst, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/med_missing_as_worst (empty)
    """
    return self.__med_missing_as_worst
      
  def _set_med_missing_as_worst(self, v, load=False):
    """
    Setter method for med_missing_as_worst, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/med_missing_as_worst (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_med_missing_as_worst is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_med_missing_as_worst() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="med-missing-as-worst", rest_name="med-missing-as-worst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Consider routes missing MED attribute as least desirable'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """med_missing_as_worst must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="med-missing-as-worst", rest_name="med-missing-as-worst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Consider routes missing MED attribute as least desirable'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)""",
        })

    self.__med_missing_as_worst = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_med_missing_as_worst(self):
    self.__med_missing_as_worst = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="med-missing-as-worst", rest_name="med-missing-as-worst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Consider routes missing MED attribute as least desirable'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)


  def _get_as_path_ignore(self):
    """
    Getter method for as_path_ignore, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/as_path_ignore (empty)
    """
    return self.__as_path_ignore
      
  def _set_as_path_ignore(self, v, load=False):
    """
    Setter method for as_path_ignore, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/as_path_ignore (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_path_ignore is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_path_ignore() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="as-path-ignore", rest_name="as-path-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Ignore AS_PATH length for best route selection'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_path_ignore must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="as-path-ignore", rest_name="as-path-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Ignore AS_PATH length for best route selection'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)""",
        })

    self.__as_path_ignore = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_path_ignore(self):
    self.__as_path_ignore = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="as-path-ignore", rest_name="as-path-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Ignore AS_PATH length for best route selection'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)


  def _get_compare_routerid(self):
    """
    Getter method for compare_routerid, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/compare_routerid (empty)
    """
    return self.__compare_routerid
      
  def _set_compare_routerid(self, v, load=False):
    """
    Setter method for compare_routerid, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/compare_routerid (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_compare_routerid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_compare_routerid() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="compare-routerid", rest_name="compare-routerid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Compare router-id for identical BGP paths'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """compare_routerid must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="compare-routerid", rest_name="compare-routerid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Compare router-id for identical BGP paths'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)""",
        })

    self.__compare_routerid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_compare_routerid(self):
    self.__compare_routerid = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="compare-routerid", rest_name="compare-routerid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Compare router-id for identical BGP paths'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)


  def _get_install_igp_cost(self):
    """
    Getter method for install_igp_cost, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/install_igp_cost (empty)
    """
    return self.__install_igp_cost
      
  def _set_install_igp_cost(self, v, load=False):
    """
    Setter method for install_igp_cost, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/install_igp_cost (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_install_igp_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_install_igp_cost() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="install-igp-cost", rest_name="install-igp-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Install igp cost to nexthop instead of MED value as BGP route cost'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """install_igp_cost must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="install-igp-cost", rest_name="install-igp-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Install igp cost to nexthop instead of MED value as BGP route cost'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)""",
        })

    self.__install_igp_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_install_igp_cost(self):
    self.__install_igp_cost = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="install-igp-cost", rest_name="install-igp-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Install igp cost to nexthop instead of MED value as BGP route cost'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)


  def _get_cluster_id(self):
    """
    Getter method for cluster_id, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/cluster_id (container)
    """
    return self.__cluster_id
      
  def _set_cluster_id(self, v, load=False):
    """
    Setter method for cluster_id, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/cluster_id (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cluster_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cluster_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=cluster_id.cluster_id, is_container='container', presence=False, yang_name="cluster-id", rest_name="cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Route-Reflector Cluster-ID'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cluster_id must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=cluster_id.cluster_id, is_container='container', presence=False, yang_name="cluster-id", rest_name="cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Route-Reflector Cluster-ID'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)""",
        })

    self.__cluster_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cluster_id(self):
    self.__cluster_id = YANGDynClass(base=cluster_id.cluster_id, is_container='container', presence=False, yang_name="cluster-id", rest_name="cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure Route-Reflector Cluster-ID'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)


  def _get_default_local_preference(self):
    """
    Getter method for default_local_preference, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/default_local_preference (local-preference-number)
    """
    return self.__default_local_preference
      
  def _set_default_local_preference(self, v, load=False):
    """
    Setter method for default_local_preference, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/default_local_preference (local-preference-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_local_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_local_preference() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="default-local-preference", rest_name="default-local-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure default local preference value'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='local-preference-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_local_preference must be of a type compatible with local-preference-number""",
          'defined-type': "brocade-bgp:local-preference-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="default-local-preference", rest_name="default-local-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure default local preference value'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='local-preference-number', is_config=True)""",
        })

    self.__default_local_preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_local_preference(self):
    self.__default_local_preference = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="default-local-preference", rest_name="default-local-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Configure default local preference value'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='local-preference-number', is_config=True)


  def _get_distance(self):
    """
    Getter method for distance, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/distance (container)
    """
    return self.__distance
      
  def _set_distance(self, v, load=False):
    """
    Setter method for distance, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/distance (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_distance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_distance() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=distance.distance, is_container='container', presence=False, yang_name="distance", rest_name="distance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-compact-syntax': None, u'info': u'Define an administrative distance', u'cli-sequence-commands': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """distance must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=distance.distance, is_container='container', presence=False, yang_name="distance", rest_name="distance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-compact-syntax': None, u'info': u'Define an administrative distance', u'cli-sequence-commands': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)""",
        })

    self.__distance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_distance(self):
    self.__distance = YANGDynClass(base=distance.distance, is_container='container', presence=False, yang_name="distance", rest_name="distance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-compact-syntax': None, u'info': u'Define an administrative distance', u'cli-sequence-commands': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)


  def _get_capability(self):
    """
    Getter method for capability, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/capability (container)
    """
    return self.__capability
      
  def _set_capability(self, v, load=False):
    """
    Setter method for capability, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/capability (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_capability() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=capability.capability, is_container='container', presence=False, yang_name="capability", rest_name="capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set capability', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """capability must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=capability.capability, is_container='container', presence=False, yang_name="capability", rest_name="capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set capability', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)""",
        })

    self.__capability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_capability(self):
    self.__capability = YANGDynClass(base=capability.capability, is_container='container', presence=False, yang_name="capability", rest_name="capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set capability', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)


  def _get_maxas_limit(self):
    """
    Getter method for maxas_limit, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/maxas_limit (container)
    """
    return self.__maxas_limit
      
  def _set_maxas_limit(self, v, load=False):
    """
    Setter method for maxas_limit, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/maxas_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxas_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxas_limit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=maxas_limit.maxas_limit, is_container='container', presence=False, yang_name="maxas-limit", rest_name="maxas-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Impose limit on number of ASes in AS-PATH attribute', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxas_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=maxas_limit.maxas_limit, is_container='container', presence=False, yang_name="maxas-limit", rest_name="maxas-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Impose limit on number of ASes in AS-PATH attribute', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)""",
        })

    self.__maxas_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxas_limit(self):
    self.__maxas_limit = YANGDynClass(base=maxas_limit.maxas_limit, is_container='container', presence=False, yang_name="maxas-limit", rest_name="maxas-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Impose limit on number of ASes in AS-PATH attribute', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)


  def _get_enforce_first_as(self):
    """
    Getter method for enforce_first_as, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/enforce_first_as (empty)
    """
    return self.__enforce_first_as
      
  def _set_enforce_first_as(self, v, load=False):
    """
    Setter method for enforce_first_as, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/enforce_first_as (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enforce_first_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enforce_first_as() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enforce-first-as", rest_name="enforce-first-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enforce the first AS for EBGP routes'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enforce_first_as must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enforce-first-as", rest_name="enforce-first-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enforce the first AS for EBGP routes'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)""",
        })

    self.__enforce_first_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enforce_first_as(self):
    self.__enforce_first_as = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enforce-first-as", rest_name="enforce-first-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Enforce the first AS for EBGP routes'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)


  def _get_fast_external_fallover(self):
    """
    Getter method for fast_external_fallover, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/fast_external_fallover (empty)
    """
    return self.__fast_external_fallover
      
  def _set_fast_external_fallover(self, v, load=False):
    """
    Setter method for fast_external_fallover, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/fast_external_fallover (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fast_external_fallover is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fast_external_fallover() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fast-external-fallover", rest_name="fast-external-fallover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Reset session if link to EBGP peer goes down'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fast_external_fallover must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fast-external-fallover", rest_name="fast-external-fallover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Reset session if link to EBGP peer goes down'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)""",
        })

    self.__fast_external_fallover = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fast_external_fallover(self):
    self.__fast_external_fallover = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fast-external-fallover", rest_name="fast-external-fallover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Reset session if link to EBGP peer goes down'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)


  def _get_timers(self):
    """
    Getter method for timers, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/timers (container)
    """
    return self.__timers
      
  def _set_timers(self, v, load=False):
    """
    Setter method for timers, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/timers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timers() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=timers.timers, is_container='container', presence=False, yang_name="timers", rest_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Adjust routing timers', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=timers.timers, is_container='container', presence=False, yang_name="timers", rest_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Adjust routing timers', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)""",
        })

    self.__timers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timers(self):
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', presence=False, yang_name="timers", rest_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Adjust routing timers', u'cli-compact-syntax': None, u'cli-sequence-commands': None, u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)


  def _get_log_dampening_debug(self):
    """
    Getter method for log_dampening_debug, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/log_dampening_debug (empty)
    """
    return self.__log_dampening_debug
      
  def _set_log_dampening_debug(self, v, load=False):
    """
    Setter method for log_dampening_debug, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/log_dampening_debug (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_dampening_debug is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_dampening_debug() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="log-dampening-debug", rest_name="log-dampening-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Log dampening debug messages'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_dampening_debug must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-dampening-debug", rest_name="log-dampening-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Log dampening debug messages'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)""",
        })

    self.__log_dampening_debug = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_dampening_debug(self):
    self.__log_dampening_debug = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-dampening-debug", rest_name="log-dampening-debug", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'cli-full-command': None, u'info': u'Log dampening debug messages'}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='empty', is_config=True)


  def _get_confederation(self):
    """
    Getter method for confederation, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/confederation (container)
    """
    return self.__confederation
      
  def _set_confederation(self, v, load=False):
    """
    Setter method for confederation, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/confederation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_confederation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_confederation() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=confederation.confederation, is_container='container', presence=False, yang_name="confederation", rest_name="confederation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure AS confederation parameters', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """confederation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=confederation.confederation, is_container='container', presence=False, yang_name="confederation", rest_name="confederation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure AS confederation parameters', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)""",
        })

    self.__confederation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_confederation(self):
    self.__confederation = YANGDynClass(base=confederation.confederation, is_container='container', presence=False, yang_name="confederation", rest_name="confederation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Configure AS confederation parameters', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)


  def _get_bfd(self):
    """
    Getter method for bfd, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/bfd (container)
    """
    return self.__bfd
      
  def _set_bfd(self, v, load=False):
    """
    Setter method for bfd, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfd() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bfd.bfd, is_container='container', presence=False, yang_name="bfd", rest_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set BFD global parameters for BGP', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bfd.bfd, is_container='container', presence=False, yang_name="bfd", rest_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set BFD global parameters for BGP', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)""",
        })

    self.__bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfd(self):
    self.__bfd = YANGDynClass(base=bfd.bfd, is_container='container', presence=False, yang_name="bfd", rest_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Set BFD global parameters for BGP', u'cli-incomplete-no': None, u'cli-incomplete-command': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)


  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/neighbor (container)
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /rbridge_id/router/router_bgp/router_bgp_attributes/neighbor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=neighbor.neighbor, is_container='container', presence=False, yang_name="neighbor", rest_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Specify a neighbor router', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=neighbor.neighbor, is_container='container', presence=False, yang_name="neighbor", rest_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Specify a neighbor router', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=neighbor.neighbor, is_container='container', presence=False, yang_name="neighbor", rest_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'info': u'Specify a neighbor router', u'cli-incomplete-no': None}}, namespace='urn:brocade.com:mgmt:brocade-bgp', defining_module='brocade-bgp', yang_type='container', is_config=True)

  local_as = __builtin__.property(_get_local_as, _set_local_as)
  always_compare_med = __builtin__.property(_get_always_compare_med, _set_always_compare_med)
  compare_med_empty_aspath = __builtin__.property(_get_compare_med_empty_aspath, _set_compare_med_empty_aspath)
  med_missing_as_worst = __builtin__.property(_get_med_missing_as_worst, _set_med_missing_as_worst)
  as_path_ignore = __builtin__.property(_get_as_path_ignore, _set_as_path_ignore)
  compare_routerid = __builtin__.property(_get_compare_routerid, _set_compare_routerid)
  install_igp_cost = __builtin__.property(_get_install_igp_cost, _set_install_igp_cost)
  cluster_id = __builtin__.property(_get_cluster_id, _set_cluster_id)
  default_local_preference = __builtin__.property(_get_default_local_preference, _set_default_local_preference)
  distance = __builtin__.property(_get_distance, _set_distance)
  capability = __builtin__.property(_get_capability, _set_capability)
  maxas_limit = __builtin__.property(_get_maxas_limit, _set_maxas_limit)
  enforce_first_as = __builtin__.property(_get_enforce_first_as, _set_enforce_first_as)
  fast_external_fallover = __builtin__.property(_get_fast_external_fallover, _set_fast_external_fallover)
  timers = __builtin__.property(_get_timers, _set_timers)
  log_dampening_debug = __builtin__.property(_get_log_dampening_debug, _set_log_dampening_debug)
  confederation = __builtin__.property(_get_confederation, _set_confederation)
  bfd = __builtin__.property(_get_bfd, _set_bfd)
  neighbor = __builtin__.property(_get_neighbor, _set_neighbor)


  _pyangbind_elements = {'local_as': local_as, 'always_compare_med': always_compare_med, 'compare_med_empty_aspath': compare_med_empty_aspath, 'med_missing_as_worst': med_missing_as_worst, 'as_path_ignore': as_path_ignore, 'compare_routerid': compare_routerid, 'install_igp_cost': install_igp_cost, 'cluster_id': cluster_id, 'default_local_preference': default_local_preference, 'distance': distance, 'capability': capability, 'maxas_limit': maxas_limit, 'enforce_first_as': enforce_first_as, 'fast_external_fallover': fast_external_fallover, 'timers': timers, 'log_dampening_debug': log_dampening_debug, 'confederation': confederation, 'bfd': bfd, 'neighbor': neighbor, }


