# -*- coding: utf-8 -*-
from distutils.core import setup

packages = \
['mixology', 'mixology.contracts', 'mixology.graph']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'mixology',
    'version': '0.1.0',
    'description': 'A generic dependency-resolution algorithm written in pure Python.',
    'long_description': '# Mixology\n\nA generic dependency-resolution algorithm written in pure Python.\n\n\n## Installation\n\nIf you are using [poetry](https://github.com/sdispater/poetry), it\'s as simple as:\n\n```bash\npoetry add mixology\n```\n\nIf not you can use `pip`:\n\n```bash\npip install mixology\n```\n\n## Usage\n\nMixology is a dependency resolution algorithm.\nIt is heavily inspired by [Molinillo](https://github.com/CocoaPods/Molinillo) in Ruby.\n\nIn order to start using `mixology` you need to initialize a `Resolver` instance\nwith a `SpecificationProvider` and a `UI` which should be adapted to work with\nyour system.\n\nThen, you need to call `Resolver.resolve()` with a list of user-requested dependencies\nand an optional "locking" `DependencyGraph`.\n\n### Specification provider\n\nThe `SpecificationProvider` class forms the basis\nfor the key integration point for a client library with Molinillo.\n\nIts methods convert the client\'s domain-specific model objects into concepts the resolver understands:\n\n- Nested dependencies\n- Names\n- Requirement satisfaction\n- Finding specifications (known internally as possibilities)\n- Sorting dependencies (for the sake of reasonable resolver performance)\n\nThe base class looks like this:\n\n```python\nclass SpecificationProvider(object):\n    """\n    Provides information about specifications and dependencies to the resolver,\n    allowing the Resolver class to remain generic while still providing power\n    and flexibility.\n\n    This contract contains the methods that users of mixology must implement\n    using knowledge of their own model classes.\n    """\n\n    @property\n    def name_for_explicit_dependency_source(self):  # type: () -> str\n        return \'user-specified dependency\'\n\n    @property\n    def name_for_locking_dependency_source(self):  # type: () -> str\n        return \'Lockfile\'\n\n    def search_for(self, dependency):  # type: (Any) -> List[Any]\n        """\n        Search for the specifications that match the given dependency.\n\n        The specifications in the returned list will be considered in reverse\n        order, so the latest version ought to be last.\n        """\n        return []\n\n    def dependencies_for(self, specification):  # type: (Any) -> List[Any]\n        """\n        Returns the dependencies of specification.\n        """\n        return []\n\n    def is_requirement_satisfied_by(self,\n                                    requirement,  # type: Any\n                                    activated,    # type: DependencyGraph\n                                    spec          # type: Any\n                                    ):  # type: (...) -> Any\n        """\n        Determines whether the given requirement is satisfied by the given\n        spec, in the context of the current activated dependency graph.\n        """\n        return True\n\n    def name_for(self, dependency):  # type: (Any) -> str\n        """\n        Returns the name for the given dependency.\n        """\n        return str(dependency)\n\n    def sort_dependencies(self,\n                          dependencies,  # type: List[Any]\n                          activated,     # type: DependencyGraph\n                          conflicts      # type: Dict[str, List[Conflict]]\n                          ):  # type: (...) -> List[Any]\n        """\n        Sort dependencies so that the ones\n        that are easiest to resolve are first.\n\n        Easiest to resolve is (usually) defined by:\n            1) Is this dependency already activated?\n            2) How relaxed are the requirements?\n            3) Are there any conflicts for this dependency?\n            4) How many possibilities are there to satisfy this dependency?\n        """\n        return sorted(\n            dependencies,\n            key=lambda dep: (\n                activated.vertex_named(self.name_for(dep)).payload is None,\n                conflicts.get(self.name_for(dep) is None)\n            )\n        )\n\n    def allow_missing(self, dependency):  # type: (Any) -> bool\n        """\n        Returns whether this dependency, which has no possible matching\n        specifications, can safely be ignored.\n        """\n        return False\n```\n\n### UI\n\nThe `UI` class helps give feedback on and debug the depency resolution process.\n\nYou can subclass it to customize it to your needs.\n\nThe base class looks like this:\n\n```python\nclass UI(object):\n\n    def __init__(self, debug=False):\n        self._debug = debug\n\n    @property\n    def output(self):\n        return sys.stdout\n\n    @property\n    def progress_rate(self):  # type: () -> float\n        return 0.33\n\n    def is_debugging(self):  # type: () -> bool\n        return self._debug\n\n    def indicate_progress(self):  # type: () -> None\n        self.output.write(\'.\')\n\n    def before_resolution(self):  # type: () -> None\n        self.output.write(\'Resolving dependencies...\\n\')\n\n    def after_resolution(self):  # type: () -> None\n        self.output.write(\'\')\n\n    def debug(self, message, depth):  # type: (...) -> None\n        if self.is_debugging():\n            debug_info = str(message)\n            debug_info = \'\\n\'.join([\n                \':{}: {}\'.format(str(depth).rjust(4), s)\n                for s in debug_info.split(\'\\n\')\n            ]) + \'\\n\'\n\n            self.output.write(debug_info)\n\n```\n\n\n## Contributing\n\nTo work on the Mixology codebase, you\'ll want to fork the project, clone the fork locally\nand install the required depedendencies via `poetry <https://poetry.eustace.io>`_.\n\n```bash\ngit clone git@github.com:sdispater/mixology.git\npoetry install\n```\n\nThen, create your feature branch:\n\n```bash\ngit checkout -b my-new-feature\n```\n\nMake your modifications, add tests accordingly and execute the test suite:\n\n```bash\npoetry run pytest tests/\n```\n\nWhen you are ready commit your changes:\n\n```bash\ngit commit -am \'Add new feature\'\n```\n\npush your branch:\n\n```bash\ngit push origin my-new-feature\n```\n\nand finally create a pull request.\n',
    'author': 'SÃ©bastien Eustace',
    'author_email': 'sebastien@eustace.io',
    'url': 'https://github.com/sdispater/mixology',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*',
}


setup(**setup_kwargs)
