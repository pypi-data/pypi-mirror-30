"""
This module does most of the heavy lifting for the pathways module.

It includes functions for calculating enrichment scores and generating plots
for GSEA / PSEA.
"""
from __future__ import division

from collections import defaultdict
from functools import partial
import logging
import multiprocessing

from adjustText.adjustText import adjust_text
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from sklearn.utils import shuffle


LOGGER = logging.getLogger("pyproteome.enrichments")
MIN_PERIODS = 5
"""
Minimum number of samples with peptide quantification and phenotypic
measurements needed to generate a correlation metric score.
"""
CORRELATION_METRICS = [
    "spearman",
    "pearson",
    "kendall",
    "fold",
    "zscore",
]
"""
Correlation metrics used for enrichment analysis. "spearman", "pearson", and
"kendall" are all calculated using `pandas.Series.corr()`.

"fold" takes ranking values direction from the "Fold Change" column.

"zscore" takes ranking values from a z-scored "Fold Change" column.
"""


class PrPDF(object):
    """
    An exact probability distribution estimator.
    """
    def __init__(self, data):
        self.data = np.sort(data)

    def pdf(self, x):
        """
        Probability density function.

        Parameters
        ----------
        x : float

        Returns
        -------
        float
        """
        return 1 / self.data.shape[0]

    def cdf(self, x):
        """
        Cumulative density function.

        Parameters
        ----------
        x : float

        Returns
        -------
        float
        """
        return np.searchsorted(self.data, x, side="left") / self.data.shape[0]

    def sf(self, x):
        """
        Survival function.

        Parameters
        ----------
        x : float

        Returns
        -------
        float
        """
        return 1 - (
            np.searchsorted(self.data, x, side="right") / self.data.shape[0]
        )


def _calc_p(ess, ess_pi):
    return [
        abs(ess) <= abs(i)
        for i in ess_pi
        if (i < 0) == (ess < 0)
    ]


def _shuffle(ser):
    ind = ser.index
    ser = shuffle(ser)
    ser.index = ind
    return ser


def simulate_es_s_pi(
    vals,
    ds, gene_sets,
    phenotype=None,
    p=1,
    metric="spearman",
    p_iter=1000,
):
    """
    Simulate ES(S, pi) by scrambling the phenotype / correlation values for a
    data set and recalculating gene set enrichment scores.

    Parameters
    ----------
    vals : :class:`pandas.DataFrame`
    ds : :class:`DataSet<pyproteome.data_sets.DataSet>`
    gene_sets : :class:`pandas.DataFrame`
    phenotype : :class:`pandas.Series`, optional
    p : float, optional
    metric : str, optional
    p_iter : int, optional
    """
    assert metric in CORRELATION_METRICS

    LOGGER.info(
        "Calculating ES(S, pi) for {} gene sets".format(len(gene_sets))
    )
    n_cpus = 6

    if metric in ["spearman", "pearson", "kendall"]:
        n_cpus = 4

    pool = multiprocessing.Pool(
        processes=n_cpus,
    )

    ess_dist = defaultdict(list)

    for ind, ess in enumerate(
        pool.imap_unordered(
            partial(
                _calc_essdist,
                ds=ds,
                gene_sets=gene_sets,
                p=p,
                metric=metric,
            ),
            [phenotype for _ in range(p_iter)],
        ),
        start=1,
    ):
        for key, val in ess.items():
            ess_dist[key].append(val)

        if ind % (p_iter // 10) == 0:
            LOGGER.info(
                "Calculated {}/{} pvals".format(ind, p_iter)
            )

    LOGGER.info("Calculating ES(S, pi)")

    vals["ES(S, pi)"] = vals.index.map(
        lambda row: ess_dist[row],
    )

    return vals


def _calc_q(nes, nes_pdf, nes_pi_pdf):
    if nes > 0:
        return (
            nes_pi_pdf.sf(nes)
        ) / (
            nes_pdf.pdf(nes) + nes_pdf.sf(nes)
        )
    else:
        return (
            nes_pi_pdf.cdf(nes)
        ) / (
            nes_pdf.pdf(nes) + nes_pdf.cdf(nes)
        )


def estimate_pq(vals):
    """
    Estimate p- and q-values for an enrichment analysis using the ES(S, pi)
    values generated by `simulate_es_s_pi`.

    Parameters
    ----------
    vals : :class:`pandas.DataFrame`
    """
    assert "ES(S)" in vals.columns
    assert "ES(S, pi)" in vals.columns

    vals = vals.copy()

    mask = vals["ES(S)"] > 0

    pos_ess = vals["ES(S)"][mask]
    neg_ess = vals["ES(S)"][~mask]

    pos_pi = vals["ES(S, pi)"].apply(np.array).apply(lambda x: x[x > 0])
    neg_pi = vals["ES(S, pi)"].apply(np.array).apply(lambda x: x[x < 0])

    pos_mean = pos_pi.apply(np.mean)
    neg_mean = neg_pi.apply(np.mean)

    pos_nes = (pos_ess / pos_mean)
    neg_nes = -(neg_ess / neg_mean)

    assert (pos_nes.isnull() | neg_nes.isnull()).all()
    assert ((~pos_nes.isnull()) | (~neg_nes.isnull())).all()

    pos_pi_nes = pos_pi / pos_mean
    neg_pi_nes = -neg_pi / neg_mean

    vals["NES(S)"] = pos_nes.fillna(neg_nes)
    vals["pos NES(S, pi)"] = pos_pi_nes
    vals["neg NES(S, pi)"] = neg_pi_nes

    pos_mat = (
        np.concatenate(pos_pi_nes.as_matrix())
        if pos_pi_nes.shape[0] > 0 else
        np.array([])
    )
    neg_mat = (
        np.concatenate(neg_pi_nes.as_matrix())
        if neg_pi_nes.shape[0] > 0 else
        np.array([])
    )

    plot_nes_dist(
        vals["NES(S)"].as_matrix(),
        np.concatenate([pos_mat, neg_mat]),
    )

    LOGGER.info("Calculated pos, neg distributions")

    pos_pdf = PrPDF(pos_nes.dropna().as_matrix())
    neg_pdf = PrPDF(neg_nes.dropna().as_matrix())

    pos_pi_pdf = PrPDF(pos_mat)
    neg_pi_pdf = PrPDF(neg_mat)

    LOGGER.info("Normalized NES distributions")

    if vals.shape[0] > 0:
        vals["p-value"] = vals.apply(
            lambda x:
            _frac_true(
                _calc_p(x["ES(S)"], x["ES(S, pi)"])
            ),
            axis=1,
        )

        vals["q-value"] = vals.apply(
            lambda x:
            _calc_q(
                x["NES(S)"],
                pos_pdf if x["NES(S)"] > 0 else neg_pdf,
                pos_pi_pdf if x["NES(S)"] > 0 else neg_pi_pdf,
            ),
            axis=1,
        )

    LOGGER.info("Calculated p, q values")
    return vals


def _frac_true(x):
    return sum(x) / max([len(x), 1])


def get_gene_changes(ds):
    """
    Extract the gene IDs and correlation values for each gene / phosphosite in
    a data set. Merge together duplicate IDs by calculating their mean
    correlation.

    Parameters
    ----------
    ds : :class:`DataSet<pyproteome.data_sets.DataSet>`
    """
    LOGGER.info("Getting gene correlations")

    gene_changes = ds.psms[["ID", "Correlation"]]
    gene_changes.is_copy = None

    # gene_changes["Abs Corr"] = gene_changes["Correlation"].apply(abs)
    # gene_changes = gene_changes.sort_values(by="Abs Corr", ascending=True)
    # gene_changes = gene_changes.drop_duplicates(subset="ID", keep="last")
    gene_changes = gene_changes.groupby(
        "ID",
        as_index=False,
    ).agg({
        "Correlation": np.mean,
    })

    gene_changes = gene_changes.sort_values(by="Correlation", ascending=False)
    gene_changes = gene_changes.set_index(keys="ID")

    return gene_changes


def _calc_essdist(phen, ds=None, gene_sets=None, p=1, metric="spearman"):
    assert metric in CORRELATION_METRICS

    if phen is not None:
        phen = _shuffle(phen)

    if metric in ["fold", "zscore"]:
        ds = ds.copy()
        ds.psms["Fold Change"] = _shuffle(ds.psms["Fold Change"])

    vals = enrichment_scores(
        ds,
        gene_sets,
        phenotype=phen,
        metric=metric,
        p=p,
        recorrelate=True,
        pval=False,
    )

    return vals["ES(S)"]


def correlate_phenotype(ds, phenotype=None, metric="spearman"):
    """
    Calculate the correlation values for each gene / phosphosite in a data set.

    Parameters
    ----------
    gene_changes : :class:`pandas.DataFrame`
    phenotype : :class:`pandas.Series`, optional
    metric : str, optional
        The correlation function to use. See CORRELATION_METRICS for a full
        list of choices.
    """
    assert metric in CORRELATION_METRICS

    ds = ds.copy()

    if metric in ["spearman", "pearson", "kendall"]:
        ds.psms["Correlation"] = ds.psms.apply(
            lambda row:
            phenotype.corr(
                pd.to_numeric(row[phenotype.index]),
                method=metric,
                min_periods=MIN_PERIODS,
            ),
            axis=1,
        )
    else:
        new = ds.psms["Fold Change"]
        new = new.apply(np.log2)

        if metric in ["zscore"]:
            new = (new - new.mean()) / new.std()

        ds.psms["Correlation"] = new

    return ds


def calculate_es_s(gene_changes, gene_set, p=1):
    """
    Calculate the enrichment score for an individual gene set.

    Parameters
    ----------
    gene_changes : :class:`pandas.DataFrame`
    gene_set : set of str
    p : float, optional
    """
    n = len(gene_changes)
    gene_set = [
        gene
        for gene in gene_set
        if gene in gene_changes.index
    ]
    hits = gene_changes.index.isin(gene_set)
    hit_list = gene_changes[hits].index.tolist()

    n_h = len(gene_set)
    n_r = gene_changes[hits]["Correlation"].apply(
        lambda x: abs(x) ** p
    ).sum()

    scores = [0] + [
        ((abs(val) ** p) / n_r)
        if hit else
        (-1 / (n - n_h))
        for hit, val in zip(hits, gene_changes["Correlation"])
    ]
    cumsum = np.cumsum(scores)

    # ess = cumsum.max() - cumsum.min()
    # ess *= np.sign(max(cumsum, key=abs))
    ess = max(cumsum, key=abs)

    return hits, hit_list, cumsum, ess


def enrichment_scores(
    ds, gene_sets,
    metric="spearman",
    phenotype=None,
    p=1,
    pval=True,
    recorrelate=False,
    p_iter=1000,
):
    """
    Calculate enrichment scores for each gene set.

    p-values and q-values are calculated by scrambling the phenotypes assigned
    to each sample or scrambling peptides' fold changes, depending on the
    correlation metric used.

    Parameters
    ----------
    ds : :class:`DataSet<pyproteome.data_sets.DataSet>`
    gene_sets : :class:`pandas.DataFrame`, optional
    metric : str, optional
    phenotype : :class:`pandas.Series`, optional
    p : float, optional
    pval : bool, optional
    recorrelate : bool, optional
    p_iter : int, optional

    Returns
    -------
    :class:`pandas.DataFrame`
    """
    assert metric in CORRELATION_METRICS

    if recorrelate:
        ds = correlate_phenotype(ds, phenotype=phenotype, metric=metric)

    gene_changes = get_gene_changes(ds)

    cols = ["name", "set", "cumscore", "ES(S)", "hits", "hit_list", "n_hits"]
    vals = pd.DataFrame(
        columns=cols,
    )

    for set_id, row in gene_sets.iterrows():
        hits, hit_list, cumscore, ess = calculate_es_s(
            gene_changes,
            row["set"],
            p=p,
        )
        vals = vals.append(
            pd.Series(
                [
                    row["name"],
                    row["set"],
                    cumscore,
                    ess,
                    hits,
                    hit_list,
                    len(hit_list),
                ],
                name=set_id,
                index=cols,
            )
        )

    if pval:
        vals = simulate_es_s_pi(
            vals, ds, gene_sets,
            phenotype=phenotype,
            p=p,
            metric=metric,
            p_iter=p_iter,
        )

        vals = estimate_pq(vals)
        vals = vals.sort_values("NES(S)", ascending=False)
    else:
        vals = vals.sort_values("ES(S)", ascending=False)

    return vals


def filter_gene_sets(gene_sets, ds, min_hits=10):
    """
    Filter gene sets to include only those with at least a given number of
    hits in a data set.

    Parameters
    ----------
    gene_sets : :class:`pandas.DataFrame`, optional
    ds : :class:`DataSet<pyproteome.data_sets.DataSet>`
    min_hits : int, optional

    Returns
    -------
    :class:`pandas.DataFrame`
    """
    LOGGER.info("Filtering gene sets")

    total_sets = gene_sets
    all_genes = set(ds["ID"])

    gene_sets = gene_sets[
        gene_sets["set"].apply(
            lambda x:
            len(x) < len(all_genes) and
            len(all_genes.intersection(x)) >= min_hits
        )
    ]

    LOGGER.info(
        "Filtered {} gene sets down to {} with {} or more genes present"
        .format(total_sets.shape[0], gene_sets.shape[0], min_hits)
    )

    return gene_sets


def filter_vals(
    vals,
    min_abs_score=.3,
    max_pval=1,
    max_qval=1,
):
    """
    Filter gene set enrichment scores using give ES(S) / p-value / q-value
    cutoffs.

    Parameters
    ----------
    vals : :class:`pandas.DataFrame`
    min_abs_score : float, optional
    max_pval : float, optional
    max_qval : float, optional

    Returns
    -------
    :class:`pandas.DataFrame`
    """
    filtered_vals = vals[
        vals.apply(
            lambda x:
            abs(x["ES(S)"]) >= min_abs_score and (
                (x["p-value"] <= max_pval)
                if "p-value" in x.index else
                True
            ) and (
                (x["q-value"] <= max_qval)
                if "q-value" in x.index else
                True
            ),
            axis=1,
        )
    ]
    LOGGER.info(
        "Filtered {} gene sets down to {} after cutoffs"
        .format(len(vals), len(filtered_vals))
    )

    return filtered_vals


def plot_nes_dist(nes_vals, nes_pi_vals):
    """
    Generate a histogram plot showing the distribution of NES(S) values
    alongside the distribution of NES(S, pi) values.

    Parameters
    ----------
    nes_vals : :class:`numpy.array`
    nes_pi_vals : :class:`numpy.array`

    Returns
    -------
    f : :class:`matplotlib.figure.Figure`
    ax : :class:`matplotlib.axes.Axes`
    """
    f, ax = plt.subplots()

    ax.hist(
        nes_pi_vals,
        bins=100,
        color='k',
        alpha=.5,
        density=True,
    )

    if nes_vals.shape[0] > 0:
        ax.hist(
            nes_vals,
            bins=50,
            color='r',
            alpha=.5,
            density=True,
        )

    return f, ax


def plot_nes(vals, max_pval=.1, max_qval=1):
    """
    Plot the ranked normalized enrichment score values.

    Annotates significant gene sets with their name on the figure.

    Parameters
    ----------
    vals : :class:`pandas.DataFrame`
        The gene sets and scores calculated by enrichment_scores().
    max_pval : float, optional
    max_qval : float, optional

    Returns
    -------
    f : :class:`matplotlib.figure.Figure`
    ax : :class:`matplotlib.axes.Axes`
    """
    f, ax = plt.subplots()
    v = vals.copy()
    v = v.sort_values("NES(S)")
    mask = (
        (v["p-value"] < max_pval) &
        (v["q-value"] < max_qval)
    )

    nes = v["NES(S)"]

    pos = nes[mask]
    neg = nes[~mask]

    ind = np.arange(v.shape[0])
    pos_ind = ind[mask]
    neg_ind = ind[~mask]

    ax.scatter(
        x=pos_ind,
        y=pos,
        color="r",
    )
    ax.scatter(
        x=neg_ind,
        y=neg,
        color="k",
    )
    ax.set_ylabel("Normalized Enrichment Score (NES)")
    ax.set_xlim(
        left=ind.min() - 5,
        right=ind.max() + 5,
    )
    ax.set_ylim(
        bottom=nes.min() - .5,
        top=nes.max() + .5,
    )

    texts = []
    labels = []

    for m, x, (_, row) in zip(mask, ind, v.iterrows()):
        y = row["NES(S)"]
        labels.append(
            (x, y)
        )
        texts.append(
            ax.text(
                x=x,
                y=y,
                s=row["name"] if m else "",
                horizontalalignment='right',
            )
        )

    adjust_text(
        x=[i[0] for i in labels],
        y=[i[1] for i in labels],
        texts=texts,
        ax=ax,
        lim=500,
        force_text=0.5,
        force_points=0.1,
        arrowprops=dict(arrowstyle="-", relpos=(0, 0), lw=1),
        only_move={
            "points": "y",
            "text": "xy",
        }
    )

    return f, ax


def plot_correlations(gene_changes):
    """
    Plot the ranked list of correlations.

    Parameters
    ----------
    gene_changes : :class:`pandas.DataFrame`
        Genes and their correlation values as calculated by get_gene_changes().

    Returns
    -------
    f : :class:`matplotlib.figure.Figure`
    ax : :class:`matplotlib.axes.Axes`
    """
    LOGGER.info("Plotting gene correlations")
    f, ax = plt.subplots()

    ax.plot(
        gene_changes["Correlation"].sort_values(ascending=False).tolist(),
    )
    ax.axhline(0, color="k")

    ax.set_xlabel("Gene List Rank", fontsize=20)
    ax.set_ylabel("Correlation", fontsize=20)

    return f, ax


def plot_enrichment(
    vals,
    cols=5,
):
    """
    Plot enrichment score curves for each gene set.

    Parameters
    ----------
    vals : :class:`pandas.DataFrame`
        The gene sets and scores calculated by enrichment_scores().
    cols : int, optional
    """
    rows = max([int(np.ceil(len(vals) / cols)), 1])
    scale = 6

    f, axes = plt.subplots(
        rows, cols,
        figsize=(scale * cols, scale * rows),
        squeeze=False,
        sharex=True,
        sharey=True,
    )
    axes = [i for j in axes for i in j]

    nes = "NES(S)" if "NES(S)" in vals.columns else "ES(S)"

    ax_iter = iter(axes)

    for (index, ax), (set_id, row) in zip(
        enumerate(ax_iter),
        vals.iterrows(),
    ):
        ax.plot(row["cumscore"])

        for ind, hit in enumerate(row["hits"]):
            if hit:
                ax.axvline(ind, linestyle=":", alpha=.25)

        name = row["name"]
        name = name if len(name) < 35 else name[:35] + "..."

        ax.set_title(
            "{}\nhits: {} {}={:.2f}"
            .format(
                name,
                row["n_hits"],
                nes.split("(")[0],
                row[nes],
            ) + (
                ", p={:.2f}".format(
                    row["p-value"],
                ) if "p-value" in row.index else ""
            ) + (
                ", q={:.2f}".format(
                    row["q-value"],
                ) if "q-value" in row.index else ""
            ),
            fontsize=20,
        )
        ax.axhline(0, color="k")

        if index >= len(axes) - cols:
            ax.set_xlabel("Gene List Rank", fontsize=20)

        if index % cols == 0:
            ax.set_ylabel("ES(S)", fontsize=20)

        ax.set_ylim(-1, 1)

    for ax in ax_iter:
        ax.axis('off')

    return f, axes


def plot_gsea(
    ds, gene_sets,
    es_args=None,
    es_plot_args=None,
    min_hits=10,
    min_abs_score=.3,
    max_pval=1,
    max_qval=1,
):
    """
    Run set enrichment analysis on a data set and generate all figures
    associated with that analysis.

    Parameters
    ----------
    ds : :class:`DataSet<pyproteome.data_sets.DataSet>`
    gene_sets : :class:`pandas.DataFrame`, optional
    es_args : dict, optional
        Keyword arguments passed to enrichment_scores().
    es_plot_args : dict, optional
        Keyword arguments passed to plot_enrichment().

    Returns
    -------
    vals : :class:`pandas.DataFrame`
    figs : list of :class:`matplotlib.figure.Figure`
    """
    es_args = es_args or {}
    es_plot_args = es_plot_args or {}

    gene_changes = get_gene_changes(ds)

    figs = ()

    figs += plot_correlations(gene_changes)[0],

    gene_sets = filter_gene_sets(
        gene_sets, ds,
        min_hits=min_hits,
    )

    vals = enrichment_scores(
        ds,
        gene_sets,
        **es_args
    )

    if vals.shape[0] > 0:
        figs += plot_enrichment(
            filter_vals(
                vals,
                min_abs_score=min_abs_score,
                max_pval=max_pval,
                max_qval=max_qval,
            ),
            **es_plot_args
        )[0],

        if "NES(S)" in vals.columns:
            figs += plot_nes(
                vals,
                max_pval=max_pval,
                max_qval=max_qval,
            )[0],

    return vals, figs
